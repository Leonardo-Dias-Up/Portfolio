/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */


"use strict";
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var ts;
(function (ts) {
    ts.versionMajorMinor = "4.7";
    ts.version = "4.7.3";
    var NativeCollections;
    (function (NativeCollections) {
        var globals = typeof globalThis !== "undefined" ? globalThis :
            typeof global !== "undefined" ? global :
                typeof self !== "undefined" ? self :
                    undefined;
        function tryGetNativeMap() {
            var gMap = globals === null || globals === void 0 ? void 0 : globals.Map;
            return typeof gMap !== "undefined" && "entries" in gMap.prototype && new gMap([[0, 0]]).size === 1 ? gMap : undefined;
        }
        NativeCollections.tryGetNativeMap = tryGetNativeMap;
        function tryGetNativeSet() {
            var gSet = globals === null || globals === void 0 ? void 0 : globals.Set;
            return typeof gSet !== "undefined" && "entries" in gSet.prototype && new gSet([0]).size === 1 ? gSet : undefined;
        }
        NativeCollections.tryGetNativeSet = tryGetNativeSet;
    })(NativeCollections || (NativeCollections = {}));
    ts.Map = getCollectionImplementation("Map", "tryGetNativeMap", "createMapShim");
    ts.Set = getCollectionImplementation("Set", "tryGetNativeSet", "createSetShim");
    function getCollectionImplementation(name, nativeFactory, shimFactory) {
        var _a;
        var constructor = (_a = NativeCollections[nativeFactory]()) !== null && _a !== void 0 ? _a : ts.ShimCollections === null || ts.ShimCollections === void 0 ? void 0 : ts.ShimCollections[shimFactory](ts.getIterator);
        if (constructor)
            return constructor;
        throw new Error("TypeScript requires an environment that provides a compatible native ".concat(name, " implementation."));
    }
})(ts || (ts = {}));
var ts;
(function (ts) {
    function getIterator(iterable) {
        if (iterable) {
            if (isArray(iterable))
                return arrayIterator(iterable);
            if (iterable instanceof ts.Map)
                return iterable.entries();
            if (iterable instanceof ts.Set)
                return iterable.values();
            throw new Error("Iteration not supported.");
        }
    }
    ts.getIterator = getIterator;
    ts.emptyArray = [];
    ts.emptyMap = new ts.Map();
    ts.emptySet = new ts.Set();
    function length(array) {
        return array ? array.length : 0;
    }
    ts.length = length;
    function forEach(array, callback) {
        if (array) {
            for (var i = 0; i < array.length; i++) {
                var result = callback(array[i], i);
                if (result) {
                    return result;
                }
            }
        }
        return undefined;
    }
    ts.forEach = forEach;
    function forEachRight(array, callback) {
        if (array) {
            for (var i = array.length - 1; i >= 0; i--) {
                var result = callback(array[i], i);
                if (result) {
                    return result;
                }
            }
        }
        return undefined;
    }
    ts.forEachRight = forEachRight;
    function firstDefined(array, callback) {
        if (array === undefined) {
            return undefined;
        }
        for (var i = 0; i < array.length; i++) {
            var result = callback(array[i], i);
            if (result !== undefined) {
                return result;
            }
        }
        return undefined;
    }
    ts.firstDefined = firstDefined;
    function firstDefinedIterator(iter, callback) {
        while (true) {
            var iterResult = iter.next();
            if (iterResult.done) {
                return undefined;
            }
            var result = callback(iterResult.value);
            if (result !== undefined) {
                return result;
            }
        }
    }
    ts.firstDefinedIterator = firstDefinedIterator;
    function reduceLeftIterator(iterator, f, initial) {
        var result = initial;
        if (iterator) {
            for (var step = iterator.next(), pos = 0; !step.done; step = iterator.next(), pos++) {
                result = f(result, step.value, pos);
            }
        }
        return result;
    }
    ts.reduceLeftIterator = reduceLeftIterator;
    function zipWith(arrayA, arrayB, callback) {
        var result = [];
        ts.Debug.assertEqual(arrayA.length, arrayB.length);
        for (var i = 0; i < arrayA.length; i++) {
            result.push(callback(arrayA[i], arrayB[i], i));
        }
        return result;
    }
    ts.zipWith = zipWith;
    function zipToIterator(arrayA, arrayB) {
        ts.Debug.assertEqual(arrayA.length, arrayB.length);
        var i = 0;
        return {
            next: function () {
                if (i === arrayA.length) {
                    return { value: undefined, done: true };
                }
                i++;
                return { value: [arrayA[i - 1], arrayB[i - 1]], done: false };
            }
        };
    }
    ts.zipToIterator = zipToIterator;
    function zipToMap(keys, values) {
        ts.Debug.assert(keys.length === values.length);
        var map = new ts.Map();
        for (var i = 0; i < keys.length; ++i) {
            map.set(keys[i], values[i]);
        }
        return map;
    }
    ts.zipToMap = zipToMap;
    function intersperse(input, element) {
        if (input.length <= 1) {
            return input;
        }
        var result = [];
        for (var i = 0, n = input.length; i < n; i++) {
            if (i)
                result.push(element);
            result.push(input[i]);
        }
        return result;
    }
    ts.intersperse = intersperse;
    function every(array, callback) {
        if (array) {
            for (var i = 0; i < array.length; i++) {
                if (!callback(array[i], i)) {
                    return false;
                }
            }
        }
        return true;
    }
    ts.every = every;
    function find(array, predicate) {
        for (var i = 0; i < array.length; i++) {
            var value = array[i];
            if (predicate(value, i)) {
                return value;
            }
        }
        return undefined;
    }
    ts.find = find;
    function findLast(array, predicate) {
        for (var i = array.length - 1; i >= 0; i--) {
            var value = array[i];
            if (predicate(value, i)) {
                return value;
            }
        }
        return undefined;
    }
    ts.findLast = findLast;
    function findIndex(array, predicate, startIndex) {
        for (var i = startIndex || 0; i < array.length; i++) {
            if (predicate(array[i], i)) {
                return i;
            }
        }
        return -1;
    }
    ts.findIndex = findIndex;
    function findLastIndex(array, predicate, startIndex) {
        for (var i = startIndex === undefined ? array.length - 1 : startIndex; i >= 0; i--) {
            if (predicate(array[i], i)) {
                return i;
            }
        }
        return -1;
    }
    ts.findLastIndex = findLastIndex;
    function findMap(array, callback) {
        for (var i = 0; i < array.length; i++) {
            var result = callback(array[i], i);
            if (result) {
                return result;
            }
        }
        return ts.Debug.fail();
    }
    ts.findMap = findMap;
    function contains(array, value, equalityComparer) {
        if (equalityComparer === void 0) { equalityComparer = equateValues; }
        if (array) {
            for (var _i = 0, array_1 = array; _i < array_1.length; _i++) {
                var v = array_1[_i];
                if (equalityComparer(v, value)) {
                    return true;
                }
            }
        }
        return false;
    }
    ts.contains = contains;
    function arraysEqual(a, b, equalityComparer) {
        if (equalityComparer === void 0) { equalityComparer = equateValues; }
        return a.length === b.length && a.every(function (x, i) { return equalityComparer(x, b[i]); });
    }
    ts.arraysEqual = arraysEqual;
    function indexOfAnyCharCode(text, charCodes, start) {
        for (var i = start || 0; i < text.length; i++) {
            if (contains(charCodes, text.charCodeAt(i))) {
                return i;
            }
        }
        return -1;
    }
    ts.indexOfAnyCharCode = indexOfAnyCharCode;
    function countWhere(array, predicate) {
        var count = 0;
        if (array) {
            for (var i = 0; i < array.length; i++) {
                var v = array[i];
                if (predicate(v, i)) {
                    count++;
                }
            }
        }
        return count;
    }
    ts.countWhere = countWhere;
    function filter(array, f) {
        if (array) {
            var len = array.length;
            var i = 0;
            while (i < len && f(array[i]))
                i++;
            if (i < len) {
                var result = array.slice(0, i);
                i++;
                while (i < len) {
                    var item = array[i];
                    if (f(item)) {
                        result.push(item);
                    }
                    i++;
                }
                return result;
            }
        }
        return array;
    }
    ts.filter = filter;
    function filterMutate(array, f) {
        var outIndex = 0;
        for (var i = 0; i < array.length; i++) {
            if (f(array[i], i, array)) {
                array[outIndex] = array[i];
                outIndex++;
            }
        }
        array.length = outIndex;
    }
    ts.filterMutate = filterMutate;
    function clear(array) {
        array.length = 0;
    }
    ts.clear = clear;
    function map(array, f) {
        var result;
        if (array) {
            result = [];
            for (var i = 0; i < array.length; i++) {
                result.push(f(array[i], i));
            }
        }
        return result;
    }
    ts.map = map;
    function mapIterator(iter, mapFn) {
        return {
            next: function () {
                var iterRes = iter.next();
                return iterRes.done ? iterRes : { value: mapFn(iterRes.value), done: false };
            }
        };
    }
    ts.mapIterator = mapIterator;
    function sameMap(array, f) {
        if (array) {
            for (var i = 0; i < array.length; i++) {
                var item = array[i];
                var mapped = f(item, i);
                if (item !== mapped) {
                    var result = array.slice(0, i);
                    result.push(mapped);
                    for (i++; i < array.length; i++) {
                        result.push(f(array[i], i));
                    }
                    return result;
                }
            }
        }
        return array;
    }
    ts.sameMap = sameMap;
    function flatten(array) {
        var result = [];
        for (var _i = 0, array_2 = array; _i < array_2.length; _i++) {
            var v = array_2[_i];
            if (v) {
                if (isArray(v)) {
                    addRange(result, v);
                }
                else {
                    result.push(v);
                }
            }
        }
        return result;
    }
    ts.flatten = flatten;
    function flatMap(array, mapfn) {
        var result;
        if (array) {
            for (var i = 0; i < array.length; i++) {
                var v = mapfn(array[i], i);
                if (v) {
                    if (isArray(v)) {
                        result = addRange(result, v);
                    }
                    else {
                        result = append(result, v);
                    }
                }
            }
        }
        return result || ts.emptyArray;
    }
    ts.flatMap = flatMap;
    function flatMapToMutable(array, mapfn) {
        var result = [];
        if (array) {
            for (var i = 0; i < array.length; i++) {
                var v = mapfn(array[i], i);
                if (v) {
                    if (isArray(v)) {
                        addRange(result, v);
                    }
                    else {
                        result.push(v);
                    }
                }
            }
        }
        return result;
    }
    ts.flatMapToMutable = flatMapToMutable;
    function flatMapIterator(iter, mapfn) {
        var first = iter.next();
        if (first.done) {
            return ts.emptyIterator;
        }
        var currentIter = getIterator(first.value);
        return {
            next: function () {
                while (true) {
                    var currentRes = currentIter.next();
                    if (!currentRes.done) {
                        return currentRes;
                    }
                    var iterRes = iter.next();
                    if (iterRes.done) {
                        return iterRes;
                    }
                    currentIter = getIterator(iterRes.value);
                }
            },
        };
        function getIterator(x) {
            var res = mapfn(x);
            return res === undefined ? ts.emptyIterator : isArray(res) ? arrayIterator(res) : res;
        }
    }
    ts.flatMapIterator = flatMapIterator;
    function sameFlatMap(array, mapfn) {
        var result;
        if (array) {
            for (var i = 0; i < array.length; i++) {
                var item = array[i];
                var mapped = mapfn(item, i);
                if (result || item !== mapped || isArray(mapped)) {
                    if (!result) {
                        result = array.slice(0, i);
                    }
                    if (isArray(mapped)) {
                        addRange(result, mapped);
                    }
                    else {
                        result.push(mapped);
                    }
                }
            }
        }
        return result || array;
    }
    ts.sameFlatMap = sameFlatMap;
    function mapAllOrFail(array, mapFn) {
        var result = [];
        for (var i = 0; i < array.length; i++) {
            var mapped = mapFn(array[i], i);
            if (mapped === undefined) {
                return undefined;
            }
            result.push(mapped);
        }
        return result;
    }
    ts.mapAllOrFail = mapAllOrFail;
    function mapDefined(array, mapFn) {
        var result = [];
        if (array) {
            for (var i = 0; i < array.length; i++) {
                var mapped = mapFn(array[i], i);
                if (mapped !== undefined) {
                    result.push(mapped);
                }
            }
        }
        return result;
    }
    ts.mapDefined = mapDefined;
    function mapDefinedIterator(iter, mapFn) {
        return {
            next: function () {
                while (true) {
                    var res = iter.next();
                    if (res.done) {
                        return res;
                    }
                    var value = mapFn(res.value);
                    if (value !== undefined) {
                        return { value: value, done: false };
                    }
                }
            }
        };
    }
    ts.mapDefinedIterator = mapDefinedIterator;
    function mapDefinedEntries(map, f) {
        if (!map) {
            return undefined;
        }
        var result = new ts.Map();
        map.forEach(function (value, key) {
            var entry = f(key, value);
            if (entry !== undefined) {
                var newKey = entry[0], newValue = entry[1];
                if (newKey !== undefined && newValue !== undefined) {
                    result.set(newKey, newValue);
                }
            }
        });
        return result;
    }
    ts.mapDefinedEntries = mapDefinedEntries;
    function mapDefinedValues(set, f) {
        if (set) {
            var result_1 = new ts.Set();
            set.forEach(function (value) {
                var newValue = f(value);
                if (newValue !== undefined) {
                    result_1.add(newValue);
                }
            });
            return result_1;
        }
    }
    ts.mapDefinedValues = mapDefinedValues;
    function getOrUpdate(map, key, callback) {
        if (map.has(key)) {
            return map.get(key);
        }
        var value = callback();
        map.set(key, value);
        return value;
    }
    ts.getOrUpdate = getOrUpdate;
    function tryAddToSet(set, value) {
        if (!set.has(value)) {
            set.add(value);
            return true;
        }
        return false;
    }
    ts.tryAddToSet = tryAddToSet;
    ts.emptyIterator = { next: function () { return ({ value: undefined, done: true }); } };
    function singleIterator(value) {
        var done = false;
        return {
            next: function () {
                var wasDone = done;
                done = true;
                return wasDone ? { value: undefined, done: true } : { value: value, done: false };
            }
        };
    }
    ts.singleIterator = singleIterator;
    function spanMap(array, keyfn, mapfn) {
        var result;
        if (array) {
            result = [];
            var len = array.length;
            var previousKey = void 0;
            var key = void 0;
            var start = 0;
            var pos = 0;
            while (start < len) {
                while (pos < len) {
                    var value = array[pos];
                    key = keyfn(value, pos);
                    if (pos === 0) {
                        previousKey = key;
                    }
                    else if (key !== previousKey) {
                        break;
                    }
                    pos++;
                }
                if (start < pos) {
                    var v = mapfn(array.slice(start, pos), previousKey, start, pos);
                    if (v) {
                        result.push(v);
                    }
                    start = pos;
                }
                previousKey = key;
                pos++;
            }
        }
        return result;
    }
    ts.spanMap = spanMap;
    function mapEntries(map, f) {
        if (!map) {
            return undefined;
        }
        var result = new ts.Map();
        map.forEach(function (value, key) {
            var _a = f(key, value), newKey = _a[0], newValue = _a[1];
            result.set(newKey, newValue);
        });
        return result;
    }
    ts.mapEntries = mapEntries;
    function some(array, predicate) {
        if (array) {
            if (predicate) {
                for (var _i = 0, array_3 = array; _i < array_3.length; _i++) {
                    var v = array_3[_i];
                    if (predicate(v)) {
                        return true;
                    }
                }
            }
            else {
                return array.length > 0;
            }
        }
        return false;
    }
    ts.some = some;
    function getRangesWhere(arr, pred, cb) {
        var start;
        for (var i = 0; i < arr.length; i++) {
            if (pred(arr[i])) {
                start = start === undefined ? i : start;
            }
            else {
                if (start !== undefined) {
                    cb(start, i);
                    start = undefined;
                }
            }
        }
        if (start !== undefined)
            cb(start, arr.length);
    }
    ts.getRangesWhere = getRangesWhere;
    function concatenate(array1, array2) {
        if (!some(array2))
            return array1;
        if (!some(array1))
            return array2;
        return __spreadArray(__spreadArray([], array1, true), array2, true);
    }
    ts.concatenate = concatenate;
    function selectIndex(_, i) {
        return i;
    }
    function indicesOf(array) {
        return array.map(selectIndex);
    }
    ts.indicesOf = indicesOf;
    function deduplicateRelational(array, equalityComparer, comparer) {
        var indices = indicesOf(array);
        stableSortIndices(array, indices, comparer);
        var last = array[indices[0]];
        var deduplicated = [indices[0]];
        for (var i = 1; i < indices.length; i++) {
            var index = indices[i];
            var item = array[index];
            if (!equalityComparer(last, item)) {
                deduplicated.push(index);
                last = item;
            }
        }
        deduplicated.sort();
        return deduplicated.map(function (i) { return array[i]; });
    }
    function deduplicateEquality(array, equalityComparer) {
        var result = [];
        for (var _i = 0, array_4 = array; _i < array_4.length; _i++) {
            var item = array_4[_i];
            pushIfUnique(result, item, equalityComparer);
        }
        return result;
    }
    function deduplicate(array, equalityComparer, comparer) {
        return array.length === 0 ? [] :
            array.length === 1 ? array.slice() :
                comparer ? deduplicateRelational(array, equalityComparer, comparer) :
                    deduplicateEquality(array, equalityComparer);
    }
    ts.deduplicate = deduplicate;
    function deduplicateSorted(array, comparer) {
        if (array.length === 0)
            return ts.emptyArray;
        var last = array[0];
        var deduplicated = [last];
        for (var i = 1; i < array.length; i++) {
            var next = array[i];
            switch (comparer(next, last)) {
                case true:
                case 0:
                    continue;
                case -1:
                    return ts.Debug.fail("Array is unsorted.");
            }
            deduplicated.push(last = next);
        }
        return deduplicated;
    }
    function createSortedArray() {
        return [];
    }
    ts.createSortedArray = createSortedArray;
    function insertSorted(array, insert, compare, allowDuplicates) {
        if (array.length === 0) {
            array.push(insert);
            return;
        }
        var insertIndex = binarySearch(array, insert, identity, compare);
        if (insertIndex < 0) {
            array.splice(~insertIndex, 0, insert);
        }
        else if (allowDuplicates) {
            array.splice(insertIndex, 0, insert);
        }
    }
    ts.insertSorted = insertSorted;
    function sortAndDeduplicate(array, comparer, equalityComparer) {
        return deduplicateSorted(sort(array, comparer), equalityComparer || comparer || compareStringsCaseSensitive);
    }
    ts.sortAndDeduplicate = sortAndDeduplicate;
    function arrayIsSorted(array, comparer) {
        if (array.length < 2)
            return true;
        var prevElement = array[0];
        for (var _i = 0, _a = array.slice(1); _i < _a.length; _i++) {
            var element = _a[_i];
            if (comparer(prevElement, element) === 1) {
                return false;
            }
            prevElement = element;
        }
        return true;
    }
    ts.arrayIsSorted = arrayIsSorted;
    function arrayIsEqualTo(array1, array2, equalityComparer) {
        if (equalityComparer === void 0) { equalityComparer = equateValues; }
        if (!array1 || !array2) {
            return array1 === array2;
        }
        if (array1.length !== array2.length) {
            return false;
        }
        for (var i = 0; i < array1.length; i++) {
            if (!equalityComparer(array1[i], array2[i], i)) {
                return false;
            }
        }
        return true;
    }
    ts.arrayIsEqualTo = arrayIsEqualTo;
    function compact(array) {
        var result;
        if (array) {
            for (var i = 0; i < array.length; i++) {
                var v = array[i];
                if (result || !v) {
                    if (!result) {
                        result = array.slice(0, i);
                    }
                    if (v) {
                        result.push(v);
                    }
                }
            }
        }
        return result || array;
    }
    ts.compact = compact;
    function relativeComplement(arrayA, arrayB, comparer) {
        if (!arrayB || !arrayA || arrayB.length === 0 || arrayA.length === 0)
            return arrayB;
        var result = [];
        loopB: for (var offsetA = 0, offsetB = 0; offsetB < arrayB.length; offsetB++) {
            if (offsetB > 0) {
                ts.Debug.assertGreaterThanOrEqual(comparer(arrayB[offsetB], arrayB[offsetB - 1]), 0);
            }
            loopA: for (var startA = offsetA; offsetA < arrayA.length; offsetA++) {
                if (offsetA > startA) {
                    ts.Debug.assertGreaterThanOrEqual(comparer(arrayA[offsetA], arrayA[offsetA - 1]), 0);
                }
                switch (comparer(arrayB[offsetB], arrayA[offsetA])) {
                    case -1:
                        result.push(arrayB[offsetB]);
                        continue loopB;
                    case 0:
                        continue loopB;
                    case 1:
                        continue loopA;
                }
            }
        }
        return result;
    }
    ts.relativeComplement = relativeComplement;
    function sum(array, prop) {
        var result = 0;
        for (var _i = 0, array_5 = array; _i < array_5.length; _i++) {
            var v = array_5[_i];
            result += v[prop];
        }
        return result;
    }
    ts.sum = sum;
    function append(to, value) {
        if (value === undefined)
            return to;
        if (to === undefined)
            return [value];
        to.push(value);
        return to;
    }
    ts.append = append;
    function combine(xs, ys) {
        if (xs === undefined)
            return ys;
        if (ys === undefined)
            return xs;
        if (isArray(xs))
            return isArray(ys) ? concatenate(xs, ys) : append(xs, ys);
        if (isArray(ys))
            return append(ys, xs);
        return [xs, ys];
    }
    ts.combine = combine;
    function toOffset(array, offset) {
        return offset < 0 ? array.length + offset : offset;
    }
    function addRange(to, from, start, end) {
        if (from === undefined || from.length === 0)
            return to;
        if (to === undefined)
            return from.slice(start, end);
        start = start === undefined ? 0 : toOffset(from, start);
        end = end === undefined ? from.length : toOffset(from, end);
        for (var i = start; i < end && i < from.length; i++) {
            if (from[i] !== undefined) {
                to.push(from[i]);
            }
        }
        return to;
    }
    ts.addRange = addRange;
    function pushIfUnique(array, toAdd, equalityComparer) {
        if (contains(array, toAdd, equalityComparer)) {
            return false;
        }
        else {
            array.push(toAdd);
            return true;
        }
    }
    ts.pushIfUnique = pushIfUnique;
    function appendIfUnique(array, toAdd, equalityComparer) {
        if (array) {
            pushIfUnique(array, toAdd, equalityComparer);
            return array;
        }
        else {
            return [toAdd];
        }
    }
    ts.appendIfUnique = appendIfUnique;
    function stableSortIndices(array, indices, comparer) {
        indices.sort(function (x, y) { return comparer(array[x], array[y]) || compareValues(x, y); });
    }
    function sort(array, comparer) {
        return (array.length === 0 ? array : array.slice().sort(comparer));
    }
    ts.sort = sort;
    function arrayIterator(array) {
        var i = 0;
        return { next: function () {
                if (i === array.length) {
                    return { value: undefined, done: true };
                }
                else {
                    i++;
                    return { value: array[i - 1], done: false };
                }
            } };
    }
    ts.arrayIterator = arrayIterator;
    function arrayReverseIterator(array) {
        var i = array.length;
        return {
            next: function () {
                if (i === 0) {
                    return { value: undefined, done: true };
                }
                else {
                    i--;
                    return { value: array[i], done: false };
                }
            }
        };
    }
    ts.arrayReverseIterator = arrayReverseIterator;
    function stableSort(array, comparer) {
        var indices = indicesOf(array);
        stableSortIndices(array, indices, comparer);
        return indices.map(function (i) { return array[i]; });
    }
    ts.stableSort = stableSort;
    function rangeEquals(array1, array2, pos, end) {
        while (pos < end) {
            if (array1[pos] !== array2[pos]) {
                return false;
            }
            pos++;
        }
        return true;
    }
    ts.rangeEquals = rangeEquals;
    function elementAt(array, offset) {
        if (array) {
            offset = toOffset(array, offset);
            if (offset < array.length) {
                return array[offset];
            }
        }
        return undefined;
    }
    ts.elementAt = elementAt;
    function firstOrUndefined(array) {
        return array.length === 0 ? undefined : array[0];
    }
    ts.firstOrUndefined = firstOrUndefined;
    function first(array) {
        ts.Debug.assert(array.length !== 0);
        return array[0];
    }
    ts.first = first;
    function lastOrUndefined(array) {
        return array.length === 0 ? undefined : array[array.length - 1];
    }
    ts.lastOrUndefined = lastOrUndefined;
    function last(array) {
        ts.Debug.assert(array.length !== 0);
        return array[array.length - 1];
    }
    ts.last = last;
    function singleOrUndefined(array) {
        return array && array.length === 1
            ? array[0]
            : undefined;
    }
    ts.singleOrUndefined = singleOrUndefined;
    function singleOrMany(array) {
        return array && array.length === 1
            ? array[0]
            : array;
    }
    ts.singleOrMany = singleOrMany;
    function replaceElement(array, index, value) {
        var result = array.slice(0);
        result[index] = value;
        return result;
    }
    ts.replaceElement = replaceElement;
    function binarySearch(array, value, keySelector, keyComparer, offset) {
        return binarySearchKey(array, keySelector(value), keySelector, keyComparer, offset);
    }
    ts.binarySearch = binarySearch;
    function binarySearchKey(array, key, keySelector, keyComparer, offset) {
        if (!some(array)) {
            return -1;
        }
        var low = offset || 0;
        var high = array.length - 1;
        while (low <= high) {
            var middle = low + ((high - low) >> 1);
            var midKey = keySelector(array[middle], middle);
            switch (keyComparer(midKey, key)) {
                case -1:
                    low = middle + 1;
                    break;
                case 0:
                    return middle;
                case 1:
                    high = middle - 1;
                    break;
            }
        }
        return ~low;
    }
    ts.binarySearchKey = binarySearchKey;
    function reduceLeft(array, f, initial, start, count) {
        if (array && array.length > 0) {
            var size = array.length;
            if (size > 0) {
                var pos = start === undefined || start < 0 ? 0 : start;
                var end = count === undefined || pos + count > size - 1 ? size - 1 : pos + count;
                var result = void 0;
                if (arguments.length <= 2) {
                    result = array[pos];
                    pos++;
                }
                else {
                    result = initial;
                }
                while (pos <= end) {
                    result = f(result, array[pos], pos);
                    pos++;
                }
                return result;
            }
        }
        return initial;
    }
    ts.reduceLeft = reduceLeft;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    function hasProperty(map, key) {
        return hasOwnProperty.call(map, key);
    }
    ts.hasProperty = hasProperty;
    function getProperty(map, key) {
        return hasOwnProperty.call(map, key) ? map[key] : undefined;
    }
    ts.getProperty = getProperty;
    function getOwnKeys(map) {
        var keys = [];
        for (var key in map) {
            if (hasOwnProperty.call(map, key)) {
                keys.push(key);
            }
        }
        return keys;
    }
    ts.getOwnKeys = getOwnKeys;
    function getAllKeys(obj) {
        var result = [];
        do {
            var names = Object.getOwnPropertyNames(obj);
            for (var _i = 0, names_1 = names; _i < names_1.length; _i++) {
                var name = names_1[_i];
                pushIfUnique(result, name);
            }
        } while (obj = Object.getPrototypeOf(obj));
        return result;
    }
    ts.getAllKeys = getAllKeys;
    function getOwnValues(collection) {
        var values = [];
        for (var key in collection) {
            if (hasOwnProperty.call(collection, key)) {
                values.push(collection[key]);
            }
        }
        return values;
    }
    ts.getOwnValues = getOwnValues;
    var _entries = Object.entries || (function (obj) {
        var keys = getOwnKeys(obj);
        var result = Array(keys.length);
        for (var i = 0; i < keys.length; i++) {
            result[i] = [keys[i], obj[keys[i]]];
        }
        return result;
    });
    function getEntries(obj) {
        return obj ? _entries(obj) : [];
    }
    ts.getEntries = getEntries;
    function arrayOf(count, f) {
        var result = new Array(count);
        for (var i = 0; i < count; i++) {
            result[i] = f(i);
        }
        return result;
    }
    ts.arrayOf = arrayOf;
    function arrayFrom(iterator, map) {
        var result = [];
        for (var iterResult = iterator.next(); !iterResult.done; iterResult = iterator.next()) {
            result.push(map ? map(iterResult.value) : iterResult.value);
        }
        return result;
    }
    ts.arrayFrom = arrayFrom;
    function assign(t) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {
            var arg = args_1[_a];
            if (arg === undefined)
                continue;
            for (var p in arg) {
                if (hasProperty(arg, p)) {
                    t[p] = arg[p];
                }
            }
        }
        return t;
    }
    ts.assign = assign;
    function equalOwnProperties(left, right, equalityComparer) {
        if (equalityComparer === void 0) { equalityComparer = equateValues; }
        if (left === right)
            return true;
        if (!left || !right)
            return false;
        for (var key in left) {
            if (hasOwnProperty.call(left, key)) {
                if (!hasOwnProperty.call(right, key))
                    return false;
                if (!equalityComparer(left[key], right[key]))
                    return false;
            }
        }
        for (var key in right) {
            if (hasOwnProperty.call(right, key)) {
                if (!hasOwnProperty.call(left, key))
                    return false;
            }
        }
        return true;
    }
    ts.equalOwnProperties = equalOwnProperties;
    function arrayToMap(array, makeKey, makeValue) {
        if (makeValue === void 0) { makeValue = identity; }
        var result = new ts.Map();
        for (var _i = 0, array_6 = array; _i < array_6.length; _i++) {
            var value = array_6[_i];
            var key = makeKey(value);
            if (key !== undefined)
                result.set(key, makeValue(value));
        }
        return result;
    }
    ts.arrayToMap = arrayToMap;
    function arrayToNumericMap(array, makeKey, makeValue) {
        if (makeValue === void 0) { makeValue = identity; }
        var result = [];
        for (var _i = 0, array_7 = array; _i < array_7.length; _i++) {
            var value = array_7[_i];
            result[makeKey(value)] = makeValue(value);
        }
        return result;
    }
    ts.arrayToNumericMap = arrayToNumericMap;
    function arrayToMultiMap(values, makeKey, makeValue) {
        if (makeValue === void 0) { makeValue = identity; }
        var result = createMultiMap();
        for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {
            var value = values_1[_i];
            result.add(makeKey(value), makeValue(value));
        }
        return result;
    }
    ts.arrayToMultiMap = arrayToMultiMap;
    function group(values, getGroupId, resultSelector) {
        if (resultSelector === void 0) { resultSelector = identity; }
        return arrayFrom(arrayToMultiMap(values, getGroupId).values(), resultSelector);
    }
    ts.group = group;
    function clone(object) {
        var result = {};
        for (var id in object) {
            if (hasOwnProperty.call(object, id)) {
                result[id] = object[id];
            }
        }
        return result;
    }
    ts.clone = clone;
    function extend(first, second) {
        var result = {};
        for (var id in second) {
            if (hasOwnProperty.call(second, id)) {
                result[id] = second[id];
            }
        }
        for (var id in first) {
            if (hasOwnProperty.call(first, id)) {
                result[id] = first[id];
            }
        }
        return result;
    }
    ts.extend = extend;
    function copyProperties(first, second) {
        for (var id in second) {
            if (hasOwnProperty.call(second, id)) {
                first[id] = second[id];
            }
        }
    }
    ts.copyProperties = copyProperties;
    function maybeBind(obj, fn) {
        return fn ? fn.bind(obj) : undefined;
    }
    ts.maybeBind = maybeBind;
    function createMultiMap() {
        var map = new ts.Map();
        map.add = multiMapAdd;
        map.remove = multiMapRemove;
        return map;
    }
    ts.createMultiMap = createMultiMap;
    function multiMapAdd(key, value) {
        var values = this.get(key);
        if (values) {
            values.push(value);
        }
        else {
            this.set(key, values = [value]);
        }
        return values;
    }
    function multiMapRemove(key, value) {
        var values = this.get(key);
        if (values) {
            unorderedRemoveItem(values, value);
            if (!values.length) {
                this.delete(key);
            }
        }
    }
    function createUnderscoreEscapedMultiMap() {
        return createMultiMap();
    }
    ts.createUnderscoreEscapedMultiMap = createUnderscoreEscapedMultiMap;
    function createSet(getHashCode, equals) {
        var multiMap = new ts.Map();
        var size = 0;
        function getElementIterator() {
            var valueIt = multiMap.values();
            var arrayIt;
            return {
                next: function () {
                    while (true) {
                        if (arrayIt) {
                            var n = arrayIt.next();
                            if (!n.done) {
                                return { value: n.value };
                            }
                            arrayIt = undefined;
                        }
                        else {
                            var n = valueIt.next();
                            if (n.done) {
                                return { value: undefined, done: true };
                            }
                            if (!isArray(n.value)) {
                                return { value: n.value };
                            }
                            arrayIt = arrayIterator(n.value);
                        }
                    }
                }
            };
        }
        var set = {
            has: function (element) {
                var hash = getHashCode(element);
                if (!multiMap.has(hash))
                    return false;
                var candidates = multiMap.get(hash);
                if (!isArray(candidates))
                    return equals(candidates, element);
                for (var _i = 0, candidates_1 = candidates; _i < candidates_1.length; _i++) {
                    var candidate = candidates_1[_i];
                    if (equals(candidate, element)) {
                        return true;
                    }
                }
                return false;
            },
            add: function (element) {
                var hash = getHashCode(element);
                if (multiMap.has(hash)) {
                    var values = multiMap.get(hash);
                    if (isArray(values)) {
                        if (!contains(values, element, equals)) {
                            values.push(element);
                            size++;
                        }
                    }
                    else {
                        var value = values;
                        if (!equals(value, element)) {
                            multiMap.set(hash, [value, element]);
                            size++;
                        }
                    }
                }
                else {
                    multiMap.set(hash, element);
                    size++;
                }
                return this;
            },
            delete: function (element) {
                var hash = getHashCode(element);
                if (!multiMap.has(hash))
                    return false;
                var candidates = multiMap.get(hash);
                if (isArray(candidates)) {
                    for (var i = 0; i < candidates.length; i++) {
                        if (equals(candidates[i], element)) {
                            if (candidates.length === 1) {
                                multiMap.delete(hash);
                            }
                            else if (candidates.length === 2) {
                                multiMap.set(hash, candidates[1 - i]);
                            }
                            else {
                                unorderedRemoveItemAt(candidates, i);
                            }
                            size--;
                            return true;
                        }
                    }
                }
                else {
                    var candidate = candidates;
                    if (equals(candidate, element)) {
                        multiMap.delete(hash);
                        size--;
                        return true;
                    }
                }
                return false;
            },
            clear: function () {
                multiMap.clear();
                size = 0;
            },
            get size() {
                return size;
            },
            forEach: function (action) {
                for (var _i = 0, _a = arrayFrom(multiMap.values()); _i < _a.length; _i++) {
                    var elements = _a[_i];
                    if (isArray(elements)) {
                        for (var _b = 0, elements_1 = elements; _b < elements_1.length; _b++) {
                            var element = elements_1[_b];
                            action(element, element);
                        }
                    }
                    else {
                        var element = elements;
                        action(element, element);
                    }
                }
            },
            keys: function () {
                return getElementIterator();
            },
            values: function () {
                return getElementIterator();
            },
            entries: function () {
                var it = getElementIterator();
                return {
                    next: function () {
                        var n = it.next();
                        return n.done ? n : { value: [n.value, n.value] };
                    }
                };
            },
        };
        return set;
    }
    ts.createSet = createSet;
    function isArray(value) {
        return Array.isArray ? Array.isArray(value) : value instanceof Array;
    }
    ts.isArray = isArray;
    function toArray(value) {
        return isArray(value) ? value : [value];
    }
    ts.toArray = toArray;
    function isString(text) {
        return typeof text === "string";
    }
    ts.isString = isString;
    function isNumber(x) {
        return typeof x === "number";
    }
    ts.isNumber = isNumber;
    function tryCast(value, test) {
        return value !== undefined && test(value) ? value : undefined;
    }
    ts.tryCast = tryCast;
    function cast(value, test) {
        if (value !== undefined && test(value))
            return value;
        return ts.Debug.fail("Invalid cast. The supplied value ".concat(value, " did not pass the test '").concat(ts.Debug.getFunctionName(test), "'."));
    }
    ts.cast = cast;
    function noop(_) { }
    ts.noop = noop;
    function returnFalse() {
        return false;
    }
    ts.returnFalse = returnFalse;
    function returnTrue() {
        return true;
    }
    ts.returnTrue = returnTrue;
    function returnUndefined() {
        return undefined;
    }
    ts.returnUndefined = returnUndefined;
    function identity(x) {
        return x;
    }
    ts.identity = identity;
    function toLowerCase(x) {
        return x.toLowerCase();
    }
    ts.toLowerCase = toLowerCase;
    var fileNameLowerCaseRegExp = /[^\u0130\u0131\u00DFa-z0-9\\/:\-_\. ]+/g;
    function toFileNameLowerCase(x) {
        return fileNameLowerCaseRegExp.test(x) ?
            x.replace(fileNameLowerCaseRegExp, toLowerCase) :
            x;
    }
    ts.toFileNameLowerCase = toFileNameLowerCase;
    function notImplemented() {
        throw new Error("Not implemented");
    }
    ts.notImplemented = notImplemented;
    function memoize(callback) {
        var value;
        return function () {
            if (callback) {
                value = callback();
                callback = undefined;
            }
            return value;
        };
    }
    ts.memoize = memoize;
    function memoizeOne(callback) {
        var map = new ts.Map();
        return function (arg) {
            var key = "".concat(typeof arg, ":").concat(arg);
            var value = map.get(key);
            if (value === undefined && !map.has(key)) {
                value = callback(arg);
                map.set(key, value);
            }
            return value;
        };
    }
    ts.memoizeOne = memoizeOne;
    function compose(a, b, c, d, e) {
        if (!!e) {
            var args_2 = [];
            for (var i = 0; i < arguments.length; i++) {
                args_2[i] = arguments[i];
            }
            return function (t) { return reduceLeft(args_2, function (u, f) { return f(u); }, t); };
        }
        else if (d) {
            return function (t) { return d(c(b(a(t)))); };
        }
        else if (c) {
            return function (t) { return c(b(a(t))); };
        }
        else if (b) {
            return function (t) { return b(a(t)); };
        }
        else if (a) {
            return function (t) { return a(t); };
        }
        else {
            return function (t) { return t; };
        }
    }
    ts.compose = compose;
    function equateValues(a, b) {
        return a === b;
    }
    ts.equateValues = equateValues;
    function equateStringsCaseInsensitive(a, b) {
        return a === b
            || a !== undefined
                && b !== undefined
                && a.toUpperCase() === b.toUpperCase();
    }
    ts.equateStringsCaseInsensitive = equateStringsCaseInsensitive;
    function equateStringsCaseSensitive(a, b) {
        return equateValues(a, b);
    }
    ts.equateStringsCaseSensitive = equateStringsCaseSensitive;
    function compareComparableValues(a, b) {
        return a === b ? 0 :
            a === undefined ? -1 :
                b === undefined ? 1 :
                    a < b ? -1 :
                        1;
    }
    function compareValues(a, b) {
        return compareComparableValues(a, b);
    }
    ts.compareValues = compareValues;
    function compareTextSpans(a, b) {
        return compareValues(a === null || a === void 0 ? void 0 : a.start, b === null || b === void 0 ? void 0 : b.start) || compareValues(a === null || a === void 0 ? void 0 : a.length, b === null || b === void 0 ? void 0 : b.length);
    }
    ts.compareTextSpans = compareTextSpans;
    function min(a, b, compare) {
        return compare(a, b) === -1 ? a : b;
    }
    ts.min = min;
    function compareStringsCaseInsensitive(a, b) {
        if (a === b)
            return 0;
        if (a === undefined)
            return -1;
        if (b === undefined)
            return 1;
        a = a.toUpperCase();
        b = b.toUpperCase();
        return a < b ? -1 : a > b ? 1 : 0;
    }
    ts.compareStringsCaseInsensitive = compareStringsCaseInsensitive;
    function compareStringsCaseSensitive(a, b) {
        return compareComparableValues(a, b);
    }
    ts.compareStringsCaseSensitive = compareStringsCaseSensitive;
    function getStringComparer(ignoreCase) {
        return ignoreCase ? compareStringsCaseInsensitive : compareStringsCaseSensitive;
    }
    ts.getStringComparer = getStringComparer;
    var createUIStringComparer = (function () {
        var defaultComparer;
        var enUSComparer;
        var stringComparerFactory = getStringComparerFactory();
        return createStringComparer;
        function compareWithCallback(a, b, comparer) {
            if (a === b)
                return 0;
            if (a === undefined)
                return -1;
            if (b === undefined)
                return 1;
            var value = comparer(a, b);
            return value < 0 ? -1 : value > 0 ? 1 : 0;
        }
        function createIntlCollatorStringComparer(locale) {
            var comparer = new Intl.Collator(locale, { usage: "sort", sensitivity: "variant" }).compare;
            return function (a, b) { return compareWithCallback(a, b, comparer); };
        }
        function createLocaleCompareStringComparer(locale) {
            if (locale !== undefined)
                return createFallbackStringComparer();
            return function (a, b) { return compareWithCallback(a, b, compareStrings); };
            function compareStrings(a, b) {
                return a.localeCompare(b);
            }
        }
        function createFallbackStringComparer() {
            return function (a, b) { return compareWithCallback(a, b, compareDictionaryOrder); };
            function compareDictionaryOrder(a, b) {
                return compareStrings(a.toUpperCase(), b.toUpperCase()) || compareStrings(a, b);
            }
            function compareStrings(a, b) {
                return a < b ? -1 : a > b ? 1 : 0;
            }
        }
        function getStringComparerFactory() {
            if (typeof Intl === "object" && typeof Intl.Collator === "function") {
                return createIntlCollatorStringComparer;
            }
            if (typeof String.prototype.localeCompare === "function" &&
                typeof String.prototype.toLocaleUpperCase === "function" &&
                "a".localeCompare("B") < 0) {
                return createLocaleCompareStringComparer;
            }
            return createFallbackStringComparer;
        }
        function createStringComparer(locale) {
            if (locale === undefined) {
                return defaultComparer || (defaultComparer = stringComparerFactory(locale));
            }
            else if (locale === "en-US") {
                return enUSComparer || (enUSComparer = stringComparerFactory(locale));
            }
            else {
                return stringComparerFactory(locale);
            }
        }
    })();
    var uiComparerCaseSensitive;
    var uiLocale;
    function getUILocale() {
        return uiLocale;
    }
    ts.getUILocale = getUILocale;
    function setUILocale(value) {
        if (uiLocale !== value) {
            uiLocale = value;
            uiComparerCaseSensitive = undefined;
        }
    }
    ts.setUILocale = setUILocale;
    function compareStringsCaseSensitiveUI(a, b) {
        var comparer = uiComparerCaseSensitive || (uiComparerCaseSensitive = createUIStringComparer(uiLocale));
        return comparer(a, b);
    }
    ts.compareStringsCaseSensitiveUI = compareStringsCaseSensitiveUI;
    function compareProperties(a, b, key, comparer) {
        return a === b ? 0 :
            a === undefined ? -1 :
                b === undefined ? 1 :
                    comparer(a[key], b[key]);
    }
    ts.compareProperties = compareProperties;
    function compareBooleans(a, b) {
        return compareValues(a ? 1 : 0, b ? 1 : 0);
    }
    ts.compareBooleans = compareBooleans;
    function getSpellingSuggestion(name, candidates, getName) {
        var maximumLengthDifference = Math.min(2, Math.floor(name.length * 0.34));
        var bestDistance = Math.floor(name.length * 0.4) + 1;
        var bestCandidate;
        for (var _i = 0, candidates_2 = candidates; _i < candidates_2.length; _i++) {
            var candidate = candidates_2[_i];
            var candidateName = getName(candidate);
            if (candidateName !== undefined && Math.abs(candidateName.length - name.length) <= maximumLengthDifference) {
                if (candidateName === name) {
                    continue;
                }
                if (candidateName.length < 3 && candidateName.toLowerCase() !== name.toLowerCase()) {
                    continue;
                }
                var distance = levenshteinWithMax(name, candidateName, bestDistance - 0.1);
                if (distance === undefined) {
                    continue;
                }
                ts.Debug.assert(distance < bestDistance);
                bestDistance = distance;
                bestCandidate = candidate;
            }
        }
        return bestCandidate;
    }
    ts.getSpellingSuggestion = getSpellingSuggestion;
    function levenshteinWithMax(s1, s2, max) {
        var previous = new Array(s2.length + 1);
        var current = new Array(s2.length + 1);
        var big = max + 0.01;
        for (var i = 0; i <= s2.length; i++) {
            previous[i] = i;
        }
        for (var i = 1; i <= s1.length; i++) {
            var c1 = s1.charCodeAt(i - 1);
            var minJ = Math.ceil(i > max ? i - max : 1);
            var maxJ = Math.floor(s2.length > max + i ? max + i : s2.length);
            current[0] = i;
            var colMin = i;
            for (var j = 1; j < minJ; j++) {
                current[j] = big;
            }
            for (var j = minJ; j <= maxJ; j++) {
                var substitutionDistance = s1[i - 1].toLowerCase() === s2[j - 1].toLowerCase()
                    ? (previous[j - 1] + 0.1)
                    : (previous[j - 1] + 2);
                var dist = c1 === s2.charCodeAt(j - 1)
                    ? previous[j - 1]
                    : Math.min(previous[j] + 1, current[j - 1] + 1, substitutionDistance);
                current[j] = dist;
                colMin = Math.min(colMin, dist);
            }
            for (var j = maxJ + 1; j <= s2.length; j++) {
                current[j] = big;
            }
            if (colMin > max) {
                return undefined;
            }
            var temp = previous;
            previous = current;
            current = temp;
        }
        var res = previous[s2.length];
        return res > max ? undefined : res;
    }
    function endsWith(str, suffix) {
        var expectedPos = str.length - suffix.length;
        return expectedPos >= 0 && str.indexOf(suffix, expectedPos) === expectedPos;
    }
    ts.endsWith = endsWith;
    function removeSuffix(str, suffix) {
        return endsWith(str, suffix) ? str.slice(0, str.length - suffix.length) : str;
    }
    ts.removeSuffix = removeSuffix;
    function tryRemoveSuffix(str, suffix) {
        return endsWith(str, suffix) ? str.slice(0, str.length - suffix.length) : undefined;
    }
    ts.tryRemoveSuffix = tryRemoveSuffix;
    function stringContains(str, substring) {
        return str.indexOf(substring) !== -1;
    }
    ts.stringContains = stringContains;
    function removeMinAndVersionNumbers(fileName) {
        var end = fileName.length;
        for (var pos = end - 1; pos > 0; pos--) {
            var ch = fileName.charCodeAt(pos);
            if (ch >= 48 && ch <= 57) {
                do {
                    --pos;
                    ch = fileName.charCodeAt(pos);
                } while (pos > 0 && ch >= 48 && ch <= 57);
            }
            else if (pos > 4 && (ch === 110 || ch === 78)) {
                --pos;
                ch = fileName.charCodeAt(pos);
                if (ch !== 105 && ch !== 73) {
                    break;
                }
                --pos;
                ch = fileName.charCodeAt(pos);
                if (ch !== 109 && ch !== 77) {
                    break;
                }
                --pos;
                ch = fileName.charCodeAt(pos);
            }
            else {
                break;
            }
            if (ch !== 45 && ch !== 46) {
                break;
            }
            end = pos;
        }
        return end === fileName.length ? fileName : fileName.slice(0, end);
    }
    ts.removeMinAndVersionNumbers = removeMinAndVersionNumbers;
    function orderedRemoveItem(array, item) {
        for (var i = 0; i < array.length; i++) {
            if (array[i] === item) {
                orderedRemoveItemAt(array, i);
                return true;
            }
        }
        return false;
    }
    ts.orderedRemoveItem = orderedRemoveItem;
    function orderedRemoveItemAt(array, index) {
        for (var i = index; i < array.length - 1; i++) {
            array[i] = array[i + 1];
        }
        array.pop();
    }
    ts.orderedRemoveItemAt = orderedRemoveItemAt;
    function unorderedRemoveItemAt(array, index) {
        array[index] = array[array.length - 1];
        array.pop();
    }
    ts.unorderedRemoveItemAt = unorderedRemoveItemAt;
    function unorderedRemoveItem(array, item) {
        return unorderedRemoveFirstItemWhere(array, function (element) { return element === item; });
    }
    ts.unorderedRemoveItem = unorderedRemoveItem;
    function unorderedRemoveFirstItemWhere(array, predicate) {
        for (var i = 0; i < array.length; i++) {
            if (predicate(array[i])) {
                unorderedRemoveItemAt(array, i);
                return true;
            }
        }
        return false;
    }
    function createGetCanonicalFileName(useCaseSensitiveFileNames) {
        return useCaseSensitiveFileNames ? identity : toFileNameLowerCase;
    }
    ts.createGetCanonicalFileName = createGetCanonicalFileName;
    function patternText(_a) {
        var prefix = _a.prefix, suffix = _a.suffix;
        return "".concat(prefix, "*").concat(suffix);
    }
    ts.patternText = patternText;
    function matchedText(pattern, candidate) {
        ts.Debug.assert(isPatternMatch(pattern, candidate));
        return candidate.substring(pattern.prefix.length, candidate.length - pattern.suffix.length);
    }
    ts.matchedText = matchedText;
    function findBestPatternMatch(values, getPattern, candidate) {
        var matchedValue;
        var longestMatchPrefixLength = -1;
        for (var _i = 0, values_2 = values; _i < values_2.length; _i++) {
            var v = values_2[_i];
            var pattern = getPattern(v);
            if (isPatternMatch(pattern, candidate) && pattern.prefix.length > longestMatchPrefixLength) {
                longestMatchPrefixLength = pattern.prefix.length;
                matchedValue = v;
            }
        }
        return matchedValue;
    }
    ts.findBestPatternMatch = findBestPatternMatch;
    function startsWith(str, prefix) {
        return str.lastIndexOf(prefix, 0) === 0;
    }
    ts.startsWith = startsWith;
    function removePrefix(str, prefix) {
        return startsWith(str, prefix) ? str.substr(prefix.length) : str;
    }
    ts.removePrefix = removePrefix;
    function tryRemovePrefix(str, prefix, getCanonicalFileName) {
        if (getCanonicalFileName === void 0) { getCanonicalFileName = identity; }
        return startsWith(getCanonicalFileName(str), getCanonicalFileName(prefix)) ? str.substring(prefix.length) : undefined;
    }
    ts.tryRemovePrefix = tryRemovePrefix;
    function isPatternMatch(_a, candidate) {
        var prefix = _a.prefix, suffix = _a.suffix;
        return candidate.length >= prefix.length + suffix.length &&
            startsWith(candidate, prefix) &&
            endsWith(candidate, suffix);
    }
    function and(f, g) {
        return function (arg) { return f(arg) && g(arg); };
    }
    ts.and = and;
    function or() {
        var fs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            fs[_i] = arguments[_i];
        }
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var lastResult;
            for (var _a = 0, fs_1 = fs; _a < fs_1.length; _a++) {
                var f = fs_1[_a];
                lastResult = f.apply(void 0, args);
                if (lastResult) {
                    return lastResult;
                }
            }
            return lastResult;
        };
    }
    ts.or = or;
    function not(fn) {
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return !fn.apply(void 0, args);
        };
    }
    ts.not = not;
    function assertType(_) { }
    ts.assertType = assertType;
    function singleElementArray(t) {
        return t === undefined ? undefined : [t];
    }
    ts.singleElementArray = singleElementArray;
    function enumerateInsertsAndDeletes(newItems, oldItems, comparer, inserted, deleted, unchanged) {
        unchanged = unchanged || noop;
        var newIndex = 0;
        var oldIndex = 0;
        var newLen = newItems.length;
        var oldLen = oldItems.length;
        var hasChanges = false;
        while (newIndex < newLen && oldIndex < oldLen) {
            var newItem = newItems[newIndex];
            var oldItem = oldItems[oldIndex];
            var compareResult = comparer(newItem, oldItem);
            if (compareResult === -1) {
                inserted(newItem);
                newIndex++;
                hasChanges = true;
            }
            else if (compareResult === 1) {
                deleted(oldItem);
                oldIndex++;
                hasChanges = true;
            }
            else {
                unchanged(oldItem, newItem);
                newIndex++;
                oldIndex++;
            }
        }
        while (newIndex < newLen) {
            inserted(newItems[newIndex++]);
            hasChanges = true;
        }
        while (oldIndex < oldLen) {
            deleted(oldItems[oldIndex++]);
            hasChanges = true;
        }
        return hasChanges;
    }
    ts.enumerateInsertsAndDeletes = enumerateInsertsAndDeletes;
    function fill(length, cb) {
        var result = Array(length);
        for (var i = 0; i < length; i++) {
            result[i] = cb(i);
        }
        return result;
    }
    ts.fill = fill;
    function cartesianProduct(arrays) {
        var result = [];
        cartesianProductWorker(arrays, result, undefined, 0);
        return result;
    }
    ts.cartesianProduct = cartesianProduct;
    function cartesianProductWorker(arrays, result, outer, index) {
        for (var _i = 0, _a = arrays[index]; _i < _a.length; _i++) {
            var element = _a[_i];
            var inner = void 0;
            if (outer) {
                inner = outer.slice();
                inner.push(element);
            }
            else {
                inner = [element];
            }
            if (index === arrays.length - 1) {
                result.push(inner);
            }
            else {
                cartesianProductWorker(arrays, result, inner, index + 1);
            }
        }
    }
    function padLeft(s, length, padString) {
        if (padString === void 0) { padString = " "; }
        return length <= s.length ? s : padString.repeat(length - s.length) + s;
    }
    ts.padLeft = padLeft;
    function padRight(s, length, padString) {
        if (padString === void 0) { padString = " "; }
        return length <= s.length ? s : s + padString.repeat(length - s.length);
    }
    ts.padRight = padRight;
    function takeWhile(array, predicate) {
        var len = array.length;
        var index = 0;
        while (index < len && predicate(array[index])) {
            index++;
        }
        return array.slice(0, index);
    }
    ts.takeWhile = takeWhile;
    ts.trimString = !!String.prototype.trim ? (function (s) { return s.trim(); }) : function (s) { return ts.trimStringEnd(ts.trimStringStart(s)); };
    ts.trimStringEnd = !!String.prototype.trimEnd ? (function (s) { return s.trimEnd(); }) : trimEndImpl;
    ts.trimStringStart = !!String.prototype.trimStart ? (function (s) { return s.trimStart(); }) : function (s) { return s.replace(/^\s+/g, ""); };
    function trimEndImpl(s) {
        var end = s.length - 1;
        while (end >= 0) {
            if (!ts.isWhiteSpaceLike(s.charCodeAt(end)))
                break;
            end--;
        }
        return s.slice(0, end + 1);
    }
})(ts || (ts = {}));
var ts;
(function (ts) {
    var LogLevel;
    (function (LogLevel) {
        LogLevel[LogLevel["Off"] = 0] = "Off";
        LogLevel[LogLevel["Error"] = 1] = "Error";
        LogLevel[LogLevel["Warning"] = 2] = "Warning";
        LogLevel[LogLevel["Info"] = 3] = "Info";
        LogLevel[LogLevel["Verbose"] = 4] = "Verbose";
    })(LogLevel = ts.LogLevel || (ts.LogLevel = {}));
    var Debug;
    (function (Debug) {
        var typeScriptVersion;
        var currentAssertionLevel = 0;
        Debug.currentLogLevel = LogLevel.Warning;
        Debug.isDebugging = false;
        function getTypeScriptVersion() {
            return typeScriptVersion !== null && typeScriptVersion !== void 0 ? typeScriptVersion : (typeScriptVersion = new ts.Version(ts.version));
        }
        Debug.getTypeScriptVersion = getTypeScriptVersion;
        function shouldLog(level) {
            return Debug.currentLogLevel <= level;
        }
        Debug.shouldLog = shouldLog;
        function logMessage(level, s) {
            if (Debug.loggingHost && shouldLog(level)) {
                Debug.loggingHost.log(level, s);
            }
        }
        function log(s) {
            logMessage(LogLevel.Info, s);
        }
        Debug.log = log;
        (function (log_1) {
            function error(s) {
                logMessage(LogLevel.Error, s);
            }
            log_1.error = error;
            function warn(s) {
                logMessage(LogLevel.Warning, s);
            }
            log_1.warn = warn;
            function log(s) {
                logMessage(LogLevel.Info, s);
            }
            log_1.log = log;
            function trace(s) {
                logMessage(LogLevel.Verbose, s);
            }
            log_1.trace = trace;
        })(log = Debug.log || (Debug.log = {}));
        var assertionCache = {};
        function getAssertionLevel() {
            return currentAssertionLevel;
        }
        Debug.getAssertionLevel = getAssertionLevel;
        function setAssertionLevel(level) {
            var prevAssertionLevel = currentAssertionLevel;
            currentAssertionLevel = level;
            if (level > prevAssertionLevel) {
                for (var _i = 0, _a = ts.getOwnKeys(assertionCache); _i < _a.length; _i++) {
                    var key = _a[_i];
                    var cachedFunc = assertionCache[key];
                    if (cachedFunc !== undefined && Debug[key] !== cachedFunc.assertion && level >= cachedFunc.level) {
                        Debug[key] = cachedFunc;
                        assertionCache[key] = undefined;
                    }
                }
            }
        }
        Debug.setAssertionLevel = setAssertionLevel;
        function shouldAssert(level) {
            return currentAssertionLevel >= level;
        }
        Debug.shouldAssert = shouldAssert;
        function shouldAssertFunction(level, name) {
            if (!shouldAssert(level)) {
                assertionCache[name] = { level: level, assertion: Debug[name] };
                Debug[name] = ts.noop;
                return false;
            }
            return true;
        }
        function fail(message, stackCrawlMark) {
            debugger;
            var e = new Error(message ? "Debug Failure. ".concat(message) : "Debug Failure.");
            if (Error.captureStackTrace) {
                Error.captureStackTrace(e, stackCrawlMark || fail);
            }
            throw e;
        }
        Debug.fail = fail;
        function failBadSyntaxKind(node, message, stackCrawlMark) {
            return fail("".concat(message || "Unexpected node.", "\r\nNode ").concat(formatSyntaxKind(node.kind), " was unexpected."), stackCrawlMark || failBadSyntaxKind);
        }
        Debug.failBadSyntaxKind = failBadSyntaxKind;
        function assert(expression, message, verboseDebugInfo, stackCrawlMark) {
            if (!expression) {
                message = message ? "False expression: ".concat(message) : "False expression.";
                if (verboseDebugInfo) {
                    message += "\r\nVerbose Debug Information: " + (typeof verboseDebugInfo === "string" ? verboseDebugInfo : verboseDebugInfo());
                }
                fail(message, stackCrawlMark || assert);
            }
        }
        Debug.assert = assert;
        function assertEqual(a, b, msg, msg2, stackCrawlMark) {
            if (a !== b) {
                var message = msg ? msg2 ? "".concat(msg, " ").concat(msg2) : msg : "";
                fail("Expected ".concat(a, " === ").concat(b, ". ").concat(message), stackCrawlMark || assertEqual);
            }
        }
        Debug.assertEqual = assertEqual;
        function assertLessThan(a, b, msg, stackCrawlMark) {
            if (a >= b) {
                fail("Expected ".concat(a, " < ").concat(b, ". ").concat(msg || ""), stackCrawlMark || assertLessThan);
            }
        }
        Debug.assertLessThan = assertLessThan;
        function assertLessThanOrEqual(a, b, stackCrawlMark) {
            if (a > b) {
                fail("Expected ".concat(a, " <= ").concat(b), stackCrawlMark || assertLessThanOrEqual);
            }
        }
        Debug.assertLessThanOrEqual = assertLessThanOrEqual;
        function assertGreaterThanOrEqual(a, b, stackCrawlMark) {
            if (a < b) {
                fail("Expected ".concat(a, " >= ").concat(b), stackCrawlMark || assertGreaterThanOrEqual);
            }
        }
        Debug.assertGreaterThanOrEqual = assertGreaterThanOrEqual;
        function assertIsDefined(value, message, stackCrawlMark) {
            if (value === undefined || value === null) {
                fail(message, stackCrawlMark || assertIsDefined);
            }
        }
        Debug.assertIsDefined = assertIsDefined;
        function checkDefined(value, message, stackCrawlMark) {
            assertIsDefined(value, message, stackCrawlMark || checkDefined);
            return value;
        }
        Debug.checkDefined = checkDefined;
        function assertEachIsDefined(value, message, stackCrawlMark) {
            for (var _i = 0, value_1 = value; _i < value_1.length; _i++) {
                var v = value_1[_i];
                assertIsDefined(v, message, stackCrawlMark || assertEachIsDefined);
            }
        }
        Debug.assertEachIsDefined = assertEachIsDefined;
        function checkEachDefined(value, message, stackCrawlMark) {
            assertEachIsDefined(value, message, stackCrawlMark || checkEachDefined);
            return value;
        }
        Debug.checkEachDefined = checkEachDefined;
        function assertNever(member, message, stackCrawlMark) {
            if (message === void 0) { message = "Illegal value:"; }
            var detail = typeof member === "object" && ts.hasProperty(member, "kind") && ts.hasProperty(member, "pos") ? "SyntaxKind: " + formatSyntaxKind(member.kind) : JSON.stringify(member);
            return fail("".concat(message, " ").concat(detail), stackCrawlMark || assertNever);
        }
        Debug.assertNever = assertNever;
        function assertEachNode(nodes, test, message, stackCrawlMark) {
            if (shouldAssertFunction(1, "assertEachNode")) {
                assert(test === undefined || ts.every(nodes, test), message || "Unexpected node.", function () { return "Node array did not pass test '".concat(getFunctionName(test), "'."); }, stackCrawlMark || assertEachNode);
            }
        }
        Debug.assertEachNode = assertEachNode;
        function assertNode(node, test, message, stackCrawlMark) {
            if (shouldAssertFunction(1, "assertNode")) {
                assert(node !== undefined && (test === undefined || test(node)), message || "Unexpected node.", function () { return "Node ".concat(formatSyntaxKind(node === null || node === void 0 ? void 0 : node.kind), " did not pass test '").concat(getFunctionName(test), "'."); }, stackCrawlMark || assertNode);
            }
        }
        Debug.assertNode = assertNode;
        function assertNotNode(node, test, message, stackCrawlMark) {
            if (shouldAssertFunction(1, "assertNotNode")) {
                assert(node === undefined || test === undefined || !test(node), message || "Unexpected node.", function () { return "Node ".concat(formatSyntaxKind(node.kind), " should not have passed test '").concat(getFunctionName(test), "'."); }, stackCrawlMark || assertNotNode);
            }
        }
        Debug.assertNotNode = assertNotNode;
        function assertOptionalNode(node, test, message, stackCrawlMark) {
            if (shouldAssertFunction(1, "assertOptionalNode")) {
                assert(test === undefined || node === undefined || test(node), message || "Unexpected node.", function () { return "Node ".concat(formatSyntaxKind(node === null || node === void 0 ? void 0 : node.kind), " did not pass test '").concat(getFunctionName(test), "'."); }, stackCrawlMark || assertOptionalNode);
            }
        }
        Debug.assertOptionalNode = assertOptionalNode;
        function assertOptionalToken(node, kind, message, stackCrawlMark) {
            if (shouldAssertFunction(1, "assertOptionalToken")) {
                assert(kind === undefined || node === undefined || node.kind === kind, message || "Unexpected node.", function () { return "Node ".concat(formatSyntaxKind(node === null || node === void 0 ? void 0 : node.kind), " was not a '").concat(formatSyntaxKind(kind), "' token."); }, stackCrawlMark || assertOptionalToken);
            }
        }
        Debug.assertOptionalToken = assertOptionalToken;
        function assertMissingNode(node, message, stackCrawlMark) {
            if (shouldAssertFunction(1, "assertMissingNode")) {
                assert(node === undefined, message || "Unexpected node.", function () { return "Node ".concat(formatSyntaxKind(node.kind), " was unexpected'."); }, stackCrawlMark || assertMissingNode);
            }
        }
        Debug.assertMissingNode = assertMissingNode;
        function type(_value) { }
        Debug.type = type;
        function getFunctionName(func) {
            if (typeof func !== "function") {
                return "";
            }
            else if (func.hasOwnProperty("name")) {
                return func.name;
            }
            else {
                var text = Function.prototype.toString.call(func);
                var match = /^function\s+([\w\$]+)\s*\(/.exec(text);
                return match ? match[1] : "";
            }
        }
        Debug.getFunctionName = getFunctionName;
        function formatSymbol(symbol) {
            return "{ name: ".concat(ts.unescapeLeadingUnderscores(symbol.escapedName), "; flags: ").concat(formatSymbolFlags(symbol.flags), "; declarations: ").concat(ts.map(symbol.declarations, function (node) { return formatSyntaxKind(node.kind); }), " }");
        }
        Debug.formatSymbol = formatSymbol;
        function formatEnum(value, enumObject, isFlags) {
            if (value === void 0) { value = 0; }
            var members = getEnumMembers(enumObject);
            if (value === 0) {
                return members.length > 0 && members[0][0] === 0 ? members[0][1] : "0";
            }
            if (isFlags) {
                var result = "";
                var remainingFlags = value;
                for (var _i = 0, members_1 = members; _i < members_1.length; _i++) {
                    var _a = members_1[_i], enumValue = _a[0], enumName = _a[1];
                    if (enumValue > value) {
                        break;
                    }
                    if (enumValue !== 0 && enumValue & value) {
                        result = "".concat(result).concat(result ? "|" : "").concat(enumName);
                        remainingFlags &= ~enumValue;
                    }
                }
                if (remainingFlags === 0) {
                    return result;
                }
            }
            else {
                for (var _b = 0, members_2 = members; _b < members_2.length; _b++) {
                    var _c = members_2[_b], enumValue = _c[0], enumName = _c[1];
                    if (enumValue === value) {
                        return enumName;
                    }
                }
            }
            return value.toString();
        }
        Debug.formatEnum = formatEnum;
        function getEnumMembers(enumObject) {
            var result = [];
            for (var name in enumObject) {
                var value = enumObject[name];
                if (typeof value === "number") {
                    result.push([value, name]);
                }
            }
            return ts.stableSort(result, function (x, y) { return ts.compareValues(x[0], y[0]); });
        }
        function formatSyntaxKind(kind) {
            return formatEnum(kind, ts.SyntaxKind, false);
        }
        Debug.formatSyntaxKind = formatSyntaxKind;
        function formatSnippetKind(kind) {
            return formatEnum(kind, ts.SnippetKind, false);
        }
        Debug.formatSnippetKind = formatSnippetKind;
        function formatNodeFlags(flags) {
            return formatEnum(flags, ts.NodeFlags, true);
        }
        Debug.formatNodeFlags = formatNodeFlags;
        function formatModifierFlags(flags) {
            return formatEnum(flags, ts.ModifierFlags, true);
        }
        Debug.formatModifierFlags = formatModifierFlags;
        function formatTransformFlags(flags) {
            return formatEnum(flags, ts.TransformFlags, true);
        }
        Debug.formatTransformFlags = formatTransformFlags;
        function formatEmitFlags(flags) {
            return formatEnum(flags, ts.EmitFlags, true);
        }
        Debug.formatEmitFlags = formatEmitFlags;
        function formatSymbolFlags(flags) {
            return formatEnum(flags, ts.SymbolFlags, true);
        }
        Debug.formatSymbolFlags = formatSymbolFlags;
        function formatTypeFlags(flags) {
            return formatEnum(flags, ts.TypeFlags, true);
        }
        Debug.formatTypeFlags = formatTypeFlags;
        function formatSignatureFlags(flags) {
            return formatEnum(flags, ts.SignatureFlags, true);
        }
        Debug.formatSignatureFlags = formatSignatureFlags;
        function formatObjectFlags(flags) {
            return formatEnum(flags, ts.ObjectFlags, true);
        }
        Debug.formatObjectFlags = formatObjectFlags;
        function formatFlowFlags(flags) {
            return formatEnum(flags, ts.FlowFlags, true);
        }
        Debug.formatFlowFlags = formatFlowFlags;
        var isDebugInfoEnabled = false;
        var extendedDebugModule;
        function extendedDebug() {
            enableDebugInfo();
            if (!extendedDebugModule) {
                throw new Error("Debugging helpers could not be loaded.");
            }
            return extendedDebugModule;
        }
        function printControlFlowGraph(flowNode) {
            return console.log(formatControlFlowGraph(flowNode));
        }
        Debug.printControlFlowGraph = printControlFlowGraph;
        function formatControlFlowGraph(flowNode) {
            return extendedDebug().formatControlFlowGraph(flowNode);
        }
        Debug.formatControlFlowGraph = formatControlFlowGraph;
        var flowNodeProto;
        function attachFlowNodeDebugInfoWorker(flowNode) {
            if (!("__debugFlowFlags" in flowNode)) {
                Object.defineProperties(flowNode, {
                    __tsDebuggerDisplay: {
                        value: function () {
                            var flowHeader = this.flags & 2 ? "FlowStart" :
                                this.flags & 4 ? "FlowBranchLabel" :
                                    this.flags & 8 ? "FlowLoopLabel" :
                                        this.flags & 16 ? "FlowAssignment" :
                                            this.flags & 32 ? "FlowTrueCondition" :
                                                this.flags & 64 ? "FlowFalseCondition" :
                                                    this.flags & 128 ? "FlowSwitchClause" :
                                                        this.flags & 256 ? "FlowArrayMutation" :
                                                            this.flags & 512 ? "FlowCall" :
                                                                this.flags & 1024 ? "FlowReduceLabel" :
                                                                    this.flags & 1 ? "FlowUnreachable" :
                                                                        "UnknownFlow";
                            var remainingFlags = this.flags & ~(2048 - 1);
                            return "".concat(flowHeader).concat(remainingFlags ? " (".concat(formatFlowFlags(remainingFlags), ")") : "");
                        }
                    },
                    __debugFlowFlags: { get: function () { return formatEnum(this.flags, ts.FlowFlags, true); } },
                    __debugToString: { value: function () { return formatControlFlowGraph(this); } }
                });
            }
        }
        function attachFlowNodeDebugInfo(flowNode) {
            if (isDebugInfoEnabled) {
                if (typeof Object.setPrototypeOf === "function") {
                    if (!flowNodeProto) {
                        flowNodeProto = Object.create(Object.prototype);
                        attachFlowNodeDebugInfoWorker(flowNodeProto);
                    }
                    Object.setPrototypeOf(flowNode, flowNodeProto);
                }
                else {
                    attachFlowNodeDebugInfoWorker(flowNode);
                }
            }
        }
        Debug.attachFlowNodeDebugInfo = attachFlowNodeDebugInfo;
        var nodeArrayProto;
        function attachNodeArrayDebugInfoWorker(array) {
            if (!("__tsDebuggerDisplay" in array)) {
                Object.defineProperties(array, {
                    __tsDebuggerDisplay: {
                        value: function (defaultValue) {
                            defaultValue = String(defaultValue).replace(/(?:,[\s\w\d_]+:[^,]+)+\]$/, "]");
                            return "NodeArray ".concat(defaultValue);
                        }
                    }
                });
            }
        }
        function attachNodeArrayDebugInfo(array) {
            if (isDebugInfoEnabled) {
                if (typeof Object.setPrototypeOf === "function") {
                    if (!nodeArrayProto) {
                        nodeArrayProto = Object.create(Array.prototype);
                        attachNodeArrayDebugInfoWorker(nodeArrayProto);
                    }
                    Object.setPrototypeOf(array, nodeArrayProto);
                }
                else {
                    attachNodeArrayDebugInfoWorker(array);
                }
            }
        }
        Debug.attachNodeArrayDebugInfo = attachNodeArrayDebugInfo;
        function enableDebugInfo() {
            if (isDebugInfoEnabled)
                return;
            var weakTypeTextMap;
            var weakNodeTextMap;
            function getWeakTypeTextMap() {
                if (weakTypeTextMap === undefined) {
                    if (typeof WeakMap === "function")
                        weakTypeTextMap = new WeakMap();
                }
                return weakTypeTextMap;
            }
            function getWeakNodeTextMap() {
                if (weakNodeTextMap === undefined) {
                    if (typeof WeakMap === "function")
                        weakNodeTextMap = new WeakMap();
                }
                return weakNodeTextMap;
            }
            Object.defineProperties(ts.objectAllocator.getSymbolConstructor().prototype, {
                __tsDebuggerDisplay: {
                    value: function () {
                        var symbolHeader = this.flags & 33554432 ? "TransientSymbol" :
                            "Symbol";
                        var remainingSymbolFlags = this.flags & ~33554432;
                        return "".concat(symbolHeader, " '").concat(ts.symbolName(this), "'").concat(remainingSymbolFlags ? " (".concat(formatSymbolFlags(remainingSymbolFlags), ")") : "");
                    }
                },
                __debugFlags: { get: function () { return formatSymbolFlags(this.flags); } }
            });
            Object.defineProperties(ts.objectAllocator.getTypeConstructor().prototype, {
                __tsDebuggerDisplay: {
                    value: function () {
                        var typeHeader = this.flags & 98304 ? "NullableType" :
                            this.flags & 384 ? "LiteralType ".concat(JSON.stringify(this.value)) :
                                this.flags & 2048 ? "LiteralType ".concat(this.value.negative ? "-" : "").concat(this.value.base10Value, "n") :
                                    this.flags & 8192 ? "UniqueESSymbolType" :
                                        this.flags & 32 ? "EnumType" :
                                            this.flags & 67359327 ? "IntrinsicType ".concat(this.intrinsicName) :
                                                this.flags & 1048576 ? "UnionType" :
                                                    this.flags & 2097152 ? "IntersectionType" :
                                                        this.flags & 4194304 ? "IndexType" :
                                                            this.flags & 8388608 ? "IndexedAccessType" :
                                                                this.flags & 16777216 ? "ConditionalType" :
                                                                    this.flags & 33554432 ? "SubstitutionType" :
                                                                        this.flags & 262144 ? "TypeParameter" :
                                                                            this.flags & 524288 ?
                                                                                this.objectFlags & 3 ? "InterfaceType" :
                                                                                    this.objectFlags & 4 ? "TypeReference" :
                                                                                        this.objectFlags & 8 ? "TupleType" :
                                                                                            this.objectFlags & 16 ? "AnonymousType" :
                                                                                                this.objectFlags & 32 ? "MappedType" :
                                                                                                    this.objectFlags & 1024 ? "ReverseMappedType" :
                                                                                                        this.objectFlags & 256 ? "EvolvingArrayType" :
                                                                                                            "ObjectType" :
                                                                                "Type";
                        var remainingObjectFlags = this.flags & 524288 ? this.objectFlags & ~1343 : 0;
                        return "".concat(typeHeader).concat(this.symbol ? " '".concat(ts.symbolName(this.symbol), "'") : "").concat(remainingObjectFlags ? " (".concat(formatObjectFlags(remainingObjectFlags), ")") : "");
                    }
                },
                __debugFlags: { get: function () { return formatTypeFlags(this.flags); } },
                __debugObjectFlags: { get: function () { return this.flags & 524288 ? formatObjectFlags(this.objectFlags) : ""; } },
                __debugTypeToString: {
                    value: function () {
                        var map = getWeakTypeTextMap();
                        var text = map === null || map === void 0 ? void 0 : map.get(this);
                        if (text === undefined) {
                            text = this.checker.typeToString(this);
                            map === null || map === void 0 ? void 0 : map.set(this, text);
                        }
                        return text;
                    }
                },
            });
            Object.defineProperties(ts.objectAllocator.getSignatureConstructor().prototype, {
                __debugFlags: { get: function () { return formatSignatureFlags(this.flags); } },
                __debugSignatureToString: { value: function () { var _a; return (_a = this.checker) === null || _a === void 0 ? void 0 : _a.signatureToString(this); } }
            });
            var nodeConstructors = [
                ts.objectAllocator.getNodeConstructor(),
                ts.objectAllocator.getIdentifierConstructor(),
                ts.objectAllocator.getTokenConstructor(),
                ts.objectAllocator.getSourceFileConstructor()
            ];
            for (var _i = 0, nodeConstructors_1 = nodeConstructors; _i < nodeConstructors_1.length; _i++) {
                var ctor = nodeConstructors_1[_i];
                if (!ctor.prototype.hasOwnProperty("__debugKind")) {
                    Object.defineProperties(ctor.prototype, {
                        __tsDebuggerDisplay: {
                            value: function () {
                                var nodeHeader = ts.isGeneratedIdentifier(this) ? "GeneratedIdentifier" :
                                    ts.isIdentifier(this) ? "Identifier '".concat(ts.idText(this), "'") :
                                        ts.isPrivateIdentifier(this) ? "PrivateIdentifier '".concat(ts.idText(this), "'") :
                                            ts.isStringLiteral(this) ? "StringLiteral ".concat(JSON.stringify(this.text.length < 10 ? this.text : this.text.slice(10) + "...")) :
                                                ts.isNumericLiteral(this) ? "NumericLiteral ".concat(this.text) :
                                                    ts.isBigIntLiteral(this) ? "BigIntLiteral ".concat(this.text, "n") :
                                                        ts.isTypeParameterDeclaration(this) ? "TypeParameterDeclaration" :
                                                            ts.isParameter(this) ? "ParameterDeclaration" :
                                                                ts.isConstructorDeclaration(this) ? "ConstructorDeclaration" :
                                                                    ts.isGetAccessorDeclaration(this) ? "GetAccessorDeclaration" :
                                                                        ts.isSetAccessorDeclaration(this) ? "SetAccessorDeclaration" :
                                                                            ts.isCallSignatureDeclaration(this) ? "CallSignatureDeclaration" :
                                                                                ts.isConstructSignatureDeclaration(this) ? "ConstructSignatureDeclaration" :
                                                                                    ts.isIndexSignatureDeclaration(this) ? "IndexSignatureDeclaration" :
                                                                                        ts.isTypePredicateNode(this) ? "TypePredicateNode" :
                                                                                            ts.isTypeReferenceNode(this) ? "TypeReferenceNode" :
                                                                                                ts.isFunctionTypeNode(this) ? "FunctionTypeNode" :
                                                                                                    ts.isConstructorTypeNode(this) ? "ConstructorTypeNode" :
                                                                                                        ts.isTypeQueryNode(this) ? "TypeQueryNode" :
                                                                                                            ts.isTypeLiteralNode(this) ? "TypeLiteralNode" :
                                                                                                                ts.isArrayTypeNode(this) ? "ArrayTypeNode" :
                                                                                                                    ts.isTupleTypeNode(this) ? "TupleTypeNode" :
                                                                                                                        ts.isOptionalTypeNode(this) ? "OptionalTypeNode" :
                                                                                                                            ts.isRestTypeNode(this) ? "RestTypeNode" :
                                                                                                                                ts.isUnionTypeNode(this) ? "UnionTypeNode" :
                                                                                                                                    ts.isIntersectionTypeNode(this) ? "IntersectionTypeNode" :
                                                                                                                                        ts.isConditionalTypeNode(this) ? "ConditionalTypeNode" :
                                                                                                                                            ts.isInferTypeNode(this) ? "InferTypeNode" :
                                                                                                                                                ts.isParenthesizedTypeNode(this) ? "ParenthesizedTypeNode" :
                                                                                                                                                    ts.isThisTypeNode(this) ? "ThisTypeNode" :
                                                                                                                                                        ts.isTypeOperatorNode(this) ? "TypeOperatorNode" :
                                                                                                                                                            ts.isIndexedAccessTypeNode(this) ? "IndexedAccessTypeNode" :
                                                                                                                                                                ts.isMappedTypeNode(this) ? "MappedTypeNode" :
                                                                                                                                                                    ts.isLiteralTypeNode(this) ? "LiteralTypeNode" :
                                                                                                                                                                        ts.isNamedTupleMember(this) ? "NamedTupleMember" :
                                                                                                                                                                            ts.isImportTypeNode(this) ? "ImportTypeNode" :
                                                                                                                                                                                formatSyntaxKind(this.kind);
                                return "".concat(nodeHeader).concat(this.flags ? " (".concat(formatNodeFlags(this.flags), ")") : "");
                            }
                        },
                        __debugKind: { get: function () { return formatSyntaxKind(this.kind); } },
                        __debugNodeFlags: { get: function () { return formatNodeFlags(this.flags); } },
                        __debugModifierFlags: { get: function () { return formatModifierFlags(ts.getEffectiveModifierFlagsNoCache(this)); } },
                        __debugTransformFlags: { get: function () { return formatTransformFlags(this.transformFlags); } },
                        __debugIsParseTreeNode: { get: function () { return ts.isParseTreeNode(this); } },
                        __debugEmitFlags: { get: function () { return formatEmitFlags(ts.getEmitFlags(this)); } },
                        __debugGetText: {
                            value: function (includeTrivia) {
                                if (ts.nodeIsSynthesized(this))
                                    return "";
                                var map = getWeakNodeTextMap();
                                var text = map === null || map === void 0 ? void 0 : map.get(this);
                                if (text === undefined) {
                                    var parseNode = ts.getParseTreeNode(this);
                                    var sourceFile = parseNode && ts.getSourceFileOfNode(parseNode);
                                    text = sourceFile ? ts.getSourceTextOfNodeFromSourceFile(sourceFile, parseNode, includeTrivia) : "";
                                    map === null || map === void 0 ? void 0 : map.set(this, text);
                                }
                                return text;
                            }
                        }
                    });
                }
            }
            try {
                if (ts.sys && ts.sys.require) {
                    var basePath = ts.getDirectoryPath(ts.resolvePath(ts.sys.getExecutingFilePath()));
                    var result = ts.sys.require(basePath, "./compiler-debug");
                    if (!result.error) {
                        result.module.init(ts);
                        extendedDebugModule = result.module;
                    }
                }
            }
            catch (_a) {
            }
            isDebugInfoEnabled = true;
        }
        Debug.enableDebugInfo = enableDebugInfo;
        function formatDeprecationMessage(name, error, errorAfter, since, message) {
            var deprecationMessage = error ? "DeprecationError: " : "DeprecationWarning: ";
            deprecationMessage += "'".concat(name, "' ");
            deprecationMessage += since ? "has been deprecated since v".concat(since) : "is deprecated";
            deprecationMessage += error ? " and can no longer be used." : errorAfter ? " and will no longer be usable after v".concat(errorAfter, ".") : ".";
            deprecationMessage += message ? " ".concat(ts.formatStringFromArgs(message, [name], 0)) : "";
            return deprecationMessage;
        }
        function createErrorDeprecation(name, errorAfter, since, message) {
            var deprecationMessage = formatDeprecationMessage(name, true, errorAfter, since, message);
            return function () {
                throw new TypeError(deprecationMessage);
            };
        }
        function createWarningDeprecation(name, errorAfter, since, message) {
            var hasWrittenDeprecation = false;
            return function () {
                if (!hasWrittenDeprecation) {
                    log.warn(formatDeprecationMessage(name, false, errorAfter, since, message));
                    hasWrittenDeprecation = true;
                }
            };
        }
        function createDeprecation(name, options) {
            var _a, _b;
            if (options === void 0) { options = {}; }
            var version = typeof options.typeScriptVersion === "string" ? new ts.Version(options.typeScriptVersion) : (_a = options.typeScriptVersion) !== null && _a !== void 0 ? _a : getTypeScriptVersion();
            var errorAfter = typeof options.errorAfter === "string" ? new ts.Version(options.errorAfter) : options.errorAfter;
            var warnAfter = typeof options.warnAfter === "string" ? new ts.Version(options.warnAfter) : options.warnAfter;
            var since = typeof options.since === "string" ? new ts.Version(options.since) : (_b = options.since) !== null && _b !== void 0 ? _b : warnAfter;
            var error = options.error || errorAfter && version.compareTo(errorAfter) <= 0;
            var warn = !warnAfter || version.compareTo(warnAfter) >= 0;
            return error ? createErrorDeprecation(name, errorAfter, since, options.message) :
                warn ? createWarningDeprecation(name, errorAfter, since, options.message) :
                    ts.noop;
        }
        function wrapFunction(deprecation, func) {
            return function () {
                deprecation();
                return func.apply(this, arguments);
            };
        }
        function deprecate(func, options) {
            var deprecation = createDeprecation(getFunctionName(func), options);
            return wrapFunction(deprecation, func);
        }
        Debug.deprecate = deprecate;
    })(Debug = ts.Debug || (ts.Debug = {}));
})(ts || (ts = {}));
var ts;
(function (ts) {
    var versionRegExp = /^(0|[1-9]\d*)(?:\.(0|[1-9]\d*)(?:\.(0|[1-9]\d*)(?:\-([a-z0-9-.]+))?(?:\+([a-z0-9-.]+))?)?)?$/i;
    var prereleaseRegExp = /^(?:0|[1-9]\d*|[a-z-][a-z0-9-]*)(?:\.(?:0|[1-9]\d*|[a-z-][a-z0-9-]*))*$/i;
    var buildRegExp = /^[a-z0-9-]+(?:\.[a-z0-9-]+)*$/i;
    var numericIdentifierRegExp = /^(0|[1-9]\d*)$/;
    var Version = (function () {
        function Version(major, minor, patch, prerelease, build) {
            if (minor === void 0) { minor = 0; }
            if (patch === void 0) { patch = 0; }
            if (prerelease === void 0) { prerelease = ""; }
            if (build === void 0) { build = ""; }
            if (typeof major === "string") {
                var result = ts.Debug.checkDefined(tryParseComponents(major), "Invalid version");
                (major = result.major, minor = result.minor, patch = result.patch, prerelease = result.prerelease, build = result.build);
            }
            ts.Debug.assert(major >= 0, "Invalid argument: major");
            ts.Debug.assert(minor >= 0, "Invalid argument: minor");
            ts.Debug.assert(patch >= 0, "Invalid argument: patch");
            ts.Debug.assert(!prerelease || prereleaseRegExp.test(prerelease), "Invalid argument: prerelease");
            ts.Debug.assert(!build || buildRegExp.test(build), "Invalid argument: build");
            this.major = major;
            this.minor = minor;
            this.patch = patch;
            this.prerelease = prerelease ? prerelease.split(".") : ts.emptyArray;
            this.build = build ? build.split(".") : ts.emptyArray;
        }
        Version.tryParse = function (text) {
            var result = tryParseComponents(text);
            if (!result)
                return undefined;
            var major = result.major, minor = result.minor, patch = result.patch, prerelease = result.prerelease, build = result.build;
            return new Version(major, minor, patch, prerelease, build);
        };
        Version.prototype.compareTo = function (other) {
            if (this === other)
                return 0;
            if (other === undefined)
                return 1;
            return ts.compareValues(this.major, other.major)
                || ts.compareValues(this.minor, other.minor)
                || ts.compareValues(this.patch, other.patch)
                || comparePrereleaseIdentifiers(this.prerelease, other.prerelease);
        };
        Version.prototype.increment = function (field) {
            switch (field) {
                case "major": return new Version(this.major + 1, 0, 0);
                case "minor": return new Version(this.major, this.minor + 1, 0);
                case "patch": return new Version(this.major, this.minor, this.patch + 1);
                default: return ts.Debug.assertNever(field);
            }
        };
        Version.prototype.toString = function () {
            var result = "".concat(this.major, ".").concat(this.minor, ".").concat(this.patch);
            if (ts.some(this.prerelease))
                result += "-".concat(this.prerelease.join("."));
            if (ts.some(this.build))
                result += "+".concat(this.build.join("."));
            return result;
        };
        Version.zero = new Version(0, 0, 0);
        return Version;
    }());
    ts.Version = Version;
    function tryParseComponents(text) {
        var match = versionRegExp.exec(text);
        if (!match)
            return undefined;
        var major = match[1], _a = match[2], minor = _a === void 0 ? "0" : _a, _b = match[3], patch = _b === void 0 ? "0" : _b, _c = match[4], prerelease = _c === void 0 ? "" : _c, _d = match[5], build = _d === void 0 ? "" : _d;
        if (prerelease && !prereleaseRegExp.test(prerelease))
            return undefined;
        if (build && !buildRegExp.test(build))
            return undefined;
        return {
            major: parseInt(major, 10),
            minor: parseInt(minor, 10),
            patch: parseInt(patch, 10),
            prerelease: prerelease,
            build: build
        };
    }
    function comparePrereleaseIdentifiers(left, right) {
        if (left === right)
            return 0;
        if (left.length === 0)
            return right.length === 0 ? 0 : 1;
        if (right.length === 0)
            return -1;
        var length = Math.min(left.length, right.length);
        for (var i = 0; i < length; i++) {
            var leftIdentifier = left[i];
            var rightIdentifier = right[i];
            if (leftIdentifier === rightIdentifier)
                continue;
            var leftIsNumeric = numericIdentifierRegExp.test(leftIdentifier);
            var rightIsNumeric = numericIdentifierRegExp.test(rightIdentifier);
            if (leftIsNumeric || rightIsNumeric) {
                if (leftIsNumeric !== rightIsNumeric)
                    return leftIsNumeric ? -1 : 1;
                var result = ts.compareValues(+leftIdentifier, +rightIdentifier);
                if (result)
                    return result;
            }
            else {
                var result = ts.compareStringsCaseSensitive(leftIdentifier, rightIdentifier);
                if (result)
                    return result;
            }
        }
        return ts.compareValues(left.length, right.length);
    }
    var VersionRange = (function () {
        function VersionRange(spec) {
            this._alternatives = spec ? ts.Debug.checkDefined(parseRange(spec), "Invalid range spec.") : ts.emptyArray;
        }
        VersionRange.tryParse = function (text) {
            var sets = parseRange(text);
            if (sets) {
                var range = new VersionRange("");
                range._alternatives = sets;
                return range;
            }
            return undefined;
        };
        VersionRange.prototype.test = function (version) {
            if (typeof version === "string")
                version = new Version(version);
            return testDisjunction(version, this._alternatives);
        };
        VersionRange.prototype.toString = function () {
            return formatDisjunction(this._alternatives);
        };
        return VersionRange;
    }());
    ts.VersionRange = VersionRange;
    var logicalOrRegExp = /\|\|/g;
    var whitespaceRegExp = /\s+/g;
    var partialRegExp = /^([xX*0]|[1-9]\d*)(?:\.([xX*0]|[1-9]\d*)(?:\.([xX*0]|[1-9]\d*)(?:-([a-z0-9-.]+))?(?:\+([a-z0-9-.]+))?)?)?$/i;
    var hyphenRegExp = /^\s*([a-z0-9-+.*]+)\s+-\s+([a-z0-9-+.*]+)\s*$/i;
    var rangeRegExp = /^(~|\^|<|<=|>|>=|=)?\s*([a-z0-9-+.*]+)$/i;
    function parseRange(text) {
        var alternatives = [];
        for (var _i = 0, _a = ts.trimString(text).split(logicalOrRegExp); _i < _a.length; _i++) {
            var range = _a[_i];
            if (!range)
                continue;
            var comparators = [];
            range = ts.trimString(range);
            var match = hyphenRegExp.exec(range);
            if (match) {
                if (!parseHyphen(match[1], match[2], comparators))
                    return undefined;
            }
            else {
                for (var _b = 0, _c = range.split(whitespaceRegExp); _b < _c.length; _b++) {
                    var simple = _c[_b];
                    var match_1 = rangeRegExp.exec(ts.trimString(simple));
                    if (!match_1 || !parseComparator(match_1[1], match_1[2], comparators))
                        return undefined;
                }
            }
            alternatives.push(comparators);
        }
        return alternatives;
    }
    function parsePartial(text) {
        var match = partialRegExp.exec(text);
        if (!match)
            return undefined;
        var major = match[1], _a = match[2], minor = _a === void 0 ? "*" : _a, _b = match[3], patch = _b === void 0 ? "*" : _b, prerelease = match[4], build = match[5];
        var version = new Version(isWildcard(major) ? 0 : parseInt(major, 10), isWildcard(major) || isWildcard(minor) ? 0 : parseInt(minor, 10), isWildcard(major) || isWildcard(minor) || isWildcard(patch) ? 0 : parseInt(patch, 10), prerelease, build);
        return { version: version, major: major, minor: minor, patch: patch };
    }
    function parseHyphen(left, right, comparators) {
        var leftResult = parsePartial(left);
        if (!leftResult)
            return false;
        var rightResult = parsePartial(right);
        if (!rightResult)
            return false;
        if (!isWildcard(leftResult.major)) {
            comparators.push(createComparator(">=", leftResult.version));
        }
        if (!isWildcard(rightResult.major)) {
            comparators.push(isWildcard(rightResult.minor) ? createComparator("<", rightResult.version.increment("major")) :
                isWildcard(rightResult.patch) ? createComparator("<", rightResult.version.increment("minor")) :
                    createComparator("<=", rightResult.version));
        }
        return true;
    }
    function parseComparator(operator, text, comparators) {
        var result = parsePartial(text);
        if (!result)
            return false;
        var version = result.version, major = result.major, minor = result.minor, patch = result.patch;
        if (!isWildcard(major)) {
            switch (operator) {
                case "~":
                    comparators.push(createComparator(">=", version));
                    comparators.push(createComparator("<", version.increment(isWildcard(minor) ? "major" :
                        "minor")));
                    break;
                case "^":
                    comparators.push(createComparator(">=", version));
                    comparators.push(createComparator("<", version.increment(version.major > 0 || isWildcard(minor) ? "major" :
                        version.minor > 0 || isWildcard(patch) ? "minor" :
                            "patch")));
                    break;
                case "<":
                case ">=":
                    comparators.push(createComparator(operator, version));
                    break;
                case "<=":
                case ">":
                    comparators.push(isWildcard(minor) ? createComparator(operator === "<=" ? "<" : ">=", version.increment("major")) :
                        isWildcard(patch) ? createComparator(operator === "<=" ? "<" : ">=", version.increment("minor")) :
                            createComparator(operator, version));
                    break;
                case "=":
                case undefined:
                    if (isWildcard(minor) || isWildcard(patch)) {
                        comparators.push(createComparator(">=", version));
                        comparators.push(createComparator("<", version.increment(isWildcard(minor) ? "major" : "minor")));
                    }
                    else {
                        comparators.push(createComparator("=", version));
                    }
                    break;
                default:
                    return false;
            }
        }
        else if (operator === "<" || operator === ">") {
            comparators.push(createComparator("<", Version.zero));
        }
        return true;
    }
    function isWildcard(part) {
        return part === "*" || part === "x" || part === "X";
    }
    function createComparator(operator, operand) {
        return { operator: operator, operand: operand };
    }
    function testDisjunction(version, alternatives) {
        if (alternatives.length === 0)
            return true;
        for (var _i = 0, alternatives_1 = alternatives; _i < alternatives_1.length; _i++) {
            var alternative = alternatives_1[_i];
            if (testAlternative(version, alternative))
                return true;
        }
        return false;
    }
    function testAlternative(version, comparators) {
        for (var _i = 0, comparators_1 = comparators; _i < comparators_1.length; _i++) {
            var comparator = comparators_1[_i];
            if (!testComparator(version, comparator.operator, comparator.operand))
                return false;
        }
        return true;
    }
    function testComparator(version, operator, operand) {
        var cmp = version.compareTo(operand);
        switch (operator) {
            case "<": return cmp < 0;
            case "<=": return cmp <= 0;
            case ">": return cmp > 0;
            case ">=": return cmp >= 0;
            case "=": return cmp === 0;
            default: return ts.Debug.assertNever(operator);
        }
    }
    function formatDisjunction(alternatives) {
        return ts.map(alternatives, formatAlternative).join(" || ") || "*";
    }
    function formatAlternative(comparators) {
        return ts.map(comparators, formatComparator).join(" ");
    }
    function formatComparator(comparator) {
        return "".concat(comparator.operator).concat(comparator.operand);
    }
})(ts || (ts = {}));
var ts;
(function (ts) {
    function hasRequiredAPI(performance, PerformanceObserver) {
        return typeof performance === "object" &&
            typeof performance.timeOrigin === "number" &&
            typeof performance.mark === "function" &&
            typeof performance.measure === "function" &&
            typeof performance.now === "function" &&
            typeof PerformanceObserver === "function";
    }
    function tryGetWebPerformanceHooks() {
        if (typeof performance === "object" &&
            typeof PerformanceObserver === "function" &&
            hasRequiredAPI(performance, PerformanceObserver)) {
            return {
                shouldWriteNativeEvents: true,
                performance: performance,
                PerformanceObserver: PerformanceObserver
            };
        }
    }
    function tryGetNodePerformanceHooks() {
        if (typeof process !== "undefined" && process.nextTick && !process.browser && typeof module === "object" && typeof require === "function") {
            try {
                var performance_1;
                var _a = require("perf_hooks"), nodePerformance_1 = _a.performance, PerformanceObserver_1 = _a.PerformanceObserver;
                if (hasRequiredAPI(nodePerformance_1, PerformanceObserver_1)) {
                    performance_1 = nodePerformance_1;
                    var version_1 = new ts.Version(process.versions.node);
                    var range = new ts.VersionRange("<12.16.3 || 13 <13.13");
                    if (range.test(version_1)) {
                        performance_1 = {
                            get timeOrigin() { return nodePerformance_1.timeOrigin; },
                            now: function () { return nodePerformance_1.now(); },
                            mark: function (name) { return nodePerformance_1.mark(name); },
                            measure: function (name, start, end) {
                                if (start === void 0) { start = "nodeStart"; }
                                if (end === undefined) {
                                    end = "__performance.measure-fix__";
                                    nodePerformance_1.mark(end);
                                }
                                nodePerformance_1.measure(name, start, end);
                                if (end === "__performance.measure-fix__") {
                                    nodePerformance_1.clearMarks("__performance.measure-fix__");
                                }
                            }
                        };
                    }
                    return {
                        shouldWriteNativeEvents: false,
                        performance: performance_1,
                        PerformanceObserver: PerformanceObserver_1
                    };
                }
            }
            catch (_b) {
            }
        }
    }
    var nativePerformanceHooks = tryGetWebPerformanceHooks() || tryGetNodePerformanceHooks();
    var nativePerformance = nativePerformanceHooks === null || nativePerformanceHooks === void 0 ? void 0 : nativePerformanceHooks.performance;
    function tryGetNativePerformanceHooks() {
        return nativePerformanceHooks;
    }
    ts.tryGetNativePerformanceHooks = tryGetNativePerformanceHooks;
    ts.timestamp = nativePerformance ? function () { return nativePerformance.now(); } :
        Date.now ? Date.now :
            function () { return +(new Date()); };
})(ts || (ts = {}));
var ts;
(function (ts) {
    var performance;
    (function (performance) {
        var perfHooks;
        var performanceImpl;
        function createTimerIf(condition, measureName, startMarkName, endMarkName) {
            return condition ? createTimer(measureName, startMarkName, endMarkName) : performance.nullTimer;
        }
        performance.createTimerIf = createTimerIf;
        function createTimer(measureName, startMarkName, endMarkName) {
            var enterCount = 0;
            return {
                enter: enter,
                exit: exit
            };
            function enter() {
                if (++enterCount === 1) {
                    mark(startMarkName);
                }
            }
            function exit() {
                if (--enterCount === 0) {
                    mark(endMarkName);
                    measure(measureName, startMarkName, endMarkName);
                }
                else if (enterCount < 0) {
                    ts.Debug.fail("enter/exit count does not match.");
                }
            }
        }
        performance.createTimer = createTimer;
        performance.nullTimer = { enter: ts.noop, exit: ts.noop };
        var enabled = false;
        var timeorigin = ts.timestamp();
        var marks = new ts.Map();
        var counts = new ts.Map();
        var durations = new ts.Map();
        function mark(markName) {
            var _a;
            if (enabled) {
                var count = (_a = counts.get(markName)) !== null && _a !== void 0 ? _a : 0;
                counts.set(markName, count + 1);
                marks.set(markName, ts.timestamp());
                performanceImpl === null || performanceImpl === void 0 ? void 0 : performanceImpl.mark(markName);
            }
        }
        performance.mark = mark;
        function measure(measureName, startMarkName, endMarkName) {
            var _a, _b;
            if (enabled) {
                var end = (_a = (endMarkName !== undefined ? marks.get(endMarkName) : undefined)) !== null && _a !== void 0 ? _a : ts.timestamp();
                var start = (_b = (startMarkName !== undefined ? marks.get(startMarkName) : undefined)) !== null && _b !== void 0 ? _b : timeorigin;
                var previousDuration = durations.get(measureName) || 0;
                durations.set(measureName, previousDuration + (end - start));
                performanceImpl === null || performanceImpl === void 0 ? void 0 : performanceImpl.measure(measureName, startMarkName, endMarkName);
            }
        }
        performance.measure = measure;
        function getCount(markName) {
            return counts.get(markName) || 0;
        }
        performance.getCount = getCount;
        function getDuration(measureName) {
            return durations.get(measureName) || 0;
        }
        performance.getDuration = getDuration;
        function forEachMeasure(cb) {
            durations.forEach(function (duration, measureName) { return cb(measureName, duration); });
        }
        performance.forEachMeasure = forEachMeasure;
        function isEnabled() {
            return enabled;
        }
        performance.isEnabled = isEnabled;
        function enable(system) {
            var _a;
            if (system === void 0) { system = ts.sys; }
            if (!enabled) {
                enabled = true;
                perfHooks || (perfHooks = ts.tryGetNativePerformanceHooks());
                if (perfHooks) {
                    timeorigin = perfHooks.performance.timeOrigin;
                    if (perfHooks.shouldWriteNativeEvents || ((_a = system === null || system === void 0 ? void 0 : system.cpuProfilingEnabled) === null || _a === void 0 ? void 0 : _a.call(system)) || (system === null || system === void 0 ? void 0 : system.debugMode)) {
                        performanceImpl = perfHooks.performance;
                    }
                }
            }
            return true;
        }
        performance.enable = enable;
        function disable() {
            if (enabled) {
                marks.clear();
                counts.clear();
                durations.clear();
                performanceImpl = undefined;
                enabled = false;
            }
        }
        performance.disable = disable;
    })(performance = ts.performance || (ts.performance = {}));
})(ts || (ts = {}));
var ts;
(function (ts) {
    var _a;
    var nullLogger = {
        logEvent: ts.noop,
        logErrEvent: ts.noop,
        logPerfEvent: ts.noop,
        logInfoEvent: ts.noop,
        logStartCommand: ts.noop,
        logStopCommand: ts.noop,
        logStartUpdateProgram: ts.noop,
        logStopUpdateProgram: ts.noop,
        logStartUpdateGraph: ts.noop,
        logStopUpdateGraph: ts.noop,
        logStartResolveModule: ts.noop,
        logStopResolveModule: ts.noop,
        logStartParseSourceFile: ts.noop,
        logStopParseSourceFile: ts.noop,
        logStartReadFile: ts.noop,
        logStopReadFile: ts.noop,
        logStartBindFile: ts.noop,
        logStopBindFile: ts.noop,
        logStartScheduledOperation: ts.noop,
        logStopScheduledOperation: ts.noop,
    };
    var etwModule;
    try {
        var etwModulePath = (_a = process.env.TS_ETW_MODULE_PATH) !== null && _a !== void 0 ? _a : "./node_modules/@microsoft/typescript-etw";
        etwModule = require(etwModulePath);
    }
    catch (e) {
        etwModule = undefined;
    }
    ts.perfLogger = etwModule && etwModule.logEvent ? etwModule : nullLogger;
})(ts || (ts = {}));
var ts;
(function (ts) {
    var tracingEnabled;
    (function (tracingEnabled) {
        var fs;
        var traceCount = 0;
        var traceFd = 0;
        var mode;
        var typeCatalog = [];
        var legendPath;
        var legend = [];
        ;
        function startTracing(tracingMode, traceDir, configFilePath) {
            ts.Debug.assert(!ts.tracing, "Tracing already started");
            if (fs === undefined) {
                try {
                    fs = require("fs");
                }
                catch (e) {
                    throw new Error("tracing requires having fs\n(original error: ".concat(e.message || e, ")"));
                }
            }
            mode = tracingMode;
            typeCatalog.length = 0;
            if (legendPath === undefined) {
                legendPath = ts.combinePaths(traceDir, "legend.json");
            }
            if (!fs.existsSync(traceDir)) {
                fs.mkdirSync(traceDir, { recursive: true });
            }
            var countPart = mode === "build" ? ".".concat(process.pid, "-").concat(++traceCount)
                : mode === "server" ? ".".concat(process.pid)
                    : "";
            var tracePath = ts.combinePaths(traceDir, "trace".concat(countPart, ".json"));
            var typesPath = ts.combinePaths(traceDir, "types".concat(countPart, ".json"));
            legend.push({
                configFilePath: configFilePath,
                tracePath: tracePath,
                typesPath: typesPath,
            });
            traceFd = fs.openSync(tracePath, "w");
            ts.tracing = tracingEnabled;
            var meta = { cat: "__metadata", ph: "M", ts: 1000 * ts.timestamp(), pid: 1, tid: 1 };
            fs.writeSync(traceFd, "[\n"
                + [__assign({ name: "process_name", args: { name: "tsc" } }, meta), __assign({ name: "thread_name", args: { name: "Main" } }, meta), __assign(__assign({ name: "TracingStartedInBrowser" }, meta), { cat: "disabled-by-default-devtools.timeline" })]
                    .map(function (v) { return JSON.stringify(v); }).join(",\n"));
        }
        tracingEnabled.startTracing = startTracing;
        function stopTracing() {
            ts.Debug.assert(ts.tracing, "Tracing is not in progress");
            ts.Debug.assert(!!typeCatalog.length === (mode !== "server"));
            fs.writeSync(traceFd, "\n]\n");
            fs.closeSync(traceFd);
            ts.tracing = undefined;
            if (typeCatalog.length) {
                dumpTypes(typeCatalog);
            }
            else {
                legend[legend.length - 1].typesPath = undefined;
            }
        }
        tracingEnabled.stopTracing = stopTracing;
        function recordType(type) {
            if (mode !== "server") {
                typeCatalog.push(type);
            }
        }
        tracingEnabled.recordType = recordType;
        function instant(phase, name, args) {
            writeEvent("I", phase, name, args, "\"s\":\"g\"");
        }
        tracingEnabled.instant = instant;
        var eventStack = [];
        function push(phase, name, args, separateBeginAndEnd) {
            if (separateBeginAndEnd === void 0) { separateBeginAndEnd = false; }
            if (separateBeginAndEnd) {
                writeEvent("B", phase, name, args);
            }
            eventStack.push({ phase: phase, name: name, args: args, time: 1000 * ts.timestamp(), separateBeginAndEnd: separateBeginAndEnd });
        }
        tracingEnabled.push = push;
        function pop() {
            ts.Debug.assert(eventStack.length > 0);
            writeStackEvent(eventStack.length - 1, 1000 * ts.timestamp());
            eventStack.length--;
        }
        tracingEnabled.pop = pop;
        function popAll() {
            var endTime = 1000 * ts.timestamp();
            for (var i = eventStack.length - 1; i >= 0; i--) {
                writeStackEvent(i, endTime);
            }
            eventStack.length = 0;
        }
        tracingEnabled.popAll = popAll;
        var sampleInterval = 1000 * 10;
        function writeStackEvent(index, endTime) {
            var _a = eventStack[index], phase = _a.phase, name = _a.name, args = _a.args, time = _a.time, separateBeginAndEnd = _a.separateBeginAndEnd;
            if (separateBeginAndEnd) {
                writeEvent("E", phase, name, args, undefined, endTime);
            }
            else if (sampleInterval - (time % sampleInterval) <= endTime - time) {
                writeEvent("X", phase, name, args, "\"dur\":".concat(endTime - time), time);
            }
        }
        function writeEvent(eventType, phase, name, args, extras, time) {
            if (time === void 0) { time = 1000 * ts.timestamp(); }
            if (mode === "server" && phase === "checkTypes")
                return;
            ts.performance.mark("beginTracing");
            fs.writeSync(traceFd, ",\n{\"pid\":1,\"tid\":1,\"ph\":\"".concat(eventType, "\",\"cat\":\"").concat(phase, "\",\"ts\":").concat(time, ",\"name\":\"").concat(name, "\""));
            if (extras)
                fs.writeSync(traceFd, ",".concat(extras));
            if (args)
                fs.writeSync(traceFd, ",\"args\":".concat(JSON.stringify(args)));
            fs.writeSync(traceFd, "}");
            ts.performance.mark("endTracing");
            ts.performance.measure("Tracing", "beginTracing", "endTracing");
        }
        function getLocation(node) {
            var file = ts.getSourceFileOfNode(node);
            return !file
                ? undefined
                : {
                    path: file.path,
                    start: indexFromOne(ts.getLineAndCharacterOfPosition(file, node.pos)),
                    end: indexFromOne(ts.getLineAndCharacterOfPosition(file, node.end)),
                };
            function indexFromOne(lc) {
                return {
                    line: lc.line + 1,
                    character: lc.character + 1,
                };
            }
        }
        function dumpTypes(types) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x;
            ts.performance.mark("beginDumpTypes");
            var typesPath = legend[legend.length - 1].typesPath;
            var typesFd = fs.openSync(typesPath, "w");
            var recursionIdentityMap = new ts.Map();
            fs.writeSync(typesFd, "[");
            var numTypes = types.length;
            for (var i = 0; i < numTypes; i++) {
                var type = types[i];
                var objectFlags = type.objectFlags;
                var symbol = (_a = type.aliasSymbol) !== null && _a !== void 0 ? _a : type.symbol;
                var display = void 0;
                if ((objectFlags & 16) | (type.flags & 2944)) {
                    try {
                        display = (_b = type.checker) === null || _b === void 0 ? void 0 : _b.typeToString(type);
                    }
                    catch (_y) {
                        display = undefined;
                    }
                }
                var indexedAccessProperties = {};
                if (type.flags & 8388608) {
                    var indexedAccessType = type;
                    indexedAccessProperties = {
                        indexedAccessObjectType: (_c = indexedAccessType.objectType) === null || _c === void 0 ? void 0 : _c.id,
                        indexedAccessIndexType: (_d = indexedAccessType.indexType) === null || _d === void 0 ? void 0 : _d.id,
                    };
                }
                var referenceProperties = {};
                if (objectFlags & 4) {
                    var referenceType = type;
                    referenceProperties = {
                        instantiatedType: (_e = referenceType.target) === null || _e === void 0 ? void 0 : _e.id,
                        typeArguments: (_f = referenceType.resolvedTypeArguments) === null || _f === void 0 ? void 0 : _f.map(function (t) { return t.id; }),
                        referenceLocation: getLocation(referenceType.node),
                    };
                }
                var conditionalProperties = {};
                if (type.flags & 16777216) {
                    var conditionalType = type;
                    conditionalProperties = {
                        conditionalCheckType: (_g = conditionalType.checkType) === null || _g === void 0 ? void 0 : _g.id,
                        conditionalExtendsType: (_h = conditionalType.extendsType) === null || _h === void 0 ? void 0 : _h.id,
                        conditionalTrueType: (_k = (_j = conditionalType.resolvedTrueType) === null || _j === void 0 ? void 0 : _j.id) !== null && _k !== void 0 ? _k : -1,
                        conditionalFalseType: (_m = (_l = conditionalType.resolvedFalseType) === null || _l === void 0 ? void 0 : _l.id) !== null && _m !== void 0 ? _m : -1,
                    };
                }
                var substitutionProperties = {};
                if (type.flags & 33554432) {
                    var substitutionType = type;
                    substitutionProperties = {
                        substitutionBaseType: (_o = substitutionType.baseType) === null || _o === void 0 ? void 0 : _o.id,
                        substituteType: (_p = substitutionType.substitute) === null || _p === void 0 ? void 0 : _p.id,
                    };
                }
                var reverseMappedProperties = {};
                if (objectFlags & 1024) {
                    var reverseMappedType = type;
                    reverseMappedProperties = {
                        reverseMappedSourceType: (_q = reverseMappedType.source) === null || _q === void 0 ? void 0 : _q.id,
                        reverseMappedMappedType: (_r = reverseMappedType.mappedType) === null || _r === void 0 ? void 0 : _r.id,
                        reverseMappedConstraintType: (_s = reverseMappedType.constraintType) === null || _s === void 0 ? void 0 : _s.id,
                    };
                }
                var evolvingArrayProperties = {};
                if (objectFlags & 256) {
                    var evolvingArrayType = type;
                    evolvingArrayProperties = {
                        evolvingArrayElementType: evolvingArrayType.elementType.id,
                        evolvingArrayFinalType: (_t = evolvingArrayType.finalArrayType) === null || _t === void 0 ? void 0 : _t.id,
                    };
                }
                var recursionToken = void 0;
                var recursionIdentity = type.checker.getRecursionIdentity(type);
                if (recursionIdentity) {
                    recursionToken = recursionIdentityMap.get(recursionIdentity);
                    if (!recursionToken) {
                        recursionToken = recursionIdentityMap.size;
                        recursionIdentityMap.set(recursionIdentity, recursionToken);
                    }
                }
                var descriptor = __assign(__assign(__assign(__assign(__assign(__assign(__assign({ id: type.id, intrinsicName: type.intrinsicName, symbolName: (symbol === null || symbol === void 0 ? void 0 : symbol.escapedName) && ts.unescapeLeadingUnderscores(symbol.escapedName), recursionId: recursionToken, isTuple: objectFlags & 8 ? true : undefined, unionTypes: (type.flags & 1048576) ? (_u = type.types) === null || _u === void 0 ? void 0 : _u.map(function (t) { return t.id; }) : undefined, intersectionTypes: (type.flags & 2097152) ? type.types.map(function (t) { return t.id; }) : undefined, aliasTypeArguments: (_v = type.aliasTypeArguments) === null || _v === void 0 ? void 0 : _v.map(function (t) { return t.id; }), keyofType: (type.flags & 4194304) ? (_w = type.type) === null || _w === void 0 ? void 0 : _w.id : undefined }, indexedAccessProperties), referenceProperties), conditionalProperties), substitutionProperties), reverseMappedProperties), evolvingArrayProperties), { destructuringPattern: getLocation(type.pattern), firstDeclaration: getLocation((_x = symbol === null || symbol === void 0 ? void 0 : symbol.declarations) === null || _x === void 0 ? void 0 : _x[0]), flags: ts.Debug.formatTypeFlags(type.flags).split("|"), display: display });
                fs.writeSync(typesFd, JSON.stringify(descriptor));
                if (i < numTypes - 1) {
                    fs.writeSync(typesFd, ",\n");
                }
            }
            fs.writeSync(typesFd, "]\n");
            fs.closeSync(typesFd);
            ts.performance.mark("endDumpTypes");
            ts.performance.measure("Dump types", "beginDumpTypes", "endDumpTypes");
        }
        function dumpLegend() {
            if (!legendPath) {
                return;
            }
            fs.writeFileSync(legendPath, JSON.stringify(legend));
        }
        tracingEnabled.dumpLegend = dumpLegend;
    })(tracingEnabled || (tracingEnabled = {}));
    ts.startTracing = tracingEnabled.startTracing;
    ts.dumpTracingLegend = tracingEnabled.dumpLegend;
})(ts || (ts = {}));
var ts;
(function (ts) {
    var OperationCanceledException = (function () {
        function OperationCanceledException() {
        }
        return OperationCanceledException;
    }());
    ts.OperationCanceledException = OperationCanceledException;
    var FileIncludeKind;
    (function (FileIncludeKind) {
        FileIncludeKind[FileIncludeKind["RootFile"] = 0] = "RootFile";
        FileIncludeKind[FileIncludeKind["SourceFromProjectReference"] = 1] = "SourceFromProjectReference";
        FileIncludeKind[FileIncludeKind["OutputFromProjectReference"] = 2] = "OutputFromProjectReference";
        FileIncludeKind[FileIncludeKind["Import"] = 3] = "Import";
        FileIncludeKind[FileIncludeKind["ReferenceFile"] = 4] = "ReferenceFile";
        FileIncludeKind[FileIncludeKind["TypeReferenceDirective"] = 5] = "TypeReferenceDirective";
        FileIncludeKind[FileIncludeKind["LibFile"] = 6] = "LibFile";
        FileIncludeKind[FileIncludeKind["LibReferenceDirective"] = 7] = "LibReferenceDirective";
        FileIncludeKind[FileIncludeKind["AutomaticTypeDirectiveFile"] = 8] = "AutomaticTypeDirectiveFile";
    })(FileIncludeKind = ts.FileIncludeKind || (ts.FileIncludeKind = {}));
    var ExitStatus;
    (function (ExitStatus) {
        ExitStatus[ExitStatus["Success"] = 0] = "Success";
        ExitStatus[ExitStatus["DiagnosticsPresent_OutputsSkipped"] = 1] = "DiagnosticsPresent_OutputsSkipped";
        ExitStatus[ExitStatus["DiagnosticsPresent_OutputsGenerated"] = 2] = "DiagnosticsPresent_OutputsGenerated";
        ExitStatus[ExitStatus["InvalidProject_OutputsSkipped"] = 3] = "InvalidProject_OutputsSkipped";
        ExitStatus[ExitStatus["ProjectReferenceCycle_OutputsSkipped"] = 4] = "ProjectReferenceCycle_OutputsSkipped";
        ExitStatus[ExitStatus["ProjectReferenceCycle_OutputsSkupped"] = 4] = "ProjectReferenceCycle_OutputsSkupped";
    })(ExitStatus = ts.ExitStatus || (ts.ExitStatus = {}));
    var TypeReferenceSerializationKind;
    (function (TypeReferenceSerializationKind) {
        TypeReferenceSerializationKind[TypeReferenceSerializationKind["Unknown"] = 0] = "Unknown";
        TypeReferenceSerializationKind[TypeReferenceSerializationKind["TypeWithConstructSignatureAndValue"] = 1] = "TypeWithConstructSignatureAndValue";
        TypeReferenceSerializationKind[TypeReferenceSerializationKind["VoidNullableOrNeverType"] = 2] = "VoidNullableOrNeverType";
        TypeReferenceSerializationKind[TypeReferenceSerializationKind["NumberLikeType"] = 3] = "NumberLikeType";
        TypeReferenceSerializationKind[TypeReferenceSerializationKind["BigIntLikeType"] = 4] = "BigIntLikeType";
        TypeReferenceSerializationKind[TypeReferenceSerializationKind["StringLikeType"] = 5] = "StringLikeType";
        TypeReferenceSerializationKind[TypeReferenceSerializationKind["BooleanType"] = 6] = "BooleanType";
        TypeReferenceSerializationKind[TypeReferenceSerializationKind["ArrayLikeType"] = 7] = "ArrayLikeType";
        TypeReferenceSerializationKind[TypeReferenceSerializationKind["ESSymbolType"] = 8] = "ESSymbolType";
        TypeReferenceSerializationKind[TypeReferenceSerializationKind["Promise"] = 9] = "Promise";
        TypeReferenceSerializationKind[TypeReferenceSerializationKind["TypeWithCallSignature"] = 10] = "TypeWithCallSignature";
        TypeReferenceSerializationKind[TypeReferenceSerializationKind["ObjectType"] = 11] = "ObjectType";
    })(TypeReferenceSerializationKind = ts.TypeReferenceSerializationKind || (ts.TypeReferenceSerializationKind = {}));
    var DiagnosticCategory;
    (function (DiagnosticCategory) {
        DiagnosticCategory[DiagnosticCategory["Warning"] = 0] = "Warning";
        DiagnosticCategory[DiagnosticCategory["Error"] = 1] = "Error";
        DiagnosticCategory[DiagnosticCategory["Suggestion"] = 2] = "Suggestion";
        DiagnosticCategory[DiagnosticCategory["Message"] = 3] = "Message";
    })(DiagnosticCategory = ts.DiagnosticCategory || (ts.DiagnosticCategory = {}));
    function diagnosticCategoryName(d, lowerCase) {
        if (lowerCase === void 0) { lowerCase = true; }
        var name = DiagnosticCategory[d.category];
        return lowerCase ? name.toLowerCase() : name;
    }
    ts.diagnosticCategoryName = diagnosticCategoryName;
    var ModuleResolutionKind;
    (function (ModuleResolutionKind) {
        ModuleResolutionKind[ModuleResolutionKind["Classic"] = 1] = "Classic";
        ModuleResolutionKind[ModuleResolutionKind["NodeJs"] = 2] = "NodeJs";
        ModuleResolutionKind[ModuleResolutionKind["Node16"] = 3] = "Node16";
        ModuleResolutionKind[ModuleResolutionKind["NodeNext"] = 99] = "NodeNext";
    })(ModuleResolutionKind = ts.ModuleResolutionKind || (ts.ModuleResolutionKind = {}));
    var ModuleDetectionKind;
    (function (ModuleDetectionKind) {
        ModuleDetectionKind[ModuleDetectionKind["Legacy"] = 1] = "Legacy";
        ModuleDetectionKind[ModuleDetectionKind["Auto"] = 2] = "Auto";
        ModuleDetectionKind[ModuleDetectionKind["Force"] = 3] = "Force";
    })(ModuleDetectionKind = ts.ModuleDetectionKind || (ts.ModuleDetectionKind = {}));
    var WatchFileKind;
    (function (WatchFileKind) {
        WatchFileKind[WatchFileKind["FixedPollingInterval"] = 0] = "FixedPollingInterval";
        WatchFileKind[WatchFileKind["PriorityPollingInterval"] = 1] = "PriorityPollingInterval";
        WatchFileKind[WatchFileKind["DynamicPriorityPolling"] = 2] = "DynamicPriorityPolling";
        WatchFileKind[WatchFileKind["FixedChunkSizePolling"] = 3] = "FixedChunkSizePolling";
        WatchFileKind[WatchFileKind["UseFsEvents"] = 4] = "UseFsEvents";
        WatchFileKind[WatchFileKind["UseFsEventsOnParentDirectory"] = 5] = "UseFsEventsOnParentDirectory";
    })(WatchFileKind = ts.WatchFileKind || (ts.WatchFileKind = {}));
    var WatchDirectoryKind;
    (function (WatchDirectoryKind) {
        WatchDirectoryKind[WatchDirectoryKind["UseFsEvents"] = 0] = "UseFsEvents";
        WatchDirectoryKind[WatchDirectoryKind["FixedPollingInterval"] = 1] = "FixedPollingInterval";
        WatchDirectoryKind[WatchDirectoryKind["DynamicPriorityPolling"] = 2] = "DynamicPriorityPolling";
        WatchDirectoryKind[WatchDirectoryKind["FixedChunkSizePolling"] = 3] = "FixedChunkSizePolling";
    })(WatchDirectoryKind = ts.WatchDirectoryKind || (ts.WatchDirectoryKind = {}));
    var PollingWatchKind;
    (function (PollingWatchKind) {
        PollingWatchKind[PollingWatchKind["FixedInterval"] = 0] = "FixedInterval";
        PollingWatchKind[PollingWatchKind["PriorityInterval"] = 1] = "PriorityInterval";
        PollingWatchKind[PollingWatchKind["DynamicPriority"] = 2] = "DynamicPriority";
        PollingWatchKind[PollingWatchKind["FixedChunkSize"] = 3] = "FixedChunkSize";
    })(PollingWatchKind = ts.PollingWatchKind || (ts.PollingWatchKind = {}));
    var ModuleKind;
    (function (ModuleKind) {
        ModuleKind[ModuleKind["None"] = 0] = "None";
        ModuleKind[ModuleKind["CommonJS"] = 1] = "CommonJS";
        ModuleKind[ModuleKind["AMD"] = 2] = "AMD";
        ModuleKind[ModuleKind["UMD"] = 3] = "UMD";
        ModuleKind[ModuleKind["System"] = 4] = "System";
        ModuleKind[ModuleKind["ES2015"] = 5] = "ES2015";
        ModuleKind[ModuleKind["ES2020"] = 6] = "ES2020";
        ModuleKind[ModuleKind["ES2022"] = 7] = "ES2022";
        ModuleKind[ModuleKind["ESNext"] = 99] = "ESNext";
        ModuleKind[ModuleKind["Node16"] = 100] = "Node16";
        ModuleKind[ModuleKind["NodeNext"] = 199] = "NodeNext";
    })(ModuleKind = ts.ModuleKind || (ts.ModuleKind = {}));
    ts.commentPragmas = {
        "reference": {
            args: [
                { name: "types", optional: true, captureSpan: true },
                { name: "lib", optional: true, captureSpan: true },
                { name: "path", optional: true, captureSpan: true },
                { name: "no-default-lib", optional: true },
                { name: "resolution-mode", optional: true }
            ],
            kind: 1
        },
        "amd-dependency": {
            args: [{ name: "path" }, { name: "name", optional: true }],
            kind: 1
        },
        "amd-module": {
            args: [{ name: "name" }],
            kind: 1
        },
        "ts-check": {
            kind: 2
        },
        "ts-nocheck": {
            kind: 2
        },
        "jsx": {
            args: [{ name: "factory" }],
            kind: 4
        },
        "jsxfrag": {
            args: [{ name: "factory" }],
            kind: 4
        },
        "jsximportsource": {
            args: [{ name: "factory" }],
            kind: 4
        },
        "jsxruntime": {
            args: [{ name: "factory" }],
            kind: 4
        },
    };
})(ts || (ts = {}));
var ts;
(function (ts) {
    function generateDjb2Hash(data) {
        var acc = 5381;
        for (var i = 0; i < data.length; i++) {
            acc = ((acc << 5) + acc) + data.charCodeAt(i);
        }
        return acc.toString();
    }
    ts.generateDjb2Hash = generateDjb2Hash;
    function setStackTraceLimit() {
        if (Error.stackTraceLimit < 100) {
            Error.stackTraceLimit = 100;
        }
    }
    ts.setStackTraceLimit = setStackTraceLimit;
    var FileWatcherEventKind;
    (function (FileWatcherEventKind) {
        FileWatcherEventKind[FileWatcherEventKind["Created"] = 0] = "Created";
        FileWatcherEventKind[FileWatcherEventKind["Changed"] = 1] = "Changed";
        FileWatcherEventKind[FileWatcherEventKind["Deleted"] = 2] = "Deleted";
    })(FileWatcherEventKind = ts.FileWatcherEventKind || (ts.FileWatcherEventKind = {}));
    var PollingInterval;
    (function (PollingInterval) {
        PollingInterval[PollingInterval["High"] = 2000] = "High";
        PollingInterval[PollingInterval["Medium"] = 500] = "Medium";
        PollingInterval[PollingInterval["Low"] = 250] = "Low";
    })(PollingInterval = ts.PollingInterval || (ts.PollingInterval = {}));
    ts.missingFileModifiedTime = new Date(0);
    function getModifiedTime(host, fileName) {
        return host.getModifiedTime(fileName) || ts.missingFileModifiedTime;
    }
    ts.getModifiedTime = getModifiedTime;
    function createPollingIntervalBasedLevels(levels) {
        var _a;
        return _a = {},
            _a[PollingInterval.Low] = levels.Low,
            _a[PollingInterval.Medium] = levels.Medium,
            _a[PollingInterval.High] = levels.High,
            _a;
    }
    var defaultChunkLevels = { Low: 32, Medium: 64, High: 256 };
    var pollingChunkSize = createPollingIntervalBasedLevels(defaultChunkLevels);
    ts.unchangedPollThresholds = createPollingIntervalBasedLevels(defaultChunkLevels);
    function setCustomPollingValues(system) {
        if (!system.getEnvironmentVariable) {
            return;
        }
        var pollingIntervalChanged = setCustomLevels("TSC_WATCH_POLLINGINTERVAL", PollingInterval);
        pollingChunkSize = getCustomPollingBasedLevels("TSC_WATCH_POLLINGCHUNKSIZE", defaultChunkLevels) || pollingChunkSize;
        ts.unchangedPollThresholds = getCustomPollingBasedLevels("TSC_WATCH_UNCHANGEDPOLLTHRESHOLDS", defaultChunkLevels) || ts.unchangedPollThresholds;
        function getLevel(envVar, level) {
            return system.getEnvironmentVariable("".concat(envVar, "_").concat(level.toUpperCase()));
        }
        function getCustomLevels(baseVariable) {
            var customLevels;
            setCustomLevel("Low");
            setCustomLevel("Medium");
            setCustomLevel("High");
            return customLevels;
            function setCustomLevel(level) {
                var customLevel = getLevel(baseVariable, level);
                if (customLevel) {
                    (customLevels || (customLevels = {}))[level] = Number(customLevel);
                }
            }
        }
        function setCustomLevels(baseVariable, levels) {
            var customLevels = getCustomLevels(baseVariable);
            if (customLevels) {
                setLevel("Low");
                setLevel("Medium");
                setLevel("High");
                return true;
            }
            return false;
            function setLevel(level) {
                levels[level] = customLevels[level] || levels[level];
            }
        }
        function getCustomPollingBasedLevels(baseVariable, defaultLevels) {
            var customLevels = getCustomLevels(baseVariable);
            return (pollingIntervalChanged || customLevels) &&
                createPollingIntervalBasedLevels(customLevels ? __assign(__assign({}, defaultLevels), customLevels) : defaultLevels);
        }
    }
    ts.setCustomPollingValues = setCustomPollingValues;
    function pollWatchedFileQueue(host, queue, pollIndex, chunkSize, callbackOnWatchFileStat) {
        var definedValueCopyToIndex = pollIndex;
        for (var canVisit = queue.length; chunkSize && canVisit; nextPollIndex(), canVisit--) {
            var watchedFile = queue[pollIndex];
            if (!watchedFile) {
                continue;
            }
            else if (watchedFile.isClosed) {
                queue[pollIndex] = undefined;
                continue;
            }
            chunkSize--;
            var fileChanged = onWatchedFileStat(watchedFile, getModifiedTime(host, watchedFile.fileName));
            if (watchedFile.isClosed) {
                queue[pollIndex] = undefined;
                continue;
            }
            callbackOnWatchFileStat === null || callbackOnWatchFileStat === void 0 ? void 0 : callbackOnWatchFileStat(watchedFile, pollIndex, fileChanged);
            if (queue[pollIndex]) {
                if (definedValueCopyToIndex < pollIndex) {
                    queue[definedValueCopyToIndex] = watchedFile;
                    queue[pollIndex] = undefined;
                }
                definedValueCopyToIndex++;
            }
        }
        return pollIndex;
        function nextPollIndex() {
            pollIndex++;
            if (pollIndex === queue.length) {
                if (definedValueCopyToIndex < pollIndex) {
                    queue.length = definedValueCopyToIndex;
                }
                pollIndex = 0;
                definedValueCopyToIndex = 0;
            }
        }
    }
    function createDynamicPriorityPollingWatchFile(host) {
        var watchedFiles = [];
        var changedFilesInLastPoll = [];
        var lowPollingIntervalQueue = createPollingIntervalQueue(PollingInterval.Low);
        var mediumPollingIntervalQueue = createPollingIntervalQueue(PollingInterval.Medium);
        var highPollingIntervalQueue = createPollingIntervalQueue(PollingInterval.High);
        return watchFile;
        function watchFile(fileName, callback, defaultPollingInterval) {
            var file = {
                fileName: fileName,
                callback: callback,
                unchangedPolls: 0,
                mtime: getModifiedTime(host, fileName)
            };
            watchedFiles.push(file);
            addToPollingIntervalQueue(file, defaultPollingInterval);
            return {
                close: function () {
                    file.isClosed = true;
                    ts.unorderedRemoveItem(watchedFiles, file);
                }
            };
        }
        function createPollingIntervalQueue(pollingInterval) {
            var queue = [];
            queue.pollingInterval = pollingInterval;
            queue.pollIndex = 0;
            queue.pollScheduled = false;
            return queue;
        }
        function pollPollingIntervalQueue(queue) {
            queue.pollIndex = pollQueue(queue, queue.pollingInterval, queue.pollIndex, pollingChunkSize[queue.pollingInterval]);
            if (queue.length) {
                scheduleNextPoll(queue.pollingInterval);
            }
            else {
                ts.Debug.assert(queue.pollIndex === 0);
                queue.pollScheduled = false;
            }
        }
        function pollLowPollingIntervalQueue(queue) {
            pollQueue(changedFilesInLastPoll, PollingInterval.Low, 0, changedFilesInLastPoll.length);
            pollPollingIntervalQueue(queue);
            if (!queue.pollScheduled && changedFilesInLastPoll.length) {
                scheduleNextPoll(PollingInterval.Low);
            }
        }
        function pollQueue(queue, pollingInterval, pollIndex, chunkSize) {
            return pollWatchedFileQueue(host, queue, pollIndex, chunkSize, onWatchFileStat);
            function onWatchFileStat(watchedFile, pollIndex, fileChanged) {
                if (fileChanged) {
                    watchedFile.unchangedPolls = 0;
                    if (queue !== changedFilesInLastPoll) {
                        queue[pollIndex] = undefined;
                        addChangedFileToLowPollingIntervalQueue(watchedFile);
                    }
                }
                else if (watchedFile.unchangedPolls !== ts.unchangedPollThresholds[pollingInterval]) {
                    watchedFile.unchangedPolls++;
                }
                else if (queue === changedFilesInLastPoll) {
                    watchedFile.unchangedPolls = 1;
                    queue[pollIndex] = undefined;
                    addToPollingIntervalQueue(watchedFile, PollingInterval.Low);
                }
                else if (pollingInterval !== PollingInterval.High) {
                    watchedFile.unchangedPolls++;
                    queue[pollIndex] = undefined;
                    addToPollingIntervalQueue(watchedFile, pollingInterval === PollingInterval.Low ? PollingInterval.Medium : PollingInterval.High);
                }
            }
        }
        function pollingIntervalQueue(pollingInterval) {
            switch (pollingInterval) {
                case PollingInterval.Low:
                    return lowPollingIntervalQueue;
                case PollingInterval.Medium:
                    return mediumPollingIntervalQueue;
                case PollingInterval.High:
                    return highPollingIntervalQueue;
            }
        }
        function addToPollingIntervalQueue(file, pollingInterval) {
            pollingIntervalQueue(pollingInterval).push(file);
            scheduleNextPollIfNotAlreadyScheduled(pollingInterval);
        }
        function addChangedFileToLowPollingIntervalQueue(file) {
            changedFilesInLastPoll.push(file);
            scheduleNextPollIfNotAlreadyScheduled(PollingInterval.Low);
        }
        function scheduleNextPollIfNotAlreadyScheduled(pollingInterval) {
            if (!pollingIntervalQueue(pollingInterval).pollScheduled) {
                scheduleNextPoll(pollingInterval);
            }
        }
        function scheduleNextPoll(pollingInterval) {
            pollingIntervalQueue(pollingInterval).pollScheduled = host.setTimeout(pollingInterval === PollingInterval.Low ? pollLowPollingIntervalQueue : pollPollingIntervalQueue, pollingInterval, pollingIntervalQueue(pollingInterval));
        }
    }
    ts.createDynamicPriorityPollingWatchFile = createDynamicPriorityPollingWatchFile;
    function createUseFsEventsOnParentDirectoryWatchFile(fsWatch, useCaseSensitiveFileNames) {
        var fileWatcherCallbacks = ts.createMultiMap();
        var dirWatchers = new ts.Map();
        var toCanonicalName = ts.createGetCanonicalFileName(useCaseSensitiveFileNames);
        return nonPollingWatchFile;
        function nonPollingWatchFile(fileName, callback, _pollingInterval, fallbackOptions) {
            var filePath = toCanonicalName(fileName);
            fileWatcherCallbacks.add(filePath, callback);
            var dirPath = ts.getDirectoryPath(filePath) || ".";
            var watcher = dirWatchers.get(dirPath) ||
                createDirectoryWatcher(ts.getDirectoryPath(fileName) || ".", dirPath, fallbackOptions);
            watcher.referenceCount++;
            return {
                close: function () {
                    if (watcher.referenceCount === 1) {
                        watcher.close();
                        dirWatchers.delete(dirPath);
                    }
                    else {
                        watcher.referenceCount--;
                    }
                    fileWatcherCallbacks.remove(filePath, callback);
                }
            };
        }
        function createDirectoryWatcher(dirName, dirPath, fallbackOptions) {
            var watcher = fsWatch(dirName, 1, function (_eventName, relativeFileName) {
                if (!ts.isString(relativeFileName))
                    return;
                var fileName = ts.getNormalizedAbsolutePath(relativeFileName, dirName);
                var callbacks = fileName && fileWatcherCallbacks.get(toCanonicalName(fileName));
                if (callbacks) {
                    for (var _i = 0, callbacks_1 = callbacks; _i < callbacks_1.length; _i++) {
                        var fileCallback = callbacks_1[_i];
                        fileCallback(fileName, FileWatcherEventKind.Changed);
                    }
                }
            }, false, PollingInterval.Medium, fallbackOptions);
            watcher.referenceCount = 0;
            dirWatchers.set(dirPath, watcher);
            return watcher;
        }
    }
    function createFixedChunkSizePollingWatchFile(host) {
        var watchedFiles = [];
        var pollIndex = 0;
        var pollScheduled;
        return watchFile;
        function watchFile(fileName, callback) {
            var file = {
                fileName: fileName,
                callback: callback,
                mtime: getModifiedTime(host, fileName)
            };
            watchedFiles.push(file);
            scheduleNextPoll();
            return {
                close: function () {
                    file.isClosed = true;
                    ts.unorderedRemoveItem(watchedFiles, file);
                }
            };
        }
        function pollQueue() {
            pollScheduled = undefined;
            pollIndex = pollWatchedFileQueue(host, watchedFiles, pollIndex, pollingChunkSize[PollingInterval.Low]);
            scheduleNextPoll();
        }
        function scheduleNextPoll() {
            if (!watchedFiles.length || pollScheduled)
                return;
            pollScheduled = host.setTimeout(pollQueue, PollingInterval.High);
        }
    }
    function createSingleFileWatcherPerName(watchFile, useCaseSensitiveFileNames) {
        var cache = new ts.Map();
        var callbacksCache = ts.createMultiMap();
        var toCanonicalFileName = ts.createGetCanonicalFileName(useCaseSensitiveFileNames);
        return function (fileName, callback, pollingInterval, options) {
            var path = toCanonicalFileName(fileName);
            var existing = cache.get(path);
            if (existing) {
                existing.refCount++;
            }
            else {
                cache.set(path, {
                    watcher: watchFile(fileName, function (fileName, eventKind) { return ts.forEach(callbacksCache.get(path), function (cb) { return cb(fileName, eventKind); }); }, pollingInterval, options),
                    refCount: 1
                });
            }
            callbacksCache.add(path, callback);
            return {
                close: function () {
                    var watcher = ts.Debug.checkDefined(cache.get(path));
                    callbacksCache.remove(path, callback);
                    watcher.refCount--;
                    if (watcher.refCount)
                        return;
                    cache.delete(path);
                    ts.closeFileWatcherOf(watcher);
                }
            };
        };
    }
    ts.createSingleFileWatcherPerName = createSingleFileWatcherPerName;
    function onWatchedFileStat(watchedFile, modifiedTime) {
        var oldTime = watchedFile.mtime.getTime();
        var newTime = modifiedTime.getTime();
        if (oldTime !== newTime) {
            watchedFile.mtime = modifiedTime;
            watchedFile.callback(watchedFile.fileName, getFileWatcherEventKind(oldTime, newTime));
            return true;
        }
        return false;
    }
    ts.onWatchedFileStat = onWatchedFileStat;
    function getFileWatcherEventKind(oldTime, newTime) {
        return oldTime === 0
            ? FileWatcherEventKind.Created
            : newTime === 0
                ? FileWatcherEventKind.Deleted
                : FileWatcherEventKind.Changed;
    }
    ts.getFileWatcherEventKind = getFileWatcherEventKind;
    ts.ignoredPaths = ["/node_modules/.", "/.git", "/.#"];
    var curSysLog = ts.noop;
    function sysLog(s) {
        return curSysLog(s);
    }
    ts.sysLog = sysLog;
    function setSysLog(logger) {
        curSysLog = logger;
    }
    ts.setSysLog = setSysLog;
    function createDirectoryWatcherSupportingRecursive(_a) {
        var watchDirectory = _a.watchDirectory, useCaseSensitiveFileNames = _a.useCaseSensitiveFileNames, getCurrentDirectory = _a.getCurrentDirectory, getAccessibleSortedChildDirectories = _a.getAccessibleSortedChildDirectories, directoryExists = _a.directoryExists, realpath = _a.realpath, setTimeout = _a.setTimeout, clearTimeout = _a.clearTimeout;
        var cache = new ts.Map();
        var callbackCache = ts.createMultiMap();
        var cacheToUpdateChildWatches = new ts.Map();
        var timerToUpdateChildWatches;
        var filePathComparer = ts.getStringComparer(!useCaseSensitiveFileNames);
        var toCanonicalFilePath = ts.createGetCanonicalFileName(useCaseSensitiveFileNames);
        return function (dirName, callback, recursive, options) { return recursive ?
            createDirectoryWatcher(dirName, options, callback) :
            watchDirectory(dirName, callback, recursive, options); };
        function createDirectoryWatcher(dirName, options, callback) {
            var dirPath = toCanonicalFilePath(dirName);
            var directoryWatcher = cache.get(dirPath);
            if (directoryWatcher) {
                directoryWatcher.refCount++;
            }
            else {
                directoryWatcher = {
                    watcher: watchDirectory(dirName, function (fileName) {
                        if (isIgnoredPath(fileName, options))
                            return;
                        if (options === null || options === void 0 ? void 0 : options.synchronousWatchDirectory) {
                            invokeCallbacks(dirPath, fileName);
                            updateChildWatches(dirName, dirPath, options);
                        }
                        else {
                            nonSyncUpdateChildWatches(dirName, dirPath, fileName, options);
                        }
                    }, false, options),
                    refCount: 1,
                    childWatches: ts.emptyArray
                };
                cache.set(dirPath, directoryWatcher);
                updateChildWatches(dirName, dirPath, options);
            }
            var callbackToAdd = callback && { dirName: dirName, callback: callback };
            if (callbackToAdd) {
                callbackCache.add(dirPath, callbackToAdd);
            }
            return {
                dirName: dirName,
                close: function () {
                    var directoryWatcher = ts.Debug.checkDefined(cache.get(dirPath));
                    if (callbackToAdd)
                        callbackCache.remove(dirPath, callbackToAdd);
                    directoryWatcher.refCount--;
                    if (directoryWatcher.refCount)
                        return;
                    cache.delete(dirPath);
                    ts.closeFileWatcherOf(directoryWatcher);
                    directoryWatcher.childWatches.forEach(ts.closeFileWatcher);
                }
            };
        }
        function invokeCallbacks(dirPath, fileNameOrInvokeMap, fileNames) {
            var fileName;
            var invokeMap;
            if (ts.isString(fileNameOrInvokeMap)) {
                fileName = fileNameOrInvokeMap;
            }
            else {
                invokeMap = fileNameOrInvokeMap;
            }
            callbackCache.forEach(function (callbacks, rootDirName) {
                var _a;
                if (invokeMap && invokeMap.get(rootDirName) === true)
                    return;
                if (rootDirName === dirPath || (ts.startsWith(dirPath, rootDirName) && dirPath[rootDirName.length] === ts.directorySeparator)) {
                    if (invokeMap) {
                        if (fileNames) {
                            var existing = invokeMap.get(rootDirName);
                            if (existing) {
                                (_a = existing).push.apply(_a, fileNames);
                            }
                            else {
                                invokeMap.set(rootDirName, fileNames.slice());
                            }
                        }
                        else {
                            invokeMap.set(rootDirName, true);
                        }
                    }
                    else {
                        callbacks.forEach(function (_a) {
                            var callback = _a.callback;
                            return callback(fileName);
                        });
                    }
                }
            });
        }
        function nonSyncUpdateChildWatches(dirName, dirPath, fileName, options) {
            var parentWatcher = cache.get(dirPath);
            if (parentWatcher && directoryExists(dirName)) {
                scheduleUpdateChildWatches(dirName, dirPath, fileName, options);
                return;
            }
            invokeCallbacks(dirPath, fileName);
            removeChildWatches(parentWatcher);
        }
        function scheduleUpdateChildWatches(dirName, dirPath, fileName, options) {
            var existing = cacheToUpdateChildWatches.get(dirPath);
            if (existing) {
                existing.fileNames.push(fileName);
            }
            else {
                cacheToUpdateChildWatches.set(dirPath, { dirName: dirName, options: options, fileNames: [fileName] });
            }
            if (timerToUpdateChildWatches) {
                clearTimeout(timerToUpdateChildWatches);
                timerToUpdateChildWatches = undefined;
            }
            timerToUpdateChildWatches = setTimeout(onTimerToUpdateChildWatches, 1000);
        }
        function onTimerToUpdateChildWatches() {
            timerToUpdateChildWatches = undefined;
            sysLog("sysLog:: onTimerToUpdateChildWatches:: ".concat(cacheToUpdateChildWatches.size));
            var start = ts.timestamp();
            var invokeMap = new ts.Map();
            while (!timerToUpdateChildWatches && cacheToUpdateChildWatches.size) {
                var result = cacheToUpdateChildWatches.entries().next();
                ts.Debug.assert(!result.done);
                var _a = result.value, dirPath = _a[0], _b = _a[1], dirName = _b.dirName, options = _b.options, fileNames = _b.fileNames;
                cacheToUpdateChildWatches.delete(dirPath);
                var hasChanges = updateChildWatches(dirName, dirPath, options);
                invokeCallbacks(dirPath, invokeMap, hasChanges ? undefined : fileNames);
            }
            sysLog("sysLog:: invokingWatchers:: Elapsed:: ".concat(ts.timestamp() - start, "ms:: ").concat(cacheToUpdateChildWatches.size));
            callbackCache.forEach(function (callbacks, rootDirName) {
                var existing = invokeMap.get(rootDirName);
                if (existing) {
                    callbacks.forEach(function (_a) {
                        var callback = _a.callback, dirName = _a.dirName;
                        if (ts.isArray(existing)) {
                            existing.forEach(callback);
                        }
                        else {
                            callback(dirName);
                        }
                    });
                }
            });
            var elapsed = ts.timestamp() - start;
            sysLog("sysLog:: Elapsed:: ".concat(elapsed, "ms:: onTimerToUpdateChildWatches:: ").concat(cacheToUpdateChildWatches.size, " ").concat(timerToUpdateChildWatches));
        }
        function removeChildWatches(parentWatcher) {
            if (!parentWatcher)
                return;
            var existingChildWatches = parentWatcher.childWatches;
            parentWatcher.childWatches = ts.emptyArray;
            for (var _i = 0, existingChildWatches_1 = existingChildWatches; _i < existingChildWatches_1.length; _i++) {
                var childWatcher = existingChildWatches_1[_i];
                childWatcher.close();
                removeChildWatches(cache.get(toCanonicalFilePath(childWatcher.dirName)));
            }
        }
        function updateChildWatches(parentDir, parentDirPath, options) {
            var parentWatcher = cache.get(parentDirPath);
            if (!parentWatcher)
                return false;
            var newChildWatches;
            var hasChanges = ts.enumerateInsertsAndDeletes(directoryExists(parentDir) ? ts.mapDefined(getAccessibleSortedChildDirectories(parentDir), function (child) {
                var childFullName = ts.getNormalizedAbsolutePath(child, parentDir);
                return !isIgnoredPath(childFullName, options) && filePathComparer(childFullName, ts.normalizePath(realpath(childFullName))) === 0 ? childFullName : undefined;
            }) : ts.emptyArray, parentWatcher.childWatches, function (child, childWatcher) { return filePathComparer(child, childWatcher.dirName); }, createAndAddChildDirectoryWatcher, ts.closeFileWatcher, addChildDirectoryWatcher);
            parentWatcher.childWatches = newChildWatches || ts.emptyArray;
            return hasChanges;
            function createAndAddChildDirectoryWatcher(childName) {
                var result = createDirectoryWatcher(childName, options);
                addChildDirectoryWatcher(result);
            }
            function addChildDirectoryWatcher(childWatcher) {
                (newChildWatches || (newChildWatches = [])).push(childWatcher);
            }
        }
        function isIgnoredPath(path, options) {
            return ts.some(ts.ignoredPaths, function (searchPath) { return isInPath(path, searchPath); }) ||
                isIgnoredByWatchOptions(path, options, useCaseSensitiveFileNames, getCurrentDirectory);
        }
        function isInPath(path, searchPath) {
            if (ts.stringContains(path, searchPath))
                return true;
            if (useCaseSensitiveFileNames)
                return false;
            return ts.stringContains(toCanonicalFilePath(path), searchPath);
        }
    }
    ts.createDirectoryWatcherSupportingRecursive = createDirectoryWatcherSupportingRecursive;
    function createFileWatcherCallback(callback) {
        return function (_fileName, eventKind) { return callback(eventKind === FileWatcherEventKind.Changed ? "change" : "rename", ""); };
    }
    ts.createFileWatcherCallback = createFileWatcherCallback;
    function createFsWatchCallbackForFileWatcherCallback(fileName, callback, fileExists) {
        return function (eventName) {
            if (eventName === "rename") {
                callback(fileName, fileExists(fileName) ? FileWatcherEventKind.Created : FileWatcherEventKind.Deleted);
            }
            else {
                callback(fileName, FileWatcherEventKind.Changed);
            }
        };
    }
    function isIgnoredByWatchOptions(pathToCheck, options, useCaseSensitiveFileNames, getCurrentDirectory) {
        return ((options === null || options === void 0 ? void 0 : options.excludeDirectories) || (options === null || options === void 0 ? void 0 : options.excludeFiles)) && (ts.matchesExclude(pathToCheck, options === null || options === void 0 ? void 0 : options.excludeFiles, useCaseSensitiveFileNames, getCurrentDirectory()) ||
            ts.matchesExclude(pathToCheck, options === null || options === void 0 ? void 0 : options.excludeDirectories, useCaseSensitiveFileNames, getCurrentDirectory()));
    }
    function createFsWatchCallbackForDirectoryWatcherCallback(directoryName, callback, options, useCaseSensitiveFileNames, getCurrentDirectory) {
        return function (eventName, relativeFileName) {
            if (eventName === "rename") {
                var fileName = !relativeFileName ? directoryName : ts.normalizePath(ts.combinePaths(directoryName, relativeFileName));
                if (!relativeFileName || !isIgnoredByWatchOptions(fileName, options, useCaseSensitiveFileNames, getCurrentDirectory)) {
                    callback(fileName);
                }
            }
        };
    }
    function createSystemWatchFunctions(_a) {
        var pollingWatchFile = _a.pollingWatchFile, getModifiedTime = _a.getModifiedTime, setTimeout = _a.setTimeout, clearTimeout = _a.clearTimeout, fsWatch = _a.fsWatch, fileExists = _a.fileExists, useCaseSensitiveFileNames = _a.useCaseSensitiveFileNames, getCurrentDirectory = _a.getCurrentDirectory, fsSupportsRecursiveFsWatch = _a.fsSupportsRecursiveFsWatch, directoryExists = _a.directoryExists, getAccessibleSortedChildDirectories = _a.getAccessibleSortedChildDirectories, realpath = _a.realpath, tscWatchFile = _a.tscWatchFile, useNonPollingWatchers = _a.useNonPollingWatchers, tscWatchDirectory = _a.tscWatchDirectory, defaultWatchFileKind = _a.defaultWatchFileKind;
        var dynamicPollingWatchFile;
        var fixedChunkSizePollingWatchFile;
        var nonPollingWatchFile;
        var hostRecursiveDirectoryWatcher;
        return {
            watchFile: watchFile,
            watchDirectory: watchDirectory
        };
        function watchFile(fileName, callback, pollingInterval, options) {
            options = updateOptionsForWatchFile(options, useNonPollingWatchers);
            var watchFileKind = ts.Debug.checkDefined(options.watchFile);
            switch (watchFileKind) {
                case ts.WatchFileKind.FixedPollingInterval:
                    return pollingWatchFile(fileName, callback, PollingInterval.Low, undefined);
                case ts.WatchFileKind.PriorityPollingInterval:
                    return pollingWatchFile(fileName, callback, pollingInterval, undefined);
                case ts.WatchFileKind.DynamicPriorityPolling:
                    return ensureDynamicPollingWatchFile()(fileName, callback, pollingInterval, undefined);
                case ts.WatchFileKind.FixedChunkSizePolling:
                    return ensureFixedChunkSizePollingWatchFile()(fileName, callback, undefined, undefined);
                case ts.WatchFileKind.UseFsEvents:
                    return fsWatch(fileName, 0, createFsWatchCallbackForFileWatcherCallback(fileName, callback, fileExists), false, pollingInterval, ts.getFallbackOptions(options));
                case ts.WatchFileKind.UseFsEventsOnParentDirectory:
                    if (!nonPollingWatchFile) {
                        nonPollingWatchFile = createUseFsEventsOnParentDirectoryWatchFile(fsWatch, useCaseSensitiveFileNames);
                    }
                    return nonPollingWatchFile(fileName, callback, pollingInterval, ts.getFallbackOptions(options));
                default:
                    ts.Debug.assertNever(watchFileKind);
            }
        }
        function ensureDynamicPollingWatchFile() {
            return dynamicPollingWatchFile || (dynamicPollingWatchFile = createDynamicPriorityPollingWatchFile({ getModifiedTime: getModifiedTime, setTimeout: setTimeout }));
        }
        function ensureFixedChunkSizePollingWatchFile() {
            return fixedChunkSizePollingWatchFile || (fixedChunkSizePollingWatchFile = createFixedChunkSizePollingWatchFile({ getModifiedTime: getModifiedTime, setTimeout: setTimeout }));
        }
        function updateOptionsForWatchFile(options, useNonPollingWatchers) {
            if (options && options.watchFile !== undefined)
                return options;
            switch (tscWatchFile) {
                case "PriorityPollingInterval":
                    return { watchFile: ts.WatchFileKind.PriorityPollingInterval };
                case "DynamicPriorityPolling":
                    return { watchFile: ts.WatchFileKind.DynamicPriorityPolling };
                case "UseFsEvents":
                    return generateWatchFileOptions(ts.WatchFileKind.UseFsEvents, ts.PollingWatchKind.PriorityInterval, options);
                case "UseFsEventsWithFallbackDynamicPolling":
                    return generateWatchFileOptions(ts.WatchFileKind.UseFsEvents, ts.PollingWatchKind.DynamicPriority, options);
                case "UseFsEventsOnParentDirectory":
                    useNonPollingWatchers = true;
                default:
                    return useNonPollingWatchers ?
                        generateWatchFileOptions(ts.WatchFileKind.UseFsEventsOnParentDirectory, ts.PollingWatchKind.PriorityInterval, options) :
                        { watchFile: (defaultWatchFileKind === null || defaultWatchFileKind === void 0 ? void 0 : defaultWatchFileKind()) || ts.WatchFileKind.FixedPollingInterval };
            }
        }
        function generateWatchFileOptions(watchFile, fallbackPolling, options) {
            var defaultFallbackPolling = options === null || options === void 0 ? void 0 : options.fallbackPolling;
            return {
                watchFile: watchFile,
                fallbackPolling: defaultFallbackPolling === undefined ?
                    fallbackPolling :
                    defaultFallbackPolling
            };
        }
        function watchDirectory(directoryName, callback, recursive, options) {
            if (fsSupportsRecursiveFsWatch) {
                return fsWatch(directoryName, 1, createFsWatchCallbackForDirectoryWatcherCallback(directoryName, callback, options, useCaseSensitiveFileNames, getCurrentDirectory), recursive, PollingInterval.Medium, ts.getFallbackOptions(options));
            }
            if (!hostRecursiveDirectoryWatcher) {
                hostRecursiveDirectoryWatcher = createDirectoryWatcherSupportingRecursive({
                    useCaseSensitiveFileNames: useCaseSensitiveFileNames,
                    getCurrentDirectory: getCurrentDirectory,
                    directoryExists: directoryExists,
                    getAccessibleSortedChildDirectories: getAccessibleSortedChildDirectories,
                    watchDirectory: nonRecursiveWatchDirectory,
                    realpath: realpath,
                    setTimeout: setTimeout,
                    clearTimeout: clearTimeout
                });
            }
            return hostRecursiveDirectoryWatcher(directoryName, callback, recursive, options);
        }
        function nonRecursiveWatchDirectory(directoryName, callback, recursive, options) {
            ts.Debug.assert(!recursive);
            var watchDirectoryOptions = updateOptionsForWatchDirectory(options);
            var watchDirectoryKind = ts.Debug.checkDefined(watchDirectoryOptions.watchDirectory);
            switch (watchDirectoryKind) {
                case ts.WatchDirectoryKind.FixedPollingInterval:
                    return pollingWatchFile(directoryName, function () { return callback(directoryName); }, PollingInterval.Medium, undefined);
                case ts.WatchDirectoryKind.DynamicPriorityPolling:
                    return ensureDynamicPollingWatchFile()(directoryName, function () { return callback(directoryName); }, PollingInterval.Medium, undefined);
                case ts.WatchDirectoryKind.FixedChunkSizePolling:
                    return ensureFixedChunkSizePollingWatchFile()(directoryName, function () { return callback(directoryName); }, undefined, undefined);
                case ts.WatchDirectoryKind.UseFsEvents:
                    return fsWatch(directoryName, 1, createFsWatchCallbackForDirectoryWatcherCallback(directoryName, callback, options, useCaseSensitiveFileNames, getCurrentDirectory), recursive, PollingInterval.Medium, ts.getFallbackOptions(watchDirectoryOptions));
                default:
                    ts.Debug.assertNever(watchDirectoryKind);
            }
        }
        function updateOptionsForWatchDirectory(options) {
            if (options && options.watchDirectory !== undefined)
                return options;
            switch (tscWatchDirectory) {
                case "RecursiveDirectoryUsingFsWatchFile":
                    return { watchDirectory: ts.WatchDirectoryKind.FixedPollingInterval };
                case "RecursiveDirectoryUsingDynamicPriorityPolling":
                    return { watchDirectory: ts.WatchDirectoryKind.DynamicPriorityPolling };
                default:
                    var defaultFallbackPolling = options === null || options === void 0 ? void 0 : options.fallbackPolling;
                    return {
                        watchDirectory: ts.WatchDirectoryKind.UseFsEvents,
                        fallbackPolling: defaultFallbackPolling !== undefined ?
                            defaultFallbackPolling :
                            undefined
                    };
            }
        }
    }
    ts.createSystemWatchFunctions = createSystemWatchFunctions;
    function patchWriteFileEnsuringDirectory(sys) {
        var originalWriteFile = sys.writeFile;
        sys.writeFile = function (path, data, writeBom) {
            return ts.writeFileEnsuringDirectories(path, data, !!writeBom, function (path, data, writeByteOrderMark) { return originalWriteFile.call(sys, path, data, writeByteOrderMark); }, function (path) { return sys.createDirectory(path); }, function (path) { return sys.directoryExists(path); });
        };
    }
    ts.patchWriteFileEnsuringDirectory = patchWriteFileEnsuringDirectory;
    function getNodeMajorVersion() {
        if (typeof process === "undefined") {
            return undefined;
        }
        var version = process.version;
        if (!version) {
            return undefined;
        }
        var dot = version.indexOf(".");
        if (dot === -1) {
            return undefined;
        }
        return parseInt(version.substring(1, dot));
    }
    ts.getNodeMajorVersion = getNodeMajorVersion;
    ts.sys = (function () {
        var byteOrderMarkIndicator = "\uFEFF";
        function getNodeSystem() {
            var _a;
            var nativePattern = /^native |^\([^)]+\)$|^(internal[\\/]|[a-zA-Z0-9_\s]+(\.js)?$)/;
            var _fs = require("fs");
            var _path = require("path");
            var _os = require("os");
            var _crypto;
            try {
                _crypto = require("crypto");
            }
            catch (_b) {
                _crypto = undefined;
            }
            var activeSession;
            var profilePath = "./profile.cpuprofile";
            var hitSystemWatcherLimit = false;
            var Buffer = require("buffer").Buffer;
            var nodeVersion = getNodeMajorVersion();
            var isNode4OrLater = nodeVersion >= 4;
            var isLinuxOrMacOs = process.platform === "linux" || process.platform === "darwin";
            var platform = _os.platform();
            var useCaseSensitiveFileNames = isFileSystemCaseSensitive();
            var realpathSync = (_a = _fs.realpathSync.native) !== null && _a !== void 0 ? _a : _fs.realpathSync;
            var fsSupportsRecursiveFsWatch = isNode4OrLater && (process.platform === "win32" || process.platform === "darwin");
            var getCurrentDirectory = ts.memoize(function () { return process.cwd(); });
            var _c = createSystemWatchFunctions({
                pollingWatchFile: createSingleFileWatcherPerName(fsWatchFileWorker, useCaseSensitiveFileNames),
                getModifiedTime: getModifiedTime,
                setTimeout: setTimeout,
                clearTimeout: clearTimeout,
                fsWatch: fsWatch,
                useCaseSensitiveFileNames: useCaseSensitiveFileNames,
                getCurrentDirectory: getCurrentDirectory,
                fileExists: fileExists,
                fsSupportsRecursiveFsWatch: fsSupportsRecursiveFsWatch,
                directoryExists: directoryExists,
                getAccessibleSortedChildDirectories: function (path) { return getAccessibleFileSystemEntries(path).directories; },
                realpath: realpath,
                tscWatchFile: process.env.TSC_WATCHFILE,
                useNonPollingWatchers: process.env.TSC_NONPOLLING_WATCHER,
                tscWatchDirectory: process.env.TSC_WATCHDIRECTORY,
                defaultWatchFileKind: function () { var _a, _b; return (_b = (_a = sys).defaultWatchFileKind) === null || _b === void 0 ? void 0 : _b.call(_a); },
            }), watchFile = _c.watchFile, watchDirectory = _c.watchDirectory;
            var nodeSystem = {
                args: process.argv.slice(2),
                newLine: _os.EOL,
                useCaseSensitiveFileNames: useCaseSensitiveFileNames,
                write: function (s) {
                    process.stdout.write(s);
                },
                getWidthOfTerminal: function () {
                    return process.stdout.columns;
                },
                writeOutputIsTTY: function () {
                    return process.stdout.isTTY;
                },
                readFile: readFile,
                writeFile: writeFile,
                watchFile: watchFile,
                watchDirectory: watchDirectory,
                resolvePath: function (path) { return _path.resolve(path); },
                fileExists: fileExists,
                directoryExists: directoryExists,
                createDirectory: function (directoryName) {
                    if (!nodeSystem.directoryExists(directoryName)) {
                        try {
                            _fs.mkdirSync(directoryName);
                        }
                        catch (e) {
                            if (e.code !== "EEXIST") {
                                throw e;
                            }
                        }
                    }
                },
                getExecutingFilePath: function () {
                    return __filename;
                },
                getCurrentDirectory: getCurrentDirectory,
                getDirectories: getDirectories,
                getEnvironmentVariable: function (name) {
                    return process.env[name] || "";
                },
                readDirectory: readDirectory,
                getModifiedTime: getModifiedTime,
                setModifiedTime: setModifiedTime,
                deleteFile: deleteFile,
                createHash: _crypto ? createSHA256Hash : generateDjb2Hash,
                createSHA256Hash: _crypto ? createSHA256Hash : undefined,
                getMemoryUsage: function () {
                    if (global.gc) {
                        global.gc();
                    }
                    return process.memoryUsage().heapUsed;
                },
                getFileSize: function (path) {
                    try {
                        var stat = statSync(path);
                        if (stat === null || stat === void 0 ? void 0 : stat.isFile()) {
                            return stat.size;
                        }
                    }
                    catch (_a) { }
                    return 0;
                },
                exit: function (exitCode) {
                    disableCPUProfiler(function () { return process.exit(exitCode); });
                },
                enableCPUProfiler: enableCPUProfiler,
                disableCPUProfiler: disableCPUProfiler,
                cpuProfilingEnabled: function () { return !!activeSession || ts.contains(process.execArgv, "--cpu-prof") || ts.contains(process.execArgv, "--prof"); },
                realpath: realpath,
                debugMode: !!process.env.NODE_INSPECTOR_IPC || !!process.env.VSCODE_INSPECTOR_OPTIONS || ts.some(process.execArgv, function (arg) { return /^--(inspect|debug)(-brk)?(=\d+)?$/i.test(arg); }),
                tryEnableSourceMapsForHost: function () {
                    try {
                        require("source-map-support").install();
                    }
                    catch (_a) {
                    }
                },
                setTimeout: setTimeout,
                clearTimeout: clearTimeout,
                clearScreen: function () {
                    process.stdout.write("\x1Bc");
                },
                setBlocking: function () {
                    if (process.stdout && process.stdout._handle && process.stdout._handle.setBlocking) {
                        process.stdout._handle.setBlocking(true);
                    }
                },
                bufferFrom: bufferFrom,
                base64decode: function (input) { return bufferFrom(input, "base64").toString("utf8"); },
                base64encode: function (input) { return bufferFrom(input).toString("base64"); },
                require: function (baseDir, moduleName) {
                    try {
                        var modulePath = ts.resolveJSModule(moduleName, baseDir, nodeSystem);
                        return { module: require(modulePath), modulePath: modulePath, error: undefined };
                    }
                    catch (error) {
                        return { module: undefined, modulePath: undefined, error: error };
                    }
                }
            };
            return nodeSystem;
            function statSync(path) {
                return _fs.statSync(path, { throwIfNoEntry: false });
            }
            function enableCPUProfiler(path, cb) {
                if (activeSession) {
                    cb();
                    return false;
                }
                var inspector = require("inspector");
                if (!inspector || !inspector.Session) {
                    cb();
                    return false;
                }
                var session = new inspector.Session();
                session.connect();
                session.post("Profiler.enable", function () {
                    session.post("Profiler.start", function () {
                        activeSession = session;
                        profilePath = path;
                        cb();
                    });
                });
                return true;
            }
            function cleanupPaths(profile) {
                var externalFileCounter = 0;
                var remappedPaths = new ts.Map();
                var normalizedDir = ts.normalizeSlashes(__dirname);
                var fileUrlRoot = "file://".concat(ts.getRootLength(normalizedDir) === 1 ? "" : "/").concat(normalizedDir);
                for (var _i = 0, _a = profile.nodes; _i < _a.length; _i++) {
                    var node = _a[_i];
                    if (node.callFrame.url) {
                        var url = ts.normalizeSlashes(node.callFrame.url);
                        if (ts.containsPath(fileUrlRoot, url, useCaseSensitiveFileNames)) {
                            node.callFrame.url = ts.getRelativePathToDirectoryOrUrl(fileUrlRoot, url, fileUrlRoot, ts.createGetCanonicalFileName(useCaseSensitiveFileNames), true);
                        }
                        else if (!nativePattern.test(url)) {
                            node.callFrame.url = (remappedPaths.has(url) ? remappedPaths : remappedPaths.set(url, "external".concat(externalFileCounter, ".js"))).get(url);
                            externalFileCounter++;
                        }
                    }
                }
                return profile;
            }
            function disableCPUProfiler(cb) {
                if (activeSession && activeSession !== "stopping") {
                    var s_1 = activeSession;
                    activeSession.post("Profiler.stop", function (err, _a) {
                        var _b;
                        var profile = _a.profile;
                        if (!err) {
                            try {
                                if ((_b = statSync(profilePath)) === null || _b === void 0 ? void 0 : _b.isDirectory()) {
                                    profilePath = _path.join(profilePath, "".concat((new Date()).toISOString().replace(/:/g, "-"), "+P").concat(process.pid, ".cpuprofile"));
                                }
                            }
                            catch (_c) {
                            }
                            try {
                                _fs.mkdirSync(_path.dirname(profilePath), { recursive: true });
                            }
                            catch (_d) {
                            }
                            _fs.writeFileSync(profilePath, JSON.stringify(cleanupPaths(profile)));
                        }
                        activeSession = undefined;
                        s_1.disconnect();
                        cb();
                    });
                    activeSession = "stopping";
                    return true;
                }
                else {
                    cb();
                    return false;
                }
            }
            function bufferFrom(input, encoding) {
                return Buffer.from && Buffer.from !== Int8Array.from
                    ? Buffer.from(input, encoding)
                    : new Buffer(input, encoding);
            }
            function isFileSystemCaseSensitive() {
                if (platform === "win32" || platform === "win64") {
                    return false;
                }
                return !fileExists(swapCase(__filename));
            }
            function swapCase(s) {
                return s.replace(/\w/g, function (ch) {
                    var up = ch.toUpperCase();
                    return ch === up ? ch.toLowerCase() : up;
                });
            }
            function fsWatchFileWorker(fileName, callback, pollingInterval) {
                _fs.watchFile(fileName, { persistent: true, interval: pollingInterval }, fileChanged);
                var eventKind;
                return {
                    close: function () { return _fs.unwatchFile(fileName, fileChanged); }
                };
                function fileChanged(curr, prev) {
                    var isPreviouslyDeleted = +prev.mtime === 0 || eventKind === FileWatcherEventKind.Deleted;
                    if (+curr.mtime === 0) {
                        if (isPreviouslyDeleted) {
                            return;
                        }
                        eventKind = FileWatcherEventKind.Deleted;
                    }
                    else if (isPreviouslyDeleted) {
                        eventKind = FileWatcherEventKind.Created;
                    }
                    else if (+curr.mtime === +prev.mtime) {
                        return;
                    }
                    else {
                        eventKind = FileWatcherEventKind.Changed;
                    }
                    callback(fileName, eventKind);
                }
            }
            function fsWatch(fileOrDirectory, entryKind, callback, recursive, fallbackPollingInterval, fallbackOptions) {
                var options;
                var lastDirectoryPartWithDirectorySeparator;
                var lastDirectoryPart;
                if (isLinuxOrMacOs) {
                    lastDirectoryPartWithDirectorySeparator = fileOrDirectory.substr(fileOrDirectory.lastIndexOf(ts.directorySeparator));
                    lastDirectoryPart = lastDirectoryPartWithDirectorySeparator.slice(ts.directorySeparator.length);
                }
                var watcher = !fileSystemEntryExists(fileOrDirectory, entryKind) ?
                    watchMissingFileSystemEntry() :
                    watchPresentFileSystemEntry();
                return {
                    close: function () {
                        watcher.close();
                        watcher = undefined;
                    }
                };
                function invokeCallbackAndUpdateWatcher(createWatcher) {
                    sysLog("sysLog:: ".concat(fileOrDirectory, ":: Changing watcher to ").concat(createWatcher === watchPresentFileSystemEntry ? "Present" : "Missing", "FileSystemEntryWatcher"));
                    callback("rename", "");
                    if (watcher) {
                        watcher.close();
                        watcher = createWatcher();
                    }
                }
                function watchPresentFileSystemEntry() {
                    if (options === undefined) {
                        if (fsSupportsRecursiveFsWatch) {
                            options = { persistent: true, recursive: !!recursive };
                        }
                        else {
                            options = { persistent: true };
                        }
                    }
                    if (hitSystemWatcherLimit) {
                        sysLog("sysLog:: ".concat(fileOrDirectory, ":: Defaulting to fsWatchFile"));
                        return watchPresentFileSystemEntryWithFsWatchFile();
                    }
                    try {
                        var presentWatcher = _fs.watch(fileOrDirectory, options, isLinuxOrMacOs ?
                            callbackChangingToMissingFileSystemEntry :
                            callback);
                        presentWatcher.on("error", function () { return invokeCallbackAndUpdateWatcher(watchMissingFileSystemEntry); });
                        return presentWatcher;
                    }
                    catch (e) {
                        hitSystemWatcherLimit || (hitSystemWatcherLimit = e.code === "ENOSPC");
                        sysLog("sysLog:: ".concat(fileOrDirectory, ":: Changing to fsWatchFile"));
                        return watchPresentFileSystemEntryWithFsWatchFile();
                    }
                }
                function callbackChangingToMissingFileSystemEntry(event, relativeName) {
                    return event === "rename" &&
                        (!relativeName ||
                            relativeName === lastDirectoryPart ||
                            (relativeName.lastIndexOf(lastDirectoryPartWithDirectorySeparator) !== -1 && relativeName.lastIndexOf(lastDirectoryPartWithDirectorySeparator) === relativeName.length - lastDirectoryPartWithDirectorySeparator.length)) &&
                        !fileSystemEntryExists(fileOrDirectory, entryKind) ?
                        invokeCallbackAndUpdateWatcher(watchMissingFileSystemEntry) :
                        callback(event, relativeName);
                }
                function watchPresentFileSystemEntryWithFsWatchFile() {
                    return watchFile(fileOrDirectory, createFileWatcherCallback(callback), fallbackPollingInterval, fallbackOptions);
                }
                function watchMissingFileSystemEntry() {
                    return watchFile(fileOrDirectory, function (_fileName, eventKind) {
                        if (eventKind === FileWatcherEventKind.Created && fileSystemEntryExists(fileOrDirectory, entryKind)) {
                            invokeCallbackAndUpdateWatcher(watchPresentFileSystemEntry);
                        }
                    }, fallbackPollingInterval, fallbackOptions);
                }
            }
            function readFileWorker(fileName, _encoding) {
                var buffer;
                try {
                    buffer = _fs.readFileSync(fileName);
                }
                catch (e) {
                    return undefined;
                }
                var len = buffer.length;
                if (len >= 2 && buffer[0] === 0xFE && buffer[1] === 0xFF) {
                    len &= ~1;
                    for (var i = 0; i < len; i += 2) {
                        var temp = buffer[i];
                        buffer[i] = buffer[i + 1];
                        buffer[i + 1] = temp;
                    }
                    return buffer.toString("utf16le", 2);
                }
                if (len >= 2 && buffer[0] === 0xFF && buffer[1] === 0xFE) {
                    return buffer.toString("utf16le", 2);
                }
                if (len >= 3 && buffer[0] === 0xEF && buffer[1] === 0xBB && buffer[2] === 0xBF) {
                    return buffer.toString("utf8", 3);
                }
                return buffer.toString("utf8");
            }
            function readFile(fileName, _encoding) {
                ts.perfLogger.logStartReadFile(fileName);
                var file = readFileWorker(fileName, _encoding);
                ts.perfLogger.logStopReadFile();
                return file;
            }
            function writeFile(fileName, data, writeByteOrderMark) {
                ts.perfLogger.logEvent("WriteFile: " + fileName);
                if (writeByteOrderMark) {
                    data = byteOrderMarkIndicator + data;
                }
                var fd;
                try {
                    fd = _fs.openSync(fileName, "w");
                    _fs.writeSync(fd, data, undefined, "utf8");
                }
                finally {
                    if (fd !== undefined) {
                        _fs.closeSync(fd);
                    }
                }
            }
            function getAccessibleFileSystemEntries(path) {
                ts.perfLogger.logEvent("ReadDir: " + (path || "."));
                try {
                    var entries = _fs.readdirSync(path || ".", { withFileTypes: true });
                    var files = [];
                    var directories = [];
                    for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {
                        var dirent = entries_1[_i];
                        var entry = typeof dirent === "string" ? dirent : dirent.name;
                        if (entry === "." || entry === "..") {
                            continue;
                        }
                        var stat = void 0;
                        if (typeof dirent === "string" || dirent.isSymbolicLink()) {
                            var name = ts.combinePaths(path, entry);
                            try {
                                stat = statSync(name);
                                if (!stat) {
                                    continue;
                                }
                            }
                            catch (e) {
                                continue;
                            }
                        }
                        else {
                            stat = dirent;
                        }
                        if (stat.isFile()) {
                            files.push(entry);
                        }
                        else if (stat.isDirectory()) {
                            directories.push(entry);
                        }
                    }
                    files.sort();
                    directories.sort();
                    return { files: files, directories: directories };
                }
                catch (e) {
                    return ts.emptyFileSystemEntries;
                }
            }
            function readDirectory(path, extensions, excludes, includes, depth) {
                return ts.matchFiles(path, extensions, excludes, includes, useCaseSensitiveFileNames, process.cwd(), depth, getAccessibleFileSystemEntries, realpath);
            }
            function fileSystemEntryExists(path, entryKind) {
                var originalStackTraceLimit = Error.stackTraceLimit;
                Error.stackTraceLimit = 0;
                try {
                    var stat = statSync(path);
                    if (!stat) {
                        return false;
                    }
                    switch (entryKind) {
                        case 0: return stat.isFile();
                        case 1: return stat.isDirectory();
                        default: return false;
                    }
                }
                catch (e) {
                    return false;
                }
                finally {
                    Error.stackTraceLimit = originalStackTraceLimit;
                }
            }
            function fileExists(path) {
                return fileSystemEntryExists(path, 0);
            }
            function directoryExists(path) {
                return fileSystemEntryExists(path, 1);
            }
            function getDirectories(path) {
                return getAccessibleFileSystemEntries(path).directories.slice();
            }
            function realpath(path) {
                try {
                    return realpathSync(path);
                }
                catch (_a) {
                    return path;
                }
            }
            function getModifiedTime(path) {
                var _a;
                try {
                    return (_a = statSync(path)) === null || _a === void 0 ? void 0 : _a.mtime;
                }
                catch (e) {
                    return undefined;
                }
            }
            function setModifiedTime(path, time) {
                try {
                    _fs.utimesSync(path, time, time);
                }
                catch (e) {
                    return;
                }
            }
            function deleteFile(path) {
                try {
                    return _fs.unlinkSync(path);
                }
                catch (e) {
                    return;
                }
            }
            function createSHA256Hash(data) {
                var hash = _crypto.createHash("sha256");
                hash.update(data);
                return hash.digest("hex");
            }
        }
        var sys;
        if (typeof process !== "undefined" && process.nextTick && !process.browser && typeof require !== "undefined") {
            sys = getNodeSystem();
        }
        if (sys) {
            patchWriteFileEnsuringDirectory(sys);
        }
        return sys;
    })();
    function setSys(s) {
        ts.sys = s;
    }
    ts.setSys = setSys;
    if (ts.sys && ts.sys.getEnvironmentVariable) {
        setCustomPollingValues(ts.sys);
        ts.Debug.setAssertionLevel(/^development$/i.test(ts.sys.getEnvironmentVariable("NODE_ENV"))
            ? 1
            : 0);
    }
    if (ts.sys && ts.sys.debugMode) {
        ts.Debug.isDebugging = true;
    }
})(ts || (ts = {}));
var ts;
(function (ts) {
    ts.directorySeparator = "/";
    ts.altDirectorySeparator = "\\";
    var urlSchemeSeparator = "://";
    var backslashRegExp = /\\/g;
    function isAnyDirectorySeparator(charCode) {
        return charCode === 47 || charCode === 92;
    }
    ts.isAnyDirectorySeparator = isAnyDirectorySeparator;
    function isUrl(path) {
        return getEncodedRootLength(path) < 0;
    }
    ts.isUrl = isUrl;
    function isRootedDiskPath(path) {
        return getEncodedRootLength(path) > 0;
    }
    ts.isRootedDiskPath = isRootedDiskPath;
    function isDiskPathRoot(path) {
        var rootLength = getEncodedRootLength(path);
        return rootLength > 0 && rootLength === path.length;
    }
    ts.isDiskPathRoot = isDiskPathRoot;
    function pathIsAbsolute(path) {
        return getEncodedRootLength(path) !== 0;
    }
    ts.pathIsAbsolute = pathIsAbsolute;
    function pathIsRelative(path) {
        return /^\.\.?($|[\\/])/.test(path);
    }
    ts.pathIsRelative = pathIsRelative;
    function pathIsBareSpecifier(path) {
        return !pathIsAbsolute(path) && !pathIsRelative(path);
    }
    ts.pathIsBareSpecifier = pathIsBareSpecifier;
    function hasExtension(fileName) {
        return ts.stringContains(getBaseFileName(fileName), ".");
    }
    ts.hasExtension = hasExtension;
    function fileExtensionIs(path, extension) {
        return path.length > extension.length && ts.endsWith(path, extension);
    }
    ts.fileExtensionIs = fileExtensionIs;
    function fileExtensionIsOneOf(path, extensions) {
        for (var _i = 0, extensions_1 = extensions; _i < extensions_1.length; _i++) {
            var extension = extensions_1[_i];
            if (fileExtensionIs(path, extension)) {
                return true;
            }
        }
        return false;
    }
    ts.fileExtensionIsOneOf = fileExtensionIsOneOf;
    function hasTrailingDirectorySeparator(path) {
        return path.length > 0 && isAnyDirectorySeparator(path.charCodeAt(path.length - 1));
    }
    ts.hasTrailingDirectorySeparator = hasTrailingDirectorySeparator;
    function isVolumeCharacter(charCode) {
        return (charCode >= 97 && charCode <= 122) ||
            (charCode >= 65 && charCode <= 90);
    }
    function getFileUrlVolumeSeparatorEnd(url, start) {
        var ch0 = url.charCodeAt(start);
        if (ch0 === 58)
            return start + 1;
        if (ch0 === 37 && url.charCodeAt(start + 1) === 51) {
            var ch2 = url.charCodeAt(start + 2);
            if (ch2 === 97 || ch2 === 65)
                return start + 3;
        }
        return -1;
    }
    function getEncodedRootLength(path) {
        if (!path)
            return 0;
        var ch0 = path.charCodeAt(0);
        if (ch0 === 47 || ch0 === 92) {
            if (path.charCodeAt(1) !== ch0)
                return 1;
            var p1 = path.indexOf(ch0 === 47 ? ts.directorySeparator : ts.altDirectorySeparator, 2);
            if (p1 < 0)
                return path.length;
            return p1 + 1;
        }
        if (isVolumeCharacter(ch0) && path.charCodeAt(1) === 58) {
            var ch2 = path.charCodeAt(2);
            if (ch2 === 47 || ch2 === 92)
                return 3;
            if (path.length === 2)
                return 2;
        }
        var schemeEnd = path.indexOf(urlSchemeSeparator);
        if (schemeEnd !== -1) {
            var authorityStart = schemeEnd + urlSchemeSeparator.length;
            var authorityEnd = path.indexOf(ts.directorySeparator, authorityStart);
            if (authorityEnd !== -1) {
                var scheme = path.slice(0, schemeEnd);
                var authority = path.slice(authorityStart, authorityEnd);
                if (scheme === "file" && (authority === "" || authority === "localhost") &&
                    isVolumeCharacter(path.charCodeAt(authorityEnd + 1))) {
                    var volumeSeparatorEnd = getFileUrlVolumeSeparatorEnd(path, authorityEnd + 2);
                    if (volumeSeparatorEnd !== -1) {
                        if (path.charCodeAt(volumeSeparatorEnd) === 47) {
                            return ~(volumeSeparatorEnd + 1);
                        }
                        if (volumeSeparatorEnd === path.length) {
                            return ~volumeSeparatorEnd;
                        }
                    }
                }
                return ~(authorityEnd + 1);
            }
            return ~path.length;
        }
        return 0;
    }
    function getRootLength(path) {
        var rootLength = getEncodedRootLength(path);
        return rootLength < 0 ? ~rootLength : rootLength;
    }
    ts.getRootLength = getRootLength;
    function getDirectoryPath(path) {
        path = normalizeSlashes(path);
        var rootLength = getRootLength(path);
        if (rootLength === path.length)
            return path;
        path = removeTrailingDirectorySeparator(path);
        return path.slice(0, Math.max(rootLength, path.lastIndexOf(ts.directorySeparator)));
    }
    ts.getDirectoryPath = getDirectoryPath;
    function getBaseFileName(path, extensions, ignoreCase) {
        path = normalizeSlashes(path);
        var rootLength = getRootLength(path);
        if (rootLength === path.length)
            return "";
        path = removeTrailingDirectorySeparator(path);
        var name = path.slice(Math.max(getRootLength(path), path.lastIndexOf(ts.directorySeparator) + 1));
        var extension = extensions !== undefined && ignoreCase !== undefined ? getAnyExtensionFromPath(name, extensions, ignoreCase) : undefined;
        return extension ? name.slice(0, name.length - extension.length) : name;
    }
    ts.getBaseFileName = getBaseFileName;
    function tryGetExtensionFromPath(path, extension, stringEqualityComparer) {
        if (!ts.startsWith(extension, "."))
            extension = "." + extension;
        if (path.length >= extension.length && path.charCodeAt(path.length - extension.length) === 46) {
            var pathExtension = path.slice(path.length - extension.length);
            if (stringEqualityComparer(pathExtension, extension)) {
                return pathExtension;
            }
        }
    }
    function getAnyExtensionFromPathWorker(path, extensions, stringEqualityComparer) {
        if (typeof extensions === "string") {
            return tryGetExtensionFromPath(path, extensions, stringEqualityComparer) || "";
        }
        for (var _i = 0, extensions_2 = extensions; _i < extensions_2.length; _i++) {
            var extension = extensions_2[_i];
            var result = tryGetExtensionFromPath(path, extension, stringEqualityComparer);
            if (result)
                return result;
        }
        return "";
    }
    function getAnyExtensionFromPath(path, extensions, ignoreCase) {
        if (extensions) {
            return getAnyExtensionFromPathWorker(removeTrailingDirectorySeparator(path), extensions, ignoreCase ? ts.equateStringsCaseInsensitive : ts.equateStringsCaseSensitive);
        }
        var baseFileName = getBaseFileName(path);
        var extensionIndex = baseFileName.lastIndexOf(".");
        if (extensionIndex >= 0) {
            return baseFileName.substring(extensionIndex);
        }
        return "";
    }
    ts.getAnyExtensionFromPath = getAnyExtensionFromPath;
    function pathComponents(path, rootLength) {
        var root = path.substring(0, rootLength);
        var rest = path.substring(rootLength).split(ts.directorySeparator);
        if (rest.length && !ts.lastOrUndefined(rest))
            rest.pop();
        return __spreadArray([root], rest, true);
    }
    function getPathComponents(path, currentDirectory) {
        if (currentDirectory === void 0) { currentDirectory = ""; }
        path = combinePaths(currentDirectory, path);
        return pathComponents(path, getRootLength(path));
    }
    ts.getPathComponents = getPathComponents;
    function getPathFromPathComponents(pathComponents) {
        if (pathComponents.length === 0)
            return "";
        var root = pathComponents[0] && ensureTrailingDirectorySeparator(pathComponents[0]);
        return root + pathComponents.slice(1).join(ts.directorySeparator);
    }
    ts.getPathFromPathComponents = getPathFromPathComponents;
    function normalizeSlashes(path) {
        var index = path.indexOf("\\");
        if (index === -1) {
            return path;
        }
        backslashRegExp.lastIndex = index;
        return path.replace(backslashRegExp, ts.directorySeparator);
    }
    ts.normalizeSlashes = normalizeSlashes;
    function reducePathComponents(components) {
        if (!ts.some(components))
            return [];
        var reduced = [components[0]];
        for (var i = 1; i < components.length; i++) {
            var component = components[i];
            if (!component)
                continue;
            if (component === ".")
                continue;
            if (component === "..") {
                if (reduced.length > 1) {
                    if (reduced[reduced.length - 1] !== "..") {
                        reduced.pop();
                        continue;
                    }
                }
                else if (reduced[0])
                    continue;
            }
            reduced.push(component);
        }
        return reduced;
    }
    ts.reducePathComponents = reducePathComponents;
    function combinePaths(path) {
        var paths = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            paths[_i - 1] = arguments[_i];
        }
        if (path)
            path = normalizeSlashes(path);
        for (var _a = 0, paths_1 = paths; _a < paths_1.length; _a++) {
            var relativePath = paths_1[_a];
            if (!relativePath)
                continue;
            relativePath = normalizeSlashes(relativePath);
            if (!path || getRootLength(relativePath) !== 0) {
                path = relativePath;
            }
            else {
                path = ensureTrailingDirectorySeparator(path) + relativePath;
            }
        }
        return path;
    }
    ts.combinePaths = combinePaths;
    function resolvePath(path) {
        var paths = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            paths[_i - 1] = arguments[_i];
        }
        return normalizePath(ts.some(paths) ? combinePaths.apply(void 0, __spreadArray([path], paths, false)) : normalizeSlashes(path));
    }
    ts.resolvePath = resolvePath;
    function getNormalizedPathComponents(path, currentDirectory) {
        return reducePathComponents(getPathComponents(path, currentDirectory));
    }
    ts.getNormalizedPathComponents = getNormalizedPathComponents;
    function getNormalizedAbsolutePath(fileName, currentDirectory) {
        return getPathFromPathComponents(getNormalizedPathComponents(fileName, currentDirectory));
    }
    ts.getNormalizedAbsolutePath = getNormalizedAbsolutePath;
    function normalizePath(path) {
        path = normalizeSlashes(path);
        if (!relativePathSegmentRegExp.test(path)) {
            return path;
        }
        var simplified = path.replace(/\/\.\//g, "/").replace(/^\.\//, "");
        if (simplified !== path) {
            path = simplified;
            if (!relativePathSegmentRegExp.test(path)) {
                return path;
            }
        }
        var normalized = getPathFromPathComponents(reducePathComponents(getPathComponents(path)));
        return normalized && hasTrailingDirectorySeparator(path) ? ensureTrailingDirectorySeparator(normalized) : normalized;
    }
    ts.normalizePath = normalizePath;
    function getPathWithoutRoot(pathComponents) {
        if (pathComponents.length === 0)
            return "";
        return pathComponents.slice(1).join(ts.directorySeparator);
    }
    function getNormalizedAbsolutePathWithoutRoot(fileName, currentDirectory) {
        return getPathWithoutRoot(getNormalizedPathComponents(fileName, currentDirectory));
    }
    ts.getNormalizedAbsolutePathWithoutRoot = getNormalizedAbsolutePathWithoutRoot;
    function toPath(fileName, basePath, getCanonicalFileName) {
        var nonCanonicalizedPath = isRootedDiskPath(fileName)
            ? normalizePath(fileName)
            : getNormalizedAbsolutePath(fileName, basePath);
        return getCanonicalFileName(nonCanonicalizedPath);
    }
    ts.toPath = toPath;
    function removeTrailingDirectorySeparator(path) {
        if (hasTrailingDirectorySeparator(path)) {
            return path.substr(0, path.length - 1);
        }
        return path;
    }
    ts.removeTrailingDirectorySeparator = removeTrailingDirectorySeparator;
    function ensureTrailingDirectorySeparator(path) {
        if (!hasTrailingDirectorySeparator(path)) {
            return path + ts.directorySeparator;
        }
        return path;
    }
    ts.ensureTrailingDirectorySeparator = ensureTrailingDirectorySeparator;
    function ensurePathIsNonModuleName(path) {
        return !pathIsAbsolute(path) && !pathIsRelative(path) ? "./" + path : path;
    }
    ts.ensurePathIsNonModuleName = ensurePathIsNonModuleName;
    function changeAnyExtension(path, ext, extensions, ignoreCase) {
        var pathext = extensions !== undefined && ignoreCase !== undefined ? getAnyExtensionFromPath(path, extensions, ignoreCase) : getAnyExtensionFromPath(path);
        return pathext ? path.slice(0, path.length - pathext.length) + (ts.startsWith(ext, ".") ? ext : "." + ext) : path;
    }
    ts.changeAnyExtension = changeAnyExtension;
    var relativePathSegmentRegExp = /(?:\/\/)|(?:^|\/)\.\.?(?:$|\/)/;
    function comparePathsWorker(a, b, componentComparer) {
        if (a === b)
            return 0;
        if (a === undefined)
            return -1;
        if (b === undefined)
            return 1;
        var aRoot = a.substring(0, getRootLength(a));
        var bRoot = b.substring(0, getRootLength(b));
        var result = ts.compareStringsCaseInsensitive(aRoot, bRoot);
        if (result !== 0) {
            return result;
        }
        var aRest = a.substring(aRoot.length);
        var bRest = b.substring(bRoot.length);
        if (!relativePathSegmentRegExp.test(aRest) && !relativePathSegmentRegExp.test(bRest)) {
            return componentComparer(aRest, bRest);
        }
        var aComponents = reducePathComponents(getPathComponents(a));
        var bComponents = reducePathComponents(getPathComponents(b));
        var sharedLength = Math.min(aComponents.length, bComponents.length);
        for (var i = 1; i < sharedLength; i++) {
            var result_2 = componentComparer(aComponents[i], bComponents[i]);
            if (result_2 !== 0) {
                return result_2;
            }
        }
        return ts.compareValues(aComponents.length, bComponents.length);
    }
    function comparePathsCaseSensitive(a, b) {
        return comparePathsWorker(a, b, ts.compareStringsCaseSensitive);
    }
    ts.comparePathsCaseSensitive = comparePathsCaseSensitive;
    function comparePathsCaseInsensitive(a, b) {
        return comparePathsWorker(a, b, ts.compareStringsCaseInsensitive);
    }
    ts.comparePathsCaseInsensitive = comparePathsCaseInsensitive;
    function comparePaths(a, b, currentDirectory, ignoreCase) {
        if (typeof currentDirectory === "string") {
            a = combinePaths(currentDirectory, a);
            b = combinePaths(currentDirectory, b);
        }
        else if (typeof currentDirectory === "boolean") {
            ignoreCase = currentDirectory;
        }
        return comparePathsWorker(a, b, ts.getStringComparer(ignoreCase));
    }
    ts.comparePaths = comparePaths;
    function containsPath(parent, child, currentDirectory, ignoreCase) {
        if (typeof currentDirectory === "string") {
            parent = combinePaths(currentDirectory, parent);
            child = combinePaths(currentDirectory, child);
        }
        else if (typeof currentDirectory === "boolean") {
            ignoreCase = currentDirectory;
        }
        if (parent === undefined || child === undefined)
            return false;
        if (parent === child)
            return true;
        var parentComponents = reducePathComponents(getPathComponents(parent));
        var childComponents = reducePathComponents(getPathComponents(child));
        if (childComponents.length < parentComponents.length) {
            return false;
        }
        var componentEqualityComparer = ignoreCase ? ts.equateStringsCaseInsensitive : ts.equateStringsCaseSensitive;
        for (var i = 0; i < parentComponents.length; i++) {
            var equalityComparer = i === 0 ? ts.equateStringsCaseInsensitive : componentEqualityComparer;
            if (!equalityComparer(parentComponents[i], childComponents[i])) {
                return false;
            }
        }
        return true;
    }
    ts.containsPath = containsPath;
    function startsWithDirectory(fileName, directoryName, getCanonicalFileName) {
        var canonicalFileName = getCanonicalFileName(fileName);
        var canonicalDirectoryName = getCanonicalFileName(directoryName);
        return ts.startsWith(canonicalFileName, canonicalDirectoryName + "/") || ts.startsWith(canonicalFileName, canonicalDirectoryName + "\\");
    }
    ts.startsWithDirectory = startsWithDirectory;
    function getPathComponentsRelativeTo(from, to, stringEqualityComparer, getCanonicalFileName) {
        var fromComponents = reducePathComponents(getPathComponents(from));
        var toComponents = reducePathComponents(getPathComponents(to));
        var start;
        for (start = 0; start < fromComponents.length && start < toComponents.length; start++) {
            var fromComponent = getCanonicalFileName(fromComponents[start]);
            var toComponent = getCanonicalFileName(toComponents[start]);
            var comparer = start === 0 ? ts.equateStringsCaseInsensitive : stringEqualityComparer;
            if (!comparer(fromComponent, toComponent))
                break;
        }
        if (start === 0) {
            return toComponents;
        }
        var components = toComponents.slice(start);
        var relative = [];
        for (; start < fromComponents.length; start++) {
            relative.push("..");
        }
        return __spreadArray(__spreadArray([""], relative, true), components, true);
    }
    ts.getPathComponentsRelativeTo = getPathComponentsRelativeTo;
    function getRelativePathFromDirectory(fromDirectory, to, getCanonicalFileNameOrIgnoreCase) {
        ts.Debug.assert((getRootLength(fromDirectory) > 0) === (getRootLength(to) > 0), "Paths must either both be absolute or both be relative");
        var getCanonicalFileName = typeof getCanonicalFileNameOrIgnoreCase === "function" ? getCanonicalFileNameOrIgnoreCase : ts.identity;
        var ignoreCase = typeof getCanonicalFileNameOrIgnoreCase === "boolean" ? getCanonicalFileNameOrIgnoreCase : false;
        var pathComponents = getPathComponentsRelativeTo(fromDirectory, to, ignoreCase ? ts.equateStringsCaseInsensitive : ts.equateStringsCaseSensitive, getCanonicalFileName);
        return getPathFromPathComponents(pathComponents);
    }
    ts.getRelativePathFromDirectory = getRelativePathFromDirectory;
    function convertToRelativePath(absoluteOrRelativePath, basePath, getCanonicalFileName) {
        return !isRootedDiskPath(absoluteOrRelativePath)
            ? absoluteOrRelativePath
            : getRelativePathToDirectoryOrUrl(basePath, absoluteOrRelativePath, basePath, getCanonicalFileName, false);
    }
    ts.convertToRelativePath = convertToRelativePath;
    function getRelativePathFromFile(from, to, getCanonicalFileName) {
        return ensurePathIsNonModuleName(getRelativePathFromDirectory(getDirectoryPath(from), to, getCanonicalFileName));
    }
    ts.getRelativePathFromFile = getRelativePathFromFile;
    function getRelativePathToDirectoryOrUrl(directoryPathOrUrl, relativeOrAbsolutePath, currentDirectory, getCanonicalFileName, isAbsolutePathAnUrl) {
        var pathComponents = getPathComponentsRelativeTo(resolvePath(currentDirectory, directoryPathOrUrl), resolvePath(currentDirectory, relativeOrAbsolutePath), ts.equateStringsCaseSensitive, getCanonicalFileName);
        var firstComponent = pathComponents[0];
        if (isAbsolutePathAnUrl && isRootedDiskPath(firstComponent)) {
            var prefix = firstComponent.charAt(0) === ts.directorySeparator ? "file://" : "file:///";
            pathComponents[0] = prefix + firstComponent;
        }
        return getPathFromPathComponents(pathComponents);
    }
    ts.getRelativePathToDirectoryOrUrl = getRelativePathToDirectoryOrUrl;
    function forEachAncestorDirectory(directory, callback) {
        while (true) {
            var result = callback(directory);
            if (result !== undefined) {
                return result;
            }
            var parentPath = getDirectoryPath(directory);
            if (parentPath === directory) {
                return undefined;
            }
            directory = parentPath;
        }
    }
    ts.forEachAncestorDirectory = forEachAncestorDirectory;
    function isNodeModulesDirectory(dirPath) {
        return ts.endsWith(dirPath, "/node_modules");
    }
    ts.isNodeModulesDirectory = isNodeModulesDirectory;
})(ts || (ts = {}));
var ts;
(function (ts) {
    function diag(code, category, key, message, reportsUnnecessary, elidedInCompatabilityPyramid, reportsDeprecated) {
        return { code: code, category: category, key: key, message: message, reportsUnnecessary: reportsUnnecessary, elidedInCompatabilityPyramid: elidedInCompatabilityPyramid, reportsDeprecated: reportsDeprecated };
    }
    ts.Diagnostics = {
        Unterminated_string_literal: diag(1002, ts.DiagnosticCategory.Error, "Unterminated_string_literal_1002", "Unterminated string literal."),
        Identifier_expected: diag(1003, ts.DiagnosticCategory.Error, "Identifier_expected_1003", "Identifier expected."),
        _0_expected: diag(1005, ts.DiagnosticCategory.Error, "_0_expected_1005", "'{0}' expected."),
        A_file_cannot_have_a_reference_to_itself: diag(1006, ts.DiagnosticCategory.Error, "A_file_cannot_have_a_reference_to_itself_1006", "A file cannot have a reference to itself."),
        The_parser_expected_to_find_a_1_to_match_the_0_token_here: diag(1007, ts.DiagnosticCategory.Error, "The_parser_expected_to_find_a_1_to_match_the_0_token_here_1007", "The parser expected to find a '{1}' to match the '{0}' token here."),
        Trailing_comma_not_allowed: diag(1009, ts.DiagnosticCategory.Error, "Trailing_comma_not_allowed_1009", "Trailing comma not allowed."),
        Asterisk_Slash_expected: diag(1010, ts.DiagnosticCategory.Error, "Asterisk_Slash_expected_1010", "'*/' expected."),
        An_element_access_expression_should_take_an_argument: diag(1011, ts.DiagnosticCategory.Error, "An_element_access_expression_should_take_an_argument_1011", "An element access expression should take an argument."),
        Unexpected_token: diag(1012, ts.DiagnosticCategory.Error, "Unexpected_token_1012", "Unexpected token."),
        A_rest_parameter_or_binding_pattern_may_not_have_a_trailing_comma: diag(1013, ts.DiagnosticCategory.Error, "A_rest_parameter_or_binding_pattern_may_not_have_a_trailing_comma_1013", "A rest parameter or binding pattern may not have a trailing comma."),
        A_rest_parameter_must_be_last_in_a_parameter_list: diag(1014, ts.DiagnosticCategory.Error, "A_rest_parameter_must_be_last_in_a_parameter_list_1014", "A rest parameter must be last in a parameter list."),
        Parameter_cannot_have_question_mark_and_initializer: diag(1015, ts.DiagnosticCategory.Error, "Parameter_cannot_have_question_mark_and_initializer_1015", "Parameter cannot have question mark and initializer."),
        A_required_parameter_cannot_follow_an_optional_parameter: diag(1016, ts.DiagnosticCategory.Error, "A_required_parameter_cannot_follow_an_optional_parameter_1016", "A required parameter cannot follow an optional parameter."),
        An_index_signature_cannot_have_a_rest_parameter: diag(1017, ts.DiagnosticCategory.Error, "An_index_signature_cannot_have_a_rest_parameter_1017", "An index signature cannot have a rest parameter."),
        An_index_signature_parameter_cannot_have_an_accessibility_modifier: diag(1018, ts.DiagnosticCategory.Error, "An_index_signature_parameter_cannot_have_an_accessibility_modifier_1018", "An index signature parameter cannot have an accessibility modifier."),
        An_index_signature_parameter_cannot_have_a_question_mark: diag(1019, ts.DiagnosticCategory.Error, "An_index_signature_parameter_cannot_have_a_question_mark_1019", "An index signature parameter cannot have a question mark."),
        An_index_signature_parameter_cannot_have_an_initializer: diag(1020, ts.DiagnosticCategory.Error, "An_index_signature_parameter_cannot_have_an_initializer_1020", "An index signature parameter cannot have an initializer."),
        An_index_signature_must_have_a_type_annotation: diag(1021, ts.DiagnosticCategory.Error, "An_index_signature_must_have_a_type_annotation_1021", "An index signature must have a type annotation."),
        An_index_signature_parameter_must_have_a_type_annotation: diag(1022, ts.DiagnosticCategory.Error, "An_index_signature_parameter_must_have_a_type_annotation_1022", "An index signature parameter must have a type annotation."),
        readonly_modifier_can_only_appear_on_a_property_declaration_or_index_signature: diag(1024, ts.DiagnosticCategory.Error, "readonly_modifier_can_only_appear_on_a_property_declaration_or_index_signature_1024", "'readonly' modifier can only appear on a property declaration or index signature."),
        An_index_signature_cannot_have_a_trailing_comma: diag(1025, ts.DiagnosticCategory.Error, "An_index_signature_cannot_have_a_trailing_comma_1025", "An index signature cannot have a trailing comma."),
        Accessibility_modifier_already_seen: diag(1028, ts.DiagnosticCategory.Error, "Accessibility_modifier_already_seen_1028", "Accessibility modifier already seen."),
        _0_modifier_must_precede_1_modifier: diag(1029, ts.DiagnosticCategory.Error, "_0_modifier_must_precede_1_modifier_1029", "'{0}' modifier must precede '{1}' modifier."),
        _0_modifier_already_seen: diag(1030, ts.DiagnosticCategory.Error, "_0_modifier_already_seen_1030", "'{0}' modifier already seen."),
        _0_modifier_cannot_appear_on_class_elements_of_this_kind: diag(1031, ts.DiagnosticCategory.Error, "_0_modifier_cannot_appear_on_class_elements_of_this_kind_1031", "'{0}' modifier cannot appear on class elements of this kind."),
        super_must_be_followed_by_an_argument_list_or_member_access: diag(1034, ts.DiagnosticCategory.Error, "super_must_be_followed_by_an_argument_list_or_member_access_1034", "'super' must be followed by an argument list or member access."),
        Only_ambient_modules_can_use_quoted_names: diag(1035, ts.DiagnosticCategory.Error, "Only_ambient_modules_can_use_quoted_names_1035", "Only ambient modules can use quoted names."),
        Statements_are_not_allowed_in_ambient_contexts: diag(1036, ts.DiagnosticCategory.Error, "Statements_are_not_allowed_in_ambient_contexts_1036", "Statements are not allowed in ambient contexts."),
        A_declare_modifier_cannot_be_used_in_an_already_ambient_context: diag(1038, ts.DiagnosticCategory.Error, "A_declare_modifier_cannot_be_used_in_an_already_ambient_context_1038", "A 'declare' modifier cannot be used in an already ambient context."),
        Initializers_are_not_allowed_in_ambient_contexts: diag(1039, ts.DiagnosticCategory.Error, "Initializers_are_not_allowed_in_ambient_contexts_1039", "Initializers are not allowed in ambient contexts."),
        _0_modifier_cannot_be_used_in_an_ambient_context: diag(1040, ts.DiagnosticCategory.Error, "_0_modifier_cannot_be_used_in_an_ambient_context_1040", "'{0}' modifier cannot be used in an ambient context."),
        _0_modifier_cannot_be_used_here: diag(1042, ts.DiagnosticCategory.Error, "_0_modifier_cannot_be_used_here_1042", "'{0}' modifier cannot be used here."),
        _0_modifier_cannot_appear_on_a_module_or_namespace_element: diag(1044, ts.DiagnosticCategory.Error, "_0_modifier_cannot_appear_on_a_module_or_namespace_element_1044", "'{0}' modifier cannot appear on a module or namespace element."),
        Top_level_declarations_in_d_ts_files_must_start_with_either_a_declare_or_export_modifier: diag(1046, ts.DiagnosticCategory.Error, "Top_level_declarations_in_d_ts_files_must_start_with_either_a_declare_or_export_modifier_1046", "Top-level declarations in .d.ts files must start with either a 'declare' or 'export' modifier."),
        A_rest_parameter_cannot_be_optional: diag(1047, ts.DiagnosticCategory.Error, "A_rest_parameter_cannot_be_optional_1047", "A rest parameter cannot be optional."),
        A_rest_parameter_cannot_have_an_initializer: diag(1048, ts.DiagnosticCategory.Error, "A_rest_parameter_cannot_have_an_initializer_1048", "A rest parameter cannot have an initializer."),
        A_set_accessor_must_have_exactly_one_parameter: diag(1049, ts.DiagnosticCategory.Error, "A_set_accessor_must_have_exactly_one_parameter_1049", "A 'set' accessor must have exactly one parameter."),
        A_set_accessor_cannot_have_an_optional_parameter: diag(1051, ts.DiagnosticCategory.Error, "A_set_accessor_cannot_have_an_optional_parameter_1051", "A 'set' accessor cannot have an optional parameter."),
        A_set_accessor_parameter_cannot_have_an_initializer: diag(1052, ts.DiagnosticCategory.Error, "A_set_accessor_parameter_cannot_have_an_initializer_1052", "A 'set' accessor parameter cannot have an initializer."),
        A_set_accessor_cannot_have_rest_parameter: diag(1053, ts.DiagnosticCategory.Error, "A_set_accessor_cannot_have_rest_parameter_1053", "A 'set' accessor cannot have rest parameter."),
        A_get_accessor_cannot_have_parameters: diag(1054, ts.DiagnosticCategory.Error, "A_get_accessor_cannot_have_parameters_1054", "A 'get' accessor cannot have parameters."),
        Type_0_is_not_a_valid_async_function_return_type_in_ES5_SlashES3_because_it_does_not_refer_to_a_Promise_compatible_constructor_value: diag(1055, ts.DiagnosticCategory.Error, "Type_0_is_not_a_valid_async_function_return_type_in_ES5_SlashES3_because_it_does_not_refer_to_a_Prom_1055", "Type '{0}' is not a valid async function return type in ES5/ES3 because it does not refer to a Promise-compatible constructor value."),
        Accessors_are_only_available_when_targeting_ECMAScript_5_and_higher: diag(1056, ts.DiagnosticCategory.Error, "Accessors_are_only_available_when_targeting_ECMAScript_5_and_higher_1056", "Accessors are only available when targeting ECMAScript 5 and higher."),
        The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member: diag(1058, ts.DiagnosticCategory.Error, "The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_t_1058", "The return type of an async function must either be a valid promise or must not contain a callable 'then' member."),
        A_promise_must_have_a_then_method: diag(1059, ts.DiagnosticCategory.Error, "A_promise_must_have_a_then_method_1059", "A promise must have a 'then' method."),
        The_first_parameter_of_the_then_method_of_a_promise_must_be_a_callback: diag(1060, ts.DiagnosticCategory.Error, "The_first_parameter_of_the_then_method_of_a_promise_must_be_a_callback_1060", "The first parameter of the 'then' method of a promise must be a callback."),
        Enum_member_must_have_initializer: diag(1061, ts.DiagnosticCategory.Error, "Enum_member_must_have_initializer_1061", "Enum member must have initializer."),
        Type_is_referenced_directly_or_indirectly_in_the_fulfillment_callback_of_its_own_then_method: diag(1062, ts.DiagnosticCategory.Error, "Type_is_referenced_directly_or_indirectly_in_the_fulfillment_callback_of_its_own_then_method_1062", "Type is referenced directly or indirectly in the fulfillment callback of its own 'then' method."),
        An_export_assignment_cannot_be_used_in_a_namespace: diag(1063, ts.DiagnosticCategory.Error, "An_export_assignment_cannot_be_used_in_a_namespace_1063", "An export assignment cannot be used in a namespace."),
        The_return_type_of_an_async_function_or_method_must_be_the_global_Promise_T_type_Did_you_mean_to_write_Promise_0: diag(1064, ts.DiagnosticCategory.Error, "The_return_type_of_an_async_function_or_method_must_be_the_global_Promise_T_type_Did_you_mean_to_wri_1064", "The return type of an async function or method must be the global Promise<T> type. Did you mean to write 'Promise<{0}>'?"),
        In_ambient_enum_declarations_member_initializer_must_be_constant_expression: diag(1066, ts.DiagnosticCategory.Error, "In_ambient_enum_declarations_member_initializer_must_be_constant_expression_1066", "In ambient enum declarations member initializer must be constant expression."),
        Unexpected_token_A_constructor_method_accessor_or_property_was_expected: diag(1068, ts.DiagnosticCategory.Error, "Unexpected_token_A_constructor_method_accessor_or_property_was_expected_1068", "Unexpected token. A constructor, method, accessor, or property was expected."),
        Unexpected_token_A_type_parameter_name_was_expected_without_curly_braces: diag(1069, ts.DiagnosticCategory.Error, "Unexpected_token_A_type_parameter_name_was_expected_without_curly_braces_1069", "Unexpected token. A type parameter name was expected without curly braces."),
        _0_modifier_cannot_appear_on_a_type_member: diag(1070, ts.DiagnosticCategory.Error, "_0_modifier_cannot_appear_on_a_type_member_1070", "'{0}' modifier cannot appear on a type member."),
        _0_modifier_cannot_appear_on_an_index_signature: diag(1071, ts.DiagnosticCategory.Error, "_0_modifier_cannot_appear_on_an_index_signature_1071", "'{0}' modifier cannot appear on an index signature."),
        A_0_modifier_cannot_be_used_with_an_import_declaration: diag(1079, ts.DiagnosticCategory.Error, "A_0_modifier_cannot_be_used_with_an_import_declaration_1079", "A '{0}' modifier cannot be used with an import declaration."),
        Invalid_reference_directive_syntax: diag(1084, ts.DiagnosticCategory.Error, "Invalid_reference_directive_syntax_1084", "Invalid 'reference' directive syntax."),
        Octal_literals_are_not_available_when_targeting_ECMAScript_5_and_higher_Use_the_syntax_0: diag(1085, ts.DiagnosticCategory.Error, "Octal_literals_are_not_available_when_targeting_ECMAScript_5_and_higher_Use_the_syntax_0_1085", "Octal literals are not available when targeting ECMAScript 5 and higher. Use the syntax '{0}'."),
        _0_modifier_cannot_appear_on_a_constructor_declaration: diag(1089, ts.DiagnosticCategory.Error, "_0_modifier_cannot_appear_on_a_constructor_declaration_1089", "'{0}' modifier cannot appear on a constructor declaration."),
        _0_modifier_cannot_appear_on_a_parameter: diag(1090, ts.DiagnosticCategory.Error, "_0_modifier_cannot_appear_on_a_parameter_1090", "'{0}' modifier cannot appear on a parameter."),
        Only_a_single_variable_declaration_is_allowed_in_a_for_in_statement: diag(1091, ts.DiagnosticCategory.Error, "Only_a_single_variable_declaration_is_allowed_in_a_for_in_statement_1091", "Only a single variable declaration is allowed in a 'for...in' statement."),
        Type_parameters_cannot_appear_on_a_constructor_declaration: diag(1092, ts.DiagnosticCategory.Error, "Type_parameters_cannot_appear_on_a_constructor_declaration_1092", "Type parameters cannot appear on a constructor declaration."),
        Type_annotation_cannot_appear_on_a_constructor_declaration: diag(1093, ts.DiagnosticCategory.Error, "Type_annotation_cannot_appear_on_a_constructor_declaration_1093", "Type annotation cannot appear on a constructor declaration."),
        An_accessor_cannot_have_type_parameters: diag(1094, ts.DiagnosticCategory.Error, "An_accessor_cannot_have_type_parameters_1094", "An accessor cannot have type parameters."),
        A_set_accessor_cannot_have_a_return_type_annotation: diag(1095, ts.DiagnosticCategory.Error, "A_set_accessor_cannot_have_a_return_type_annotation_1095", "A 'set' accessor cannot have a return type annotation."),
        An_index_signature_must_have_exactly_one_parameter: diag(1096, ts.DiagnosticCategory.Error, "An_index_signature_must_have_exactly_one_parameter_1096", "An index signature must have exactly one parameter."),
        _0_list_cannot_be_empty: diag(1097, ts.DiagnosticCategory.Error, "_0_list_cannot_be_empty_1097", "'{0}' list cannot be empty."),
        Type_parameter_list_cannot_be_empty: diag(1098, ts.DiagnosticCategory.Error, "Type_parameter_list_cannot_be_empty_1098", "Type parameter list cannot be empty."),
        Type_argument_list_cannot_be_empty: diag(1099, ts.DiagnosticCategory.Error, "Type_argument_list_cannot_be_empty_1099", "Type argument list cannot be empty."),
        Invalid_use_of_0_in_strict_mode: diag(1100, ts.DiagnosticCategory.Error, "Invalid_use_of_0_in_strict_mode_1100", "Invalid use of '{0}' in strict mode."),
        with_statements_are_not_allowed_in_strict_mode: diag(1101, ts.DiagnosticCategory.Error, "with_statements_are_not_allowed_in_strict_mode_1101", "'with' statements are not allowed in strict mode."),
        delete_cannot_be_called_on_an_identifier_in_strict_mode: diag(1102, ts.DiagnosticCategory.Error, "delete_cannot_be_called_on_an_identifier_in_strict_mode_1102", "'delete' cannot be called on an identifier in strict mode."),
        for_await_loops_are_only_allowed_within_async_functions_and_at_the_top_levels_of_modules: diag(1103, ts.DiagnosticCategory.Error, "for_await_loops_are_only_allowed_within_async_functions_and_at_the_top_levels_of_modules_1103", "'for await' loops are only allowed within async functions and at the top levels of modules."),
        A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement: diag(1104, ts.DiagnosticCategory.Error, "A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement_1104", "A 'continue' statement can only be used within an enclosing iteration statement."),
        A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement: diag(1105, ts.DiagnosticCategory.Error, "A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement_1105", "A 'break' statement can only be used within an enclosing iteration or switch statement."),
        The_left_hand_side_of_a_for_of_statement_may_not_be_async: diag(1106, ts.DiagnosticCategory.Error, "The_left_hand_side_of_a_for_of_statement_may_not_be_async_1106", "The left-hand side of a 'for...of' statement may not be 'async'."),
        Jump_target_cannot_cross_function_boundary: diag(1107, ts.DiagnosticCategory.Error, "Jump_target_cannot_cross_function_boundary_1107", "Jump target cannot cross function boundary."),
        A_return_statement_can_only_be_used_within_a_function_body: diag(1108, ts.DiagnosticCategory.Error, "A_return_statement_can_only_be_used_within_a_function_body_1108", "A 'return' statement can only be used within a function body."),
        Expression_expected: diag(1109, ts.DiagnosticCategory.Error, "Expression_expected_1109", "Expression expected."),
        Type_expected: diag(1110, ts.DiagnosticCategory.Error, "Type_expected_1110", "Type expected."),
        A_default_clause_cannot_appear_more_than_once_in_a_switch_statement: diag(1113, ts.DiagnosticCategory.Error, "A_default_clause_cannot_appear_more_than_once_in_a_switch_statement_1113", "A 'default' clause cannot appear more than once in a 'switch' statement."),
        Duplicate_label_0: diag(1114, ts.DiagnosticCategory.Error, "Duplicate_label_0_1114", "Duplicate label '{0}'."),
        A_continue_statement_can_only_jump_to_a_label_of_an_enclosing_iteration_statement: diag(1115, ts.DiagnosticCategory.Error, "A_continue_statement_can_only_jump_to_a_label_of_an_enclosing_iteration_statement_1115", "A 'continue' statement can only jump to a label of an enclosing iteration statement."),
        A_break_statement_can_only_jump_to_a_label_of_an_enclosing_statement: diag(1116, ts.DiagnosticCategory.Error, "A_break_statement_can_only_jump_to_a_label_of_an_enclosing_statement_1116", "A 'break' statement can only jump to a label of an enclosing statement."),
        An_object_literal_cannot_have_multiple_properties_with_the_same_name: diag(1117, ts.DiagnosticCategory.Error, "An_object_literal_cannot_have_multiple_properties_with_the_same_name_1117", "An object literal cannot have multiple properties with the same name."),
        An_object_literal_cannot_have_multiple_get_Slashset_accessors_with_the_same_name: diag(1118, ts.DiagnosticCategory.Error, "An_object_literal_cannot_have_multiple_get_Slashset_accessors_with_the_same_name_1118", "An object literal cannot have multiple get/set accessors with the same name."),
        An_object_literal_cannot_have_property_and_accessor_with_the_same_name: diag(1119, ts.DiagnosticCategory.Error, "An_object_literal_cannot_have_property_and_accessor_with_the_same_name_1119", "An object literal cannot have property and accessor with the same name."),
        An_export_assignment_cannot_have_modifiers: diag(1120, ts.DiagnosticCategory.Error, "An_export_assignment_cannot_have_modifiers_1120", "An export assignment cannot have modifiers."),
        Octal_literals_are_not_allowed_in_strict_mode: diag(1121, ts.DiagnosticCategory.Error, "Octal_literals_are_not_allowed_in_strict_mode_1121", "Octal literals are not allowed in strict mode."),
        Variable_declaration_list_cannot_be_empty: diag(1123, ts.DiagnosticCategory.Error, "Variable_declaration_list_cannot_be_empty_1123", "Variable declaration list cannot be empty."),
        Digit_expected: diag(1124, ts.DiagnosticCategory.Error, "Digit_expected_1124", "Digit expected."),
        Hexadecimal_digit_expected: diag(1125, ts.DiagnosticCategory.Error, "Hexadecimal_digit_expected_1125", "Hexadecimal digit expected."),
        Unexpected_end_of_text: diag(1126, ts.DiagnosticCategory.Error, "Unexpected_end_of_text_1126", "Unexpected end of text."),
        Invalid_character: diag(1127, ts.DiagnosticCategory.Error, "Invalid_character_1127", "Invalid character."),
        Declaration_or_statement_expected: diag(1128, ts.DiagnosticCategory.Error, "Declaration_or_statement_expected_1128", "Declaration or statement expected."),
        Statement_expected: diag(1129, ts.DiagnosticCategory.Error, "Statement_expected_1129", "Statement expected."),
        case_or_default_expected: diag(1130, ts.DiagnosticCategory.Error, "case_or_default_expected_1130", "'case' or 'default' expected."),
        Property_or_signature_expected: diag(1131, ts.DiagnosticCategory.Error, "Property_or_signature_expected_1131", "Property or signature expected."),
        Enum_member_expected: diag(1132, ts.DiagnosticCategory.Error, "Enum_member_expected_1132", "Enum member expected."),
        Variable_declaration_expected: diag(1134, ts.DiagnosticCategory.Error, "Variable_declaration_expected_1134", "Variable declaration expected."),
        Argument_expression_expected: diag(1135, ts.DiagnosticCategory.Error, "Argument_expression_expected_1135", "Argument expression expected."),
        Property_assignment_expected: diag(1136, ts.DiagnosticCategory.Error, "Property_assignment_expected_1136", "Property assignment expected."),
        Expression_or_comma_expected: diag(1137, ts.DiagnosticCategory.Error, "Expression_or_comma_expected_1137", "Expression or comma expected."),
        Parameter_declaration_expected: diag(1138, ts.DiagnosticCategory.Error, "Parameter_declaration_expected_1138", "Parameter declaration expected."),
        Type_parameter_declaration_expected: diag(1139, ts.DiagnosticCategory.Error, "Type_parameter_declaration_expected_1139", "Type parameter declaration expected."),
        Type_argument_expected: diag(1140, ts.DiagnosticCategory.Error, "Type_argument_expected_1140", "Type argument expected."),
        String_literal_expected: diag(1141, ts.DiagnosticCategory.Error, "String_literal_expected_1141", "String literal expected."),
        Line_break_not_permitted_here: diag(1142, ts.DiagnosticCategory.Error, "Line_break_not_permitted_here_1142", "Line break not permitted here."),
        or_expected: diag(1144, ts.DiagnosticCategory.Error, "or_expected_1144", "'{' or ';' expected."),
        Declaration_expected: diag(1146, ts.DiagnosticCategory.Error, "Declaration_expected_1146", "Declaration expected."),
        Import_declarations_in_a_namespace_cannot_reference_a_module: diag(1147, ts.DiagnosticCategory.Error, "Import_declarations_in_a_namespace_cannot_reference_a_module_1147", "Import declarations in a namespace cannot reference a module."),
        Cannot_use_imports_exports_or_module_augmentations_when_module_is_none: diag(1148, ts.DiagnosticCategory.Error, "Cannot_use_imports_exports_or_module_augmentations_when_module_is_none_1148", "Cannot use imports, exports, or module augmentations when '--module' is 'none'."),
        File_name_0_differs_from_already_included_file_name_1_only_in_casing: diag(1149, ts.DiagnosticCategory.Error, "File_name_0_differs_from_already_included_file_name_1_only_in_casing_1149", "File name '{0}' differs from already included file name '{1}' only in casing."),
        const_declarations_must_be_initialized: diag(1155, ts.DiagnosticCategory.Error, "const_declarations_must_be_initialized_1155", "'const' declarations must be initialized."),
        const_declarations_can_only_be_declared_inside_a_block: diag(1156, ts.DiagnosticCategory.Error, "const_declarations_can_only_be_declared_inside_a_block_1156", "'const' declarations can only be declared inside a block."),
        let_declarations_can_only_be_declared_inside_a_block: diag(1157, ts.DiagnosticCategory.Error, "let_declarations_can_only_be_declared_inside_a_block_1157", "'let' declarations can only be declared inside a block."),
        Unterminated_template_literal: diag(1160, ts.DiagnosticCategory.Error, "Unterminated_template_literal_1160", "Unterminated template literal."),
        Unterminated_regular_expression_literal: diag(1161, ts.DiagnosticCategory.Error, "Unterminated_regular_expression_literal_1161", "Unterminated regular expression literal."),
        An_object_member_cannot_be_declared_optional: diag(1162, ts.DiagnosticCategory.Error, "An_object_member_cannot_be_declared_optional_1162", "An object member cannot be declared optional."),
        A_yield_expression_is_only_allowed_in_a_generator_body: diag(1163, ts.DiagnosticCategory.Error, "A_yield_expression_is_only_allowed_in_a_generator_body_1163", "A 'yield' expression is only allowed in a generator body."),
        Computed_property_names_are_not_allowed_in_enums: diag(1164, ts.DiagnosticCategory.Error, "Computed_property_names_are_not_allowed_in_enums_1164", "Computed property names are not allowed in enums."),
        A_computed_property_name_in_an_ambient_context_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type: diag(1165, ts.DiagnosticCategory.Error, "A_computed_property_name_in_an_ambient_context_must_refer_to_an_expression_whose_type_is_a_literal_t_1165", "A computed property name in an ambient context must refer to an expression whose type is a literal type or a 'unique symbol' type."),
        A_computed_property_name_in_a_class_property_declaration_must_have_a_simple_literal_type_or_a_unique_symbol_type: diag(1166, ts.DiagnosticCategory.Error, "A_computed_property_name_in_a_class_property_declaration_must_have_a_simple_literal_type_or_a_unique_1166", "A computed property name in a class property declaration must have a simple literal type or a 'unique symbol' type."),
        A_computed_property_name_in_a_method_overload_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type: diag(1168, ts.DiagnosticCategory.Error, "A_computed_property_name_in_a_method_overload_must_refer_to_an_expression_whose_type_is_a_literal_ty_1168", "A computed property name in a method overload must refer to an expression whose type is a literal type or a 'unique symbol' type."),
        A_computed_property_name_in_an_interface_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type: diag(1169, ts.DiagnosticCategory.Error, "A_computed_property_name_in_an_interface_must_refer_to_an_expression_whose_type_is_a_literal_type_or_1169", "A computed property name in an interface must refer to an expression whose type is a literal type or a 'unique symbol' type."),
        A_computed_property_name_in_a_type_literal_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type: diag(1170, ts.DiagnosticCategory.Error, "A_computed_property_name_in_a_type_literal_must_refer_to_an_expression_whose_type_is_a_literal_type__1170", "A computed property name in a type literal must refer to an expression whose type is a literal type or a 'unique symbol' type."),
        A_comma_expression_is_not_allowed_in_a_computed_property_name: diag(1171, ts.DiagnosticCategory.Error, "A_comma_expression_is_not_allowed_in_a_computed_property_name_1171", "A comma expression is not allowed in a computed property name."),
        extends_clause_already_seen: diag(1172, ts.DiagnosticCategory.Error, "extends_clause_already_seen_1172", "'extends' clause already seen."),
        extends_clause_must_precede_implements_clause: diag(1173, ts.DiagnosticCategory.Error, "extends_clause_must_precede_implements_clause_1173", "'extends' clause must precede 'implements' clause."),
        Classes_can_only_extend_a_single_class: diag(1174, ts.DiagnosticCategory.Error, "Classes_can_only_extend_a_single_class_1174", "Classes can only extend a single class."),
        implements_clause_already_seen: diag(1175, ts.DiagnosticCategory.Error, "implements_clause_already_seen_1175", "'implements' clause already seen."),
        Interface_declaration_cannot_have_implements_clause: diag(1176, ts.DiagnosticCategory.Error, "Interface_declaration_cannot_have_implements_clause_1176", "Interface declaration cannot have 'implements' clause."),
        Binary_digit_expected: diag(1177, ts.DiagnosticCategory.Error, "Binary_digit_expected_1177", "Binary digit expected."),
        Octal_digit_expected: diag(1178, ts.DiagnosticCategory.Error, "Octal_digit_expected_1178", "Octal digit expected."),
        Unexpected_token_expected: diag(1179, ts.DiagnosticCategory.Error, "Unexpected_token_expected_1179", "Unexpected token. '{' expected."),
        Property_destructuring_pattern_expected: diag(1180, ts.DiagnosticCategory.Error, "Property_destructuring_pattern_expected_1180", "Property destructuring pattern expected."),
        Array_element_destructuring_pattern_expected: diag(1181, ts.DiagnosticCategory.Error, "Array_element_destructuring_pattern_expected_1181", "Array element destructuring pattern expected."),
        A_destructuring_declaration_must_have_an_initializer: diag(1182, ts.DiagnosticCategory.Error, "A_destructuring_declaration_must_have_an_initializer_1182", "A destructuring declaration must have an initializer."),
        An_implementation_cannot_be_declared_in_ambient_contexts: diag(1183, ts.DiagnosticCategory.Error, "An_implementation_cannot_be_declared_in_ambient_contexts_1183", "An implementation cannot be declared in ambient contexts."),
        Modifiers_cannot_appear_here: diag(1184, ts.DiagnosticCategory.Error, "Modifiers_cannot_appear_here_1184", "Modifiers cannot appear here."),
        Merge_conflict_marker_encountered: diag(1185, ts.DiagnosticCategory.Error, "Merge_conflict_marker_encountered_1185", "Merge conflict marker encountered."),
        A_rest_element_cannot_have_an_initializer: diag(1186, ts.DiagnosticCategory.Error, "A_rest_element_cannot_have_an_initializer_1186", "A rest element cannot have an initializer."),
        A_parameter_property_may_not_be_declared_using_a_binding_pattern: diag(1187, ts.DiagnosticCategory.Error, "A_parameter_property_may_not_be_declared_using_a_binding_pattern_1187", "A parameter property may not be declared using a binding pattern."),
        Only_a_single_variable_declaration_is_allowed_in_a_for_of_statement: diag(1188, ts.DiagnosticCategory.Error, "Only_a_single_variable_declaration_is_allowed_in_a_for_of_statement_1188", "Only a single variable declaration is allowed in a 'for...of' statement."),
        The_variable_declaration_of_a_for_in_statement_cannot_have_an_initializer: diag(1189, ts.DiagnosticCategory.Error, "The_variable_declaration_of_a_for_in_statement_cannot_have_an_initializer_1189", "The variable declaration of a 'for...in' statement cannot have an initializer."),
        The_variable_declaration_of_a_for_of_statement_cannot_have_an_initializer: diag(1190, ts.DiagnosticCategory.Error, "The_variable_declaration_of_a_for_of_statement_cannot_have_an_initializer_1190", "The variable declaration of a 'for...of' statement cannot have an initializer."),
        An_import_declaration_cannot_have_modifiers: diag(1191, ts.DiagnosticCategory.Error, "An_import_declaration_cannot_have_modifiers_1191", "An import declaration cannot have modifiers."),
        Module_0_has_no_default_export: diag(1192, ts.DiagnosticCategory.Error, "Module_0_has_no_default_export_1192", "Module '{0}' has no default export."),
        An_export_declaration_cannot_have_modifiers: diag(1193, ts.DiagnosticCategory.Error, "An_export_declaration_cannot_have_modifiers_1193", "An export declaration cannot have modifiers."),
        Export_declarations_are_not_permitted_in_a_namespace: diag(1194, ts.DiagnosticCategory.Error, "Export_declarations_are_not_permitted_in_a_namespace_1194", "Export declarations are not permitted in a namespace."),
        export_Asterisk_does_not_re_export_a_default: diag(1195, ts.DiagnosticCategory.Error, "export_Asterisk_does_not_re_export_a_default_1195", "'export *' does not re-export a default."),
        Catch_clause_variable_type_annotation_must_be_any_or_unknown_if_specified: diag(1196, ts.DiagnosticCategory.Error, "Catch_clause_variable_type_annotation_must_be_any_or_unknown_if_specified_1196", "Catch clause variable type annotation must be 'any' or 'unknown' if specified."),
        Catch_clause_variable_cannot_have_an_initializer: diag(1197, ts.DiagnosticCategory.Error, "Catch_clause_variable_cannot_have_an_initializer_1197", "Catch clause variable cannot have an initializer."),
        An_extended_Unicode_escape_value_must_be_between_0x0_and_0x10FFFF_inclusive: diag(1198, ts.DiagnosticCategory.Error, "An_extended_Unicode_escape_value_must_be_between_0x0_and_0x10FFFF_inclusive_1198", "An extended Unicode escape value must be between 0x0 and 0x10FFFF inclusive."),
        Unterminated_Unicode_escape_sequence: diag(1199, ts.DiagnosticCategory.Error, "Unterminated_Unicode_escape_sequence_1199", "Unterminated Unicode escape sequence."),
        Line_terminator_not_permitted_before_arrow: diag(1200, ts.DiagnosticCategory.Error, "Line_terminator_not_permitted_before_arrow_1200", "Line terminator not permitted before arrow."),
        Import_assignment_cannot_be_used_when_targeting_ECMAScript_modules_Consider_using_import_Asterisk_as_ns_from_mod_import_a_from_mod_import_d_from_mod_or_another_module_format_instead: diag(1202, ts.DiagnosticCategory.Error, "Import_assignment_cannot_be_used_when_targeting_ECMAScript_modules_Consider_using_import_Asterisk_as_1202", "Import assignment cannot be used when targeting ECMAScript modules. Consider using 'import * as ns from \"mod\"', 'import {a} from \"mod\"', 'import d from \"mod\"', or another module format instead."),
        Export_assignment_cannot_be_used_when_targeting_ECMAScript_modules_Consider_using_export_default_or_another_module_format_instead: diag(1203, ts.DiagnosticCategory.Error, "Export_assignment_cannot_be_used_when_targeting_ECMAScript_modules_Consider_using_export_default_or__1203", "Export assignment cannot be used when targeting ECMAScript modules. Consider using 'export default' or another module format instead."),
        Re_exporting_a_type_when_the_isolatedModules_flag_is_provided_requires_using_export_type: diag(1205, ts.DiagnosticCategory.Error, "Re_exporting_a_type_when_the_isolatedModules_flag_is_provided_requires_using_export_type_1205", "Re-exporting a type when the '--isolatedModules' flag is provided requires using 'export type'."),
        Decorators_are_not_valid_here: diag(1206, ts.DiagnosticCategory.Error, "Decorators_are_not_valid_here_1206", "Decorators are not valid here."),
        Decorators_cannot_be_applied_to_multiple_get_Slashset_accessors_of_the_same_name: diag(1207, ts.DiagnosticCategory.Error, "Decorators_cannot_be_applied_to_multiple_get_Slashset_accessors_of_the_same_name_1207", "Decorators cannot be applied to multiple get/set accessors of the same name."),
        _0_cannot_be_compiled_under_isolatedModules_because_it_is_considered_a_global_script_file_Add_an_import_export_or_an_empty_export_statement_to_make_it_a_module: diag(1208, ts.DiagnosticCategory.Error, "_0_cannot_be_compiled_under_isolatedModules_because_it_is_considered_a_global_script_file_Add_an_imp_1208", "'{0}' cannot be compiled under '--isolatedModules' because it is considered a global script file. Add an import, export, or an empty 'export {}' statement to make it a module."),
        Code_contained_in_a_class_is_evaluated_in_JavaScript_s_strict_mode_which_does_not_allow_this_use_of_0_For_more_information_see_https_Colon_Slash_Slashdeveloper_mozilla_org_Slashen_US_Slashdocs_SlashWeb_SlashJavaScript_SlashReference_SlashStrict_mode: diag(1210, ts.DiagnosticCategory.Error, "Code_contained_in_a_class_is_evaluated_in_JavaScript_s_strict_mode_which_does_not_allow_this_use_of__1210", "Code contained in a class is evaluated in JavaScript's strict mode which does not allow this use of '{0}'. For more information, see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode."),
        A_class_declaration_without_the_default_modifier_must_have_a_name: diag(1211, ts.DiagnosticCategory.Error, "A_class_declaration_without_the_default_modifier_must_have_a_name_1211", "A class declaration without the 'default' modifier must have a name."),
        Identifier_expected_0_is_a_reserved_word_in_strict_mode: diag(1212, ts.DiagnosticCategory.Error, "Identifier_expected_0_is_a_reserved_word_in_strict_mode_1212", "Identifier expected. '{0}' is a reserved word in strict mode."),
        Identifier_expected_0_is_a_reserved_word_in_strict_mode_Class_definitions_are_automatically_in_strict_mode: diag(1213, ts.DiagnosticCategory.Error, "Identifier_expected_0_is_a_reserved_word_in_strict_mode_Class_definitions_are_automatically_in_stric_1213", "Identifier expected. '{0}' is a reserved word in strict mode. Class definitions are automatically in strict mode."),
        Identifier_expected_0_is_a_reserved_word_in_strict_mode_Modules_are_automatically_in_strict_mode: diag(1214, ts.DiagnosticCategory.Error, "Identifier_expected_0_is_a_reserved_word_in_strict_mode_Modules_are_automatically_in_strict_mode_1214", "Identifier expected. '{0}' is a reserved word in strict mode. Modules are automatically in strict mode."),
        Invalid_use_of_0_Modules_are_automatically_in_strict_mode: diag(1215, ts.DiagnosticCategory.Error, "Invalid_use_of_0_Modules_are_automatically_in_strict_mode_1215", "Invalid use of '{0}'. Modules are automatically in strict mode."),
        Identifier_expected_esModule_is_reserved_as_an_exported_marker_when_transforming_ECMAScript_modules: diag(1216, ts.DiagnosticCategory.Error, "Identifier_expected_esModule_is_reserved_as_an_exported_marker_when_transforming_ECMAScript_modules_1216", "Identifier expected. '__esModule' is reserved as an exported marker when transforming ECMAScript modules."),
        Export_assignment_is_not_supported_when_module_flag_is_system: diag(1218, ts.DiagnosticCategory.Error, "Export_assignment_is_not_supported_when_module_flag_is_system_1218", "Export assignment is not supported when '--module' flag is 'system'."),
        Experimental_support_for_decorators_is_a_feature_that_is_subject_to_change_in_a_future_release_Set_the_experimentalDecorators_option_in_your_tsconfig_or_jsconfig_to_remove_this_warning: diag(1219, ts.DiagnosticCategory.Error, "Experimental_support_for_decorators_is_a_feature_that_is_subject_to_change_in_a_future_release_Set_t_1219", "Experimental support for decorators is a feature that is subject to change in a future release. Set the 'experimentalDecorators' option in your 'tsconfig' or 'jsconfig' to remove this warning."),
        Generators_are_not_allowed_in_an_ambient_context: diag(1221, ts.DiagnosticCategory.Error, "Generators_are_not_allowed_in_an_ambient_context_1221", "Generators are not allowed in an ambient context."),
        An_overload_signature_cannot_be_declared_as_a_generator: diag(1222, ts.DiagnosticCategory.Error, "An_overload_signature_cannot_be_declared_as_a_generator_1222", "An overload signature cannot be declared as a generator."),
        _0_tag_already_specified: diag(1223, ts.DiagnosticCategory.Error, "_0_tag_already_specified_1223", "'{0}' tag already specified."),
        Signature_0_must_be_a_type_predicate: diag(1224, ts.DiagnosticCategory.Error, "Signature_0_must_be_a_type_predicate_1224", "Signature '{0}' must be a type predicate."),
        Cannot_find_parameter_0: diag(1225, ts.DiagnosticCategory.Error, "Cannot_find_parameter_0_1225", "Cannot find parameter '{0}'."),
        Type_predicate_0_is_not_assignable_to_1: diag(1226, ts.DiagnosticCategory.Error, "Type_predicate_0_is_not_assignable_to_1_1226", "Type predicate '{0}' is not assignable to '{1}'."),
        Parameter_0_is_not_in_the_same_position_as_parameter_1: diag(1227, ts.DiagnosticCategory.Error, "Parameter_0_is_not_in_the_same_position_as_parameter_1_1227", "Parameter '{0}' is not in the same position as parameter '{1}'."),
        A_type_predicate_is_only_allowed_in_return_type_position_for_functions_and_methods: diag(1228, ts.DiagnosticCategory.Error, "A_type_predicate_is_only_allowed_in_return_type_position_for_functions_and_methods_1228", "A type predicate is only allowed in return type position for functions and methods."),
        A_type_predicate_cannot_reference_a_rest_parameter: diag(1229, ts.DiagnosticCategory.Error, "A_type_predicate_cannot_reference_a_rest_parameter_1229", "A type predicate cannot reference a rest parameter."),
        A_type_predicate_cannot_reference_element_0_in_a_binding_pattern: diag(1230, ts.DiagnosticCategory.Error, "A_type_predicate_cannot_reference_element_0_in_a_binding_pattern_1230", "A type predicate cannot reference element '{0}' in a binding pattern."),
        An_export_assignment_must_be_at_the_top_level_of_a_file_or_module_declaration: diag(1231, ts.DiagnosticCategory.Error, "An_export_assignment_must_be_at_the_top_level_of_a_file_or_module_declaration_1231", "An export assignment must be at the top level of a file or module declaration."),
        An_import_declaration_can_only_be_used_at_the_top_level_of_a_namespace_or_module: diag(1232, ts.DiagnosticCategory.Error, "An_import_declaration_can_only_be_used_at_the_top_level_of_a_namespace_or_module_1232", "An import declaration can only be used at the top level of a namespace or module."),
        An_export_declaration_can_only_be_used_at_the_top_level_of_a_namespace_or_module: diag(1233, ts.DiagnosticCategory.Error, "An_export_declaration_can_only_be_used_at_the_top_level_of_a_namespace_or_module_1233", "An export declaration can only be used at the top level of a namespace or module."),
        An_ambient_module_declaration_is_only_allowed_at_the_top_level_in_a_file: diag(1234, ts.DiagnosticCategory.Error, "An_ambient_module_declaration_is_only_allowed_at_the_top_level_in_a_file_1234", "An ambient module declaration is only allowed at the top level in a file."),
        A_namespace_declaration_is_only_allowed_at_the_top_level_of_a_namespace_or_module: diag(1235, ts.DiagnosticCategory.Error, "A_namespace_declaration_is_only_allowed_at_the_top_level_of_a_namespace_or_module_1235", "A namespace declaration is only allowed at the top level of a namespace or module."),
        The_return_type_of_a_property_decorator_function_must_be_either_void_or_any: diag(1236, ts.DiagnosticCategory.Error, "The_return_type_of_a_property_decorator_function_must_be_either_void_or_any_1236", "The return type of a property decorator function must be either 'void' or 'any'."),
        The_return_type_of_a_parameter_decorator_function_must_be_either_void_or_any: diag(1237, ts.DiagnosticCategory.Error, "The_return_type_of_a_parameter_decorator_function_must_be_either_void_or_any_1237", "The return type of a parameter decorator function must be either 'void' or 'any'."),
        Unable_to_resolve_signature_of_class_decorator_when_called_as_an_expression: diag(1238, ts.DiagnosticCategory.Error, "Unable_to_resolve_signature_of_class_decorator_when_called_as_an_expression_1238", "Unable to resolve signature of class decorator when called as an expression."),
        Unable_to_resolve_signature_of_parameter_decorator_when_called_as_an_expression: diag(1239, ts.DiagnosticCategory.Error, "Unable_to_resolve_signature_of_parameter_decorator_when_called_as_an_expression_1239", "Unable to resolve signature of parameter decorator when called as an expression."),
        Unable_to_resolve_signature_of_property_decorator_when_called_as_an_expression: diag(1240, ts.DiagnosticCategory.Error, "Unable_to_resolve_signature_of_property_decorator_when_called_as_an_expression_1240", "Unable to resolve signature of property decorator when called as an expression."),
        Unable_to_resolve_signature_of_method_decorator_when_called_as_an_expression: diag(1241, ts.DiagnosticCategory.Error, "Unable_to_resolve_signature_of_method_decorator_when_called_as_an_expression_1241", "Unable to resolve signature of method decorator when called as an expression."),
        abstract_modifier_can_only_appear_on_a_class_method_or_property_declaration: diag(1242, ts.DiagnosticCategory.Error, "abstract_modifier_can_only_appear_on_a_class_method_or_property_declaration_1242", "'abstract' modifier can only appear on a class, method, or property declaration."),
        _0_modifier_cannot_be_used_with_1_modifier: diag(1243, ts.DiagnosticCategory.Error, "_0_modifier_cannot_be_used_with_1_modifier_1243", "'{0}' modifier cannot be used with '{1}' modifier."),
        Abstract_methods_can_only_appear_within_an_abstract_class: diag(1244, ts.DiagnosticCategory.Error, "Abstract_methods_can_only_appear_within_an_abstract_class_1244", "Abstract methods can only appear within an abstract class."),
        Method_0_cannot_have_an_implementation_because_it_is_marked_abstract: diag(1245, ts.DiagnosticCategory.Error, "Method_0_cannot_have_an_implementation_because_it_is_marked_abstract_1245", "Method '{0}' cannot have an implementation because it is marked abstract."),
        An_interface_property_cannot_have_an_initializer: diag(1246, ts.DiagnosticCategory.Error, "An_interface_property_cannot_have_an_initializer_1246", "An interface property cannot have an initializer."),
        A_type_literal_property_cannot_have_an_initializer: diag(1247, ts.DiagnosticCategory.Error, "A_type_literal_property_cannot_have_an_initializer_1247", "A type literal property cannot have an initializer."),
        A_class_member_cannot_have_the_0_keyword: diag(1248, ts.DiagnosticCategory.Error, "A_class_member_cannot_have_the_0_keyword_1248", "A class member cannot have the '{0}' keyword."),
        A_decorator_can_only_decorate_a_method_implementation_not_an_overload: diag(1249, ts.DiagnosticCategory.Error, "A_decorator_can_only_decorate_a_method_implementation_not_an_overload_1249", "A decorator can only decorate a method implementation, not an overload."),
        Function_declarations_are_not_allowed_inside_blocks_in_strict_mode_when_targeting_ES3_or_ES5: diag(1250, ts.DiagnosticCategory.Error, "Function_declarations_are_not_allowed_inside_blocks_in_strict_mode_when_targeting_ES3_or_ES5_1250", "Function declarations are not allowed inside blocks in strict mode when targeting 'ES3' or 'ES5'."),
        Function_declarations_are_not_allowed_inside_blocks_in_strict_mode_when_targeting_ES3_or_ES5_Class_definitions_are_automatically_in_strict_mode: diag(1251, ts.DiagnosticCategory.Error, "Function_declarations_are_not_allowed_inside_blocks_in_strict_mode_when_targeting_ES3_or_ES5_Class_d_1251", "Function declarations are not allowed inside blocks in strict mode when targeting 'ES3' or 'ES5'. Class definitions are automatically in strict mode."),
        Function_declarations_are_not_allowed_inside_blocks_in_strict_mode_when_targeting_ES3_or_ES5_Modules_are_automatically_in_strict_mode: diag(1252, ts.DiagnosticCategory.Error, "Function_declarations_are_not_allowed_inside_blocks_in_strict_mode_when_targeting_ES3_or_ES5_Modules_1252", "Function declarations are not allowed inside blocks in strict mode when targeting 'ES3' or 'ES5'. Modules are automatically in strict mode."),
        A_const_initializer_in_an_ambient_context_must_be_a_string_or_numeric_literal_or_literal_enum_reference: diag(1254, ts.DiagnosticCategory.Error, "A_const_initializer_in_an_ambient_context_must_be_a_string_or_numeric_literal_or_literal_enum_refere_1254", "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference."),
        A_definite_assignment_assertion_is_not_permitted_in_this_context: diag(1255, ts.DiagnosticCategory.Error, "A_definite_assignment_assertion_is_not_permitted_in_this_context_1255", "A definite assignment assertion '!' is not permitted in this context."),
        A_required_element_cannot_follow_an_optional_element: diag(1257, ts.DiagnosticCategory.Error, "A_required_element_cannot_follow_an_optional_element_1257", "A required element cannot follow an optional element."),
        A_default_export_must_be_at_the_top_level_of_a_file_or_module_declaration: diag(1258, ts.DiagnosticCategory.Error, "A_default_export_must_be_at_the_top_level_of_a_file_or_module_declaration_1258", "A default export must be at the top level of a file or module declaration."),
        Module_0_can_only_be_default_imported_using_the_1_flag: diag(1259, ts.DiagnosticCategory.Error, "Module_0_can_only_be_default_imported_using_the_1_flag_1259", "Module '{0}' can only be default-imported using the '{1}' flag"),
        Keywords_cannot_contain_escape_characters: diag(1260, ts.DiagnosticCategory.Error, "Keywords_cannot_contain_escape_characters_1260", "Keywords cannot contain escape characters."),
        Already_included_file_name_0_differs_from_file_name_1_only_in_casing: diag(1261, ts.DiagnosticCategory.Error, "Already_included_file_name_0_differs_from_file_name_1_only_in_casing_1261", "Already included file name '{0}' differs from file name '{1}' only in casing."),
        Identifier_expected_0_is_a_reserved_word_at_the_top_level_of_a_module: diag(1262, ts.DiagnosticCategory.Error, "Identifier_expected_0_is_a_reserved_word_at_the_top_level_of_a_module_1262", "Identifier expected. '{0}' is a reserved word at the top-level of a module."),
        Declarations_with_initializers_cannot_also_have_definite_assignment_assertions: diag(1263, ts.DiagnosticCategory.Error, "Declarations_with_initializers_cannot_also_have_definite_assignment_assertions_1263", "Declarations with initializers cannot also have definite assignment assertions."),
        Declarations_with_definite_assignment_assertions_must_also_have_type_annotations: diag(1264, ts.DiagnosticCategory.Error, "Declarations_with_definite_assignment_assertions_must_also_have_type_annotations_1264", "Declarations with definite assignment assertions must also have type annotations."),
        A_rest_element_cannot_follow_another_rest_element: diag(1265, ts.DiagnosticCategory.Error, "A_rest_element_cannot_follow_another_rest_element_1265", "A rest element cannot follow another rest element."),
        An_optional_element_cannot_follow_a_rest_element: diag(1266, ts.DiagnosticCategory.Error, "An_optional_element_cannot_follow_a_rest_element_1266", "An optional element cannot follow a rest element."),
        Property_0_cannot_have_an_initializer_because_it_is_marked_abstract: diag(1267, ts.DiagnosticCategory.Error, "Property_0_cannot_have_an_initializer_because_it_is_marked_abstract_1267", "Property '{0}' cannot have an initializer because it is marked abstract."),
        An_index_signature_parameter_type_must_be_string_number_symbol_or_a_template_literal_type: diag(1268, ts.DiagnosticCategory.Error, "An_index_signature_parameter_type_must_be_string_number_symbol_or_a_template_literal_type_1268", "An index signature parameter type must be 'string', 'number', 'symbol', or a template literal type."),
        Cannot_use_export_import_on_a_type_or_type_only_namespace_when_the_isolatedModules_flag_is_provided: diag(1269, ts.DiagnosticCategory.Error, "Cannot_use_export_import_on_a_type_or_type_only_namespace_when_the_isolatedModules_flag_is_provided_1269", "Cannot use 'export import' on a type or type-only namespace when the '--isolatedModules' flag is provided."),
        Decorator_function_return_type_0_is_not_assignable_to_type_1: diag(1270, ts.DiagnosticCategory.Error, "Decorator_function_return_type_0_is_not_assignable_to_type_1_1270", "Decorator function return type '{0}' is not assignable to type '{1}'."),
        Decorator_function_return_type_is_0_but_is_expected_to_be_void_or_any: diag(1271, ts.DiagnosticCategory.Error, "Decorator_function_return_type_is_0_but_is_expected_to_be_void_or_any_1271", "Decorator function return type is '{0}' but is expected to be 'void' or 'any'."),
        A_type_referenced_in_a_decorated_signature_must_be_imported_with_import_type_or_a_namespace_import_when_isolatedModules_and_emitDecoratorMetadata_are_enabled: diag(1272, ts.DiagnosticCategory.Error, "A_type_referenced_in_a_decorated_signature_must_be_imported_with_import_type_or_a_namespace_import_w_1272", "A type referenced in a decorated signature must be imported with 'import type' or a namespace import when 'isolatedModules' and 'emitDecoratorMetadata' are enabled."),
        _0_modifier_cannot_appear_on_a_type_parameter: diag(1273, ts.DiagnosticCategory.Error, "_0_modifier_cannot_appear_on_a_type_parameter_1273", "'{0}' modifier cannot appear on a type parameter"),
        _0_modifier_can_only_appear_on_a_type_parameter_of_a_class_interface_or_type_alias: diag(1274, ts.DiagnosticCategory.Error, "_0_modifier_can_only_appear_on_a_type_parameter_of_a_class_interface_or_type_alias_1274", "'{0}' modifier can only appear on a type parameter of a class, interface or type alias"),
        with_statements_are_not_allowed_in_an_async_function_block: diag(1300, ts.DiagnosticCategory.Error, "with_statements_are_not_allowed_in_an_async_function_block_1300", "'with' statements are not allowed in an async function block."),
        await_expressions_are_only_allowed_within_async_functions_and_at_the_top_levels_of_modules: diag(1308, ts.DiagnosticCategory.Error, "await_expressions_are_only_allowed_within_async_functions_and_at_the_top_levels_of_modules_1308", "'await' expressions are only allowed within async functions and at the top levels of modules."),
        The_current_file_is_a_CommonJS_module_and_cannot_use_await_at_the_top_level: diag(1309, ts.DiagnosticCategory.Error, "The_current_file_is_a_CommonJS_module_and_cannot_use_await_at_the_top_level_1309", "The current file is a CommonJS module and cannot use 'await' at the top level."),
        Did_you_mean_to_use_a_Colon_An_can_only_follow_a_property_name_when_the_containing_object_literal_is_part_of_a_destructuring_pattern: diag(1312, ts.DiagnosticCategory.Error, "Did_you_mean_to_use_a_Colon_An_can_only_follow_a_property_name_when_the_containing_object_literal_is_1312", "Did you mean to use a ':'? An '=' can only follow a property name when the containing object literal is part of a destructuring pattern."),
        The_body_of_an_if_statement_cannot_be_the_empty_statement: diag(1313, ts.DiagnosticCategory.Error, "The_body_of_an_if_statement_cannot_be_the_empty_statement_1313", "The body of an 'if' statement cannot be the empty statement."),
        Global_module_exports_may_only_appear_in_module_files: diag(1314, ts.DiagnosticCategory.Error, "Global_module_exports_may_only_appear_in_module_files_1314", "Global module exports may only appear in module files."),
        Global_module_exports_may_only_appear_in_declaration_files: diag(1315, ts.DiagnosticCategory.Error, "Global_module_exports_may_only_appear_in_declaration_files_1315", "Global module exports may only appear in declaration files."),
        Global_module_exports_may_only_appear_at_top_level: diag(1316, ts.DiagnosticCategory.Error, "Global_module_exports_may_only_appear_at_top_level_1316", "Global module exports may only appear at top level."),
        A_parameter_property_cannot_be_declared_using_a_rest_parameter: diag(1317, ts.DiagnosticCategory.Error, "A_parameter_property_cannot_be_declared_using_a_rest_parameter_1317", "A parameter property cannot be declared using a rest parameter."),
        An_abstract_accessor_cannot_have_an_implementation: diag(1318, ts.DiagnosticCategory.Error, "An_abstract_accessor_cannot_have_an_implementation_1318", "An abstract accessor cannot have an implementation."),
        A_default_export_can_only_be_used_in_an_ECMAScript_style_module: diag(1319, ts.DiagnosticCategory.Error, "A_default_export_can_only_be_used_in_an_ECMAScript_style_module_1319", "A default export can only be used in an ECMAScript-style module."),
        Type_of_await_operand_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member: diag(1320, ts.DiagnosticCategory.Error, "Type_of_await_operand_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member_1320", "Type of 'await' operand must either be a valid promise or must not contain a callable 'then' member."),
        Type_of_yield_operand_in_an_async_generator_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member: diag(1321, ts.DiagnosticCategory.Error, "Type_of_yield_operand_in_an_async_generator_must_either_be_a_valid_promise_or_must_not_contain_a_cal_1321", "Type of 'yield' operand in an async generator must either be a valid promise or must not contain a callable 'then' member."),
        Type_of_iterated_elements_of_a_yield_Asterisk_operand_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member: diag(1322, ts.DiagnosticCategory.Error, "Type_of_iterated_elements_of_a_yield_Asterisk_operand_must_either_be_a_valid_promise_or_must_not_con_1322", "Type of iterated elements of a 'yield*' operand must either be a valid promise or must not contain a callable 'then' member."),
        Dynamic_imports_are_only_supported_when_the_module_flag_is_set_to_es2020_es2022_esnext_commonjs_amd_system_umd_node16_or_nodenext: diag(1323, ts.DiagnosticCategory.Error, "Dynamic_imports_are_only_supported_when_the_module_flag_is_set_to_es2020_es2022_esnext_commonjs_amd__1323", "Dynamic imports are only supported when the '--module' flag is set to 'es2020', 'es2022', 'esnext', 'commonjs', 'amd', 'system', 'umd', 'node16', or 'nodenext'."),
        Dynamic_imports_only_support_a_second_argument_when_the_module_option_is_set_to_esnext_node16_or_nodenext: diag(1324, ts.DiagnosticCategory.Error, "Dynamic_imports_only_support_a_second_argument_when_the_module_option_is_set_to_esnext_node16_or_nod_1324", "Dynamic imports only support a second argument when the '--module' option is set to 'esnext', 'node16', or 'nodenext'."),
        Argument_of_dynamic_import_cannot_be_spread_element: diag(1325, ts.DiagnosticCategory.Error, "Argument_of_dynamic_import_cannot_be_spread_element_1325", "Argument of dynamic import cannot be spread element."),
        This_use_of_import_is_invalid_import_calls_can_be_written_but_they_must_have_parentheses_and_cannot_have_type_arguments: diag(1326, ts.DiagnosticCategory.Error, "This_use_of_import_is_invalid_import_calls_can_be_written_but_they_must_have_parentheses_and_cannot__1326", "This use of 'import' is invalid. 'import()' calls can be written, but they must have parentheses and cannot have type arguments."),
        String_literal_with_double_quotes_expected: diag(1327, ts.DiagnosticCategory.Error, "String_literal_with_double_quotes_expected_1327", "String literal with double quotes expected."),
        Property_value_can_only_be_string_literal_numeric_literal_true_false_null_object_literal_or_array_literal: diag(1328, ts.DiagnosticCategory.Error, "Property_value_can_only_be_string_literal_numeric_literal_true_false_null_object_literal_or_array_li_1328", "Property value can only be string literal, numeric literal, 'true', 'false', 'null', object literal or array literal."),
        _0_accepts_too_few_arguments_to_be_used_as_a_decorator_here_Did_you_mean_to_call_it_first_and_write_0: diag(1329, ts.DiagnosticCategory.Error, "_0_accepts_too_few_arguments_to_be_used_as_a_decorator_here_Did_you_mean_to_call_it_first_and_write__1329", "'{0}' accepts too few arguments to be used as a decorator here. Did you mean to call it first and write '@{0}()'?"),
        A_property_of_an_interface_or_type_literal_whose_type_is_a_unique_symbol_type_must_be_readonly: diag(1330, ts.DiagnosticCategory.Error, "A_property_of_an_interface_or_type_literal_whose_type_is_a_unique_symbol_type_must_be_readonly_1330", "A property of an interface or type literal whose type is a 'unique symbol' type must be 'readonly'."),
        A_property_of_a_class_whose_type_is_a_unique_symbol_type_must_be_both_static_and_readonly: diag(1331, ts.DiagnosticCategory.Error, "A_property_of_a_class_whose_type_is_a_unique_symbol_type_must_be_both_static_and_readonly_1331", "A property of a class whose type is a 'unique symbol' type must be both 'static' and 'readonly'."),
        A_variable_whose_type_is_a_unique_symbol_type_must_be_const: diag(1332, ts.DiagnosticCategory.Error, "A_variable_whose_type_is_a_unique_symbol_type_must_be_const_1332", "A variable whose type is a 'unique symbol' type must be 'const'."),
        unique_symbol_types_may_not_be_used_on_a_variable_declaration_with_a_binding_name: diag(1333, ts.DiagnosticCategory.Error, "unique_symbol_types_may_not_be_used_on_a_variable_declaration_with_a_binding_name_1333", "'unique symbol' types may not be used on a variable declaration with a binding name."),
        unique_symbol_types_are_only_allowed_on_variables_in_a_variable_statement: diag(1334, ts.DiagnosticCategory.Error, "unique_symbol_types_are_only_allowed_on_variables_in_a_variable_statement_1334", "'unique symbol' types are only allowed on variables in a variable statement."),
        unique_symbol_types_are_not_allowed_here: diag(1335, ts.DiagnosticCategory.Error, "unique_symbol_types_are_not_allowed_here_1335", "'unique symbol' types are not allowed here."),
        An_index_signature_parameter_type_cannot_be_a_literal_type_or_generic_type_Consider_using_a_mapped_object_type_instead: diag(1337, ts.DiagnosticCategory.Error, "An_index_signature_parameter_type_cannot_be_a_literal_type_or_generic_type_Consider_using_a_mapped_o_1337", "An index signature parameter type cannot be a literal type or generic type. Consider using a mapped object type instead."),
        infer_declarations_are_only_permitted_in_the_extends_clause_of_a_conditional_type: diag(1338, ts.DiagnosticCategory.Error, "infer_declarations_are_only_permitted_in_the_extends_clause_of_a_conditional_type_1338", "'infer' declarations are only permitted in the 'extends' clause of a conditional type."),
        Module_0_does_not_refer_to_a_value_but_is_used_as_a_value_here: diag(1339, ts.DiagnosticCategory.Error, "Module_0_does_not_refer_to_a_value_but_is_used_as_a_value_here_1339", "Module '{0}' does not refer to a value, but is used as a value here."),
        Module_0_does_not_refer_to_a_type_but_is_used_as_a_type_here_Did_you_mean_typeof_import_0: diag(1340, ts.DiagnosticCategory.Error, "Module_0_does_not_refer_to_a_type_but_is_used_as_a_type_here_Did_you_mean_typeof_import_0_1340", "Module '{0}' does not refer to a type, but is used as a type here. Did you mean 'typeof import('{0}')'?"),
        Type_arguments_cannot_be_used_here: diag(1342, ts.DiagnosticCategory.Error, "Type_arguments_cannot_be_used_here_1342", "Type arguments cannot be used here."),
        The_import_meta_meta_property_is_only_allowed_when_the_module_option_is_es2020_es2022_esnext_system_node16_or_nodenext: diag(1343, ts.DiagnosticCategory.Error, "The_import_meta_meta_property_is_only_allowed_when_the_module_option_is_es2020_es2022_esnext_system__1343", "The 'import.meta' meta-property is only allowed when the '--module' option is 'es2020', 'es2022', 'esnext', 'system', 'node16', or 'nodenext'."),
        A_label_is_not_allowed_here: diag(1344, ts.DiagnosticCategory.Error, "A_label_is_not_allowed_here_1344", "'A label is not allowed here."),
        An_expression_of_type_void_cannot_be_tested_for_truthiness: diag(1345, ts.DiagnosticCategory.Error, "An_expression_of_type_void_cannot_be_tested_for_truthiness_1345", "An expression of type 'void' cannot be tested for truthiness."),
        This_parameter_is_not_allowed_with_use_strict_directive: diag(1346, ts.DiagnosticCategory.Error, "This_parameter_is_not_allowed_with_use_strict_directive_1346", "This parameter is not allowed with 'use strict' directive."),
        use_strict_directive_cannot_be_used_with_non_simple_parameter_list: diag(1347, ts.DiagnosticCategory.Error, "use_strict_directive_cannot_be_used_with_non_simple_parameter_list_1347", "'use strict' directive cannot be used with non-simple parameter list."),
        Non_simple_parameter_declared_here: diag(1348, ts.DiagnosticCategory.Error, "Non_simple_parameter_declared_here_1348", "Non-simple parameter declared here."),
        use_strict_directive_used_here: diag(1349, ts.DiagnosticCategory.Error, "use_strict_directive_used_here_1349", "'use strict' directive used here."),
        Print_the_final_configuration_instead_of_building: diag(1350, ts.DiagnosticCategory.Message, "Print_the_final_configuration_instead_of_building_1350", "Print the final configuration instead of building."),
        An_identifier_or_keyword_cannot_immediately_follow_a_numeric_literal: diag(1351, ts.DiagnosticCategory.Error, "An_identifier_or_keyword_cannot_immediately_follow_a_numeric_literal_1351", "An identifier or keyword cannot immediately follow a numeric literal."),
        A_bigint_literal_cannot_use_exponential_notation: diag(1352, ts.DiagnosticCategory.Error, "A_bigint_literal_cannot_use_exponential_notation_1352", "A bigint literal cannot use exponential notation."),
        A_bigint_literal_must_be_an_integer: diag(1353, ts.DiagnosticCategory.Error, "A_bigint_literal_must_be_an_integer_1353", "A bigint literal must be an integer."),
        readonly_type_modifier_is_only_permitted_on_array_and_tuple_literal_types: diag(1354, ts.DiagnosticCategory.Error, "readonly_type_modifier_is_only_permitted_on_array_and_tuple_literal_types_1354", "'readonly' type modifier is only permitted on array and tuple literal types."),
        A_const_assertions_can_only_be_applied_to_references_to_enum_members_or_string_number_boolean_array_or_object_literals: diag(1355, ts.DiagnosticCategory.Error, "A_const_assertions_can_only_be_applied_to_references_to_enum_members_or_string_number_boolean_array__1355", "A 'const' assertions can only be applied to references to enum members, or string, number, boolean, array, or object literals."),
        Did_you_mean_to_mark_this_function_as_async: diag(1356, ts.DiagnosticCategory.Error, "Did_you_mean_to_mark_this_function_as_async_1356", "Did you mean to mark this function as 'async'?"),
        An_enum_member_name_must_be_followed_by_a_or: diag(1357, ts.DiagnosticCategory.Error, "An_enum_member_name_must_be_followed_by_a_or_1357", "An enum member name must be followed by a ',', '=', or '}'."),
        Tagged_template_expressions_are_not_permitted_in_an_optional_chain: diag(1358, ts.DiagnosticCategory.Error, "Tagged_template_expressions_are_not_permitted_in_an_optional_chain_1358", "Tagged template expressions are not permitted in an optional chain."),
        Identifier_expected_0_is_a_reserved_word_that_cannot_be_used_here: diag(1359, ts.DiagnosticCategory.Error, "Identifier_expected_0_is_a_reserved_word_that_cannot_be_used_here_1359", "Identifier expected. '{0}' is a reserved word that cannot be used here."),
        _0_cannot_be_used_as_a_value_because_it_was_imported_using_import_type: diag(1361, ts.DiagnosticCategory.Error, "_0_cannot_be_used_as_a_value_because_it_was_imported_using_import_type_1361", "'{0}' cannot be used as a value because it was imported using 'import type'."),
        _0_cannot_be_used_as_a_value_because_it_was_exported_using_export_type: diag(1362, ts.DiagnosticCategory.Error, "_0_cannot_be_used_as_a_value_because_it_was_exported_using_export_type_1362", "'{0}' cannot be used as a value because it was exported using 'export type'."),
        A_type_only_import_can_specify_a_default_import_or_named_bindings_but_not_both: diag(1363, ts.DiagnosticCategory.Error, "A_type_only_import_can_specify_a_default_import_or_named_bindings_but_not_both_1363", "A type-only import can specify a default import or named bindings, but not both."),
        Convert_to_type_only_export: diag(1364, ts.DiagnosticCategory.Message, "Convert_to_type_only_export_1364", "Convert to type-only export"),
        Convert_all_re_exported_types_to_type_only_exports: diag(1365, ts.DiagnosticCategory.Message, "Convert_all_re_exported_types_to_type_only_exports_1365", "Convert all re-exported types to type-only exports"),
        Split_into_two_separate_import_declarations: diag(1366, ts.DiagnosticCategory.Message, "Split_into_two_separate_import_declarations_1366", "Split into two separate import declarations"),
        Split_all_invalid_type_only_imports: diag(1367, ts.DiagnosticCategory.Message, "Split_all_invalid_type_only_imports_1367", "Split all invalid type-only imports"),
        Did_you_mean_0: diag(1369, ts.DiagnosticCategory.Message, "Did_you_mean_0_1369", "Did you mean '{0}'?"),
        This_import_is_never_used_as_a_value_and_must_use_import_type_because_importsNotUsedAsValues_is_set_to_error: diag(1371, ts.DiagnosticCategory.Error, "This_import_is_never_used_as_a_value_and_must_use_import_type_because_importsNotUsedAsValues_is_set__1371", "This import is never used as a value and must use 'import type' because 'importsNotUsedAsValues' is set to 'error'."),
        Convert_to_type_only_import: diag(1373, ts.DiagnosticCategory.Message, "Convert_to_type_only_import_1373", "Convert to type-only import"),
        Convert_all_imports_not_used_as_a_value_to_type_only_imports: diag(1374, ts.DiagnosticCategory.Message, "Convert_all_imports_not_used_as_a_value_to_type_only_imports_1374", "Convert all imports not used as a value to type-only imports"),
        await_expressions_are_only_allowed_at_the_top_level_of_a_file_when_that_file_is_a_module_but_this_file_has_no_imports_or_exports_Consider_adding_an_empty_export_to_make_this_file_a_module: diag(1375, ts.DiagnosticCategory.Error, "await_expressions_are_only_allowed_at_the_top_level_of_a_file_when_that_file_is_a_module_but_this_fi_1375", "'await' expressions are only allowed at the top level of a file when that file is a module, but this file has no imports or exports. Consider adding an empty 'export {}' to make this file a module."),
        _0_was_imported_here: diag(1376, ts.DiagnosticCategory.Message, "_0_was_imported_here_1376", "'{0}' was imported here."),
        _0_was_exported_here: diag(1377, ts.DiagnosticCategory.Message, "_0_was_exported_here_1377", "'{0}' was exported here."),
        Top_level_await_expressions_are_only_allowed_when_the_module_option_is_set_to_es2022_esnext_system_node16_or_nodenext_and_the_target_option_is_set_to_es2017_or_higher: diag(1378, ts.DiagnosticCategory.Error, "Top_level_await_expressions_are_only_allowed_when_the_module_option_is_set_to_es2022_esnext_system_n_1378", "Top-level 'await' expressions are only allowed when the 'module' option is set to 'es2022', 'esnext', 'system', 'node16', or 'nodenext', and the 'target' option is set to 'es2017' or higher."),
        An_import_alias_cannot_reference_a_declaration_that_was_exported_using_export_type: diag(1379, ts.DiagnosticCategory.Error, "An_import_alias_cannot_reference_a_declaration_that_was_exported_using_export_type_1379", "An import alias cannot reference a declaration that was exported using 'export type'."),
        An_import_alias_cannot_reference_a_declaration_that_was_imported_using_import_type: diag(1380, ts.DiagnosticCategory.Error, "An_import_alias_cannot_reference_a_declaration_that_was_imported_using_import_type_1380", "An import alias cannot reference a declaration that was imported using 'import type'."),
        Unexpected_token_Did_you_mean_or_rbrace: diag(1381, ts.DiagnosticCategory.Error, "Unexpected_token_Did_you_mean_or_rbrace_1381", "Unexpected token. Did you mean `{'}'}` or `&rbrace;`?"),
        Unexpected_token_Did_you_mean_or_gt: diag(1382, ts.DiagnosticCategory.Error, "Unexpected_token_Did_you_mean_or_gt_1382", "Unexpected token. Did you mean `{'>'}` or `&gt;`?"),
        Only_named_exports_may_use_export_type: diag(1383, ts.DiagnosticCategory.Error, "Only_named_exports_may_use_export_type_1383", "Only named exports may use 'export type'."),
        Function_type_notation_must_be_parenthesized_when_used_in_a_union_type: diag(1385, ts.DiagnosticCategory.Error, "Function_type_notation_must_be_parenthesized_when_used_in_a_union_type_1385", "Function type notation must be parenthesized when used in a union type."),
        Constructor_type_notation_must_be_parenthesized_when_used_in_a_union_type: diag(1386, ts.DiagnosticCategory.Error, "Constructor_type_notation_must_be_parenthesized_when_used_in_a_union_type_1386", "Constructor type notation must be parenthesized when used in a union type."),
        Function_type_notation_must_be_parenthesized_when_used_in_an_intersection_type: diag(1387, ts.DiagnosticCategory.Error, "Function_type_notation_must_be_parenthesized_when_used_in_an_intersection_type_1387", "Function type notation must be parenthesized when used in an intersection type."),
        Constructor_type_notation_must_be_parenthesized_when_used_in_an_intersection_type: diag(1388, ts.DiagnosticCategory.Error, "Constructor_type_notation_must_be_parenthesized_when_used_in_an_intersection_type_1388", "Constructor type notation must be parenthesized when used in an intersection type."),
        _0_is_not_allowed_as_a_variable_declaration_name: diag(1389, ts.DiagnosticCategory.Error, "_0_is_not_allowed_as_a_variable_declaration_name_1389", "'{0}' is not allowed as a variable declaration name."),
        _0_is_not_allowed_as_a_parameter_name: diag(1390, ts.DiagnosticCategory.Error, "_0_is_not_allowed_as_a_parameter_name_1390", "'{0}' is not allowed as a parameter name."),
        An_import_alias_cannot_use_import_type: diag(1392, ts.DiagnosticCategory.Error, "An_import_alias_cannot_use_import_type_1392", "An import alias cannot use 'import type'"),
        Imported_via_0_from_file_1: diag(1393, ts.DiagnosticCategory.Message, "Imported_via_0_from_file_1_1393", "Imported via {0} from file '{1}'"),
        Imported_via_0_from_file_1_with_packageId_2: diag(1394, ts.DiagnosticCategory.Message, "Imported_via_0_from_file_1_with_packageId_2_1394", "Imported via {0} from file '{1}' with packageId '{2}'"),
        Imported_via_0_from_file_1_to_import_importHelpers_as_specified_in_compilerOptions: diag(1395, ts.DiagnosticCategory.Message, "Imported_via_0_from_file_1_to_import_importHelpers_as_specified_in_compilerOptions_1395", "Imported via {0} from file '{1}' to import 'importHelpers' as specified in compilerOptions"),
        Imported_via_0_from_file_1_with_packageId_2_to_import_importHelpers_as_specified_in_compilerOptions: diag(1396, ts.DiagnosticCategory.Message, "Imported_via_0_from_file_1_with_packageId_2_to_import_importHelpers_as_specified_in_compilerOptions_1396", "Imported via {0} from file '{1}' with packageId '{2}' to import 'importHelpers' as specified in compilerOptions"),
        Imported_via_0_from_file_1_to_import_jsx_and_jsxs_factory_functions: diag(1397, ts.DiagnosticCategory.Message, "Imported_via_0_from_file_1_to_import_jsx_and_jsxs_factory_functions_1397", "Imported via {0} from file '{1}' to import 'jsx' and 'jsxs' factory functions"),
        Imported_via_0_from_file_1_with_packageId_2_to_import_jsx_and_jsxs_factory_functions: diag(1398, ts.DiagnosticCategory.Message, "Imported_via_0_from_file_1_with_packageId_2_to_import_jsx_and_jsxs_factory_functions_1398", "Imported via {0} from file '{1}' with packageId '{2}' to import 'jsx' and 'jsxs' factory functions"),
        File_is_included_via_import_here: diag(1399, ts.DiagnosticCategory.Message, "File_is_included_via_import_here_1399", "File is included via import here."),
        Referenced_via_0_from_file_1: diag(1400, ts.DiagnosticCategory.Message, "Referenced_via_0_from_file_1_1400", "Referenced via '{0}' from file '{1}'"),
        File_is_included_via_reference_here: diag(1401, ts.DiagnosticCategory.Message, "File_is_included_via_reference_here_1401", "File is included via reference here."),
        Type_library_referenced_via_0_from_file_1: diag(1402, ts.DiagnosticCategory.Message, "Type_library_referenced_via_0_from_file_1_1402", "Type library referenced via '{0}' from file '{1}'"),
        Type_library_referenced_via_0_from_file_1_with_packageId_2: diag(1403, ts.DiagnosticCategory.Message, "Type_library_referenced_via_0_from_file_1_with_packageId_2_1403", "Type library referenced via '{0}' from file '{1}' with packageId '{2}'"),
        File_is_included_via_type_library_reference_here: diag(1404, ts.DiagnosticCategory.Message, "File_is_included_via_type_library_reference_here_1404", "File is included via type library reference here."),
        Library_referenced_via_0_from_file_1: diag(1405, ts.DiagnosticCategory.Message, "Library_referenced_via_0_from_file_1_1405", "Library referenced via '{0}' from file '{1}'"),
        File_is_included_via_library_reference_here: diag(1406, ts.DiagnosticCategory.Message, "File_is_included_via_library_reference_here_1406", "File is included via library reference here."),
        Matched_by_include_pattern_0_in_1: diag(1407, ts.DiagnosticCategory.Message, "Matched_by_include_pattern_0_in_1_1407", "Matched by include pattern '{0}' in '{1}'"),
        File_is_matched_by_include_pattern_specified_here: diag(1408, ts.DiagnosticCategory.Message, "File_is_matched_by_include_pattern_specified_here_1408", "File is matched by include pattern specified here."),
        Part_of_files_list_in_tsconfig_json: diag(1409, ts.DiagnosticCategory.Message, "Part_of_files_list_in_tsconfig_json_1409", "Part of 'files' list in tsconfig.json"),
        File_is_matched_by_files_list_specified_here: diag(1410, ts.DiagnosticCategory.Message, "File_is_matched_by_files_list_specified_here_1410", "File is matched by 'files' list specified here."),
        Output_from_referenced_project_0_included_because_1_specified: diag(1411, ts.DiagnosticCategory.Message, "Output_from_referenced_project_0_included_because_1_specified_1411", "Output from referenced project '{0}' included because '{1}' specified"),
        Output_from_referenced_project_0_included_because_module_is_specified_as_none: diag(1412, ts.DiagnosticCategory.Message, "Output_from_referenced_project_0_included_because_module_is_specified_as_none_1412", "Output from referenced project '{0}' included because '--module' is specified as 'none'"),
        File_is_output_from_referenced_project_specified_here: diag(1413, ts.DiagnosticCategory.Message, "File_is_output_from_referenced_project_specified_here_1413", "File is output from referenced project specified here."),
        Source_from_referenced_project_0_included_because_1_specified: diag(1414, ts.DiagnosticCategory.Message, "Source_from_referenced_project_0_included_because_1_specified_1414", "Source from referenced project '{0}' included because '{1}' specified"),
        Source_from_referenced_project_0_included_because_module_is_specified_as_none: diag(1415, ts.DiagnosticCategory.Message, "Source_from_referenced_project_0_included_because_module_is_specified_as_none_1415", "Source from referenced project '{0}' included because '--module' is specified as 'none'"),
        File_is_source_from_referenced_project_specified_here: diag(1416, ts.DiagnosticCategory.Message, "File_is_source_from_referenced_project_specified_here_1416", "File is source from referenced project specified here."),
        Entry_point_of_type_library_0_specified_in_compilerOptions: diag(1417, ts.DiagnosticCategory.Message, "Entry_point_of_type_library_0_specified_in_compilerOptions_1417", "Entry point of type library '{0}' specified in compilerOptions"),
        Entry_point_of_type_library_0_specified_in_compilerOptions_with_packageId_1: diag(1418, ts.DiagnosticCategory.Message, "Entry_point_of_type_library_0_specified_in_compilerOptions_with_packageId_1_1418", "Entry point of type library '{0}' specified in compilerOptions with packageId '{1}'"),
        File_is_entry_point_of_type_library_specified_here: diag(1419, ts.DiagnosticCategory.Message, "File_is_entry_point_of_type_library_specified_here_1419", "File is entry point of type library specified here."),
        Entry_point_for_implicit_type_library_0: diag(1420, ts.DiagnosticCategory.Message, "Entry_point_for_implicit_type_library_0_1420", "Entry point for implicit type library '{0}'"),
        Entry_point_for_implicit_type_library_0_with_packageId_1: diag(1421, ts.DiagnosticCategory.Message, "Entry_point_for_implicit_type_library_0_with_packageId_1_1421", "Entry point for implicit type library '{0}' with packageId '{1}'"),
        Library_0_specified_in_compilerOptions: diag(1422, ts.DiagnosticCategory.Message, "Library_0_specified_in_compilerOptions_1422", "Library '{0}' specified in compilerOptions"),
        File_is_library_specified_here: diag(1423, ts.DiagnosticCategory.Message, "File_is_library_specified_here_1423", "File is library specified here."),
        Default_library: diag(1424, ts.DiagnosticCategory.Message, "Default_library_1424", "Default library"),
        Default_library_for_target_0: diag(1425, ts.DiagnosticCategory.Message, "Default_library_for_target_0_1425", "Default library for target '{0}'"),
        File_is_default_library_for_target_specified_here: diag(1426, ts.DiagnosticCategory.Message, "File_is_default_library_for_target_specified_here_1426", "File is default library for target specified here."),
        Root_file_specified_for_compilation: diag(1427, ts.DiagnosticCategory.Message, "Root_file_specified_for_compilation_1427", "Root file specified for compilation"),
        File_is_output_of_project_reference_source_0: diag(1428, ts.DiagnosticCategory.Message, "File_is_output_of_project_reference_source_0_1428", "File is output of project reference source '{0}'"),
        File_redirects_to_file_0: diag(1429, ts.DiagnosticCategory.Message, "File_redirects_to_file_0_1429", "File redirects to file '{0}'"),
        The_file_is_in_the_program_because_Colon: diag(1430, ts.DiagnosticCategory.Message, "The_file_is_in_the_program_because_Colon_1430", "The file is in the program because:"),
        for_await_loops_are_only_allowed_at_the_top_level_of_a_file_when_that_file_is_a_module_but_this_file_has_no_imports_or_exports_Consider_adding_an_empty_export_to_make_this_file_a_module: diag(1431, ts.DiagnosticCategory.Error, "for_await_loops_are_only_allowed_at_the_top_level_of_a_file_when_that_file_is_a_module_but_this_file_1431", "'for await' loops are only allowed at the top level of a file when that file is a module, but this file has no imports or exports. Consider adding an empty 'export {}' to make this file a module."),
        Top_level_for_await_loops_are_only_allowed_when_the_module_option_is_set_to_es2022_esnext_system_node16_or_nodenext_and_the_target_option_is_set_to_es2017_or_higher: diag(1432, ts.DiagnosticCategory.Error, "Top_level_for_await_loops_are_only_allowed_when_the_module_option_is_set_to_es2022_esnext_system_nod_1432", "Top-level 'for await' loops are only allowed when the 'module' option is set to 'es2022', 'esnext', 'system', 'node16', or 'nodenext', and the 'target' option is set to 'es2017' or higher."),
        Decorators_may_not_be_applied_to_this_parameters: diag(1433, ts.DiagnosticCategory.Error, "Decorators_may_not_be_applied_to_this_parameters_1433", "Decorators may not be applied to 'this' parameters."),
        Unexpected_keyword_or_identifier: diag(1434, ts.DiagnosticCategory.Error, "Unexpected_keyword_or_identifier_1434", "Unexpected keyword or identifier."),
        Unknown_keyword_or_identifier_Did_you_mean_0: diag(1435, ts.DiagnosticCategory.Error, "Unknown_keyword_or_identifier_Did_you_mean_0_1435", "Unknown keyword or identifier. Did you mean '{0}'?"),
        Decorators_must_precede_the_name_and_all_keywords_of_property_declarations: diag(1436, ts.DiagnosticCategory.Error, "Decorators_must_precede_the_name_and_all_keywords_of_property_declarations_1436", "Decorators must precede the name and all keywords of property declarations."),
        Namespace_must_be_given_a_name: diag(1437, ts.DiagnosticCategory.Error, "Namespace_must_be_given_a_name_1437", "Namespace must be given a name."),
        Interface_must_be_given_a_name: diag(1438, ts.DiagnosticCategory.Error, "Interface_must_be_given_a_name_1438", "Interface must be given a name."),
        Type_alias_must_be_given_a_name: diag(1439, ts.DiagnosticCategory.Error, "Type_alias_must_be_given_a_name_1439", "Type alias must be given a name."),
        Variable_declaration_not_allowed_at_this_location: diag(1440, ts.DiagnosticCategory.Error, "Variable_declaration_not_allowed_at_this_location_1440", "Variable declaration not allowed at this location."),
        Cannot_start_a_function_call_in_a_type_annotation: diag(1441, ts.DiagnosticCategory.Error, "Cannot_start_a_function_call_in_a_type_annotation_1441", "Cannot start a function call in a type annotation."),
        Expected_for_property_initializer: diag(1442, ts.DiagnosticCategory.Error, "Expected_for_property_initializer_1442", "Expected '=' for property initializer."),
        Module_declaration_names_may_only_use_or_quoted_strings: diag(1443, ts.DiagnosticCategory.Error, "Module_declaration_names_may_only_use_or_quoted_strings_1443", "Module declaration names may only use ' or \" quoted strings."),
        _0_is_a_type_and_must_be_imported_using_a_type_only_import_when_preserveValueImports_and_isolatedModules_are_both_enabled: diag(1444, ts.DiagnosticCategory.Error, "_0_is_a_type_and_must_be_imported_using_a_type_only_import_when_preserveValueImports_and_isolatedMod_1444", "'{0}' is a type and must be imported using a type-only import when 'preserveValueImports' and 'isolatedModules' are both enabled."),
        _0_resolves_to_a_type_only_declaration_and_must_be_imported_using_a_type_only_import_when_preserveValueImports_and_isolatedModules_are_both_enabled: diag(1446, ts.DiagnosticCategory.Error, "_0_resolves_to_a_type_only_declaration_and_must_be_imported_using_a_type_only_import_when_preserveVa_1446", "'{0}' resolves to a type-only declaration and must be imported using a type-only import when 'preserveValueImports' and 'isolatedModules' are both enabled."),
        _0_resolves_to_a_type_only_declaration_and_must_be_re_exported_using_a_type_only_re_export_when_isolatedModules_is_enabled: diag(1448, ts.DiagnosticCategory.Error, "_0_resolves_to_a_type_only_declaration_and_must_be_re_exported_using_a_type_only_re_export_when_isol_1448", "'{0}' resolves to a type-only declaration and must be re-exported using a type-only re-export when 'isolatedModules' is enabled."),
        Preserve_unused_imported_values_in_the_JavaScript_output_that_would_otherwise_be_removed: diag(1449, ts.DiagnosticCategory.Message, "Preserve_unused_imported_values_in_the_JavaScript_output_that_would_otherwise_be_removed_1449", "Preserve unused imported values in the JavaScript output that would otherwise be removed."),
        Dynamic_imports_can_only_accept_a_module_specifier_and_an_optional_assertion_as_arguments: diag(1450, ts.DiagnosticCategory.Message, "Dynamic_imports_can_only_accept_a_module_specifier_and_an_optional_assertion_as_arguments_1450", "Dynamic imports can only accept a module specifier and an optional assertion as arguments"),
        Private_identifiers_are_only_allowed_in_class_bodies_and_may_only_be_used_as_part_of_a_class_member_declaration_property_access_or_on_the_left_hand_side_of_an_in_expression: diag(1451, ts.DiagnosticCategory.Error, "Private_identifiers_are_only_allowed_in_class_bodies_and_may_only_be_used_as_part_of_a_class_member__1451", "Private identifiers are only allowed in class bodies and may only be used as part of a class member declaration, property access, or on the left-hand-side of an 'in' expression"),
        resolution_mode_assertions_are_only_supported_when_moduleResolution_is_node16_or_nodenext: diag(1452, ts.DiagnosticCategory.Error, "resolution_mode_assertions_are_only_supported_when_moduleResolution_is_node16_or_nodenext_1452", "'resolution-mode' assertions are only supported when `moduleResolution` is `node16` or `nodenext`."),
        resolution_mode_should_be_either_require_or_import: diag(1453, ts.DiagnosticCategory.Error, "resolution_mode_should_be_either_require_or_import_1453", "`resolution-mode` should be either `require` or `import`."),
        resolution_mode_can_only_be_set_for_type_only_imports: diag(1454, ts.DiagnosticCategory.Error, "resolution_mode_can_only_be_set_for_type_only_imports_1454", "`resolution-mode` can only be set for type-only imports."),
        resolution_mode_is_the_only_valid_key_for_type_import_assertions: diag(1455, ts.DiagnosticCategory.Error, "resolution_mode_is_the_only_valid_key_for_type_import_assertions_1455", "`resolution-mode` is the only valid key for type import assertions."),
        Type_import_assertions_should_have_exactly_one_key_resolution_mode_with_value_import_or_require: diag(1456, ts.DiagnosticCategory.Error, "Type_import_assertions_should_have_exactly_one_key_resolution_mode_with_value_import_or_require_1456", "Type import assertions should have exactly one key - `resolution-mode` - with value `import` or `require`."),
        The_import_meta_meta_property_is_not_allowed_in_files_which_will_build_into_CommonJS_output: diag(1470, ts.DiagnosticCategory.Error, "The_import_meta_meta_property_is_not_allowed_in_files_which_will_build_into_CommonJS_output_1470", "The 'import.meta' meta-property is not allowed in files which will build into CommonJS output."),
        Module_0_cannot_be_imported_using_this_construct_The_specifier_only_resolves_to_an_ES_module_which_cannot_be_imported_synchronously_Use_dynamic_import_instead: diag(1471, ts.DiagnosticCategory.Error, "Module_0_cannot_be_imported_using_this_construct_The_specifier_only_resolves_to_an_ES_module_which_c_1471", "Module '{0}' cannot be imported using this construct. The specifier only resolves to an ES module, which cannot be imported synchronously. Use dynamic import instead."),
        catch_or_finally_expected: diag(1472, ts.DiagnosticCategory.Error, "catch_or_finally_expected_1472", "'catch' or 'finally' expected."),
        An_import_declaration_can_only_be_used_at_the_top_level_of_a_module: diag(1473, ts.DiagnosticCategory.Error, "An_import_declaration_can_only_be_used_at_the_top_level_of_a_module_1473", "An import declaration can only be used at the top level of a module."),
        An_export_declaration_can_only_be_used_at_the_top_level_of_a_module: diag(1474, ts.DiagnosticCategory.Error, "An_export_declaration_can_only_be_used_at_the_top_level_of_a_module_1474", "An export declaration can only be used at the top level of a module."),
        Control_what_method_is_used_to_detect_module_format_JS_files: diag(1475, ts.DiagnosticCategory.Message, "Control_what_method_is_used_to_detect_module_format_JS_files_1475", "Control what method is used to detect module-format JS files."),
        auto_Colon_Treat_files_with_imports_exports_import_meta_jsx_with_jsx_Colon_react_jsx_or_esm_format_with_module_Colon_node16_as_modules: diag(1476, ts.DiagnosticCategory.Message, "auto_Colon_Treat_files_with_imports_exports_import_meta_jsx_with_jsx_Colon_react_jsx_or_esm_format_w_1476", "\"auto\": Treat files with imports, exports, import.meta, jsx (with jsx: react-jsx), or esm format (with module: node16+) as modules."),
        The_types_of_0_are_incompatible_between_these_types: diag(2200, ts.DiagnosticCategory.Error, "The_types_of_0_are_incompatible_between_these_types_2200", "The types of '{0}' are incompatible between these types."),
        The_types_returned_by_0_are_incompatible_between_these_types: diag(2201, ts.DiagnosticCategory.Error, "The_types_returned_by_0_are_incompatible_between_these_types_2201", "The types returned by '{0}' are incompatible between these types."),
        Call_signature_return_types_0_and_1_are_incompatible: diag(2202, ts.DiagnosticCategory.Error, "Call_signature_return_types_0_and_1_are_incompatible_2202", "Call signature return types '{0}' and '{1}' are incompatible.", undefined, true),
        Construct_signature_return_types_0_and_1_are_incompatible: diag(2203, ts.DiagnosticCategory.Error, "Construct_signature_return_types_0_and_1_are_incompatible_2203", "Construct signature return types '{0}' and '{1}' are incompatible.", undefined, true),
        Call_signatures_with_no_arguments_have_incompatible_return_types_0_and_1: diag(2204, ts.DiagnosticCategory.Error, "Call_signatures_with_no_arguments_have_incompatible_return_types_0_and_1_2204", "Call signatures with no arguments have incompatible return types '{0}' and '{1}'.", undefined, true),
        Construct_signatures_with_no_arguments_have_incompatible_return_types_0_and_1: diag(2205, ts.DiagnosticCategory.Error, "Construct_signatures_with_no_arguments_have_incompatible_return_types_0_and_1_2205", "Construct signatures with no arguments have incompatible return types '{0}' and '{1}'.", undefined, true),
        The_type_modifier_cannot_be_used_on_a_named_import_when_import_type_is_used_on_its_import_statement: diag(2206, ts.DiagnosticCategory.Error, "The_type_modifier_cannot_be_used_on_a_named_import_when_import_type_is_used_on_its_import_statement_2206", "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement."),
        The_type_modifier_cannot_be_used_on_a_named_export_when_export_type_is_used_on_its_export_statement: diag(2207, ts.DiagnosticCategory.Error, "The_type_modifier_cannot_be_used_on_a_named_export_when_export_type_is_used_on_its_export_statement_2207", "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement."),
        The_project_root_is_ambiguous_but_is_required_to_resolve_export_map_entry_0_in_file_1_Supply_the_rootDir_compiler_option_to_disambiguate: diag(2209, ts.DiagnosticCategory.Error, "The_project_root_is_ambiguous_but_is_required_to_resolve_export_map_entry_0_in_file_1_Supply_the_roo_2209", "The project root is ambiguous, but is required to resolve export map entry '{0}' in file '{1}'. Supply the `rootDir` compiler option to disambiguate."),
        The_project_root_is_ambiguous_but_is_required_to_resolve_import_map_entry_0_in_file_1_Supply_the_rootDir_compiler_option_to_disambiguate: diag(2210, ts.DiagnosticCategory.Error, "The_project_root_is_ambiguous_but_is_required_to_resolve_import_map_entry_0_in_file_1_Supply_the_roo_2210", "The project root is ambiguous, but is required to resolve import map entry '{0}' in file '{1}'. Supply the `rootDir` compiler option to disambiguate."),
        Duplicate_identifier_0: diag(2300, ts.DiagnosticCategory.Error, "Duplicate_identifier_0_2300", "Duplicate identifier '{0}'."),
        Initializer_of_instance_member_variable_0_cannot_reference_identifier_1_declared_in_the_constructor: diag(2301, ts.DiagnosticCategory.Error, "Initializer_of_instance_member_variable_0_cannot_reference_identifier_1_declared_in_the_constructor_2301", "Initializer of instance member variable '{0}' cannot reference identifier '{1}' declared in the constructor."),
        Static_members_cannot_reference_class_type_parameters: diag(2302, ts.DiagnosticCategory.Error, "Static_members_cannot_reference_class_type_parameters_2302", "Static members cannot reference class type parameters."),
        Circular_definition_of_import_alias_0: diag(2303, ts.DiagnosticCategory.Error, "Circular_definition_of_import_alias_0_2303", "Circular definition of import alias '{0}'."),
        Cannot_find_name_0: diag(2304, ts.DiagnosticCategory.Error, "Cannot_find_name_0_2304", "Cannot find name '{0}'."),
        Module_0_has_no_exported_member_1: diag(2305, ts.DiagnosticCategory.Error, "Module_0_has_no_exported_member_1_2305", "Module '{0}' has no exported member '{1}'."),
        File_0_is_not_a_module: diag(2306, ts.DiagnosticCategory.Error, "File_0_is_not_a_module_2306", "File '{0}' is not a module."),
        Cannot_find_module_0_or_its_corresponding_type_declarations: diag(2307, ts.DiagnosticCategory.Error, "Cannot_find_module_0_or_its_corresponding_type_declarations_2307", "Cannot find module '{0}' or its corresponding type declarations."),
        Module_0_has_already_exported_a_member_named_1_Consider_explicitly_re_exporting_to_resolve_the_ambiguity: diag(2308, ts.DiagnosticCategory.Error, "Module_0_has_already_exported_a_member_named_1_Consider_explicitly_re_exporting_to_resolve_the_ambig_2308", "Module {0} has already exported a member named '{1}'. Consider explicitly re-exporting to resolve the ambiguity."),
        An_export_assignment_cannot_be_used_in_a_module_with_other_exported_elements: diag(2309, ts.DiagnosticCategory.Error, "An_export_assignment_cannot_be_used_in_a_module_with_other_exported_elements_2309", "An export assignment cannot be used in a module with other exported elements."),
        Type_0_recursively_references_itself_as_a_base_type: diag(2310, ts.DiagnosticCategory.Error, "Type_0_recursively_references_itself_as_a_base_type_2310", "Type '{0}' recursively references itself as a base type."),
        Cannot_find_name_0_Did_you_mean_to_write_this_in_an_async_function: diag(2311, ts.DiagnosticCategory.Error, "Cannot_find_name_0_Did_you_mean_to_write_this_in_an_async_function_2311", "Cannot find name '{0}'. Did you mean to write this in an async function?"),
        An_interface_can_only_extend_an_object_type_or_intersection_of_object_types_with_statically_known_members: diag(2312, ts.DiagnosticCategory.Error, "An_interface_can_only_extend_an_object_type_or_intersection_of_object_types_with_statically_known_me_2312", "An interface can only extend an object type or intersection of object types with statically known members."),
        Type_parameter_0_has_a_circular_constraint: diag(2313, ts.DiagnosticCategory.Error, "Type_parameter_0_has_a_circular_constraint_2313", "Type parameter '{0}' has a circular constraint."),
        Generic_type_0_requires_1_type_argument_s: diag(2314, ts.DiagnosticCategory.Error, "Generic_type_0_requires_1_type_argument_s_2314", "Generic type '{0}' requires {1} type argument(s)."),
        Type_0_is_not_generic: diag(2315, ts.DiagnosticCategory.Error, "Type_0_is_not_generic_2315", "Type '{0}' is not generic."),
        Global_type_0_must_be_a_class_or_interface_type: diag(2316, ts.DiagnosticCategory.Error, "Global_type_0_must_be_a_class_or_interface_type_2316", "Global type '{0}' must be a class or interface type."),
        Global_type_0_must_have_1_type_parameter_s: diag(2317, ts.DiagnosticCategory.Error, "Global_type_0_must_have_1_type_parameter_s_2317", "Global type '{0}' must have {1} type parameter(s)."),
        Cannot_find_global_type_0: diag(2318, ts.DiagnosticCategory.Error, "Cannot_find_global_type_0_2318", "Cannot find global type '{0}'."),
        Named_property_0_of_types_1_and_2_are_not_identical: diag(2319, ts.DiagnosticCategory.Error, "Named_property_0_of_types_1_and_2_are_not_identical_2319", "Named property '{0}' of types '{1}' and '{2}' are not identical."),
        Interface_0_cannot_simultaneously_extend_types_1_and_2: diag(2320, ts.DiagnosticCategory.Error, "Interface_0_cannot_simultaneously_extend_types_1_and_2_2320", "Interface '{0}' cannot simultaneously extend types '{1}' and '{2}'."),
        Excessive_stack_depth_comparing_types_0_and_1: diag(2321, ts.DiagnosticCategory.Error, "Excessive_stack_depth_comparing_types_0_and_1_2321", "Excessive stack depth comparing types '{0}' and '{1}'."),
        Type_0_is_not_assignable_to_type_1: diag(2322, ts.DiagnosticCategory.Error, "Type_0_is_not_assignable_to_type_1_2322", "Type '{0}' is not assignable to type '{1}'."),
        Cannot_redeclare_exported_variable_0: diag(2323, ts.DiagnosticCategory.Error, "Cannot_redeclare_exported_variable_0_2323", "Cannot redeclare exported variable '{0}'."),
        Property_0_is_missing_in_type_1: diag(2324, ts.DiagnosticCategory.Error, "Property_0_is_missing_in_type_1_2324", "Property '{0}' is missing in type '{1}'."),
        Property_0_is_private_in_type_1_but_not_in_type_2: diag(2325, ts.DiagnosticCategory.Error, "Property_0_is_private_in_type_1_but_not_in_type_2_2325", "Property '{0}' is private in type '{1}' but not in type '{2}'."),
        Types_of_property_0_are_incompatible: diag(2326, ts.DiagnosticCategory.Error, "Types_of_property_0_are_incompatible_2326", "Types of property '{0}' are incompatible."),
        Property_0_is_optional_in_type_1_but_required_in_type_2: diag(2327, ts.DiagnosticCategory.Error, "Property_0_is_optional_in_type_1_but_required_in_type_2_2327", "Property '{0}' is optional in type '{1}' but required in type '{2}'."),
        Types_of_parameters_0_and_1_are_incompatible: diag(2328, ts.DiagnosticCategory.Error, "Types_of_parameters_0_and_1_are_incompatible_2328", "Types of parameters '{0}' and '{1}' are incompatible."),
        Index_signature_for_type_0_is_missing_in_type_1: diag(2329, ts.DiagnosticCategory.Error, "Index_signature_for_type_0_is_missing_in_type_1_2329", "Index signature for type '{0}' is missing in type '{1}'."),
        _0_and_1_index_signatures_are_incompatible: diag(2330, ts.DiagnosticCategory.Error, "_0_and_1_index_signatures_are_incompatible_2330", "'{0}' and '{1}' index signatures are incompatible."),
        this_cannot_be_referenced_in_a_module_or_namespace_body: diag(2331, ts.DiagnosticCategory.Error, "this_cannot_be_referenced_in_a_module_or_namespace_body_2331", "'this' cannot be referenced in a module or namespace body."),
        this_cannot_be_referenced_in_current_location: diag(2332, ts.DiagnosticCategory.Error, "this_cannot_be_referenced_in_current_location_2332", "'this' cannot be referenced in current location."),
        this_cannot_be_referenced_in_constructor_arguments: diag(2333, ts.DiagnosticCategory.Error, "this_cannot_be_referenced_in_constructor_arguments_2333", "'this' cannot be referenced in constructor arguments."),
        this_cannot_be_referenced_in_a_static_property_initializer: diag(2334, ts.DiagnosticCategory.Error, "this_cannot_be_referenced_in_a_static_property_initializer_2334", "'this' cannot be referenced in a static property initializer."),
        super_can_only_be_referenced_in_a_derived_class: diag(2335, ts.DiagnosticCategory.Error, "super_can_only_be_referenced_in_a_derived_class_2335", "'super' can only be referenced in a derived class."),
        super_cannot_be_referenced_in_constructor_arguments: diag(2336, ts.DiagnosticCategory.Error, "super_cannot_be_referenced_in_constructor_arguments_2336", "'super' cannot be referenced in constructor arguments."),
        Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors: diag(2337, ts.DiagnosticCategory.Error, "Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors_2337", "Super calls are not permitted outside constructors or in nested functions inside constructors."),
        super_property_access_is_permitted_only_in_a_constructor_member_function_or_member_accessor_of_a_derived_class: diag(2338, ts.DiagnosticCategory.Error, "super_property_access_is_permitted_only_in_a_constructor_member_function_or_member_accessor_of_a_der_2338", "'super' property access is permitted only in a constructor, member function, or member accessor of a derived class."),
        Property_0_does_not_exist_on_type_1: diag(2339, ts.DiagnosticCategory.Error, "Property_0_does_not_exist_on_type_1_2339", "Property '{0}' does not exist on type '{1}'."),
        Only_public_and_protected_methods_of_the_base_class_are_accessible_via_the_super_keyword: diag(2340, ts.DiagnosticCategory.Error, "Only_public_and_protected_methods_of_the_base_class_are_accessible_via_the_super_keyword_2340", "Only public and protected methods of the base class are accessible via the 'super' keyword."),
        Property_0_is_private_and_only_accessible_within_class_1: diag(2341, ts.DiagnosticCategory.Error, "Property_0_is_private_and_only_accessible_within_class_1_2341", "Property '{0}' is private and only accessible within class '{1}'."),
        This_syntax_requires_an_imported_helper_named_1_which_does_not_exist_in_0_Consider_upgrading_your_version_of_0: diag(2343, ts.DiagnosticCategory.Error, "This_syntax_requires_an_imported_helper_named_1_which_does_not_exist_in_0_Consider_upgrading_your_ve_2343", "This syntax requires an imported helper named '{1}' which does not exist in '{0}'. Consider upgrading your version of '{0}'."),
        Type_0_does_not_satisfy_the_constraint_1: diag(2344, ts.DiagnosticCategory.Error, "Type_0_does_not_satisfy_the_constraint_1_2344", "Type '{0}' does not satisfy the constraint '{1}'."),
        Argument_of_type_0_is_not_assignable_to_parameter_of_type_1: diag(2345, ts.DiagnosticCategory.Error, "Argument_of_type_0_is_not_assignable_to_parameter_of_type_1_2345", "Argument of type '{0}' is not assignable to parameter of type '{1}'."),
        Call_target_does_not_contain_any_signatures: diag(2346, ts.DiagnosticCategory.Error, "Call_target_does_not_contain_any_signatures_2346", "Call target does not contain any signatures."),
        Untyped_function_calls_may_not_accept_type_arguments: diag(2347, ts.DiagnosticCategory.Error, "Untyped_function_calls_may_not_accept_type_arguments_2347", "Untyped function calls may not accept type arguments."),
        Value_of_type_0_is_not_callable_Did_you_mean_to_include_new: diag(2348, ts.DiagnosticCategory.Error, "Value_of_type_0_is_not_callable_Did_you_mean_to_include_new_2348", "Value of type '{0}' is not callable. Did you mean to include 'new'?"),
        This_expression_is_not_callable: diag(2349, ts.DiagnosticCategory.Error, "This_expression_is_not_callable_2349", "This expression is not callable."),
        Only_a_void_function_can_be_called_with_the_new_keyword: diag(2350, ts.DiagnosticCategory.Error, "Only_a_void_function_can_be_called_with_the_new_keyword_2350", "Only a void function can be called with the 'new' keyword."),
        This_expression_is_not_constructable: diag(2351, ts.DiagnosticCategory.Error, "This_expression_is_not_constructable_2351", "This expression is not constructable."),
        Conversion_of_type_0_to_type_1_may_be_a_mistake_because_neither_type_sufficiently_overlaps_with_the_other_If_this_was_intentional_convert_the_expression_to_unknown_first: diag(2352, ts.DiagnosticCategory.Error, "Conversion_of_type_0_to_type_1_may_be_a_mistake_because_neither_type_sufficiently_overlaps_with_the__2352", "Conversion of type '{0}' to type '{1}' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first."),
        Object_literal_may_only_specify_known_properties_and_0_does_not_exist_in_type_1: diag(2353, ts.DiagnosticCategory.Error, "Object_literal_may_only_specify_known_properties_and_0_does_not_exist_in_type_1_2353", "Object literal may only specify known properties, and '{0}' does not exist in type '{1}'."),
        This_syntax_requires_an_imported_helper_but_module_0_cannot_be_found: diag(2354, ts.DiagnosticCategory.Error, "This_syntax_requires_an_imported_helper_but_module_0_cannot_be_found_2354", "This syntax requires an imported helper but module '{0}' cannot be found."),
        A_function_whose_declared_type_is_neither_void_nor_any_must_return_a_value: diag(2355, ts.DiagnosticCategory.Error, "A_function_whose_declared_type_is_neither_void_nor_any_must_return_a_value_2355", "A function whose declared type is neither 'void' nor 'any' must return a value."),
        An_arithmetic_operand_must_be_of_type_any_number_bigint_or_an_enum_type: diag(2356, ts.DiagnosticCategory.Error, "An_arithmetic_operand_must_be_of_type_any_number_bigint_or_an_enum_type_2356", "An arithmetic operand must be of type 'any', 'number', 'bigint' or an enum type."),
        The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access: diag(2357, ts.DiagnosticCategory.Error, "The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access_2357", "The operand of an increment or decrement operator must be a variable or a property access."),
        The_left_hand_side_of_an_instanceof_expression_must_be_of_type_any_an_object_type_or_a_type_parameter: diag(2358, ts.DiagnosticCategory.Error, "The_left_hand_side_of_an_instanceof_expression_must_be_of_type_any_an_object_type_or_a_type_paramete_2358", "The left-hand side of an 'instanceof' expression must be of type 'any', an object type or a type parameter."),
        The_right_hand_side_of_an_instanceof_expression_must_be_of_type_any_or_of_a_type_assignable_to_the_Function_interface_type: diag(2359, ts.DiagnosticCategory.Error, "The_right_hand_side_of_an_instanceof_expression_must_be_of_type_any_or_of_a_type_assignable_to_the_F_2359", "The right-hand side of an 'instanceof' expression must be of type 'any' or of a type assignable to the 'Function' interface type."),
        The_left_hand_side_of_an_in_expression_must_be_a_private_identifier_or_of_type_any_string_number_or_symbol: diag(2360, ts.DiagnosticCategory.Error, "The_left_hand_side_of_an_in_expression_must_be_a_private_identifier_or_of_type_any_string_number_or__2360", "The left-hand side of an 'in' expression must be a private identifier or of type 'any', 'string', 'number', or 'symbol'."),
        The_right_hand_side_of_an_in_expression_must_not_be_a_primitive: diag(2361, ts.DiagnosticCategory.Error, "The_right_hand_side_of_an_in_expression_must_not_be_a_primitive_2361", "The right-hand side of an 'in' expression must not be a primitive."),
        The_left_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_bigint_or_an_enum_type: diag(2362, ts.DiagnosticCategory.Error, "The_left_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_bigint_or_an_enum_type_2362", "The left-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type."),
        The_right_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_bigint_or_an_enum_type: diag(2363, ts.DiagnosticCategory.Error, "The_right_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_bigint_or_an_enum_type_2363", "The right-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type."),
        The_left_hand_side_of_an_assignment_expression_must_be_a_variable_or_a_property_access: diag(2364, ts.DiagnosticCategory.Error, "The_left_hand_side_of_an_assignment_expression_must_be_a_variable_or_a_property_access_2364", "The left-hand side of an assignment expression must be a variable or a property access."),
        Operator_0_cannot_be_applied_to_types_1_and_2: diag(2365, ts.DiagnosticCategory.Error, "Operator_0_cannot_be_applied_to_types_1_and_2_2365", "Operator '{0}' cannot be applied to types '{1}' and '{2}'."),
        Function_lacks_ending_return_statement_and_return_type_does_not_include_undefined: diag(2366, ts.DiagnosticCategory.Error, "Function_lacks_ending_return_statement_and_return_type_does_not_include_undefined_2366", "Function lacks ending return statement and return type does not include 'undefined'."),
        This_condition_will_always_return_0_since_the_types_1_and_2_have_no_overlap: diag(2367, ts.DiagnosticCategory.Error, "This_condition_will_always_return_0_since_the_types_1_and_2_have_no_overlap_2367", "This condition will always return '{0}' since the types '{1}' and '{2}' have no overlap."),
        Type_parameter_name_cannot_be_0: diag(2368, ts.DiagnosticCategory.Error, "Type_parameter_name_cannot_be_0_2368", "Type parameter name cannot be '{0}'."),
        A_parameter_property_is_only_allowed_in_a_constructor_implementation: diag(2369, ts.DiagnosticCategory.Error, "A_parameter_property_is_only_allowed_in_a_constructor_implementation_2369", "A parameter property is only allowed in a constructor implementation."),
        A_rest_parameter_must_be_of_an_array_type: diag(2370, ts.DiagnosticCategory.Error, "A_rest_parameter_must_be_of_an_array_type_2370", "A rest parameter must be of an array type."),
        A_parameter_initializer_is_only_allowed_in_a_function_or_constructor_implementation: diag(2371, ts.DiagnosticCategory.Error, "A_parameter_initializer_is_only_allowed_in_a_function_or_constructor_implementation_2371", "A parameter initializer is only allowed in a function or constructor implementation."),
        Parameter_0_cannot_reference_itself: diag(2372, ts.DiagnosticCategory.Error, "Parameter_0_cannot_reference_itself_2372", "Parameter '{0}' cannot reference itself."),
        Parameter_0_cannot_reference_identifier_1_declared_after_it: diag(2373, ts.DiagnosticCategory.Error, "Parameter_0_cannot_reference_identifier_1_declared_after_it_2373", "Parameter '{0}' cannot reference identifier '{1}' declared after it."),
        Duplicate_index_signature_for_type_0: diag(2374, ts.DiagnosticCategory.Error, "Duplicate_index_signature_for_type_0_2374", "Duplicate index signature for type '{0}'."),
        Type_0_is_not_assignable_to_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefined_to_the_types_of_the_target_s_properties: diag(2375, ts.DiagnosticCategory.Error, "Type_0_is_not_assignable_to_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefi_2375", "Type '{0}' is not assignable to type '{1}' with 'exactOptionalPropertyTypes: true'. Consider adding 'undefined' to the types of the target's properties."),
        A_super_call_must_be_the_first_statement_in_the_constructor_to_refer_to_super_or_this_when_a_derived_class_contains_initialized_properties_parameter_properties_or_private_identifiers: diag(2376, ts.DiagnosticCategory.Error, "A_super_call_must_be_the_first_statement_in_the_constructor_to_refer_to_super_or_this_when_a_derived_2376", "A 'super' call must be the first statement in the constructor to refer to 'super' or 'this' when a derived class contains initialized properties, parameter properties, or private identifiers."),
        Constructors_for_derived_classes_must_contain_a_super_call: diag(2377, ts.DiagnosticCategory.Error, "Constructors_for_derived_classes_must_contain_a_super_call_2377", "Constructors for derived classes must contain a 'super' call."),
        A_get_accessor_must_return_a_value: diag(2378, ts.DiagnosticCategory.Error, "A_get_accessor_must_return_a_value_2378", "A 'get' accessor must return a value."),
        Argument_of_type_0_is_not_assignable_to_parameter_of_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefined_to_the_types_of_the_target_s_properties: diag(2379, ts.DiagnosticCategory.Error, "Argument_of_type_0_is_not_assignable_to_parameter_of_type_1_with_exactOptionalPropertyTypes_Colon_tr_2379", "Argument of type '{0}' is not assignable to parameter of type '{1}' with 'exactOptionalPropertyTypes: true'. Consider adding 'undefined' to the types of the target's properties."),
        The_return_type_of_a_get_accessor_must_be_assignable_to_its_set_accessor_type: diag(2380, ts.DiagnosticCategory.Error, "The_return_type_of_a_get_accessor_must_be_assignable_to_its_set_accessor_type_2380", "The return type of a 'get' accessor must be assignable to its 'set' accessor type"),
        Overload_signatures_must_all_be_exported_or_non_exported: diag(2383, ts.DiagnosticCategory.Error, "Overload_signatures_must_all_be_exported_or_non_exported_2383", "Overload signatures must all be exported or non-exported."),
        Overload_signatures_must_all_be_ambient_or_non_ambient: diag(2384, ts.DiagnosticCategory.Error, "Overload_signatures_must_all_be_ambient_or_non_ambient_2384", "Overload signatures must all be ambient or non-ambient."),
        Overload_signatures_must_all_be_public_private_or_protected: diag(2385, ts.DiagnosticCategory.Error, "Overload_signatures_must_all_be_public_private_or_protected_2385", "Overload signatures must all be public, private or protected."),
        Overload_signatures_must_all_be_optional_or_required: diag(2386, ts.DiagnosticCategory.Error, "Overload_signatures_must_all_be_optional_or_required_2386", "Overload signatures must all be optional or required."),
        Function_overload_must_be_static: diag(2387, ts.DiagnosticCategory.Error, "Function_overload_must_be_static_2387", "Function overload must be static."),
        Function_overload_must_not_be_static: diag(2388, ts.DiagnosticCategory.Error, "Function_overload_must_not_be_static_2388", "Function overload must not be static."),
        Function_implementation_name_must_be_0: diag(2389, ts.DiagnosticCategory.Error, "Function_implementation_name_must_be_0_2389", "Function implementation name must be '{0}'."),
        Constructor_implementation_is_missing: diag(2390, ts.DiagnosticCategory.Error, "Constructor_implementation_is_missing_2390", "Constructor implementation is missing."),
        Function_implementation_is_missing_or_not_immediately_following_the_declaration: diag(2391, ts.DiagnosticCategory.Error, "Function_implementation_is_missing_or_not_immediately_following_the_declaration_2391", "Function implementation is missing or not immediately following the declaration."),
        Multiple_constructor_implementations_are_not_allowed: diag(2392, ts.DiagnosticCategory.Error, "Multiple_constructor_implementations_are_not_allowed_2392", "Multiple constructor implementations are not allowed."),
        Duplicate_function_implementation: diag(2393, ts.DiagnosticCategory.Error, "Duplicate_function_implementation_2393", "Duplicate function implementation."),
        This_overload_signature_is_not_compatible_with_its_implementation_signature: diag(2394, ts.DiagnosticCategory.Error, "This_overload_signature_is_not_compatible_with_its_implementation_signature_2394", "This overload signature is not compatible with its implementation signature."),
        Individual_declarations_in_merged_declaration_0_must_be_all_exported_or_all_local: diag(2395, ts.DiagnosticCategory.Error, "Individual_declarations_in_merged_declaration_0_must_be_all_exported_or_all_local_2395", "Individual declarations in merged declaration '{0}' must be all exported or all local."),
        Duplicate_identifier_arguments_Compiler_uses_arguments_to_initialize_rest_parameters: diag(2396, ts.DiagnosticCategory.Error, "Duplicate_identifier_arguments_Compiler_uses_arguments_to_initialize_rest_parameters_2396", "Duplicate identifier 'arguments'. Compiler uses 'arguments' to initialize rest parameters."),
        Declaration_name_conflicts_with_built_in_global_identifier_0: diag(2397, ts.DiagnosticCategory.Error, "Declaration_name_conflicts_with_built_in_global_identifier_0_2397", "Declaration name conflicts with built-in global identifier '{0}'."),
        constructor_cannot_be_used_as_a_parameter_property_name: diag(2398, ts.DiagnosticCategory.Error, "constructor_cannot_be_used_as_a_parameter_property_name_2398", "'constructor' cannot be used as a parameter property name."),
        Duplicate_identifier_this_Compiler_uses_variable_declaration_this_to_capture_this_reference: diag(2399, ts.DiagnosticCategory.Error, "Duplicate_identifier_this_Compiler_uses_variable_declaration_this_to_capture_this_reference_2399", "Duplicate identifier '_this'. Compiler uses variable declaration '_this' to capture 'this' reference."),
        Expression_resolves_to_variable_declaration_this_that_compiler_uses_to_capture_this_reference: diag(2400, ts.DiagnosticCategory.Error, "Expression_resolves_to_variable_declaration_this_that_compiler_uses_to_capture_this_reference_2400", "Expression resolves to variable declaration '_this' that compiler uses to capture 'this' reference."),
        A_super_call_must_be_a_root_level_statement_within_a_constructor_of_a_derived_class_that_contains_initialized_properties_parameter_properties_or_private_identifiers: diag(2401, ts.DiagnosticCategory.Error, "A_super_call_must_be_a_root_level_statement_within_a_constructor_of_a_derived_class_that_contains_in_2401", "A 'super' call must be a root-level statement within a constructor of a derived class that contains initialized properties, parameter properties, or private identifiers."),
        Expression_resolves_to_super_that_compiler_uses_to_capture_base_class_reference: diag(2402, ts.DiagnosticCategory.Error, "Expression_resolves_to_super_that_compiler_uses_to_capture_base_class_reference_2402", "Expression resolves to '_super' that compiler uses to capture base class reference."),
        Subsequent_variable_declarations_must_have_the_same_type_Variable_0_must_be_of_type_1_but_here_has_type_2: diag(2403, ts.DiagnosticCategory.Error, "Subsequent_variable_declarations_must_have_the_same_type_Variable_0_must_be_of_type_1_but_here_has_t_2403", "Subsequent variable declarations must have the same type.  Variable '{0}' must be of type '{1}', but here has type '{2}'."),
        The_left_hand_side_of_a_for_in_statement_cannot_use_a_type_annotation: diag(2404, ts.DiagnosticCategory.Error, "The_left_hand_side_of_a_for_in_statement_cannot_use_a_type_annotation_2404", "The left-hand side of a 'for...in' statement cannot use a type annotation."),
        The_left_hand_side_of_a_for_in_statement_must_be_of_type_string_or_any: diag(2405, ts.DiagnosticCategory.Error, "The_left_hand_side_of_a_for_in_statement_must_be_of_type_string_or_any_2405", "The left-hand side of a 'for...in' statement must be of type 'string' or 'any'."),
        The_left_hand_side_of_a_for_in_statement_must_be_a_variable_or_a_property_access: diag(2406, ts.DiagnosticCategory.Error, "The_left_hand_side_of_a_for_in_statement_must_be_a_variable_or_a_property_access_2406", "The left-hand side of a 'for...in' statement must be a variable or a property access."),
        The_right_hand_side_of_a_for_in_statement_must_be_of_type_any_an_object_type_or_a_type_parameter_but_here_has_type_0: diag(2407, ts.DiagnosticCategory.Error, "The_right_hand_side_of_a_for_in_statement_must_be_of_type_any_an_object_type_or_a_type_parameter_but_2407", "The right-hand side of a 'for...in' statement must be of type 'any', an object type or a type parameter, but here has type '{0}'."),
        Setters_cannot_return_a_value: diag(2408, ts.DiagnosticCategory.Error, "Setters_cannot_return_a_value_2408", "Setters cannot return a value."),
        Return_type_of_constructor_signature_must_be_assignable_to_the_instance_type_of_the_class: diag(2409, ts.DiagnosticCategory.Error, "Return_type_of_constructor_signature_must_be_assignable_to_the_instance_type_of_the_class_2409", "Return type of constructor signature must be assignable to the instance type of the class."),
        The_with_statement_is_not_supported_All_symbols_in_a_with_block_will_have_type_any: diag(2410, ts.DiagnosticCategory.Error, "The_with_statement_is_not_supported_All_symbols_in_a_with_block_will_have_type_any_2410", "The 'with' statement is not supported. All symbols in a 'with' block will have type 'any'."),
        Type_0_is_not_assignable_to_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefined_to_the_type_of_the_target: diag(2412, ts.DiagnosticCategory.Error, "Type_0_is_not_assignable_to_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefi_2412", "Type '{0}' is not assignable to type '{1}' with 'exactOptionalPropertyTypes: true'. Consider adding 'undefined' to the type of the target."),
        Property_0_of_type_1_is_not_assignable_to_2_index_type_3: diag(2411, ts.DiagnosticCategory.Error, "Property_0_of_type_1_is_not_assignable_to_2_index_type_3_2411", "Property '{0}' of type '{1}' is not assignable to '{2}' index type '{3}'."),
        _0_index_type_1_is_not_assignable_to_2_index_type_3: diag(2413, ts.DiagnosticCategory.Error, "_0_index_type_1_is_not_assignable_to_2_index_type_3_2413", "'{0}' index type '{1}' is not assignable to '{2}' index type '{3}'."),
        Class_name_cannot_be_0: diag(2414, ts.DiagnosticCategory.Error, "Class_name_cannot_be_0_2414", "Class name cannot be '{0}'."),
        Class_0_incorrectly_extends_base_class_1: diag(2415, ts.DiagnosticCategory.Error, "Class_0_incorrectly_extends_base_class_1_2415", "Class '{0}' incorrectly extends base class '{1}'."),
        Property_0_in_type_1_is_not_assignable_to_the_same_property_in_base_type_2: diag(2416, ts.DiagnosticCategory.Error, "Property_0_in_type_1_is_not_assignable_to_the_same_property_in_base_type_2_2416", "Property '{0}' in type '{1}' is not assignable to the same property in base type '{2}'."),
        Class_static_side_0_incorrectly_extends_base_class_static_side_1: diag(2417, ts.DiagnosticCategory.Error, "Class_static_side_0_incorrectly_extends_base_class_static_side_1_2417", "Class static side '{0}' incorrectly extends base class static side '{1}'."),
        Type_of_computed_property_s_value_is_0_which_is_not_assignable_to_type_1: diag(2418, ts.DiagnosticCategory.Error, "Type_of_computed_property_s_value_is_0_which_is_not_assignable_to_type_1_2418", "Type of computed property's value is '{0}', which is not assignable to type '{1}'."),
        Types_of_construct_signatures_are_incompatible: diag(2419, ts.DiagnosticCategory.Error, "Types_of_construct_signatures_are_incompatible_2419", "Types of construct signatures are incompatible."),
        Class_0_incorrectly_implements_interface_1: diag(2420, ts.DiagnosticCategory.Error, "Class_0_incorrectly_implements_interface_1_2420", "Class '{0}' incorrectly implements interface '{1}'."),
        A_class_can_only_implement_an_object_type_or_intersection_of_object_types_with_statically_known_members: diag(2422, ts.DiagnosticCategory.Error, "A_class_can_only_implement_an_object_type_or_intersection_of_object_types_with_statically_known_memb_2422", "A class can only implement an object type or intersection of object types with statically known members."),
        Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_accessor: diag(2423, ts.DiagnosticCategory.Error, "Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_access_2423", "Class '{0}' defines instance member function '{1}', but extended class '{2}' defines it as instance member accessor."),
        Class_0_defines_instance_member_property_1_but_extended_class_2_defines_it_as_instance_member_function: diag(2425, ts.DiagnosticCategory.Error, "Class_0_defines_instance_member_property_1_but_extended_class_2_defines_it_as_instance_member_functi_2425", "Class '{0}' defines instance member property '{1}', but extended class '{2}' defines it as instance member function."),
        Class_0_defines_instance_member_accessor_1_but_extended_class_2_defines_it_as_instance_member_function: diag(2426, ts.DiagnosticCategory.Error, "Class_0_defines_instance_member_accessor_1_but_extended_class_2_defines_it_as_instance_member_functi_2426", "Class '{0}' defines instance member accessor '{1}', but extended class '{2}' defines it as instance member function."),
        Interface_name_cannot_be_0: diag(2427, ts.DiagnosticCategory.Error, "Interface_name_cannot_be_0_2427", "Interface name cannot be '{0}'."),
        All_declarations_of_0_must_have_identical_type_parameters: diag(2428, ts.DiagnosticCategory.Error, "All_declarations_of_0_must_have_identical_type_parameters_2428", "All declarations of '{0}' must have identical type parameters."),
        Interface_0_incorrectly_extends_interface_1: diag(2430, ts.DiagnosticCategory.Error, "Interface_0_incorrectly_extends_interface_1_2430", "Interface '{0}' incorrectly extends interface '{1}'."),
        Enum_name_cannot_be_0: diag(2431, ts.DiagnosticCategory.Error, "Enum_name_cannot_be_0_2431", "Enum name cannot be '{0}'."),
        In_an_enum_with_multiple_declarations_only_one_declaration_can_omit_an_initializer_for_its_first_enum_element: diag(2432, ts.DiagnosticCategory.Error, "In_an_enum_with_multiple_declarations_only_one_declaration_can_omit_an_initializer_for_its_first_enu_2432", "In an enum with multiple declarations, only one declaration can omit an initializer for its first enum element."),
        A_namespace_declaration_cannot_be_in_a_different_file_from_a_class_or_function_with_which_it_is_merged: diag(2433, ts.DiagnosticCategory.Error, "A_namespace_declaration_cannot_be_in_a_different_file_from_a_class_or_function_with_which_it_is_merg_2433", "A namespace declaration cannot be in a different file from a class or function with which it is merged."),
        A_namespace_declaration_cannot_be_located_prior_to_a_class_or_function_with_which_it_is_merged: diag(2434, ts.DiagnosticCategory.Error, "A_namespace_declaration_cannot_be_located_prior_to_a_class_or_function_with_which_it_is_merged_2434", "A namespace declaration cannot be located prior to a class or function with which it is merged."),
        Ambient_modules_cannot_be_nested_in_other_modules_or_namespaces: diag(2435, ts.DiagnosticCategory.Error, "Ambient_modules_cannot_be_nested_in_other_modules_or_namespaces_2435", "Ambient modules cannot be nested in other modules or namespaces."),
        Ambient_module_declaration_cannot_specify_relative_module_name: diag(2436, ts.DiagnosticCategory.Error, "Ambient_module_declaration_cannot_specify_relative_module_name_2436", "Ambient module declaration cannot specify relative module name."),
        Module_0_is_hidden_by_a_local_declaration_with_the_same_name: diag(2437, ts.DiagnosticCategory.Error, "Module_0_is_hidden_by_a_local_declaration_with_the_same_name_2437", "Module '{0}' is hidden by a local declaration with the same name."),
        Import_name_cannot_be_0: diag(2438, ts.DiagnosticCategory.Error, "Import_name_cannot_be_0_2438", "Import name cannot be '{0}'."),
        Import_or_export_declaration_in_an_ambient_module_declaration_cannot_reference_module_through_relative_module_name: diag(2439, ts.DiagnosticCategory.Error, "Import_or_export_declaration_in_an_ambient_module_declaration_cannot_reference_module_through_relati_2439", "Import or export declaration in an ambient module declaration cannot reference module through relative module name."),
        Import_declaration_conflicts_with_local_declaration_of_0: diag(2440, ts.DiagnosticCategory.Error, "Import_declaration_conflicts_with_local_declaration_of_0_2440", "Import declaration conflicts with local declaration of '{0}'."),
        Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_a_module: diag(2441, ts.DiagnosticCategory.Error, "Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_a_module_2441", "Duplicate identifier '{0}'. Compiler reserves name '{1}' in top level scope of a module."),
        Types_have_separate_declarations_of_a_private_property_0: diag(2442, ts.DiagnosticCategory.Error, "Types_have_separate_declarations_of_a_private_property_0_2442", "Types have separate declarations of a private property '{0}'."),
        Property_0_is_protected_but_type_1_is_not_a_class_derived_from_2: diag(2443, ts.DiagnosticCategory.Error, "Property_0_is_protected_but_type_1_is_not_a_class_derived_from_2_2443", "Property '{0}' is protected but type '{1}' is not a class derived from '{2}'."),
        Property_0_is_protected_in_type_1_but_public_in_type_2: diag(2444, ts.DiagnosticCategory.Error, "Property_0_is_protected_in_type_1_but_public_in_type_2_2444", "Property '{0}' is protected in type '{1}' but public in type '{2}'."),
        Property_0_is_protected_and_only_accessible_within_class_1_and_its_subclasses: diag(2445, ts.DiagnosticCategory.Error, "Property_0_is_protected_and_only_accessible_within_class_1_and_its_subclasses_2445", "Property '{0}' is protected and only accessible within class '{1}' and its subclasses."),
        Property_0_is_protected_and_only_accessible_through_an_instance_of_class_1_This_is_an_instance_of_class_2: diag(2446, ts.DiagnosticCategory.Error, "Property_0_is_protected_and_only_accessible_through_an_instance_of_class_1_This_is_an_instance_of_cl_2446", "Property '{0}' is protected and only accessible through an instance of class '{1}'. This is an instance of class '{2}'."),
        The_0_operator_is_not_allowed_for_boolean_types_Consider_using_1_instead: diag(2447, ts.DiagnosticCategory.Error, "The_0_operator_is_not_allowed_for_boolean_types_Consider_using_1_instead_2447", "The '{0}' operator is not allowed for boolean types. Consider using '{1}' instead."),
        Block_scoped_variable_0_used_before_its_declaration: diag(2448, ts.DiagnosticCategory.Error, "Block_scoped_variable_0_used_before_its_declaration_2448", "Block-scoped variable '{0}' used before its declaration."),
        Class_0_used_before_its_declaration: diag(2449, ts.DiagnosticCategory.Error, "Class_0_used_before_its_declaration_2449", "Class '{0}' used before its declaration."),
        Enum_0_used_before_its_declaration: diag(2450, ts.DiagnosticCategory.Error, "Enum_0_used_before_its_declaration_2450", "Enum '{0}' used before its declaration."),
        Cannot_redeclare_block_scoped_variable_0: diag(2451, ts.DiagnosticCategory.Error, "Cannot_redeclare_block_scoped_variable_0_2451", "Cannot redeclare block-scoped variable '{0}'."),
        An_enum_member_cannot_have_a_numeric_name: diag(2452, ts.DiagnosticCategory.Error, "An_enum_member_cannot_have_a_numeric_name_2452", "An enum member cannot have a numeric name."),
        Variable_0_is_used_before_being_assigned: diag(2454, ts.DiagnosticCategory.Error, "Variable_0_is_used_before_being_assigned_2454", "Variable '{0}' is used before being assigned."),
        Type_alias_0_circularly_references_itself: diag(2456, ts.DiagnosticCategory.Error, "Type_alias_0_circularly_references_itself_2456", "Type alias '{0}' circularly references itself."),
        Type_alias_name_cannot_be_0: diag(2457, ts.DiagnosticCategory.Error, "Type_alias_name_cannot_be_0_2457", "Type alias name cannot be '{0}'."),
        An_AMD_module_cannot_have_multiple_name_assignments: diag(2458, ts.DiagnosticCategory.Error, "An_AMD_module_cannot_have_multiple_name_assignments_2458", "An AMD module cannot have multiple name assignments."),
        Module_0_declares_1_locally_but_it_is_not_exported: diag(2459, ts.DiagnosticCategory.Error, "Module_0_declares_1_locally_but_it_is_not_exported_2459", "Module '{0}' declares '{1}' locally, but it is not exported."),
        Module_0_declares_1_locally_but_it_is_exported_as_2: diag(2460, ts.DiagnosticCategory.Error, "Module_0_declares_1_locally_but_it_is_exported_as_2_2460", "Module '{0}' declares '{1}' locally, but it is exported as '{2}'."),
        Type_0_is_not_an_array_type: diag(2461, ts.DiagnosticCategory.Error, "Type_0_is_not_an_array_type_2461", "Type '{0}' is not an array type."),
        A_rest_element_must_be_last_in_a_destructuring_pattern: diag(2462, ts.DiagnosticCategory.Error, "A_rest_element_must_be_last_in_a_destructuring_pattern_2462", "A rest element must be last in a destructuring pattern."),
        A_binding_pattern_parameter_cannot_be_optional_in_an_implementation_signature: diag(2463, ts.DiagnosticCategory.Error, "A_binding_pattern_parameter_cannot_be_optional_in_an_implementation_signature_2463", "A binding pattern parameter cannot be optional in an implementation signature."),
        A_computed_property_name_must_be_of_type_string_number_symbol_or_any: diag(2464, ts.DiagnosticCategory.Error, "A_computed_property_name_must_be_of_type_string_number_symbol_or_any_2464", "A computed property name must be of type 'string', 'number', 'symbol', or 'any'."),
        this_cannot_be_referenced_in_a_computed_property_name: diag(2465, ts.DiagnosticCategory.Error, "this_cannot_be_referenced_in_a_computed_property_name_2465", "'this' cannot be referenced in a computed property name."),
        super_cannot_be_referenced_in_a_computed_property_name: diag(2466, ts.DiagnosticCategory.Error, "super_cannot_be_referenced_in_a_computed_property_name_2466", "'super' cannot be referenced in a computed property name."),
        A_computed_property_name_cannot_reference_a_type_parameter_from_its_containing_type: diag(2467, ts.DiagnosticCategory.Error, "A_computed_property_name_cannot_reference_a_type_parameter_from_its_containing_type_2467", "A computed property name cannot reference a type parameter from its containing type."),
        Cannot_find_global_value_0: diag(2468, ts.DiagnosticCategory.Error, "Cannot_find_global_value_0_2468", "Cannot find global value '{0}'."),
        The_0_operator_cannot_be_applied_to_type_symbol: diag(2469, ts.DiagnosticCategory.Error, "The_0_operator_cannot_be_applied_to_type_symbol_2469", "The '{0}' operator cannot be applied to type 'symbol'."),
        Spread_operator_in_new_expressions_is_only_available_when_targeting_ECMAScript_5_and_higher: diag(2472, ts.DiagnosticCategory.Error, "Spread_operator_in_new_expressions_is_only_available_when_targeting_ECMAScript_5_and_higher_2472", "Spread operator in 'new' expressions is only available when targeting ECMAScript 5 and higher."),
        Enum_declarations_must_all_be_const_or_non_const: diag(2473, ts.DiagnosticCategory.Error, "Enum_declarations_must_all_be_const_or_non_const_2473", "Enum declarations must all be const or non-const."),
        const_enum_member_initializers_can_only_contain_literal_values_and_other_computed_enum_values: diag(2474, ts.DiagnosticCategory.Error, "const_enum_member_initializers_can_only_contain_literal_values_and_other_computed_enum_values_2474", "const enum member initializers can only contain literal values and other computed enum values."),
        const_enums_can_only_be_used_in_property_or_index_access_expressions_or_the_right_hand_side_of_an_import_declaration_or_export_assignment_or_type_query: diag(2475, ts.DiagnosticCategory.Error, "const_enums_can_only_be_used_in_property_or_index_access_expressions_or_the_right_hand_side_of_an_im_2475", "'const' enums can only be used in property or index access expressions or the right hand side of an import declaration or export assignment or type query."),
        A_const_enum_member_can_only_be_accessed_using_a_string_literal: diag(2476, ts.DiagnosticCategory.Error, "A_const_enum_member_can_only_be_accessed_using_a_string_literal_2476", "A const enum member can only be accessed using a string literal."),
        const_enum_member_initializer_was_evaluated_to_a_non_finite_value: diag(2477, ts.DiagnosticCategory.Error, "const_enum_member_initializer_was_evaluated_to_a_non_finite_value_2477", "'const' enum member initializer was evaluated to a non-finite value."),
        const_enum_member_initializer_was_evaluated_to_disallowed_value_NaN: diag(2478, ts.DiagnosticCategory.Error, "const_enum_member_initializer_was_evaluated_to_disallowed_value_NaN_2478", "'const' enum member initializer was evaluated to disallowed value 'NaN'."),
        let_is_not_allowed_to_be_used_as_a_name_in_let_or_const_declarations: diag(2480, ts.DiagnosticCategory.Error, "let_is_not_allowed_to_be_used_as_a_name_in_let_or_const_declarations_2480", "'let' is not allowed to be used as a name in 'let' or 'const' declarations."),
        Cannot_initialize_outer_scoped_variable_0_in_the_same_scope_as_block_scoped_declaration_1: diag(2481, ts.DiagnosticCategory.Error, "Cannot_initialize_outer_scoped_variable_0_in_the_same_scope_as_block_scoped_declaration_1_2481", "Cannot initialize outer scoped variable '{0}' in the same scope as block scoped declaration '{1}'."),
        The_left_hand_side_of_a_for_of_statement_cannot_use_a_type_annotation: diag(2483, ts.DiagnosticCategory.Error, "The_left_hand_side_of_a_for_of_statement_cannot_use_a_type_annotation_2483", "The left-hand side of a 'for...of' statement cannot use a type annotation."),
        Export_declaration_conflicts_with_exported_declaration_of_0: diag(2484, ts.DiagnosticCategory.Error, "Export_declaration_conflicts_with_exported_declaration_of_0_2484", "Export declaration conflicts with exported declaration of '{0}'."),
        The_left_hand_side_of_a_for_of_statement_must_be_a_variable_or_a_property_access: diag(2487, ts.DiagnosticCategory.Error, "The_left_hand_side_of_a_for_of_statement_must_be_a_variable_or_a_property_access_2487", "The left-hand side of a 'for...of' statement must be a variable or a property access."),
        Type_0_must_have_a_Symbol_iterator_method_that_returns_an_iterator: diag(2488, ts.DiagnosticCategory.Error, "Type_0_must_have_a_Symbol_iterator_method_that_returns_an_iterator_2488", "Type '{0}' must have a '[Symbol.iterator]()' method that returns an iterator."),
        An_iterator_must_have_a_next_method: diag(2489, ts.DiagnosticCategory.Error, "An_iterator_must_have_a_next_method_2489", "An iterator must have a 'next()' method."),
        The_type_returned_by_the_0_method_of_an_iterator_must_have_a_value_property: diag(2490, ts.DiagnosticCategory.Error, "The_type_returned_by_the_0_method_of_an_iterator_must_have_a_value_property_2490", "The type returned by the '{0}()' method of an iterator must have a 'value' property."),
        The_left_hand_side_of_a_for_in_statement_cannot_be_a_destructuring_pattern: diag(2491, ts.DiagnosticCategory.Error, "The_left_hand_side_of_a_for_in_statement_cannot_be_a_destructuring_pattern_2491", "The left-hand side of a 'for...in' statement cannot be a destructuring pattern."),
        Cannot_redeclare_identifier_0_in_catch_clause: diag(2492, ts.DiagnosticCategory.Error, "Cannot_redeclare_identifier_0_in_catch_clause_2492", "Cannot redeclare identifier '{0}' in catch clause."),
        Tuple_type_0_of_length_1_has_no_element_at_index_2: diag(2493, ts.DiagnosticCategory.Error, "Tuple_type_0_of_length_1_has_no_element_at_index_2_2493", "Tuple type '{0}' of length '{1}' has no element at index '{2}'."),
        Using_a_string_in_a_for_of_statement_is_only_supported_in_ECMAScript_5_and_higher: diag(2494, ts.DiagnosticCategory.Error, "Using_a_string_in_a_for_of_statement_is_only_supported_in_ECMAScript_5_and_higher_2494", "Using a string in a 'for...of' statement is only supported in ECMAScript 5 and higher."),
        Type_0_is_not_an_array_type_or_a_string_type: diag(2495, ts.DiagnosticCategory.Error, "Type_0_is_not_an_array_type_or_a_string_type_2495", "Type '{0}' is not an array type or a string type."),
        The_arguments_object_cannot_be_referenced_in_an_arrow_function_in_ES3_and_ES5_Consider_using_a_standard_function_expression: diag(2496, ts.DiagnosticCategory.Error, "The_arguments_object_cannot_be_referenced_in_an_arrow_function_in_ES3_and_ES5_Consider_using_a_stand_2496", "The 'arguments' object cannot be referenced in an arrow function in ES3 and ES5. Consider using a standard function expression."),
        This_module_can_only_be_referenced_with_ECMAScript_imports_Slashexports_by_turning_on_the_0_flag_and_referencing_its_default_export: diag(2497, ts.DiagnosticCategory.Error, "This_module_can_only_be_referenced_with_ECMAScript_imports_Slashexports_by_turning_on_the_0_flag_and_2497", "This module can only be referenced with ECMAScript imports/exports by turning on the '{0}' flag and referencing its default export."),
        Module_0_uses_export_and_cannot_be_used_with_export_Asterisk: diag(2498, ts.DiagnosticCategory.Error, "Module_0_uses_export_and_cannot_be_used_with_export_Asterisk_2498", "Module '{0}' uses 'export =' and cannot be used with 'export *'."),
        An_interface_can_only_extend_an_identifier_Slashqualified_name_with_optional_type_arguments: diag(2499, ts.DiagnosticCategory.Error, "An_interface_can_only_extend_an_identifier_Slashqualified_name_with_optional_type_arguments_2499", "An interface can only extend an identifier/qualified-name with optional type arguments."),
        A_class_can_only_implement_an_identifier_Slashqualified_name_with_optional_type_arguments: diag(2500, ts.DiagnosticCategory.Error, "A_class_can_only_implement_an_identifier_Slashqualified_name_with_optional_type_arguments_2500", "A class can only implement an identifier/qualified-name with optional type arguments."),
        A_rest_element_cannot_contain_a_binding_pattern: diag(2501, ts.DiagnosticCategory.Error, "A_rest_element_cannot_contain_a_binding_pattern_2501", "A rest element cannot contain a binding pattern."),
        _0_is_referenced_directly_or_indirectly_in_its_own_type_annotation: diag(2502, ts.DiagnosticCategory.Error, "_0_is_referenced_directly_or_indirectly_in_its_own_type_annotation_2502", "'{0}' is referenced directly or indirectly in its own type annotation."),
        Cannot_find_namespace_0: diag(2503, ts.DiagnosticCategory.Error, "Cannot_find_namespace_0_2503", "Cannot find namespace '{0}'."),
        Type_0_must_have_a_Symbol_asyncIterator_method_that_returns_an_async_iterator: diag(2504, ts.DiagnosticCategory.Error, "Type_0_must_have_a_Symbol_asyncIterator_method_that_returns_an_async_iterator_2504", "Type '{0}' must have a '[Symbol.asyncIterator]()' method that returns an async iterator."),
        A_generator_cannot_have_a_void_type_annotation: diag(2505, ts.DiagnosticCategory.Error, "A_generator_cannot_have_a_void_type_annotation_2505", "A generator cannot have a 'void' type annotation."),
        _0_is_referenced_directly_or_indirectly_in_its_own_base_expression: diag(2506, ts.DiagnosticCategory.Error, "_0_is_referenced_directly_or_indirectly_in_its_own_base_expression_2506", "'{0}' is referenced directly or indirectly in its own base expression."),
        Type_0_is_not_a_constructor_function_type: diag(2507, ts.DiagnosticCategory.Error, "Type_0_is_not_a_constructor_function_type_2507", "Type '{0}' is not a constructor function type."),
        No_base_constructor_has_the_specified_number_of_type_arguments: diag(2508, ts.DiagnosticCategory.Error, "No_base_constructor_has_the_specified_number_of_type_arguments_2508", "No base constructor has the specified number of type arguments."),
        Base_constructor_return_type_0_is_not_an_object_type_or_intersection_of_object_types_with_statically_known_members: diag(2509, ts.DiagnosticCategory.Error, "Base_constructor_return_type_0_is_not_an_object_type_or_intersection_of_object_types_with_statically_2509", "Base constructor return type '{0}' is not an object type or intersection of object types with statically known members."),
        Base_constructors_must_all_have_the_same_return_type: diag(2510, ts.DiagnosticCategory.Error, "Base_constructors_must_all_have_the_same_return_type_2510", "Base constructors must all have the same return type."),
        Cannot_create_an_instance_of_an_abstract_class: diag(2511, ts.DiagnosticCategory.Error, "Cannot_create_an_instance_of_an_abstract_class_2511", "Cannot create an instance of an abstract class."),
        Overload_signatures_must_all_be_abstract_or_non_abstract: diag(2512, ts.DiagnosticCategory.Error, "Overload_signatures_must_all_be_abstract_or_non_abstract_2512", "Overload signatures must all be abstract or non-abstract."),
        Abstract_method_0_in_class_1_cannot_be_accessed_via_super_expression: diag(2513, ts.DiagnosticCategory.Error, "Abstract_method_0_in_class_1_cannot_be_accessed_via_super_expression_2513", "Abstract method '{0}' in class '{1}' cannot be accessed via super expression."),
        Non_abstract_class_0_does_not_implement_inherited_abstract_member_1_from_class_2: diag(2515, ts.DiagnosticCategory.Error, "Non_abstract_class_0_does_not_implement_inherited_abstract_member_1_from_class_2_2515", "Non-abstract class '{0}' does not implement inherited abstract member '{1}' from class '{2}'."),
        All_declarations_of_an_abstract_method_must_be_consecutive: diag(2516, ts.DiagnosticCategory.Error, "All_declarations_of_an_abstract_method_must_be_consecutive_2516", "All declarations of an abstract method must be consecutive."),
        Cannot_assign_an_abstract_constructor_type_to_a_non_abstract_constructor_type: diag(2517, ts.DiagnosticCategory.Error, "Cannot_assign_an_abstract_constructor_type_to_a_non_abstract_constructor_type_2517", "Cannot assign an abstract constructor type to a non-abstract constructor type."),
        A_this_based_type_guard_is_not_compatible_with_a_parameter_based_type_guard: diag(2518, ts.DiagnosticCategory.Error, "A_this_based_type_guard_is_not_compatible_with_a_parameter_based_type_guard_2518", "A 'this'-based type guard is not compatible with a parameter-based type guard."),
        An_async_iterator_must_have_a_next_method: diag(2519, ts.DiagnosticCategory.Error, "An_async_iterator_must_have_a_next_method_2519", "An async iterator must have a 'next()' method."),
        Duplicate_identifier_0_Compiler_uses_declaration_1_to_support_async_functions: diag(2520, ts.DiagnosticCategory.Error, "Duplicate_identifier_0_Compiler_uses_declaration_1_to_support_async_functions_2520", "Duplicate identifier '{0}'. Compiler uses declaration '{1}' to support async functions."),
        The_arguments_object_cannot_be_referenced_in_an_async_function_or_method_in_ES3_and_ES5_Consider_using_a_standard_function_or_method: diag(2522, ts.DiagnosticCategory.Error, "The_arguments_object_cannot_be_referenced_in_an_async_function_or_method_in_ES3_and_ES5_Consider_usi_2522", "The 'arguments' object cannot be referenced in an async function or method in ES3 and ES5. Consider using a standard function or method."),
        yield_expressions_cannot_be_used_in_a_parameter_initializer: diag(2523, ts.DiagnosticCategory.Error, "yield_expressions_cannot_be_used_in_a_parameter_initializer_2523", "'yield' expressions cannot be used in a parameter initializer."),
        await_expressions_cannot_be_used_in_a_parameter_initializer: diag(2524, ts.DiagnosticCategory.Error, "await_expressions_cannot_be_used_in_a_parameter_initializer_2524", "'await' expressions cannot be used in a parameter initializer."),
        Initializer_provides_no_value_for_this_binding_element_and_the_binding_element_has_no_default_value: diag(2525, ts.DiagnosticCategory.Error, "Initializer_provides_no_value_for_this_binding_element_and_the_binding_element_has_no_default_value_2525", "Initializer provides no value for this binding element and the binding element has no default value."),
        A_this_type_is_available_only_in_a_non_static_member_of_a_class_or_interface: diag(2526, ts.DiagnosticCategory.Error, "A_this_type_is_available_only_in_a_non_static_member_of_a_class_or_interface_2526", "A 'this' type is available only in a non-static member of a class or interface."),
        The_inferred_type_of_0_references_an_inaccessible_1_type_A_type_annotation_is_necessary: diag(2527, ts.DiagnosticCategory.Error, "The_inferred_type_of_0_references_an_inaccessible_1_type_A_type_annotation_is_necessary_2527", "The inferred type of '{0}' references an inaccessible '{1}' type. A type annotation is necessary."),
        A_module_cannot_have_multiple_default_exports: diag(2528, ts.DiagnosticCategory.Error, "A_module_cannot_have_multiple_default_exports_2528", "A module cannot have multiple default exports."),
        Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_a_module_containing_async_functions: diag(2529, ts.DiagnosticCategory.Error, "Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_a_module_containing_async_func_2529", "Duplicate identifier '{0}'. Compiler reserves name '{1}' in top level scope of a module containing async functions."),
        Property_0_is_incompatible_with_index_signature: diag(2530, ts.DiagnosticCategory.Error, "Property_0_is_incompatible_with_index_signature_2530", "Property '{0}' is incompatible with index signature."),
        Object_is_possibly_null: diag(2531, ts.DiagnosticCategory.Error, "Object_is_possibly_null_2531", "Object is possibly 'null'."),
        Object_is_possibly_undefined: diag(2532, ts.DiagnosticCategory.Error, "Object_is_possibly_undefined_2532", "Object is possibly 'undefined'."),
        Object_is_possibly_null_or_undefined: diag(2533, ts.DiagnosticCategory.Error, "Object_is_possibly_null_or_undefined_2533", "Object is possibly 'null' or 'undefined'."),
        A_function_returning_never_cannot_have_a_reachable_end_point: diag(2534, ts.DiagnosticCategory.Error, "A_function_returning_never_cannot_have_a_reachable_end_point_2534", "A function returning 'never' cannot have a reachable end point."),
        Enum_type_0_has_members_with_initializers_that_are_not_literals: diag(2535, ts.DiagnosticCategory.Error, "Enum_type_0_has_members_with_initializers_that_are_not_literals_2535", "Enum type '{0}' has members with initializers that are not literals."),
        Type_0_cannot_be_used_to_index_type_1: diag(2536, ts.DiagnosticCategory.Error, "Type_0_cannot_be_used_to_index_type_1_2536", "Type '{0}' cannot be used to index type '{1}'."),
        Type_0_has_no_matching_index_signature_for_type_1: diag(2537, ts.DiagnosticCategory.Error, "Type_0_has_no_matching_index_signature_for_type_1_2537", "Type '{0}' has no matching index signature for type '{1}'."),
        Type_0_cannot_be_used_as_an_index_type: diag(2538, ts.DiagnosticCategory.Error, "Type_0_cannot_be_used_as_an_index_type_2538", "Type '{0}' cannot be used as an index type."),
        Cannot_assign_to_0_because_it_is_not_a_variable: diag(2539, ts.DiagnosticCategory.Error, "Cannot_assign_to_0_because_it_is_not_a_variable_2539", "Cannot assign to '{0}' because it is not a variable."),
        Cannot_assign_to_0_because_it_is_a_read_only_property: diag(2540, ts.DiagnosticCategory.Error, "Cannot_assign_to_0_because_it_is_a_read_only_property_2540", "Cannot assign to '{0}' because it is a read-only property."),
        Index_signature_in_type_0_only_permits_reading: diag(2542, ts.DiagnosticCategory.Error, "Index_signature_in_type_0_only_permits_reading_2542", "Index signature in type '{0}' only permits reading."),
        Duplicate_identifier_newTarget_Compiler_uses_variable_declaration_newTarget_to_capture_new_target_meta_property_reference: diag(2543, ts.DiagnosticCategory.Error, "Duplicate_identifier_newTarget_Compiler_uses_variable_declaration_newTarget_to_capture_new_target_me_2543", "Duplicate identifier '_newTarget'. Compiler uses variable declaration '_newTarget' to capture 'new.target' meta-property reference."),
        Expression_resolves_to_variable_declaration_newTarget_that_compiler_uses_to_capture_new_target_meta_property_reference: diag(2544, ts.DiagnosticCategory.Error, "Expression_resolves_to_variable_declaration_newTarget_that_compiler_uses_to_capture_new_target_meta__2544", "Expression resolves to variable declaration '_newTarget' that compiler uses to capture 'new.target' meta-property reference."),
        A_mixin_class_must_have_a_constructor_with_a_single_rest_parameter_of_type_any: diag(2545, ts.DiagnosticCategory.Error, "A_mixin_class_must_have_a_constructor_with_a_single_rest_parameter_of_type_any_2545", "A mixin class must have a constructor with a single rest parameter of type 'any[]'."),
        The_type_returned_by_the_0_method_of_an_async_iterator_must_be_a_promise_for_a_type_with_a_value_property: diag(2547, ts.DiagnosticCategory.Error, "The_type_returned_by_the_0_method_of_an_async_iterator_must_be_a_promise_for_a_type_with_a_value_pro_2547", "The type returned by the '{0}()' method of an async iterator must be a promise for a type with a 'value' property."),
        Type_0_is_not_an_array_type_or_does_not_have_a_Symbol_iterator_method_that_returns_an_iterator: diag(2548, ts.DiagnosticCategory.Error, "Type_0_is_not_an_array_type_or_does_not_have_a_Symbol_iterator_method_that_returns_an_iterator_2548", "Type '{0}' is not an array type or does not have a '[Symbol.iterator]()' method that returns an iterator."),
        Type_0_is_not_an_array_type_or_a_string_type_or_does_not_have_a_Symbol_iterator_method_that_returns_an_iterator: diag(2549, ts.DiagnosticCategory.Error, "Type_0_is_not_an_array_type_or_a_string_type_or_does_not_have_a_Symbol_iterator_method_that_returns__2549", "Type '{0}' is not an array type or a string type or does not have a '[Symbol.iterator]()' method that returns an iterator."),
        Property_0_does_not_exist_on_type_1_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_2_or_later: diag(2550, ts.DiagnosticCategory.Error, "Property_0_does_not_exist_on_type_1_Do_you_need_to_change_your_target_library_Try_changing_the_lib_c_2550", "Property '{0}' does not exist on type '{1}'. Do you need to change your target library? Try changing the 'lib' compiler option to '{2}' or later."),
        Property_0_does_not_exist_on_type_1_Did_you_mean_2: diag(2551, ts.DiagnosticCategory.Error, "Property_0_does_not_exist_on_type_1_Did_you_mean_2_2551", "Property '{0}' does not exist on type '{1}'. Did you mean '{2}'?"),
        Cannot_find_name_0_Did_you_mean_1: diag(2552, ts.DiagnosticCategory.Error, "Cannot_find_name_0_Did_you_mean_1_2552", "Cannot find name '{0}'. Did you mean '{1}'?"),
        Computed_values_are_not_permitted_in_an_enum_with_string_valued_members: diag(2553, ts.DiagnosticCategory.Error, "Computed_values_are_not_permitted_in_an_enum_with_string_valued_members_2553", "Computed values are not permitted in an enum with string valued members."),
        Expected_0_arguments_but_got_1: diag(2554, ts.DiagnosticCategory.Error, "Expected_0_arguments_but_got_1_2554", "Expected {0} arguments, but got {1}."),
        Expected_at_least_0_arguments_but_got_1: diag(2555, ts.DiagnosticCategory.Error, "Expected_at_least_0_arguments_but_got_1_2555", "Expected at least {0} arguments, but got {1}."),
        A_spread_argument_must_either_have_a_tuple_type_or_be_passed_to_a_rest_parameter: diag(2556, ts.DiagnosticCategory.Error, "A_spread_argument_must_either_have_a_tuple_type_or_be_passed_to_a_rest_parameter_2556", "A spread argument must either have a tuple type or be passed to a rest parameter."),
        Expected_0_type_arguments_but_got_1: diag(2558, ts.DiagnosticCategory.Error, "Expected_0_type_arguments_but_got_1_2558", "Expected {0} type arguments, but got {1}."),
        Type_0_has_no_properties_in_common_with_type_1: diag(2559, ts.DiagnosticCategory.Error, "Type_0_has_no_properties_in_common_with_type_1_2559", "Type '{0}' has no properties in common with type '{1}'."),
        Value_of_type_0_has_no_properties_in_common_with_type_1_Did_you_mean_to_call_it: diag(2560, ts.DiagnosticCategory.Error, "Value_of_type_0_has_no_properties_in_common_with_type_1_Did_you_mean_to_call_it_2560", "Value of type '{0}' has no properties in common with type '{1}'. Did you mean to call it?"),
        Object_literal_may_only_specify_known_properties_but_0_does_not_exist_in_type_1_Did_you_mean_to_write_2: diag(2561, ts.DiagnosticCategory.Error, "Object_literal_may_only_specify_known_properties_but_0_does_not_exist_in_type_1_Did_you_mean_to_writ_2561", "Object literal may only specify known properties, but '{0}' does not exist in type '{1}'. Did you mean to write '{2}'?"),
        Base_class_expressions_cannot_reference_class_type_parameters: diag(2562, ts.DiagnosticCategory.Error, "Base_class_expressions_cannot_reference_class_type_parameters_2562", "Base class expressions cannot reference class type parameters."),
        The_containing_function_or_module_body_is_too_large_for_control_flow_analysis: diag(2563, ts.DiagnosticCategory.Error, "The_containing_function_or_module_body_is_too_large_for_control_flow_analysis_2563", "The containing function or module body is too large for control flow analysis."),
        Property_0_has_no_initializer_and_is_not_definitely_assigned_in_the_constructor: diag(2564, ts.DiagnosticCategory.Error, "Property_0_has_no_initializer_and_is_not_definitely_assigned_in_the_constructor_2564", "Property '{0}' has no initializer and is not definitely assigned in the constructor."),
        Property_0_is_used_before_being_assigned: diag(2565, ts.DiagnosticCategory.Error, "Property_0_is_used_before_being_assigned_2565", "Property '{0}' is used before being assigned."),
        A_rest_element_cannot_have_a_property_name: diag(2566, ts.DiagnosticCategory.Error, "A_rest_element_cannot_have_a_property_name_2566", "A rest element cannot have a property name."),
        Enum_declarations_can_only_merge_with_namespace_or_other_enum_declarations: diag(2567, ts.DiagnosticCategory.Error, "Enum_declarations_can_only_merge_with_namespace_or_other_enum_declarations_2567", "Enum declarations can only merge with namespace or other enum declarations."),
        Property_0_may_not_exist_on_type_1_Did_you_mean_2: diag(2568, ts.DiagnosticCategory.Error, "Property_0_may_not_exist_on_type_1_Did_you_mean_2_2568", "Property '{0}' may not exist on type '{1}'. Did you mean '{2}'?"),
        Could_not_find_name_0_Did_you_mean_1: diag(2570, ts.DiagnosticCategory.Error, "Could_not_find_name_0_Did_you_mean_1_2570", "Could not find name '{0}'. Did you mean '{1}'?"),
        Object_is_of_type_unknown: diag(2571, ts.DiagnosticCategory.Error, "Object_is_of_type_unknown_2571", "Object is of type 'unknown'."),
        A_rest_element_type_must_be_an_array_type: diag(2574, ts.DiagnosticCategory.Error, "A_rest_element_type_must_be_an_array_type_2574", "A rest element type must be an array type."),
        No_overload_expects_0_arguments_but_overloads_do_exist_that_expect_either_1_or_2_arguments: diag(2575, ts.DiagnosticCategory.Error, "No_overload_expects_0_arguments_but_overloads_do_exist_that_expect_either_1_or_2_arguments_2575", "No overload expects {0} arguments, but overloads do exist that expect either {1} or {2} arguments."),
        Property_0_does_not_exist_on_type_1_Did_you_mean_to_access_the_static_member_2_instead: diag(2576, ts.DiagnosticCategory.Error, "Property_0_does_not_exist_on_type_1_Did_you_mean_to_access_the_static_member_2_instead_2576", "Property '{0}' does not exist on type '{1}'. Did you mean to access the static member '{2}' instead?"),
        Return_type_annotation_circularly_references_itself: diag(2577, ts.DiagnosticCategory.Error, "Return_type_annotation_circularly_references_itself_2577", "Return type annotation circularly references itself."),
        Unused_ts_expect_error_directive: diag(2578, ts.DiagnosticCategory.Error, "Unused_ts_expect_error_directive_2578", "Unused '@ts-expect-error' directive."),
        Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_node_Try_npm_i_save_dev_types_Slashnode: diag(2580, ts.DiagnosticCategory.Error, "Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_node_Try_npm_i_save_dev_types_Slashno_2580", "Cannot find name '{0}'. Do you need to install type definitions for node? Try `npm i --save-dev @types/node`."),
        Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_jQuery_Try_npm_i_save_dev_types_Slashjquery: diag(2581, ts.DiagnosticCategory.Error, "Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_jQuery_Try_npm_i_save_dev_types_Slash_2581", "Cannot find name '{0}'. Do you need to install type definitions for jQuery? Try `npm i --save-dev @types/jquery`."),
        Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_a_test_runner_Try_npm_i_save_dev_types_Slashjest_or_npm_i_save_dev_types_Slashmocha: diag(2582, ts.DiagnosticCategory.Error, "Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_a_test_runner_Try_npm_i_save_dev_type_2582", "Cannot find name '{0}'. Do you need to install type definitions for a test runner? Try `npm i --save-dev @types/jest` or `npm i --save-dev @types/mocha`."),
        Cannot_find_name_0_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_1_or_later: diag(2583, ts.DiagnosticCategory.Error, "Cannot_find_name_0_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_2583", "Cannot find name '{0}'. Do you need to change your target library? Try changing the 'lib' compiler option to '{1}' or later."),
        Cannot_find_name_0_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_include_dom: diag(2584, ts.DiagnosticCategory.Error, "Cannot_find_name_0_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_2584", "Cannot find name '{0}'. Do you need to change your target library? Try changing the 'lib' compiler option to include 'dom'."),
        _0_only_refers_to_a_type_but_is_being_used_as_a_value_here_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_es2015_or_later: diag(2585, ts.DiagnosticCategory.Error, "_0_only_refers_to_a_type_but_is_being_used_as_a_value_here_Do_you_need_to_change_your_target_library_2585", "'{0}' only refers to a type, but is being used as a value here. Do you need to change your target library? Try changing the 'lib' compiler option to es2015 or later."),
        Cannot_assign_to_0_because_it_is_a_constant: diag(2588, ts.DiagnosticCategory.Error, "Cannot_assign_to_0_because_it_is_a_constant_2588", "Cannot assign to '{0}' because it is a constant."),
        Type_instantiation_is_excessively_deep_and_possibly_infinite: diag(2589, ts.DiagnosticCategory.Error, "Type_instantiation_is_excessively_deep_and_possibly_infinite_2589", "Type instantiation is excessively deep and possibly infinite."),
        Expression_produces_a_union_type_that_is_too_complex_to_represent: diag(2590, ts.DiagnosticCategory.Error, "Expression_produces_a_union_type_that_is_too_complex_to_represent_2590", "Expression produces a union type that is too complex to represent."),
        Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_node_Try_npm_i_save_dev_types_Slashnode_and_then_add_node_to_the_types_field_in_your_tsconfig: diag(2591, ts.DiagnosticCategory.Error, "Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_node_Try_npm_i_save_dev_types_Slashno_2591", "Cannot find name '{0}'. Do you need to install type definitions for node? Try `npm i --save-dev @types/node` and then add 'node' to the types field in your tsconfig."),
        Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_jQuery_Try_npm_i_save_dev_types_Slashjquery_and_then_add_jquery_to_the_types_field_in_your_tsconfig: diag(2592, ts.DiagnosticCategory.Error, "Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_jQuery_Try_npm_i_save_dev_types_Slash_2592", "Cannot find name '{0}'. Do you need to install type definitions for jQuery? Try `npm i --save-dev @types/jquery` and then add 'jquery' to the types field in your tsconfig."),
        Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_a_test_runner_Try_npm_i_save_dev_types_Slashjest_or_npm_i_save_dev_types_Slashmocha_and_then_add_jest_or_mocha_to_the_types_field_in_your_tsconfig: diag(2593, ts.DiagnosticCategory.Error, "Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_a_test_runner_Try_npm_i_save_dev_type_2593", "Cannot find name '{0}'. Do you need to install type definitions for a test runner? Try `npm i --save-dev @types/jest` or `npm i --save-dev @types/mocha` and then add 'jest' or 'mocha' to the types field in your tsconfig."),
        This_module_is_declared_with_using_export_and_can_only_be_used_with_a_default_import_when_using_the_0_flag: diag(2594, ts.DiagnosticCategory.Error, "This_module_is_declared_with_using_export_and_can_only_be_used_with_a_default_import_when_using_the__2594", "This module is declared with using 'export =', and can only be used with a default import when using the '{0}' flag."),
        _0_can_only_be_imported_by_using_a_default_import: diag(2595, ts.DiagnosticCategory.Error, "_0_can_only_be_imported_by_using_a_default_import_2595", "'{0}' can only be imported by using a default import."),
        _0_can_only_be_imported_by_turning_on_the_esModuleInterop_flag_and_using_a_default_import: diag(2596, ts.DiagnosticCategory.Error, "_0_can_only_be_imported_by_turning_on_the_esModuleInterop_flag_and_using_a_default_import_2596", "'{0}' can only be imported by turning on the 'esModuleInterop' flag and using a default import."),
        _0_can_only_be_imported_by_using_a_require_call_or_by_using_a_default_import: diag(2597, ts.DiagnosticCategory.Error, "_0_can_only_be_imported_by_using_a_require_call_or_by_using_a_default_import_2597", "'{0}' can only be imported by using a 'require' call or by using a default import."),
        _0_can_only_be_imported_by_using_a_require_call_or_by_turning_on_the_esModuleInterop_flag_and_using_a_default_import: diag(2598, ts.DiagnosticCategory.Error, "_0_can_only_be_imported_by_using_a_require_call_or_by_turning_on_the_esModuleInterop_flag_and_using__2598", "'{0}' can only be imported by using a 'require' call or by turning on the 'esModuleInterop' flag and using a default import."),
        JSX_element_implicitly_has_type_any_because_the_global_type_JSX_Element_does_not_exist: diag(2602, ts.DiagnosticCategory.Error, "JSX_element_implicitly_has_type_any_because_the_global_type_JSX_Element_does_not_exist_2602", "JSX element implicitly has type 'any' because the global type 'JSX.Element' does not exist."),
        Property_0_in_type_1_is_not_assignable_to_type_2: diag(2603, ts.DiagnosticCategory.Error, "Property_0_in_type_1_is_not_assignable_to_type_2_2603", "Property '{0}' in type '{1}' is not assignable to type '{2}'."),
        JSX_element_type_0_does_not_have_any_construct_or_call_signatures: diag(2604, ts.DiagnosticCategory.Error, "JSX_element_type_0_does_not_have_any_construct_or_call_signatures_2604", "JSX element type '{0}' does not have any construct or call signatures."),
        Property_0_of_JSX_spread_attribute_is_not_assignable_to_target_property: diag(2606, ts.DiagnosticCategory.Error, "Property_0_of_JSX_spread_attribute_is_not_assignable_to_target_property_2606", "Property '{0}' of JSX spread attribute is not assignable to target property."),
        JSX_element_class_does_not_support_attributes_because_it_does_not_have_a_0_property: diag(2607, ts.DiagnosticCategory.Error, "JSX_element_class_does_not_support_attributes_because_it_does_not_have_a_0_property_2607", "JSX element class does not support attributes because it does not have a '{0}' property."),
        The_global_type_JSX_0_may_not_have_more_than_one_property: diag(2608, ts.DiagnosticCategory.Error, "The_global_type_JSX_0_may_not_have_more_than_one_property_2608", "The global type 'JSX.{0}' may not have more than one property."),
        JSX_spread_child_must_be_an_array_type: diag(2609, ts.DiagnosticCategory.Error, "JSX_spread_child_must_be_an_array_type_2609", "JSX spread child must be an array type."),
        _0_is_defined_as_an_accessor_in_class_1_but_is_overridden_here_in_2_as_an_instance_property: diag(2610, ts.DiagnosticCategory.Error, "_0_is_defined_as_an_accessor_in_class_1_but_is_overridden_here_in_2_as_an_instance_property_2610", "'{0}' is defined as an accessor in class '{1}', but is overridden here in '{2}' as an instance property."),
        _0_is_defined_as_a_property_in_class_1_but_is_overridden_here_in_2_as_an_accessor: diag(2611, ts.DiagnosticCategory.Error, "_0_is_defined_as_a_property_in_class_1_but_is_overridden_here_in_2_as_an_accessor_2611", "'{0}' is defined as a property in class '{1}', but is overridden here in '{2}' as an accessor."),
        Property_0_will_overwrite_the_base_property_in_1_If_this_is_intentional_add_an_initializer_Otherwise_add_a_declare_modifier_or_remove_the_redundant_declaration: diag(2612, ts.DiagnosticCategory.Error, "Property_0_will_overwrite_the_base_property_in_1_If_this_is_intentional_add_an_initializer_Otherwise_2612", "Property '{0}' will overwrite the base property in '{1}'. If this is intentional, add an initializer. Otherwise, add a 'declare' modifier or remove the redundant declaration."),
        Module_0_has_no_default_export_Did_you_mean_to_use_import_1_from_0_instead: diag(2613, ts.DiagnosticCategory.Error, "Module_0_has_no_default_export_Did_you_mean_to_use_import_1_from_0_instead_2613", "Module '{0}' has no default export. Did you mean to use 'import { {1} } from {0}' instead?"),
        Module_0_has_no_exported_member_1_Did_you_mean_to_use_import_1_from_0_instead: diag(2614, ts.DiagnosticCategory.Error, "Module_0_has_no_exported_member_1_Did_you_mean_to_use_import_1_from_0_instead_2614", "Module '{0}' has no exported member '{1}'. Did you mean to use 'import {1} from {0}' instead?"),
        Type_of_property_0_circularly_references_itself_in_mapped_type_1: diag(2615, ts.DiagnosticCategory.Error, "Type_of_property_0_circularly_references_itself_in_mapped_type_1_2615", "Type of property '{0}' circularly references itself in mapped type '{1}'."),
        _0_can_only_be_imported_by_using_import_1_require_2_or_a_default_import: diag(2616, ts.DiagnosticCategory.Error, "_0_can_only_be_imported_by_using_import_1_require_2_or_a_default_import_2616", "'{0}' can only be imported by using 'import {1} = require({2})' or a default import."),
        _0_can_only_be_imported_by_using_import_1_require_2_or_by_turning_on_the_esModuleInterop_flag_and_using_a_default_import: diag(2617, ts.DiagnosticCategory.Error, "_0_can_only_be_imported_by_using_import_1_require_2_or_by_turning_on_the_esModuleInterop_flag_and_us_2617", "'{0}' can only be imported by using 'import {1} = require({2})' or by turning on the 'esModuleInterop' flag and using a default import."),
        Source_has_0_element_s_but_target_requires_1: diag(2618, ts.DiagnosticCategory.Error, "Source_has_0_element_s_but_target_requires_1_2618", "Source has {0} element(s) but target requires {1}."),
        Source_has_0_element_s_but_target_allows_only_1: diag(2619, ts.DiagnosticCategory.Error, "Source_has_0_element_s_but_target_allows_only_1_2619", "Source has {0} element(s) but target allows only {1}."),
        Target_requires_0_element_s_but_source_may_have_fewer: diag(2620, ts.DiagnosticCategory.Error, "Target_requires_0_element_s_but_source_may_have_fewer_2620", "Target requires {0} element(s) but source may have fewer."),
        Target_allows_only_0_element_s_but_source_may_have_more: diag(2621, ts.DiagnosticCategory.Error, "Target_allows_only_0_element_s_but_source_may_have_more_2621", "Target allows only {0} element(s) but source may have more."),
        Source_provides_no_match_for_required_element_at_position_0_in_target: diag(2623, ts.DiagnosticCategory.Error, "Source_provides_no_match_for_required_element_at_position_0_in_target_2623", "Source provides no match for required element at position {0} in target."),
        Source_provides_no_match_for_variadic_element_at_position_0_in_target: diag(2624, ts.DiagnosticCategory.Error, "Source_provides_no_match_for_variadic_element_at_position_0_in_target_2624", "Source provides no match for variadic element at position {0} in target."),
        Variadic_element_at_position_0_in_source_does_not_match_element_at_position_1_in_target: diag(2625, ts.DiagnosticCategory.Error, "Variadic_element_at_position_0_in_source_does_not_match_element_at_position_1_in_target_2625", "Variadic element at position {0} in source does not match element at position {1} in target."),
        Type_at_position_0_in_source_is_not_compatible_with_type_at_position_1_in_target: diag(2626, ts.DiagnosticCategory.Error, "Type_at_position_0_in_source_is_not_compatible_with_type_at_position_1_in_target_2626", "Type at position {0} in source is not compatible with type at position {1} in target."),
        Type_at_positions_0_through_1_in_source_is_not_compatible_with_type_at_position_2_in_target: diag(2627, ts.DiagnosticCategory.Error, "Type_at_positions_0_through_1_in_source_is_not_compatible_with_type_at_position_2_in_target_2627", "Type at positions {0} through {1} in source is not compatible with type at position {2} in target."),
        Cannot_assign_to_0_because_it_is_an_enum: diag(2628, ts.DiagnosticCategory.Error, "Cannot_assign_to_0_because_it_is_an_enum_2628", "Cannot assign to '{0}' because it is an enum."),
        Cannot_assign_to_0_because_it_is_a_class: diag(2629, ts.DiagnosticCategory.Error, "Cannot_assign_to_0_because_it_is_a_class_2629", "Cannot assign to '{0}' because it is a class."),
        Cannot_assign_to_0_because_it_is_a_function: diag(2630, ts.DiagnosticCategory.Error, "Cannot_assign_to_0_because_it_is_a_function_2630", "Cannot assign to '{0}' because it is a function."),
        Cannot_assign_to_0_because_it_is_a_namespace: diag(2631, ts.DiagnosticCategory.Error, "Cannot_assign_to_0_because_it_is_a_namespace_2631", "Cannot assign to '{0}' because it is a namespace."),
        Cannot_assign_to_0_because_it_is_an_import: diag(2632, ts.DiagnosticCategory.Error, "Cannot_assign_to_0_because_it_is_an_import_2632", "Cannot assign to '{0}' because it is an import."),
        JSX_property_access_expressions_cannot_include_JSX_namespace_names: diag(2633, ts.DiagnosticCategory.Error, "JSX_property_access_expressions_cannot_include_JSX_namespace_names_2633", "JSX property access expressions cannot include JSX namespace names"),
        _0_index_signatures_are_incompatible: diag(2634, ts.DiagnosticCategory.Error, "_0_index_signatures_are_incompatible_2634", "'{0}' index signatures are incompatible."),
        Type_0_has_no_signatures_for_which_the_type_argument_list_is_applicable: diag(2635, ts.DiagnosticCategory.Error, "Type_0_has_no_signatures_for_which_the_type_argument_list_is_applicable_2635", "Type '{0}' has no signatures for which the type argument list is applicable."),
        Type_0_is_not_assignable_to_type_1_as_implied_by_variance_annotation: diag(2636, ts.DiagnosticCategory.Error, "Type_0_is_not_assignable_to_type_1_as_implied_by_variance_annotation_2636", "Type '{0}' is not assignable to type '{1}' as implied by variance annotation."),
        Variance_annotations_are_only_supported_in_type_aliases_for_object_function_constructor_and_mapped_types: diag(2637, ts.DiagnosticCategory.Error, "Variance_annotations_are_only_supported_in_type_aliases_for_object_function_constructor_and_mapped_t_2637", "Variance annotations are only supported in type aliases for object, function, constructor, and mapped types."),
        Cannot_augment_module_0_with_value_exports_because_it_resolves_to_a_non_module_entity: diag(2649, ts.DiagnosticCategory.Error, "Cannot_augment_module_0_with_value_exports_because_it_resolves_to_a_non_module_entity_2649", "Cannot augment module '{0}' with value exports because it resolves to a non-module entity."),
        A_member_initializer_in_a_enum_declaration_cannot_reference_members_declared_after_it_including_members_defined_in_other_enums: diag(2651, ts.DiagnosticCategory.Error, "A_member_initializer_in_a_enum_declaration_cannot_reference_members_declared_after_it_including_memb_2651", "A member initializer in a enum declaration cannot reference members declared after it, including members defined in other enums."),
        Merged_declaration_0_cannot_include_a_default_export_declaration_Consider_adding_a_separate_export_default_0_declaration_instead: diag(2652, ts.DiagnosticCategory.Error, "Merged_declaration_0_cannot_include_a_default_export_declaration_Consider_adding_a_separate_export_d_2652", "Merged declaration '{0}' cannot include a default export declaration. Consider adding a separate 'export default {0}' declaration instead."),
        Non_abstract_class_expression_does_not_implement_inherited_abstract_member_0_from_class_1: diag(2653, ts.DiagnosticCategory.Error, "Non_abstract_class_expression_does_not_implement_inherited_abstract_member_0_from_class_1_2653", "Non-abstract class expression does not implement inherited abstract member '{0}' from class '{1}'."),
        JSX_expressions_must_have_one_parent_element: diag(2657, ts.DiagnosticCategory.Error, "JSX_expressions_must_have_one_parent_element_2657", "JSX expressions must have one parent element."),
        Type_0_provides_no_match_for_the_signature_1: diag(2658, ts.DiagnosticCategory.Error, "Type_0_provides_no_match_for_the_signature_1_2658", "Type '{0}' provides no match for the signature '{1}'."),
        super_is_only_allowed_in_members_of_object_literal_expressions_when_option_target_is_ES2015_or_higher: diag(2659, ts.DiagnosticCategory.Error, "super_is_only_allowed_in_members_of_object_literal_expressions_when_option_target_is_ES2015_or_highe_2659", "'super' is only allowed in members of object literal expressions when option 'target' is 'ES2015' or higher."),
        super_can_only_be_referenced_in_members_of_derived_classes_or_object_literal_expressions: diag(2660, ts.DiagnosticCategory.Error, "super_can_only_be_referenced_in_members_of_derived_classes_or_object_literal_expressions_2660", "'super' can only be referenced in members of derived classes or object literal expressions."),
        Cannot_export_0_Only_local_declarations_can_be_exported_from_a_module: diag(2661, ts.DiagnosticCategory.Error, "Cannot_export_0_Only_local_declarations_can_be_exported_from_a_module_2661", "Cannot export '{0}'. Only local declarations can be exported from a module."),
        Cannot_find_name_0_Did_you_mean_the_static_member_1_0: diag(2662, ts.DiagnosticCategory.Error, "Cannot_find_name_0_Did_you_mean_the_static_member_1_0_2662", "Cannot find name '{0}'. Did you mean the static member '{1}.{0}'?"),
        Cannot_find_name_0_Did_you_mean_the_instance_member_this_0: diag(2663, ts.DiagnosticCategory.Error, "Cannot_find_name_0_Did_you_mean_the_instance_member_this_0_2663", "Cannot find name '{0}'. Did you mean the instance member 'this.{0}'?"),
        Invalid_module_name_in_augmentation_module_0_cannot_be_found: diag(2664, ts.DiagnosticCategory.Error, "Invalid_module_name_in_augmentation_module_0_cannot_be_found_2664", "Invalid module name in augmentation, module '{0}' cannot be found."),
        Invalid_module_name_in_augmentation_Module_0_resolves_to_an_untyped_module_at_1_which_cannot_be_augmented: diag(2665, ts.DiagnosticCategory.Error, "Invalid_module_name_in_augmentation_Module_0_resolves_to_an_untyped_module_at_1_which_cannot_be_augm_2665", "Invalid module name in augmentation. Module '{0}' resolves to an untyped module at '{1}', which cannot be augmented."),
        Exports_and_export_assignments_are_not_permitted_in_module_augmentations: diag(2666, ts.DiagnosticCategory.Error, "Exports_and_export_assignments_are_not_permitted_in_module_augmentations_2666", "Exports and export assignments are not permitted in module augmentations."),
        Imports_are_not_permitted_in_module_augmentations_Consider_moving_them_to_the_enclosing_external_module: diag(2667, ts.DiagnosticCategory.Error, "Imports_are_not_permitted_in_module_augmentations_Consider_moving_them_to_the_enclosing_external_mod_2667", "Imports are not permitted in module augmentations. Consider moving them to the enclosing external module."),
        export_modifier_cannot_be_applied_to_ambient_modules_and_module_augmentations_since_they_are_always_visible: diag(2668, ts.DiagnosticCategory.Error, "export_modifier_cannot_be_applied_to_ambient_modules_and_module_augmentations_since_they_are_always__2668", "'export' modifier cannot be applied to ambient modules and module augmentations since they are always visible."),
        Augmentations_for_the_global_scope_can_only_be_directly_nested_in_external_modules_or_ambient_module_declarations: diag(2669, ts.DiagnosticCategory.Error, "Augmentations_for_the_global_scope_can_only_be_directly_nested_in_external_modules_or_ambient_module_2669", "Augmentations for the global scope can only be directly nested in external modules or ambient module declarations."),
        Augmentations_for_the_global_scope_should_have_declare_modifier_unless_they_appear_in_already_ambient_context: diag(2670, ts.DiagnosticCategory.Error, "Augmentations_for_the_global_scope_should_have_declare_modifier_unless_they_appear_in_already_ambien_2670", "Augmentations for the global scope should have 'declare' modifier unless they appear in already ambient context."),
        Cannot_augment_module_0_because_it_resolves_to_a_non_module_entity: diag(2671, ts.DiagnosticCategory.Error, "Cannot_augment_module_0_because_it_resolves_to_a_non_module_entity_2671", "Cannot augment module '{0}' because it resolves to a non-module entity."),
        Cannot_assign_a_0_constructor_type_to_a_1_constructor_type: diag(2672, ts.DiagnosticCategory.Error, "Cannot_assign_a_0_constructor_type_to_a_1_constructor_type_2672", "Cannot assign a '{0}' constructor type to a '{1}' constructor type."),
        Constructor_of_class_0_is_private_and_only_accessible_within_the_class_declaration: diag(2673, ts.DiagnosticCategory.Error, "Constructor_of_class_0_is_private_and_only_accessible_within_the_class_declaration_2673", "Constructor of class '{0}' is private and only accessible within the class declaration."),
        Constructor_of_class_0_is_protected_and_only_accessible_within_the_class_declaration: diag(2674, ts.DiagnosticCategory.Error, "Constructor_of_class_0_is_protected_and_only_accessible_within_the_class_declaration_2674", "Constructor of class '{0}' is protected and only accessible within the class declaration."),
        Cannot_extend_a_class_0_Class_constructor_is_marked_as_private: diag(2675, ts.DiagnosticCategory.Error, "Cannot_extend_a_class_0_Class_constructor_is_marked_as_private_2675", "Cannot extend a class '{0}'. Class constructor is marked as private."),
        Accessors_must_both_be_abstract_or_non_abstract: diag(2676, ts.DiagnosticCategory.Error, "Accessors_must_both_be_abstract_or_non_abstract_2676", "Accessors must both be abstract or non-abstract."),
        A_type_predicate_s_type_must_be_assignable_to_its_parameter_s_type: diag(2677, ts.DiagnosticCategory.Error, "A_type_predicate_s_type_must_be_assignable_to_its_parameter_s_type_2677", "A type predicate's type must be assignable to its parameter's type."),
        Type_0_is_not_comparable_to_type_1: diag(2678, ts.DiagnosticCategory.Error, "Type_0_is_not_comparable_to_type_1_2678", "Type '{0}' is not comparable to type '{1}'."),
        A_function_that_is_called_with_the_new_keyword_cannot_have_a_this_type_that_is_void: diag(2679, ts.DiagnosticCategory.Error, "A_function_that_is_called_with_the_new_keyword_cannot_have_a_this_type_that_is_void_2679", "A function that is called with the 'new' keyword cannot have a 'this' type that is 'void'."),
        A_0_parameter_must_be_the_first_parameter: diag(2680, ts.DiagnosticCategory.Error, "A_0_parameter_must_be_the_first_parameter_2680", "A '{0}' parameter must be the first parameter."),
        A_constructor_cannot_have_a_this_parameter: diag(2681, ts.DiagnosticCategory.Error, "A_constructor_cannot_have_a_this_parameter_2681", "A constructor cannot have a 'this' parameter."),
        this_implicitly_has_type_any_because_it_does_not_have_a_type_annotation: diag(2683, ts.DiagnosticCategory.Error, "this_implicitly_has_type_any_because_it_does_not_have_a_type_annotation_2683", "'this' implicitly has type 'any' because it does not have a type annotation."),
        The_this_context_of_type_0_is_not_assignable_to_method_s_this_of_type_1: diag(2684, ts.DiagnosticCategory.Error, "The_this_context_of_type_0_is_not_assignable_to_method_s_this_of_type_1_2684", "The 'this' context of type '{0}' is not assignable to method's 'this' of type '{1}'."),
        The_this_types_of_each_signature_are_incompatible: diag(2685, ts.DiagnosticCategory.Error, "The_this_types_of_each_signature_are_incompatible_2685", "The 'this' types of each signature are incompatible."),
        _0_refers_to_a_UMD_global_but_the_current_file_is_a_module_Consider_adding_an_import_instead: diag(2686, ts.DiagnosticCategory.Error, "_0_refers_to_a_UMD_global_but_the_current_file_is_a_module_Consider_adding_an_import_instead_2686", "'{0}' refers to a UMD global, but the current file is a module. Consider adding an import instead."),
        All_declarations_of_0_must_have_identical_modifiers: diag(2687, ts.DiagnosticCategory.Error, "All_declarations_of_0_must_have_identical_modifiers_2687", "All declarations of '{0}' must have identical modifiers."),
        Cannot_find_type_definition_file_for_0: diag(2688, ts.DiagnosticCategory.Error, "Cannot_find_type_definition_file_for_0_2688", "Cannot find type definition file for '{0}'."),
        Cannot_extend_an_interface_0_Did_you_mean_implements: diag(2689, ts.DiagnosticCategory.Error, "Cannot_extend_an_interface_0_Did_you_mean_implements_2689", "Cannot extend an interface '{0}'. Did you mean 'implements'?"),
        _0_only_refers_to_a_type_but_is_being_used_as_a_value_here_Did_you_mean_to_use_1_in_0: diag(2690, ts.DiagnosticCategory.Error, "_0_only_refers_to_a_type_but_is_being_used_as_a_value_here_Did_you_mean_to_use_1_in_0_2690", "'{0}' only refers to a type, but is being used as a value here. Did you mean to use '{1} in {0}'?"),
        An_import_path_cannot_end_with_a_0_extension_Consider_importing_1_instead: diag(2691, ts.DiagnosticCategory.Error, "An_import_path_cannot_end_with_a_0_extension_Consider_importing_1_instead_2691", "An import path cannot end with a '{0}' extension. Consider importing '{1}' instead."),
        _0_is_a_primitive_but_1_is_a_wrapper_object_Prefer_using_0_when_possible: diag(2692, ts.DiagnosticCategory.Error, "_0_is_a_primitive_but_1_is_a_wrapper_object_Prefer_using_0_when_possible_2692", "'{0}' is a primitive, but '{1}' is a wrapper object. Prefer using '{0}' when possible."),
        _0_only_refers_to_a_type_but_is_being_used_as_a_value_here: diag(2693, ts.DiagnosticCategory.Error, "_0_only_refers_to_a_type_but_is_being_used_as_a_value_here_2693", "'{0}' only refers to a type, but is being used as a value here."),
        Namespace_0_has_no_exported_member_1: diag(2694, ts.DiagnosticCategory.Error, "Namespace_0_has_no_exported_member_1_2694", "Namespace '{0}' has no exported member '{1}'."),
        Left_side_of_comma_operator_is_unused_and_has_no_side_effects: diag(2695, ts.DiagnosticCategory.Error, "Left_side_of_comma_operator_is_unused_and_has_no_side_effects_2695", "Left side of comma operator is unused and has no side effects.", true),
        The_Object_type_is_assignable_to_very_few_other_types_Did_you_mean_to_use_the_any_type_instead: diag(2696, ts.DiagnosticCategory.Error, "The_Object_type_is_assignable_to_very_few_other_types_Did_you_mean_to_use_the_any_type_instead_2696", "The 'Object' type is assignable to very few other types. Did you mean to use the 'any' type instead?"),
        An_async_function_or_method_must_return_a_Promise_Make_sure_you_have_a_declaration_for_Promise_or_include_ES2015_in_your_lib_option: diag(2697, ts.DiagnosticCategory.Error, "An_async_function_or_method_must_return_a_Promise_Make_sure_you_have_a_declaration_for_Promise_or_in_2697", "An async function or method must return a 'Promise'. Make sure you have a declaration for 'Promise' or include 'ES2015' in your '--lib' option."),
        Spread_types_may_only_be_created_from_object_types: diag(2698, ts.DiagnosticCategory.Error, "Spread_types_may_only_be_created_from_object_types_2698", "Spread types may only be created from object types."),
        Static_property_0_conflicts_with_built_in_property_Function_0_of_constructor_function_1: diag(2699, ts.DiagnosticCategory.Error, "Static_property_0_conflicts_with_built_in_property_Function_0_of_constructor_function_1_2699", "Static property '{0}' conflicts with built-in property 'Function.{0}' of constructor function '{1}'."),
        Rest_types_may_only_be_created_from_object_types: diag(2700, ts.DiagnosticCategory.Error, "Rest_types_may_only_be_created_from_object_types_2700", "Rest types may only be created from object types."),
        The_target_of_an_object_rest_assignment_must_be_a_variable_or_a_property_access: diag(2701, ts.DiagnosticCategory.Error, "The_target_of_an_object_rest_assignment_must_be_a_variable_or_a_property_access_2701", "The target of an object rest assignment must be a variable or a property access."),
        _0_only_refers_to_a_type_but_is_being_used_as_a_namespace_here: diag(2702, ts.DiagnosticCategory.Error, "_0_only_refers_to_a_type_but_is_being_used_as_a_namespace_here_2702", "'{0}' only refers to a type, but is being used as a namespace here."),
        The_operand_of_a_delete_operator_must_be_a_property_reference: diag(2703, ts.DiagnosticCategory.Error, "The_operand_of_a_delete_operator_must_be_a_property_reference_2703", "The operand of a 'delete' operator must be a property reference."),
        The_operand_of_a_delete_operator_cannot_be_a_read_only_property: diag(2704, ts.DiagnosticCategory.Error, "The_operand_of_a_delete_operator_cannot_be_a_read_only_property_2704", "The operand of a 'delete' operator cannot be a read-only property."),
        An_async_function_or_method_in_ES5_SlashES3_requires_the_Promise_constructor_Make_sure_you_have_a_declaration_for_the_Promise_constructor_or_include_ES2015_in_your_lib_option: diag(2705, ts.DiagnosticCategory.Error, "An_async_function_or_method_in_ES5_SlashES3_requires_the_Promise_constructor_Make_sure_you_have_a_de_2705", "An async function or method in ES5/ES3 requires the 'Promise' constructor.  Make sure you have a declaration for the 'Promise' constructor or include 'ES2015' in your '--lib' option."),
        Required_type_parameters_may_not_follow_optional_type_parameters: diag(2706, ts.DiagnosticCategory.Error, "Required_type_parameters_may_not_follow_optional_type_parameters_2706", "Required type parameters may not follow optional type parameters."),
        Generic_type_0_requires_between_1_and_2_type_arguments: diag(2707, ts.DiagnosticCategory.Error, "Generic_type_0_requires_between_1_and_2_type_arguments_2707", "Generic type '{0}' requires between {1} and {2} type arguments."),
        Cannot_use_namespace_0_as_a_value: diag(2708, ts.DiagnosticCategory.Error, "Cannot_use_namespace_0_as_a_value_2708", "Cannot use namespace '{0}' as a value."),
        Cannot_use_namespace_0_as_a_type: diag(2709, ts.DiagnosticCategory.Error, "Cannot_use_namespace_0_as_a_type_2709", "Cannot use namespace '{0}' as a type."),
        _0_are_specified_twice_The_attribute_named_0_will_be_overwritten: diag(2710, ts.DiagnosticCategory.Error, "_0_are_specified_twice_The_attribute_named_0_will_be_overwritten_2710", "'{0}' are specified twice. The attribute named '{0}' will be overwritten."),
        A_dynamic_import_call_returns_a_Promise_Make_sure_you_have_a_declaration_for_Promise_or_include_ES2015_in_your_lib_option: diag(2711, ts.DiagnosticCategory.Error, "A_dynamic_import_call_returns_a_Promise_Make_sure_you_have_a_declaration_for_Promise_or_include_ES20_2711", "A dynamic import call returns a 'Promise'. Make sure you have a declaration for 'Promise' or include 'ES2015' in your '--lib' option."),
        A_dynamic_import_call_in_ES5_SlashES3_requires_the_Promise_constructor_Make_sure_you_have_a_declaration_for_the_Promise_constructor_or_include_ES2015_in_your_lib_option: diag(2712, ts.DiagnosticCategory.Error, "A_dynamic_import_call_in_ES5_SlashES3_requires_the_Promise_constructor_Make_sure_you_have_a_declarat_2712", "A dynamic import call in ES5/ES3 requires the 'Promise' constructor.  Make sure you have a declaration for the 'Promise' constructor or include 'ES2015' in your '--lib' option."),
        Cannot_access_0_1_because_0_is_a_type_but_not_a_namespace_Did_you_mean_to_retrieve_the_type_of_the_property_1_in_0_with_0_1: diag(2713, ts.DiagnosticCategory.Error, "Cannot_access_0_1_because_0_is_a_type_but_not_a_namespace_Did_you_mean_to_retrieve_the_type_of_the_p_2713", "Cannot access '{0}.{1}' because '{0}' is a type, but not a namespace. Did you mean to retrieve the type of the property '{1}' in '{0}' with '{0}[\"{1}\"]'?"),
        The_expression_of_an_export_assignment_must_be_an_identifier_or_qualified_name_in_an_ambient_context: diag(2714, ts.DiagnosticCategory.Error, "The_expression_of_an_export_assignment_must_be_an_identifier_or_qualified_name_in_an_ambient_context_2714", "The expression of an export assignment must be an identifier or qualified name in an ambient context."),
        Abstract_property_0_in_class_1_cannot_be_accessed_in_the_constructor: diag(2715, ts.DiagnosticCategory.Error, "Abstract_property_0_in_class_1_cannot_be_accessed_in_the_constructor_2715", "Abstract property '{0}' in class '{1}' cannot be accessed in the constructor."),
        Type_parameter_0_has_a_circular_default: diag(2716, ts.DiagnosticCategory.Error, "Type_parameter_0_has_a_circular_default_2716", "Type parameter '{0}' has a circular default."),
        Subsequent_property_declarations_must_have_the_same_type_Property_0_must_be_of_type_1_but_here_has_type_2: diag(2717, ts.DiagnosticCategory.Error, "Subsequent_property_declarations_must_have_the_same_type_Property_0_must_be_of_type_1_but_here_has_t_2717", "Subsequent property declarations must have the same type.  Property '{0}' must be of type '{1}', but here has type '{2}'."),
        Duplicate_property_0: diag(2718, ts.DiagnosticCategory.Error, "Duplicate_property_0_2718", "Duplicate property '{0}'."),
        Type_0_is_not_assignable_to_type_1_Two_different_types_with_this_name_exist_but_they_are_unrelated: diag(2719, ts.DiagnosticCategory.Error, "Type_0_is_not_assignable_to_type_1_Two_different_types_with_this_name_exist_but_they_are_unrelated_2719", "Type '{0}' is not assignable to type '{1}'. Two different types with this name exist, but they are unrelated."),
        Class_0_incorrectly_implements_class_1_Did_you_mean_to_extend_1_and_inherit_its_members_as_a_subclass: diag(2720, ts.DiagnosticCategory.Error, "Class_0_incorrectly_implements_class_1_Did_you_mean_to_extend_1_and_inherit_its_members_as_a_subclas_2720", "Class '{0}' incorrectly implements class '{1}'. Did you mean to extend '{1}' and inherit its members as a subclass?"),
        Cannot_invoke_an_object_which_is_possibly_null: diag(2721, ts.DiagnosticCategory.Error, "Cannot_invoke_an_object_which_is_possibly_null_2721", "Cannot invoke an object which is possibly 'null'."),
        Cannot_invoke_an_object_which_is_possibly_undefined: diag(2722, ts.DiagnosticCategory.Error, "Cannot_invoke_an_object_which_is_possibly_undefined_2722", "Cannot invoke an object which is possibly 'undefined'."),
        Cannot_invoke_an_object_which_is_possibly_null_or_undefined: diag(2723, ts.DiagnosticCategory.Error, "Cannot_invoke_an_object_which_is_possibly_null_or_undefined_2723", "Cannot invoke an object which is possibly 'null' or 'undefined'."),
        _0_has_no_exported_member_named_1_Did_you_mean_2: diag(2724, ts.DiagnosticCategory.Error, "_0_has_no_exported_member_named_1_Did_you_mean_2_2724", "'{0}' has no exported member named '{1}'. Did you mean '{2}'?"),
        Class_name_cannot_be_Object_when_targeting_ES5_with_module_0: diag(2725, ts.DiagnosticCategory.Error, "Class_name_cannot_be_Object_when_targeting_ES5_with_module_0_2725", "Class name cannot be 'Object' when targeting ES5 with module {0}."),
        Cannot_find_lib_definition_for_0: diag(2726, ts.DiagnosticCategory.Error, "Cannot_find_lib_definition_for_0_2726", "Cannot find lib definition for '{0}'."),
        Cannot_find_lib_definition_for_0_Did_you_mean_1: diag(2727, ts.DiagnosticCategory.Error, "Cannot_find_lib_definition_for_0_Did_you_mean_1_2727", "Cannot find lib definition for '{0}'. Did you mean '{1}'?"),
        _0_is_declared_here: diag(2728, ts.DiagnosticCategory.Message, "_0_is_declared_here_2728", "'{0}' is declared here."),
        Property_0_is_used_before_its_initialization: diag(2729, ts.DiagnosticCategory.Error, "Property_0_is_used_before_its_initialization_2729", "Property '{0}' is used before its initialization."),
        An_arrow_function_cannot_have_a_this_parameter: diag(2730, ts.DiagnosticCategory.Error, "An_arrow_function_cannot_have_a_this_parameter_2730", "An arrow function cannot have a 'this' parameter."),
        Implicit_conversion_of_a_symbol_to_a_string_will_fail_at_runtime_Consider_wrapping_this_expression_in_String: diag(2731, ts.DiagnosticCategory.Error, "Implicit_conversion_of_a_symbol_to_a_string_will_fail_at_runtime_Consider_wrapping_this_expression_i_2731", "Implicit conversion of a 'symbol' to a 'string' will fail at runtime. Consider wrapping this expression in 'String(...)'."),
        Cannot_find_module_0_Consider_using_resolveJsonModule_to_import_module_with_json_extension: diag(2732, ts.DiagnosticCategory.Error, "Cannot_find_module_0_Consider_using_resolveJsonModule_to_import_module_with_json_extension_2732", "Cannot find module '{0}'. Consider using '--resolveJsonModule' to import module with '.json' extension."),
        Property_0_was_also_declared_here: diag(2733, ts.DiagnosticCategory.Error, "Property_0_was_also_declared_here_2733", "Property '{0}' was also declared here."),
        Are_you_missing_a_semicolon: diag(2734, ts.DiagnosticCategory.Error, "Are_you_missing_a_semicolon_2734", "Are you missing a semicolon?"),
        Did_you_mean_for_0_to_be_constrained_to_type_new_args_Colon_any_1: diag(2735, ts.DiagnosticCategory.Error, "Did_you_mean_for_0_to_be_constrained_to_type_new_args_Colon_any_1_2735", "Did you mean for '{0}' to be constrained to type 'new (...args: any[]) => {1}'?"),
        Operator_0_cannot_be_applied_to_type_1: diag(2736, ts.DiagnosticCategory.Error, "Operator_0_cannot_be_applied_to_type_1_2736", "Operator '{0}' cannot be applied to type '{1}'."),
        BigInt_literals_are_not_available_when_targeting_lower_than_ES2020: diag(2737, ts.DiagnosticCategory.Error, "BigInt_literals_are_not_available_when_targeting_lower_than_ES2020_2737", "BigInt literals are not available when targeting lower than ES2020."),
        An_outer_value_of_this_is_shadowed_by_this_container: diag(2738, ts.DiagnosticCategory.Message, "An_outer_value_of_this_is_shadowed_by_this_container_2738", "An outer value of 'this' is shadowed by this container."),
        Type_0_is_missing_the_following_properties_from_type_1_Colon_2: diag(2739, ts.DiagnosticCategory.Error, "Type_0_is_missing_the_following_properties_from_type_1_Colon_2_2739", "Type '{0}' is missing the following properties from type '{1}': {2}"),
        Type_0_is_missing_the_following_properties_from_type_1_Colon_2_and_3_more: diag(2740, ts.DiagnosticCategory.Error, "Type_0_is_missing_the_following_properties_from_type_1_Colon_2_and_3_more_2740", "Type '{0}' is missing the following properties from type '{1}': {2}, and {3} more."),
        Property_0_is_missing_in_type_1_but_required_in_type_2: diag(2741, ts.DiagnosticCategory.Error, "Property_0_is_missing_in_type_1_but_required_in_type_2_2741", "Property '{0}' is missing in type '{1}' but required in type '{2}'."),
        The_inferred_type_of_0_cannot_be_named_without_a_reference_to_1_This_is_likely_not_portable_A_type_annotation_is_necessary: diag(2742, ts.DiagnosticCategory.Error, "The_inferred_type_of_0_cannot_be_named_without_a_reference_to_1_This_is_likely_not_portable_A_type_a_2742", "The inferred type of '{0}' cannot be named without a reference to '{1}'. This is likely not portable. A type annotation is necessary."),
        No_overload_expects_0_type_arguments_but_overloads_do_exist_that_expect_either_1_or_2_type_arguments: diag(2743, ts.DiagnosticCategory.Error, "No_overload_expects_0_type_arguments_but_overloads_do_exist_that_expect_either_1_or_2_type_arguments_2743", "No overload expects {0} type arguments, but overloads do exist that expect either {1} or {2} type arguments."),
        Type_parameter_defaults_can_only_reference_previously_declared_type_parameters: diag(2744, ts.DiagnosticCategory.Error, "Type_parameter_defaults_can_only_reference_previously_declared_type_parameters_2744", "Type parameter defaults can only reference previously declared type parameters."),
        This_JSX_tag_s_0_prop_expects_type_1_which_requires_multiple_children_but_only_a_single_child_was_provided: diag(2745, ts.DiagnosticCategory.Error, "This_JSX_tag_s_0_prop_expects_type_1_which_requires_multiple_children_but_only_a_single_child_was_pr_2745", "This JSX tag's '{0}' prop expects type '{1}' which requires multiple children, but only a single child was provided."),
        This_JSX_tag_s_0_prop_expects_a_single_child_of_type_1_but_multiple_children_were_provided: diag(2746, ts.DiagnosticCategory.Error, "This_JSX_tag_s_0_prop_expects_a_single_child_of_type_1_but_multiple_children_were_provided_2746", "This JSX tag's '{0}' prop expects a single child of type '{1}', but multiple children were provided."),
        _0_components_don_t_accept_text_as_child_elements_Text_in_JSX_has_the_type_string_but_the_expected_type_of_1_is_2: diag(2747, ts.DiagnosticCategory.Error, "_0_components_don_t_accept_text_as_child_elements_Text_in_JSX_has_the_type_string_but_the_expected_t_2747", "'{0}' components don't accept text as child elements. Text in JSX has the type 'string', but the expected type of '{1}' is '{2}'."),
        Cannot_access_ambient_const_enums_when_the_isolatedModules_flag_is_provided: diag(2748, ts.DiagnosticCategory.Error, "Cannot_access_ambient_const_enums_when_the_isolatedModules_flag_is_provided_2748", "Cannot access ambient const enums when the '--isolatedModules' flag is provided."),
        _0_refers_to_a_value_but_is_being_used_as_a_type_here_Did_you_mean_typeof_0: diag(2749, ts.DiagnosticCategory.Error, "_0_refers_to_a_value_but_is_being_used_as_a_type_here_Did_you_mean_typeof_0_2749", "'{0}' refers to a value, but is being used as a type here. Did you mean 'typeof {0}'?"),
        The_implementation_signature_is_declared_here: diag(2750, ts.DiagnosticCategory.Error, "The_implementation_signature_is_declared_here_2750", "The implementation signature is declared here."),
        Circularity_originates_in_type_at_this_location: diag(2751, ts.DiagnosticCategory.Error, "Circularity_originates_in_type_at_this_location_2751", "Circularity originates in type at this location."),
        The_first_export_default_is_here: diag(2752, ts.DiagnosticCategory.Error, "The_first_export_default_is_here_2752", "The first export default is here."),
        Another_export_default_is_here: diag(2753, ts.DiagnosticCategory.Error, "Another_export_default_is_here_2753", "Another export default is here."),
        super_may_not_use_type_arguments: diag(2754, ts.DiagnosticCategory.Error, "super_may_not_use_type_arguments_2754", "'super' may not use type arguments."),
        No_constituent_of_type_0_is_callable: diag(2755, ts.DiagnosticCategory.Error, "No_constituent_of_type_0_is_callable_2755", "No constituent of type '{0}' is callable."),
        Not_all_constituents_of_type_0_are_callable: diag(2756, ts.DiagnosticCategory.Error, "Not_all_constituents_of_type_0_are_callable_2756", "Not all constituents of type '{0}' are callable."),
        Type_0_has_no_call_signatures: diag(2757, ts.DiagnosticCategory.Error, "Type_0_has_no_call_signatures_2757", "Type '{0}' has no call signatures."),
        Each_member_of_the_union_type_0_has_signatures_but_none_of_those_signatures_are_compatible_with_each_other: diag(2758, ts.DiagnosticCategory.Error, "Each_member_of_the_union_type_0_has_signatures_but_none_of_those_signatures_are_compatible_with_each_2758", "Each member of the union type '{0}' has signatures, but none of those signatures are compatible with each other."),
        No_constituent_of_type_0_is_constructable: diag(2759, ts.DiagnosticCategory.Error, "No_constituent_of_type_0_is_constructable_2759", "No constituent of type '{0}' is constructable."),
        Not_all_constituents_of_type_0_are_constructable: diag(2760, ts.DiagnosticCategory.Error, "Not_all_constituents_of_type_0_are_constructable_2760", "Not all constituents of type '{0}' are constructable."),
        Type_0_has_no_construct_signatures: diag(2761, ts.DiagnosticCategory.Error, "Type_0_has_no_construct_signatures_2761", "Type '{0}' has no construct signatures."),
        Each_member_of_the_union_type_0_has_construct_signatures_but_none_of_those_signatures_are_compatible_with_each_other: diag(2762, ts.DiagnosticCategory.Error, "Each_member_of_the_union_type_0_has_construct_signatures_but_none_of_those_signatures_are_compatible_2762", "Each member of the union type '{0}' has construct signatures, but none of those signatures are compatible with each other."),
        Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_for_of_will_always_send_0: diag(2763, ts.DiagnosticCategory.Error, "Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_for_of_will_always_s_2763", "Cannot iterate value because the 'next' method of its iterator expects type '{1}', but for-of will always send '{0}'."),
        Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_array_spread_will_always_send_0: diag(2764, ts.DiagnosticCategory.Error, "Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_array_spread_will_al_2764", "Cannot iterate value because the 'next' method of its iterator expects type '{1}', but array spread will always send '{0}'."),
        Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_array_destructuring_will_always_send_0: diag(2765, ts.DiagnosticCategory.Error, "Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_array_destructuring__2765", "Cannot iterate value because the 'next' method of its iterator expects type '{1}', but array destructuring will always send '{0}'."),
        Cannot_delegate_iteration_to_value_because_the_next_method_of_its_iterator_expects_type_1_but_the_containing_generator_will_always_send_0: diag(2766, ts.DiagnosticCategory.Error, "Cannot_delegate_iteration_to_value_because_the_next_method_of_its_iterator_expects_type_1_but_the_co_2766", "Cannot delegate iteration to value because the 'next' method of its iterator expects type '{1}', but the containing generator will always send '{0}'."),
        The_0_property_of_an_iterator_must_be_a_method: diag(2767, ts.DiagnosticCategory.Error, "The_0_property_of_an_iterator_must_be_a_method_2767", "The '{0}' property of an iterator must be a method."),
        The_0_property_of_an_async_iterator_must_be_a_method: diag(2768, ts.DiagnosticCategory.Error, "The_0_property_of_an_async_iterator_must_be_a_method_2768", "The '{0}' property of an async iterator must be a method."),
        No_overload_matches_this_call: diag(2769, ts.DiagnosticCategory.Error, "No_overload_matches_this_call_2769", "No overload matches this call."),
        The_last_overload_gave_the_following_error: diag(2770, ts.DiagnosticCategory.Error, "The_last_overload_gave_the_following_error_2770", "The last overload gave the following error."),
        The_last_overload_is_declared_here: diag(2771, ts.DiagnosticCategory.Error, "The_last_overload_is_declared_here_2771", "The last overload is declared here."),
        Overload_0_of_1_2_gave_the_following_error: diag(2772, ts.DiagnosticCategory.Error, "Overload_0_of_1_2_gave_the_following_error_2772", "Overload {0} of {1}, '{2}', gave the following error."),
        Did_you_forget_to_use_await: diag(2773, ts.DiagnosticCategory.Error, "Did_you_forget_to_use_await_2773", "Did you forget to use 'await'?"),
        This_condition_will_always_return_true_since_this_function_is_always_defined_Did_you_mean_to_call_it_instead: diag(2774, ts.DiagnosticCategory.Error, "This_condition_will_always_return_true_since_this_function_is_always_defined_Did_you_mean_to_call_it_2774", "This condition will always return true since this function is always defined. Did you mean to call it instead?"),
        Assertions_require_every_name_in_the_call_target_to_be_declared_with_an_explicit_type_annotation: diag(2775, ts.DiagnosticCategory.Error, "Assertions_require_every_name_in_the_call_target_to_be_declared_with_an_explicit_type_annotation_2775", "Assertions require every name in the call target to be declared with an explicit type annotation."),
        Assertions_require_the_call_target_to_be_an_identifier_or_qualified_name: diag(2776, ts.DiagnosticCategory.Error, "Assertions_require_the_call_target_to_be_an_identifier_or_qualified_name_2776", "Assertions require the call target to be an identifier or qualified name."),
        The_operand_of_an_increment_or_decrement_operator_may_not_be_an_optional_property_access: diag(2777, ts.DiagnosticCategory.Error, "The_operand_of_an_increment_or_decrement_operator_may_not_be_an_optional_property_access_2777", "The operand of an increment or decrement operator may not be an optional property access."),
        The_target_of_an_object_rest_assignment_may_not_be_an_optional_property_access: diag(2778, ts.DiagnosticCategory.Error, "The_target_of_an_object_rest_assignment_may_not_be_an_optional_property_access_2778", "The target of an object rest assignment may not be an optional property access."),
        The_left_hand_side_of_an_assignment_expression_may_not_be_an_optional_property_access: diag(2779, ts.DiagnosticCategory.Error, "The_left_hand_side_of_an_assignment_expression_may_not_be_an_optional_property_access_2779", "The left-hand side of an assignment expression may not be an optional property access."),
        The_left_hand_side_of_a_for_in_statement_may_not_be_an_optional_property_access: diag(2780, ts.DiagnosticCategory.Error, "The_left_hand_side_of_a_for_in_statement_may_not_be_an_optional_property_access_2780", "The left-hand side of a 'for...in' statement may not be an optional property access."),
        The_left_hand_side_of_a_for_of_statement_may_not_be_an_optional_property_access: diag(2781, ts.DiagnosticCategory.Error, "The_left_hand_side_of_a_for_of_statement_may_not_be_an_optional_property_access_2781", "The left-hand side of a 'for...of' statement may not be an optional property access."),
        _0_needs_an_explicit_type_annotation: diag(2782, ts.DiagnosticCategory.Message, "_0_needs_an_explicit_type_annotation_2782", "'{0}' needs an explicit type annotation."),
        _0_is_specified_more_than_once_so_this_usage_will_be_overwritten: diag(2783, ts.DiagnosticCategory.Error, "_0_is_specified_more_than_once_so_this_usage_will_be_overwritten_2783", "'{0}' is specified more than once, so this usage will be overwritten."),
        get_and_set_accessors_cannot_declare_this_parameters: diag(2784, ts.DiagnosticCategory.Error, "get_and_set_accessors_cannot_declare_this_parameters_2784", "'get' and 'set' accessors cannot declare 'this' parameters."),
        This_spread_always_overwrites_this_property: diag(2785, ts.DiagnosticCategory.Error, "This_spread_always_overwrites_this_property_2785", "This spread always overwrites this property."),
        _0_cannot_be_used_as_a_JSX_component: diag(2786, ts.DiagnosticCategory.Error, "_0_cannot_be_used_as_a_JSX_component_2786", "'{0}' cannot be used as a JSX component."),
        Its_return_type_0_is_not_a_valid_JSX_element: diag(2787, ts.DiagnosticCategory.Error, "Its_return_type_0_is_not_a_valid_JSX_element_2787", "Its return type '{0}' is not a valid JSX element."),
        Its_instance_type_0_is_not_a_valid_JSX_element: diag(2788, ts.DiagnosticCategory.Error, "Its_instance_type_0_is_not_a_valid_JSX_element_2788", "Its instance type '{0}' is not a valid JSX element."),
        Its_element_type_0_is_not_a_valid_JSX_element: diag(2789, ts.DiagnosticCategory.Error, "Its_element_type_0_is_not_a_valid_JSX_element_2789", "Its element type '{0}' is not a valid JSX element."),
        The_operand_of_a_delete_operator_must_be_optional: diag(2790, ts.DiagnosticCategory.Error, "The_operand_of_a_delete_operator_must_be_optional_2790", "The operand of a 'delete' operator must be optional."),
        Exponentiation_cannot_be_performed_on_bigint_values_unless_the_target_option_is_set_to_es2016_or_later: diag(2791, ts.DiagnosticCategory.Error, "Exponentiation_cannot_be_performed_on_bigint_values_unless_the_target_option_is_set_to_es2016_or_lat_2791", "Exponentiation cannot be performed on 'bigint' values unless the 'target' option is set to 'es2016' or later."),
        Cannot_find_module_0_Did_you_mean_to_set_the_moduleResolution_option_to_node_or_to_add_aliases_to_the_paths_option: diag(2792, ts.DiagnosticCategory.Error, "Cannot_find_module_0_Did_you_mean_to_set_the_moduleResolution_option_to_node_or_to_add_aliases_to_th_2792", "Cannot find module '{0}'. Did you mean to set the 'moduleResolution' option to 'node', or to add aliases to the 'paths' option?"),
        The_call_would_have_succeeded_against_this_implementation_but_implementation_signatures_of_overloads_are_not_externally_visible: diag(2793, ts.DiagnosticCategory.Error, "The_call_would_have_succeeded_against_this_implementation_but_implementation_signatures_of_overloads_2793", "The call would have succeeded against this implementation, but implementation signatures of overloads are not externally visible."),
        Expected_0_arguments_but_got_1_Did_you_forget_to_include_void_in_your_type_argument_to_Promise: diag(2794, ts.DiagnosticCategory.Error, "Expected_0_arguments_but_got_1_Did_you_forget_to_include_void_in_your_type_argument_to_Promise_2794", "Expected {0} arguments, but got {1}. Did you forget to include 'void' in your type argument to 'Promise'?"),
        The_intrinsic_keyword_can_only_be_used_to_declare_compiler_provided_intrinsic_types: diag(2795, ts.DiagnosticCategory.Error, "The_intrinsic_keyword_can_only_be_used_to_declare_compiler_provided_intrinsic_types_2795", "The 'intrinsic' keyword can only be used to declare compiler provided intrinsic types."),
        It_is_likely_that_you_are_missing_a_comma_to_separate_these_two_template_expressions_They_form_a_tagged_template_expression_which_cannot_be_invoked: diag(2796, ts.DiagnosticCategory.Error, "It_is_likely_that_you_are_missing_a_comma_to_separate_these_two_template_expressions_They_form_a_tag_2796", "It is likely that you are missing a comma to separate these two template expressions. They form a tagged template expression which cannot be invoked."),
        A_mixin_class_that_extends_from_a_type_variable_containing_an_abstract_construct_signature_must_also_be_declared_abstract: diag(2797, ts.DiagnosticCategory.Error, "A_mixin_class_that_extends_from_a_type_variable_containing_an_abstract_construct_signature_must_also_2797", "A mixin class that extends from a type variable containing an abstract construct signature must also be declared 'abstract'."),
        The_declaration_was_marked_as_deprecated_here: diag(2798, ts.DiagnosticCategory.Error, "The_declaration_was_marked_as_deprecated_here_2798", "The declaration was marked as deprecated here."),
        Type_produces_a_tuple_type_that_is_too_large_to_represent: diag(2799, ts.DiagnosticCategory.Error, "Type_produces_a_tuple_type_that_is_too_large_to_represent_2799", "Type produces a tuple type that is too large to represent."),
        Expression_produces_a_tuple_type_that_is_too_large_to_represent: diag(2800, ts.DiagnosticCategory.Error, "Expression_produces_a_tuple_type_that_is_too_large_to_represent_2800", "Expression produces a tuple type that is too large to represent."),
        This_condition_will_always_return_true_since_this_0_is_always_defined: diag(2801, ts.DiagnosticCategory.Error, "This_condition_will_always_return_true_since_this_0_is_always_defined_2801", "This condition will always return true since this '{0}' is always defined."),
        Type_0_can_only_be_iterated_through_when_using_the_downlevelIteration_flag_or_with_a_target_of_es2015_or_higher: diag(2802, ts.DiagnosticCategory.Error, "Type_0_can_only_be_iterated_through_when_using_the_downlevelIteration_flag_or_with_a_target_of_es201_2802", "Type '{0}' can only be iterated through when using the '--downlevelIteration' flag or with a '--target' of 'es2015' or higher."),
        Cannot_assign_to_private_method_0_Private_methods_are_not_writable: diag(2803, ts.DiagnosticCategory.Error, "Cannot_assign_to_private_method_0_Private_methods_are_not_writable_2803", "Cannot assign to private method '{0}'. Private methods are not writable."),
        Duplicate_identifier_0_Static_and_instance_elements_cannot_share_the_same_private_name: diag(2804, ts.DiagnosticCategory.Error, "Duplicate_identifier_0_Static_and_instance_elements_cannot_share_the_same_private_name_2804", "Duplicate identifier '{0}'. Static and instance elements cannot share the same private name."),
        Private_accessor_was_defined_without_a_getter: diag(2806, ts.DiagnosticCategory.Error, "Private_accessor_was_defined_without_a_getter_2806", "Private accessor was defined without a getter."),
        This_syntax_requires_an_imported_helper_named_1_with_2_parameters_which_is_not_compatible_with_the_one_in_0_Consider_upgrading_your_version_of_0: diag(2807, ts.DiagnosticCategory.Error, "This_syntax_requires_an_imported_helper_named_1_with_2_parameters_which_is_not_compatible_with_the_o_2807", "This syntax requires an imported helper named '{1}' with {2} parameters, which is not compatible with the one in '{0}'. Consider upgrading your version of '{0}'."),
        A_get_accessor_must_be_at_least_as_accessible_as_the_setter: diag(2808, ts.DiagnosticCategory.Error, "A_get_accessor_must_be_at_least_as_accessible_as_the_setter_2808", "A get accessor must be at least as accessible as the setter"),
        Declaration_or_statement_expected_This_follows_a_block_of_statements_so_if_you_intended_to_write_a_destructuring_assignment_you_might_need_to_wrap_the_the_whole_assignment_in_parentheses: diag(2809, ts.DiagnosticCategory.Error, "Declaration_or_statement_expected_This_follows_a_block_of_statements_so_if_you_intended_to_write_a_d_2809", "Declaration or statement expected. This '=' follows a block of statements, so if you intended to write a destructuring assignment, you might need to wrap the the whole assignment in parentheses."),
        Expected_1_argument_but_got_0_new_Promise_needs_a_JSDoc_hint_to_produce_a_resolve_that_can_be_called_without_arguments: diag(2810, ts.DiagnosticCategory.Error, "Expected_1_argument_but_got_0_new_Promise_needs_a_JSDoc_hint_to_produce_a_resolve_that_can_be_called_2810", "Expected 1 argument, but got 0. 'new Promise()' needs a JSDoc hint to produce a 'resolve' that can be called without arguments."),
        Initializer_for_property_0: diag(2811, ts.DiagnosticCategory.Error, "Initializer_for_property_0_2811", "Initializer for property '{0}'"),
        Property_0_does_not_exist_on_type_1_Try_changing_the_lib_compiler_option_to_include_dom: diag(2812, ts.DiagnosticCategory.Error, "Property_0_does_not_exist_on_type_1_Try_changing_the_lib_compiler_option_to_include_dom_2812", "Property '{0}' does not exist on type '{1}'. Try changing the 'lib' compiler option to include 'dom'."),
        Class_declaration_cannot_implement_overload_list_for_0: diag(2813, ts.DiagnosticCategory.Error, "Class_declaration_cannot_implement_overload_list_for_0_2813", "Class declaration cannot implement overload list for '{0}'."),
        Function_with_bodies_can_only_merge_with_classes_that_are_ambient: diag(2814, ts.DiagnosticCategory.Error, "Function_with_bodies_can_only_merge_with_classes_that_are_ambient_2814", "Function with bodies can only merge with classes that are ambient."),
        arguments_cannot_be_referenced_in_property_initializers: diag(2815, ts.DiagnosticCategory.Error, "arguments_cannot_be_referenced_in_property_initializers_2815", "'arguments' cannot be referenced in property initializers."),
        Cannot_use_this_in_a_static_property_initializer_of_a_decorated_class: diag(2816, ts.DiagnosticCategory.Error, "Cannot_use_this_in_a_static_property_initializer_of_a_decorated_class_2816", "Cannot use 'this' in a static property initializer of a decorated class."),
        Property_0_has_no_initializer_and_is_not_definitely_assigned_in_a_class_static_block: diag(2817, ts.DiagnosticCategory.Error, "Property_0_has_no_initializer_and_is_not_definitely_assigned_in_a_class_static_block_2817", "Property '{0}' has no initializer and is not definitely assigned in a class static block."),
        Duplicate_identifier_0_Compiler_reserves_name_1_when_emitting_super_references_in_static_initializers: diag(2818, ts.DiagnosticCategory.Error, "Duplicate_identifier_0_Compiler_reserves_name_1_when_emitting_super_references_in_static_initializer_2818", "Duplicate identifier '{0}'. Compiler reserves name '{1}' when emitting 'super' references in static initializers."),
        Namespace_name_cannot_be_0: diag(2819, ts.DiagnosticCategory.Error, "Namespace_name_cannot_be_0_2819", "Namespace name cannot be '{0}'."),
        Type_0_is_not_assignable_to_type_1_Did_you_mean_2: diag(2820, ts.DiagnosticCategory.Error, "Type_0_is_not_assignable_to_type_1_Did_you_mean_2_2820", "Type '{0}' is not assignable to type '{1}'. Did you mean '{2}'?"),
        Import_assertions_are_only_supported_when_the_module_option_is_set_to_esnext_or_nodenext: diag(2821, ts.DiagnosticCategory.Error, "Import_assertions_are_only_supported_when_the_module_option_is_set_to_esnext_or_nodenext_2821", "Import assertions are only supported when the '--module' option is set to 'esnext' or 'nodenext'."),
        Import_assertions_cannot_be_used_with_type_only_imports_or_exports: diag(2822, ts.DiagnosticCategory.Error, "Import_assertions_cannot_be_used_with_type_only_imports_or_exports_2822", "Import assertions cannot be used with type-only imports or exports."),
        Cannot_find_namespace_0_Did_you_mean_1: diag(2833, ts.DiagnosticCategory.Error, "Cannot_find_namespace_0_Did_you_mean_1_2833", "Cannot find namespace '{0}'. Did you mean '{1}'?"),
        Relative_import_paths_need_explicit_file_extensions_in_EcmaScript_imports_when_moduleResolution_is_node16_or_nodenext_Consider_adding_an_extension_to_the_import_path: diag(2834, ts.DiagnosticCategory.Error, "Relative_import_paths_need_explicit_file_extensions_in_EcmaScript_imports_when_moduleResolution_is_n_2834", "Relative import paths need explicit file extensions in EcmaScript imports when '--moduleResolution' is 'node16' or 'nodenext'. Consider adding an extension to the import path."),
        Relative_import_paths_need_explicit_file_extensions_in_EcmaScript_imports_when_moduleResolution_is_node16_or_nodenext_Did_you_mean_0: diag(2835, ts.DiagnosticCategory.Error, "Relative_import_paths_need_explicit_file_extensions_in_EcmaScript_imports_when_moduleResolution_is_n_2835", "Relative import paths need explicit file extensions in EcmaScript imports when '--moduleResolution' is 'node16' or 'nodenext'. Did you mean '{0}'?"),
        Import_assertions_are_not_allowed_on_statements_that_transpile_to_commonjs_require_calls: diag(2836, ts.DiagnosticCategory.Error, "Import_assertions_are_not_allowed_on_statements_that_transpile_to_commonjs_require_calls_2836", "Import assertions are not allowed on statements that transpile to commonjs 'require' calls."),
        Import_assertion_values_must_be_string_literal_expressions: diag(2837, ts.DiagnosticCategory.Error, "Import_assertion_values_must_be_string_literal_expressions_2837", "Import assertion values must be string literal expressions."),
        All_declarations_of_0_must_have_identical_constraints: diag(2838, ts.DiagnosticCategory.Error, "All_declarations_of_0_must_have_identical_constraints_2838", "All declarations of '{0}' must have identical constraints."),
        The_type_of_this_expression_cannot_be_named_without_a_resolution_mode_assertion_which_is_an_unstable_feature_Use_nightly_TypeScript_to_silence_this_error_Try_updating_with_npm_install_D_typescript_next: diag(2841, ts.DiagnosticCategory.Error, "The_type_of_this_expression_cannot_be_named_without_a_resolution_mode_assertion_which_is_an_unstable_2841", "The type of this expression cannot be named without a 'resolution-mode' assertion, which is an unstable feature. Use nightly TypeScript to silence this error. Try updating with 'npm install -D typescript@next'."),
        Import_declaration_0_is_using_private_name_1: diag(4000, ts.DiagnosticCategory.Error, "Import_declaration_0_is_using_private_name_1_4000", "Import declaration '{0}' is using private name '{1}'."),
        Type_parameter_0_of_exported_class_has_or_is_using_private_name_1: diag(4002, ts.DiagnosticCategory.Error, "Type_parameter_0_of_exported_class_has_or_is_using_private_name_1_4002", "Type parameter '{0}' of exported class has or is using private name '{1}'."),
        Type_parameter_0_of_exported_interface_has_or_is_using_private_name_1: diag(4004, ts.DiagnosticCategory.Error, "Type_parameter_0_of_exported_interface_has_or_is_using_private_name_1_4004", "Type parameter '{0}' of exported interface has or is using private name '{1}'."),
        Type_parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_1: diag(4006, ts.DiagnosticCategory.Error, "Type_parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_1_4006", "Type parameter '{0}' of constructor signature from exported interface has or is using private name '{1}'."),
        Type_parameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_name_1: diag(4008, ts.DiagnosticCategory.Error, "Type_parameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_name_1_4008", "Type parameter '{0}' of call signature from exported interface has or is using private name '{1}'."),
        Type_parameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_name_1: diag(4010, ts.DiagnosticCategory.Error, "Type_parameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_name_1_4010", "Type parameter '{0}' of public static method from exported class has or is using private name '{1}'."),
        Type_parameter_0_of_public_method_from_exported_class_has_or_is_using_private_name_1: diag(4012, ts.DiagnosticCategory.Error, "Type_parameter_0_of_public_method_from_exported_class_has_or_is_using_private_name_1_4012", "Type parameter '{0}' of public method from exported class has or is using private name '{1}'."),
        Type_parameter_0_of_method_from_exported_interface_has_or_is_using_private_name_1: diag(4014, ts.DiagnosticCategory.Error, "Type_parameter_0_of_method_from_exported_interface_has_or_is_using_private_name_1_4014", "Type parameter '{0}' of method from exported interface has or is using private name '{1}'."),
        Type_parameter_0_of_exported_function_has_or_is_using_private_name_1: diag(4016, ts.DiagnosticCategory.Error, "Type_parameter_0_of_exported_function_has_or_is_using_private_name_1_4016", "Type parameter '{0}' of exported function has or is using private name '{1}'."),
        Implements_clause_of_exported_class_0_has_or_is_using_private_name_1: diag(4019, ts.DiagnosticCategory.Error, "Implements_clause_of_exported_class_0_has_or_is_using_private_name_1_4019", "Implements clause of exported class '{0}' has or is using private name '{1}'."),
        extends_clause_of_exported_class_0_has_or_is_using_private_name_1: diag(4020, ts.DiagnosticCategory.Error, "extends_clause_of_exported_class_0_has_or_is_using_private_name_1_4020", "'extends' clause of exported class '{0}' has or is using private name '{1}'."),
        extends_clause_of_exported_class_has_or_is_using_private_name_0: diag(4021, ts.DiagnosticCategory.Error, "extends_clause_of_exported_class_has_or_is_using_private_name_0_4021", "'extends' clause of exported class has or is using private name '{0}'."),
        extends_clause_of_exported_interface_0_has_or_is_using_private_name_1: diag(4022, ts.DiagnosticCategory.Error, "extends_clause_of_exported_interface_0_has_or_is_using_private_name_1_4022", "'extends' clause of exported interface '{0}' has or is using private name '{1}'."),
        Exported_variable_0_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: diag(4023, ts.DiagnosticCategory.Error, "Exported_variable_0_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named_4023", "Exported variable '{0}' has or is using name '{1}' from external module {2} but cannot be named."),
        Exported_variable_0_has_or_is_using_name_1_from_private_module_2: diag(4024, ts.DiagnosticCategory.Error, "Exported_variable_0_has_or_is_using_name_1_from_private_module_2_4024", "Exported variable '{0}' has or is using name '{1}' from private module '{2}'."),
        Exported_variable_0_has_or_is_using_private_name_1: diag(4025, ts.DiagnosticCategory.Error, "Exported_variable_0_has_or_is_using_private_name_1_4025", "Exported variable '{0}' has or is using private name '{1}'."),
        Public_static_property_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: diag(4026, ts.DiagnosticCategory.Error, "Public_static_property_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot__4026", "Public static property '{0}' of exported class has or is using name '{1}' from external module {2} but cannot be named."),
        Public_static_property_0_of_exported_class_has_or_is_using_name_1_from_private_module_2: diag(4027, ts.DiagnosticCategory.Error, "Public_static_property_0_of_exported_class_has_or_is_using_name_1_from_private_module_2_4027", "Public static property '{0}' of exported class has or is using name '{1}' from private module '{2}'."),
        Public_static_property_0_of_exported_class_has_or_is_using_private_name_1: diag(4028, ts.DiagnosticCategory.Error, "Public_static_property_0_of_exported_class_has_or_is_using_private_name_1_4028", "Public static property '{0}' of exported class has or is using private name '{1}'."),
        Public_property_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: diag(4029, ts.DiagnosticCategory.Error, "Public_property_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_name_4029", "Public property '{0}' of exported class has or is using name '{1}' from external module {2} but cannot be named."),
        Public_property_0_of_exported_class_has_or_is_using_name_1_from_private_module_2: diag(4030, ts.DiagnosticCategory.Error, "Public_property_0_of_exported_class_has_or_is_using_name_1_from_private_module_2_4030", "Public property '{0}' of exported class has or is using name '{1}' from private module '{2}'."),
        Public_property_0_of_exported_class_has_or_is_using_private_name_1: diag(4031, ts.DiagnosticCategory.Error, "Public_property_0_of_exported_class_has_or_is_using_private_name_1_4031", "Public property '{0}' of exported class has or is using private name '{1}'."),
        Property_0_of_exported_interface_has_or_is_using_name_1_from_private_module_2: diag(4032, ts.DiagnosticCategory.Error, "Property_0_of_exported_interface_has_or_is_using_name_1_from_private_module_2_4032", "Property '{0}' of exported interface has or is using name '{1}' from private module '{2}'."),
        Property_0_of_exported_interface_has_or_is_using_private_name_1: diag(4033, ts.DiagnosticCategory.Error, "Property_0_of_exported_interface_has_or_is_using_private_name_1_4033", "Property '{0}' of exported interface has or is using private name '{1}'."),
        Parameter_type_of_public_static_setter_0_from_exported_class_has_or_is_using_name_1_from_private_module_2: diag(4034, ts.DiagnosticCategory.Error, "Parameter_type_of_public_static_setter_0_from_exported_class_has_or_is_using_name_1_from_private_mod_4034", "Parameter type of public static setter '{0}' from exported class has or is using name '{1}' from private module '{2}'."),
        Parameter_type_of_public_static_setter_0_from_exported_class_has_or_is_using_private_name_1: diag(4035, ts.DiagnosticCategory.Error, "Parameter_type_of_public_static_setter_0_from_exported_class_has_or_is_using_private_name_1_4035", "Parameter type of public static setter '{0}' from exported class has or is using private name '{1}'."),
        Parameter_type_of_public_setter_0_from_exported_class_has_or_is_using_name_1_from_private_module_2: diag(4036, ts.DiagnosticCategory.Error, "Parameter_type_of_public_setter_0_from_exported_class_has_or_is_using_name_1_from_private_module_2_4036", "Parameter type of public setter '{0}' from exported class has or is using name '{1}' from private module '{2}'."),
        Parameter_type_of_public_setter_0_from_exported_class_has_or_is_using_private_name_1: diag(4037, ts.DiagnosticCategory.Error, "Parameter_type_of_public_setter_0_from_exported_class_has_or_is_using_private_name_1_4037", "Parameter type of public setter '{0}' from exported class has or is using private name '{1}'."),
        Return_type_of_public_static_getter_0_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: diag(4038, ts.DiagnosticCategory.Error, "Return_type_of_public_static_getter_0_from_exported_class_has_or_is_using_name_1_from_external_modul_4038", "Return type of public static getter '{0}' from exported class has or is using name '{1}' from external module {2} but cannot be named."),
        Return_type_of_public_static_getter_0_from_exported_class_has_or_is_using_name_1_from_private_module_2: diag(4039, ts.DiagnosticCategory.Error, "Return_type_of_public_static_getter_0_from_exported_class_has_or_is_using_name_1_from_private_module_4039", "Return type of public static getter '{0}' from exported class has or is using name '{1}' from private module '{2}'."),
        Return_type_of_public_static_getter_0_from_exported_class_has_or_is_using_private_name_1: diag(4040, ts.DiagnosticCategory.Error, "Return_type_of_public_static_getter_0_from_exported_class_has_or_is_using_private_name_1_4040", "Return type of public static getter '{0}' from exported class has or is using private name '{1}'."),
        Return_type_of_public_getter_0_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: diag(4041, ts.DiagnosticCategory.Error, "Return_type_of_public_getter_0_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_4041", "Return type of public getter '{0}' from exported class has or is using name '{1}' from external module {2} but cannot be named."),
        Return_type_of_public_getter_0_from_exported_class_has_or_is_using_name_1_from_private_module_2: diag(4042, ts.DiagnosticCategory.Error, "Return_type_of_public_getter_0_from_exported_class_has_or_is_using_name_1_from_private_module_2_4042", "Return type of public getter '{0}' from exported class has or is using name '{1}' from private module '{2}'."),
        Return_type_of_public_getter_0_from_exported_class_has_or_is_using_private_name_1: diag(4043, ts.DiagnosticCategory.Error, "Return_type_of_public_getter_0_from_exported_class_has_or_is_using_private_name_1_4043", "Return type of public getter '{0}' from exported class has or is using private name '{1}'."),
        Return_type_of_constructor_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1: diag(4044, ts.DiagnosticCategory.Error, "Return_type_of_constructor_signature_from_exported_interface_has_or_is_using_name_0_from_private_mod_4044", "Return type of constructor signature from exported interface has or is using name '{0}' from private module '{1}'."),
        Return_type_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_0: diag(4045, ts.DiagnosticCategory.Error, "Return_type_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_0_4045", "Return type of constructor signature from exported interface has or is using private name '{0}'."),
        Return_type_of_call_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1: diag(4046, ts.DiagnosticCategory.Error, "Return_type_of_call_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1_4046", "Return type of call signature from exported interface has or is using name '{0}' from private module '{1}'."),
        Return_type_of_call_signature_from_exported_interface_has_or_is_using_private_name_0: diag(4047, ts.DiagnosticCategory.Error, "Return_type_of_call_signature_from_exported_interface_has_or_is_using_private_name_0_4047", "Return type of call signature from exported interface has or is using private name '{0}'."),
        Return_type_of_index_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1: diag(4048, ts.DiagnosticCategory.Error, "Return_type_of_index_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1_4048", "Return type of index signature from exported interface has or is using name '{0}' from private module '{1}'."),
        Return_type_of_index_signature_from_exported_interface_has_or_is_using_private_name_0: diag(4049, ts.DiagnosticCategory.Error, "Return_type_of_index_signature_from_exported_interface_has_or_is_using_private_name_0_4049", "Return type of index signature from exported interface has or is using private name '{0}'."),
        Return_type_of_public_static_method_from_exported_class_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named: diag(4050, ts.DiagnosticCategory.Error, "Return_type_of_public_static_method_from_exported_class_has_or_is_using_name_0_from_external_module__4050", "Return type of public static method from exported class has or is using name '{0}' from external module {1} but cannot be named."),
        Return_type_of_public_static_method_from_exported_class_has_or_is_using_name_0_from_private_module_1: diag(4051, ts.DiagnosticCategory.Error, "Return_type_of_public_static_method_from_exported_class_has_or_is_using_name_0_from_private_module_1_4051", "Return type of public static method from exported class has or is using name '{0}' from private module '{1}'."),
        Return_type_of_public_static_method_from_exported_class_has_or_is_using_private_name_0: diag(4052, ts.DiagnosticCategory.Error, "Return_type_of_public_static_method_from_exported_class_has_or_is_using_private_name_0_4052", "Return type of public static method from exported class has or is using private name '{0}'."),
        Return_type_of_public_method_from_exported_class_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named: diag(4053, ts.DiagnosticCategory.Error, "Return_type_of_public_method_from_exported_class_has_or_is_using_name_0_from_external_module_1_but_c_4053", "Return type of public method from exported class has or is using name '{0}' from external module {1} but cannot be named."),
        Return_type_of_public_method_from_exported_class_has_or_is_using_name_0_from_private_module_1: diag(4054, ts.DiagnosticCategory.Error, "Return_type_of_public_method_from_exported_class_has_or_is_using_name_0_from_private_module_1_4054", "Return type of public method from exported class has or is using name '{0}' from private module '{1}'."),
        Return_type_of_public_method_from_exported_class_has_or_is_using_private_name_0: diag(4055, ts.DiagnosticCategory.Error, "Return_type_of_public_method_from_exported_class_has_or_is_using_private_name_0_4055", "Return type of public method from exported class has or is using private name '{0}'."),
        Return_type_of_method_from_exported_interface_has_or_is_using_name_0_from_private_module_1: diag(4056, ts.DiagnosticCategory.Error, "Return_type_of_method_from_exported_interface_has_or_is_using_name_0_from_private_module_1_4056", "Return type of method from exported interface has or is using name '{0}' from private module '{1}'."),
        Return_type_of_method_from_exported_interface_has_or_is_using_private_name_0: diag(4057, ts.DiagnosticCategory.Error, "Return_type_of_method_from_exported_interface_has_or_is_using_private_name_0_4057", "Return type of method from exported interface has or is using private name '{0}'."),
        Return_type_of_exported_function_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named: diag(4058, ts.DiagnosticCategory.Error, "Return_type_of_exported_function_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named_4058", "Return type of exported function has or is using name '{0}' from external module {1} but cannot be named."),
        Return_type_of_exported_function_has_or_is_using_name_0_from_private_module_1: diag(4059, ts.DiagnosticCategory.Error, "Return_type_of_exported_function_has_or_is_using_name_0_from_private_module_1_4059", "Return type of exported function has or is using name '{0}' from private module '{1}'."),
        Return_type_of_exported_function_has_or_is_using_private_name_0: diag(4060, ts.DiagnosticCategory.Error, "Return_type_of_exported_function_has_or_is_using_private_name_0_4060", "Return type of exported function has or is using private name '{0}'."),
        Parameter_0_of_constructor_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: diag(4061, ts.DiagnosticCategory.Error, "Parameter_0_of_constructor_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_can_4061", "Parameter '{0}' of constructor from exported class has or is using name '{1}' from external module {2} but cannot be named."),
        Parameter_0_of_constructor_from_exported_class_has_or_is_using_name_1_from_private_module_2: diag(4062, ts.DiagnosticCategory.Error, "Parameter_0_of_constructor_from_exported_class_has_or_is_using_name_1_from_private_module_2_4062", "Parameter '{0}' of constructor from exported class has or is using name '{1}' from private module '{2}'."),
        Parameter_0_of_constructor_from_exported_class_has_or_is_using_private_name_1: diag(4063, ts.DiagnosticCategory.Error, "Parameter_0_of_constructor_from_exported_class_has_or_is_using_private_name_1_4063", "Parameter '{0}' of constructor from exported class has or is using private name '{1}'."),
        Parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2: diag(4064, ts.DiagnosticCategory.Error, "Parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_name_1_from_private_mod_4064", "Parameter '{0}' of constructor signature from exported interface has or is using name '{1}' from private module '{2}'."),
        Parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_1: diag(4065, ts.DiagnosticCategory.Error, "Parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_1_4065", "Parameter '{0}' of constructor signature from exported interface has or is using private name '{1}'."),
        Parameter_0_of_call_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2: diag(4066, ts.DiagnosticCategory.Error, "Parameter_0_of_call_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2_4066", "Parameter '{0}' of call signature from exported interface has or is using name '{1}' from private module '{2}'."),
        Parameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_name_1: diag(4067, ts.DiagnosticCategory.Error, "Parameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_name_1_4067", "Parameter '{0}' of call signature from exported interface has or is using private name '{1}'."),
        Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: diag(4068, ts.DiagnosticCategory.Error, "Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_name_1_from_external_module__4068", "Parameter '{0}' of public static method from exported class has or is using name '{1}' from external module {2} but cannot be named."),
        Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_name_1_from_private_module_2: diag(4069, ts.DiagnosticCategory.Error, "Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_name_1_from_private_module_2_4069", "Parameter '{0}' of public static method from exported class has or is using name '{1}' from private module '{2}'."),
        Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_name_1: diag(4070, ts.DiagnosticCategory.Error, "Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_name_1_4070", "Parameter '{0}' of public static method from exported class has or is using private name '{1}'."),
        Parameter_0_of_public_method_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: diag(4071, ts.DiagnosticCategory.Error, "Parameter_0_of_public_method_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_c_4071", "Parameter '{0}' of public method from exported class has or is using name '{1}' from external module {2} but cannot be named."),
        Parameter_0_of_public_method_from_exported_class_has_or_is_using_name_1_from_private_module_2: diag(4072, ts.DiagnosticCategory.Error, "Parameter_0_of_public_method_from_exported_class_has_or_is_using_name_1_from_private_module_2_4072", "Parameter '{0}' of public method from exported class has or is using name '{1}' from private module '{2}'."),
        Parameter_0_of_public_method_from_exported_class_has_or_is_using_private_name_1: diag(4073, ts.DiagnosticCategory.Error, "Parameter_0_of_public_method_from_exported_class_has_or_is_using_private_name_1_4073", "Parameter '{0}' of public method from exported class has or is using private name '{1}'."),
        Parameter_0_of_method_from_exported_interface_has_or_is_using_name_1_from_private_module_2: diag(4074, ts.DiagnosticCategory.Error, "Parameter_0_of_method_from_exported_interface_has_or_is_using_name_1_from_private_module_2_4074", "Parameter '{0}' of method from exported interface has or is using name '{1}' from private module '{2}'."),
        Parameter_0_of_method_from_exported_interface_has_or_is_using_private_name_1: diag(4075, ts.DiagnosticCategory.Error, "Parameter_0_of_method_from_exported_interface_has_or_is_using_private_name_1_4075", "Parameter '{0}' of method from exported interface has or is using private name '{1}'."),
        Parameter_0_of_exported_function_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: diag(4076, ts.DiagnosticCategory.Error, "Parameter_0_of_exported_function_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named_4076", "Parameter '{0}' of exported function has or is using name '{1}' from external module {2} but cannot be named."),
        Parameter_0_of_exported_function_has_or_is_using_name_1_from_private_module_2: diag(4077, ts.DiagnosticCategory.Error, "Parameter_0_of_exported_function_has_or_is_using_name_1_from_private_module_2_4077", "Parameter '{0}' of exported function has or is using name '{1}' from private module '{2}'."),
        Parameter_0_of_exported_function_has_or_is_using_private_name_1: diag(4078, ts.DiagnosticCategory.Error, "Parameter_0_of_exported_function_has_or_is_using_private_name_1_4078", "Parameter '{0}' of exported function has or is using private name '{1}'."),
        Exported_type_alias_0_has_or_is_using_private_name_1: diag(4081, ts.DiagnosticCategory.Error, "Exported_type_alias_0_has_or_is_using_private_name_1_4081", "Exported type alias '{0}' has or is using private name '{1}'."),
        Default_export_of_the_module_has_or_is_using_private_name_0: diag(4082, ts.DiagnosticCategory.Error, "Default_export_of_the_module_has_or_is_using_private_name_0_4082", "Default export of the module has or is using private name '{0}'."),
        Type_parameter_0_of_exported_type_alias_has_or_is_using_private_name_1: diag(4083, ts.DiagnosticCategory.Error, "Type_parameter_0_of_exported_type_alias_has_or_is_using_private_name_1_4083", "Type parameter '{0}' of exported type alias has or is using private name '{1}'."),
        Exported_type_alias_0_has_or_is_using_private_name_1_from_module_2: diag(4084, ts.DiagnosticCategory.Error, "Exported_type_alias_0_has_or_is_using_private_name_1_from_module_2_4084", "Exported type alias '{0}' has or is using private name '{1}' from module {2}."),
        Conflicting_definitions_for_0_found_at_1_and_2_Consider_installing_a_specific_version_of_this_library_to_resolve_the_conflict: diag(4090, ts.DiagnosticCategory.Error, "Conflicting_definitions_for_0_found_at_1_and_2_Consider_installing_a_specific_version_of_this_librar_4090", "Conflicting definitions for '{0}' found at '{1}' and '{2}'. Consider installing a specific version of this library to resolve the conflict."),
        Parameter_0_of_index_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2: diag(4091, ts.DiagnosticCategory.Error, "Parameter_0_of_index_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2_4091", "Parameter '{0}' of index signature from exported interface has or is using name '{1}' from private module '{2}'."),
        Parameter_0_of_index_signature_from_exported_interface_has_or_is_using_private_name_1: diag(4092, ts.DiagnosticCategory.Error, "Parameter_0_of_index_signature_from_exported_interface_has_or_is_using_private_name_1_4092", "Parameter '{0}' of index signature from exported interface has or is using private name '{1}'."),
        Property_0_of_exported_class_expression_may_not_be_private_or_protected: diag(4094, ts.DiagnosticCategory.Error, "Property_0_of_exported_class_expression_may_not_be_private_or_protected_4094", "Property '{0}' of exported class expression may not be private or protected."),
        Public_static_method_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: diag(4095, ts.DiagnosticCategory.Error, "Public_static_method_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_4095", "Public static method '{0}' of exported class has or is using name '{1}' from external module {2} but cannot be named."),
        Public_static_method_0_of_exported_class_has_or_is_using_name_1_from_private_module_2: diag(4096, ts.DiagnosticCategory.Error, "Public_static_method_0_of_exported_class_has_or_is_using_name_1_from_private_module_2_4096", "Public static method '{0}' of exported class has or is using name '{1}' from private module '{2}'."),
        Public_static_method_0_of_exported_class_has_or_is_using_private_name_1: diag(4097, ts.DiagnosticCategory.Error, "Public_static_method_0_of_exported_class_has_or_is_using_private_name_1_4097", "Public static method '{0}' of exported class has or is using private name '{1}'."),
        Public_method_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: diag(4098, ts.DiagnosticCategory.Error, "Public_method_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named_4098", "Public method '{0}' of exported class has or is using name '{1}' from external module {2} but cannot be named."),
        Public_method_0_of_exported_class_has_or_is_using_name_1_from_private_module_2: diag(4099, ts.DiagnosticCategory.Error, "Public_method_0_of_exported_class_has_or_is_using_name_1_from_private_module_2_4099", "Public method '{0}' of exported class has or is using name '{1}' from private module '{2}'."),
        Public_method_0_of_exported_class_has_or_is_using_private_name_1: diag(4100, ts.DiagnosticCategory.Error, "Public_method_0_of_exported_class_has_or_is_using_private_name_1_4100", "Public method '{0}' of exported class has or is using private name '{1}'."),
        Method_0_of_exported_interface_has_or_is_using_name_1_from_private_module_2: diag(4101, ts.DiagnosticCategory.Error, "Method_0_of_exported_interface_has_or_is_using_name_1_from_private_module_2_4101", "Method '{0}' of exported interface has or is using name '{1}' from private module '{2}'."),
        Method_0_of_exported_interface_has_or_is_using_private_name_1: diag(4102, ts.DiagnosticCategory.Error, "Method_0_of_exported_interface_has_or_is_using_private_name_1_4102", "Method '{0}' of exported interface has or is using private name '{1}'."),
        Type_parameter_0_of_exported_mapped_object_type_is_using_private_name_1: diag(4103, ts.DiagnosticCategory.Error, "Type_parameter_0_of_exported_mapped_object_type_is_using_private_name_1_4103", "Type parameter '{0}' of exported mapped object type is using private name '{1}'."),
        The_type_0_is_readonly_and_cannot_be_assigned_to_the_mutable_type_1: diag(4104, ts.DiagnosticCategory.Error, "The_type_0_is_readonly_and_cannot_be_assigned_to_the_mutable_type_1_4104", "The type '{0}' is 'readonly' and cannot be assigned to the mutable type '{1}'."),
        Private_or_protected_member_0_cannot_be_accessed_on_a_type_parameter: diag(4105, ts.DiagnosticCategory.Error, "Private_or_protected_member_0_cannot_be_accessed_on_a_type_parameter_4105", "Private or protected member '{0}' cannot be accessed on a type parameter."),
        Parameter_0_of_accessor_has_or_is_using_private_name_1: diag(4106, ts.DiagnosticCategory.Error, "Parameter_0_of_accessor_has_or_is_using_private_name_1_4106", "Parameter '{0}' of accessor has or is using private name '{1}'."),
        Parameter_0_of_accessor_has_or_is_using_name_1_from_private_module_2: diag(4107, ts.DiagnosticCategory.Error, "Parameter_0_of_accessor_has_or_is_using_name_1_from_private_module_2_4107", "Parameter '{0}' of accessor has or is using name '{1}' from private module '{2}'."),
        Parameter_0_of_accessor_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: diag(4108, ts.DiagnosticCategory.Error, "Parameter_0_of_accessor_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named_4108", "Parameter '{0}' of accessor has or is using name '{1}' from external module '{2}' but cannot be named."),
        Type_arguments_for_0_circularly_reference_themselves: diag(4109, ts.DiagnosticCategory.Error, "Type_arguments_for_0_circularly_reference_themselves_4109", "Type arguments for '{0}' circularly reference themselves."),
        Tuple_type_arguments_circularly_reference_themselves: diag(4110, ts.DiagnosticCategory.Error, "Tuple_type_arguments_circularly_reference_themselves_4110", "Tuple type arguments circularly reference themselves."),
        Property_0_comes_from_an_index_signature_so_it_must_be_accessed_with_0: diag(4111, ts.DiagnosticCategory.Error, "Property_0_comes_from_an_index_signature_so_it_must_be_accessed_with_0_4111", "Property '{0}' comes from an index signature, so it must be accessed with ['{0}']."),
        This_member_cannot_have_an_override_modifier_because_its_containing_class_0_does_not_extend_another_class: diag(4112, ts.DiagnosticCategory.Error, "This_member_cannot_have_an_override_modifier_because_its_containing_class_0_does_not_extend_another__4112", "This member cannot have an 'override' modifier because its containing class '{0}' does not extend another class."),
        This_member_cannot_have_an_override_modifier_because_it_is_not_declared_in_the_base_class_0: diag(4113, ts.DiagnosticCategory.Error, "This_member_cannot_have_an_override_modifier_because_it_is_not_declared_in_the_base_class_0_4113", "This member cannot have an 'override' modifier because it is not declared in the base class '{0}'."),
        This_member_must_have_an_override_modifier_because_it_overrides_a_member_in_the_base_class_0: diag(4114, ts.DiagnosticCategory.Error, "This_member_must_have_an_override_modifier_because_it_overrides_a_member_in_the_base_class_0_4114", "This member must have an 'override' modifier because it overrides a member in the base class '{0}'."),
        This_parameter_property_must_have_an_override_modifier_because_it_overrides_a_member_in_base_class_0: diag(4115, ts.DiagnosticCategory.Error, "This_parameter_property_must_have_an_override_modifier_because_it_overrides_a_member_in_base_class_0_4115", "This parameter property must have an 'override' modifier because it overrides a member in base class '{0}'."),
        This_member_must_have_an_override_modifier_because_it_overrides_an_abstract_method_that_is_declared_in_the_base_class_0: diag(4116, ts.DiagnosticCategory.Error, "This_member_must_have_an_override_modifier_because_it_overrides_an_abstract_method_that_is_declared__4116", "This member must have an 'override' modifier because it overrides an abstract method that is declared in the base class '{0}'."),
        This_member_cannot_have_an_override_modifier_because_it_is_not_declared_in_the_base_class_0_Did_you_mean_1: diag(4117, ts.DiagnosticCategory.Error, "This_member_cannot_have_an_override_modifier_because_it_is_not_declared_in_the_base_class_0_Did_you__4117", "This member cannot have an 'override' modifier because it is not declared in the base class '{0}'. Did you mean '{1}'?"),
        The_type_of_this_node_cannot_be_serialized_because_its_property_0_cannot_be_serialized: diag(4118, ts.DiagnosticCategory.Error, "The_type_of_this_node_cannot_be_serialized_because_its_property_0_cannot_be_serialized_4118", "The type of this node cannot be serialized because its property '{0}' cannot be serialized."),
        This_member_must_have_a_JSDoc_comment_with_an_override_tag_because_it_overrides_a_member_in_the_base_class_0: diag(4119, ts.DiagnosticCategory.Error, "This_member_must_have_a_JSDoc_comment_with_an_override_tag_because_it_overrides_a_member_in_the_base_4119", "This member must have a JSDoc comment with an '@override' tag because it overrides a member in the base class '{0}'."),
        This_parameter_property_must_have_a_JSDoc_comment_with_an_override_tag_because_it_overrides_a_member_in_the_base_class_0: diag(4120, ts.DiagnosticCategory.Error, "This_parameter_property_must_have_a_JSDoc_comment_with_an_override_tag_because_it_overrides_a_member_4120", "This parameter property must have a JSDoc comment with an '@override' tag because it overrides a member in the base class '{0}'."),
        This_member_cannot_have_a_JSDoc_comment_with_an_override_tag_because_its_containing_class_0_does_not_extend_another_class: diag(4121, ts.DiagnosticCategory.Error, "This_member_cannot_have_a_JSDoc_comment_with_an_override_tag_because_its_containing_class_0_does_not_4121", "This member cannot have a JSDoc comment with an '@override' tag because its containing class '{0}' does not extend another class."),
        This_member_cannot_have_a_JSDoc_comment_with_an_override_tag_because_it_is_not_declared_in_the_base_class_0: diag(4122, ts.DiagnosticCategory.Error, "This_member_cannot_have_a_JSDoc_comment_with_an_override_tag_because_it_is_not_declared_in_the_base__4122", "This member cannot have a JSDoc comment with an '@override' tag because it is not declared in the base class '{0}'."),
        This_member_cannot_have_a_JSDoc_comment_with_an_override_tag_because_it_is_not_declared_in_the_base_class_0_Did_you_mean_1: diag(4123, ts.DiagnosticCategory.Error, "This_member_cannot_have_a_JSDoc_comment_with_an_override_tag_because_it_is_not_declared_in_the_base__4123", "This member cannot have a JSDoc comment with an 'override' tag because it is not declared in the base class '{0}'. Did you mean '{1}'?"),
        Compiler_option_0_of_value_1_is_unstable_Use_nightly_TypeScript_to_silence_this_error_Try_updating_with_npm_install_D_typescript_next: diag(4124, ts.DiagnosticCategory.Error, "Compiler_option_0_of_value_1_is_unstable_Use_nightly_TypeScript_to_silence_this_error_Try_updating_w_4124", "Compiler option '{0}' of value '{1}' is unstable. Use nightly TypeScript to silence this error. Try updating with 'npm install -D typescript@next'."),
        resolution_mode_assertions_are_unstable_Use_nightly_TypeScript_to_silence_this_error_Try_updating_with_npm_install_D_typescript_next: diag(4125, ts.DiagnosticCategory.Error, "resolution_mode_assertions_are_unstable_Use_nightly_TypeScript_to_silence_this_error_Try_updating_wi_4125", "'resolution-mode' assertions are unstable. Use nightly TypeScript to silence this error. Try updating with 'npm install -D typescript@next'."),
        The_current_host_does_not_support_the_0_option: diag(5001, ts.DiagnosticCategory.Error, "The_current_host_does_not_support_the_0_option_5001", "The current host does not support the '{0}' option."),
        Cannot_find_the_common_subdirectory_path_for_the_input_files: diag(5009, ts.DiagnosticCategory.Error, "Cannot_find_the_common_subdirectory_path_for_the_input_files_5009", "Cannot find the common subdirectory path for the input files."),
        File_specification_cannot_end_in_a_recursive_directory_wildcard_Asterisk_Asterisk_Colon_0: diag(5010, ts.DiagnosticCategory.Error, "File_specification_cannot_end_in_a_recursive_directory_wildcard_Asterisk_Asterisk_Colon_0_5010", "File specification cannot end in a recursive directory wildcard ('**'): '{0}'."),
        Cannot_read_file_0_Colon_1: diag(5012, ts.DiagnosticCategory.Error, "Cannot_read_file_0_Colon_1_5012", "Cannot read file '{0}': {1}."),
        Failed_to_parse_file_0_Colon_1: diag(5014, ts.DiagnosticCategory.Error, "Failed_to_parse_file_0_Colon_1_5014", "Failed to parse file '{0}': {1}."),
        Unknown_compiler_option_0: diag(5023, ts.DiagnosticCategory.Error, "Unknown_compiler_option_0_5023", "Unknown compiler option '{0}'."),
        Compiler_option_0_requires_a_value_of_type_1: diag(5024, ts.DiagnosticCategory.Error, "Compiler_option_0_requires_a_value_of_type_1_5024", "Compiler option '{0}' requires a value of type {1}."),
        Unknown_compiler_option_0_Did_you_mean_1: diag(5025, ts.DiagnosticCategory.Error, "Unknown_compiler_option_0_Did_you_mean_1_5025", "Unknown compiler option '{0}'. Did you mean '{1}'?"),
        Could_not_write_file_0_Colon_1: diag(5033, ts.DiagnosticCategory.Error, "Could_not_write_file_0_Colon_1_5033", "Could not write file '{0}': {1}."),
        Option_project_cannot_be_mixed_with_source_files_on_a_command_line: diag(5042, ts.DiagnosticCategory.Error, "Option_project_cannot_be_mixed_with_source_files_on_a_command_line_5042", "Option 'project' cannot be mixed with source files on a command line."),
        Option_isolatedModules_can_only_be_used_when_either_option_module_is_provided_or_option_target_is_ES2015_or_higher: diag(5047, ts.DiagnosticCategory.Error, "Option_isolatedModules_can_only_be_used_when_either_option_module_is_provided_or_option_target_is_ES_5047", "Option 'isolatedModules' can only be used when either option '--module' is provided or option 'target' is 'ES2015' or higher."),
        Option_0_cannot_be_specified_when_option_target_is_ES3: diag(5048, ts.DiagnosticCategory.Error, "Option_0_cannot_be_specified_when_option_target_is_ES3_5048", "Option '{0}' cannot be specified when option 'target' is 'ES3'."),
        Option_0_can_only_be_used_when_either_option_inlineSourceMap_or_option_sourceMap_is_provided: diag(5051, ts.DiagnosticCategory.Error, "Option_0_can_only_be_used_when_either_option_inlineSourceMap_or_option_sourceMap_is_provided_5051", "Option '{0} can only be used when either option '--inlineSourceMap' or option '--sourceMap' is provided."),
        Option_0_cannot_be_specified_without_specifying_option_1: diag(5052, ts.DiagnosticCategory.Error, "Option_0_cannot_be_specified_without_specifying_option_1_5052", "Option '{0}' cannot be specified without specifying option '{1}'."),
        Option_0_cannot_be_specified_with_option_1: diag(5053, ts.DiagnosticCategory.Error, "Option_0_cannot_be_specified_with_option_1_5053", "Option '{0}' cannot be specified with option '{1}'."),
        A_tsconfig_json_file_is_already_defined_at_Colon_0: diag(5054, ts.DiagnosticCategory.Error, "A_tsconfig_json_file_is_already_defined_at_Colon_0_5054", "A 'tsconfig.json' file is already defined at: '{0}'."),
        Cannot_write_file_0_because_it_would_overwrite_input_file: diag(5055, ts.DiagnosticCategory.Error, "Cannot_write_file_0_because_it_would_overwrite_input_file_5055", "Cannot write file '{0}' because it would overwrite input file."),
        Cannot_write_file_0_because_it_would_be_overwritten_by_multiple_input_files: diag(5056, ts.DiagnosticCategory.Error, "Cannot_write_file_0_because_it_would_be_overwritten_by_multiple_input_files_5056", "Cannot write file '{0}' because it would be overwritten by multiple input files."),
        Cannot_find_a_tsconfig_json_file_at_the_specified_directory_Colon_0: diag(5057, ts.DiagnosticCategory.Error, "Cannot_find_a_tsconfig_json_file_at_the_specified_directory_Colon_0_5057", "Cannot find a tsconfig.json file at the specified directory: '{0}'."),
        The_specified_path_does_not_exist_Colon_0: diag(5058, ts.DiagnosticCategory.Error, "The_specified_path_does_not_exist_Colon_0_5058", "The specified path does not exist: '{0}'."),
        Invalid_value_for_reactNamespace_0_is_not_a_valid_identifier: diag(5059, ts.DiagnosticCategory.Error, "Invalid_value_for_reactNamespace_0_is_not_a_valid_identifier_5059", "Invalid value for '--reactNamespace'. '{0}' is not a valid identifier."),
        Pattern_0_can_have_at_most_one_Asterisk_character: diag(5061, ts.DiagnosticCategory.Error, "Pattern_0_can_have_at_most_one_Asterisk_character_5061", "Pattern '{0}' can have at most one '*' character."),
        Substitution_0_in_pattern_1_can_have_at_most_one_Asterisk_character: diag(5062, ts.DiagnosticCategory.Error, "Substitution_0_in_pattern_1_can_have_at_most_one_Asterisk_character_5062", "Substitution '{0}' in pattern '{1}' can have at most one '*' character."),
        Substitutions_for_pattern_0_should_be_an_array: diag(5063, ts.DiagnosticCategory.Error, "Substitutions_for_pattern_0_should_be_an_array_5063", "Substitutions for pattern '{0}' should be an array."),
        Substitution_0_for_pattern_1_has_incorrect_type_expected_string_got_2: diag(5064, ts.DiagnosticCategory.Error, "Substitution_0_for_pattern_1_has_incorrect_type_expected_string_got_2_5064", "Substitution '{0}' for pattern '{1}' has incorrect type, expected 'string', got '{2}'."),
        File_specification_cannot_contain_a_parent_directory_that_appears_after_a_recursive_directory_wildcard_Asterisk_Asterisk_Colon_0: diag(5065, ts.DiagnosticCategory.Error, "File_specification_cannot_contain_a_parent_directory_that_appears_after_a_recursive_directory_wildca_5065", "File specification cannot contain a parent directory ('..') that appears after a recursive directory wildcard ('**'): '{0}'."),
        Substitutions_for_pattern_0_shouldn_t_be_an_empty_array: diag(5066, ts.DiagnosticCategory.Error, "Substitutions_for_pattern_0_shouldn_t_be_an_empty_array_5066", "Substitutions for pattern '{0}' shouldn't be an empty array."),
        Invalid_value_for_jsxFactory_0_is_not_a_valid_identifier_or_qualified_name: diag(5067, ts.DiagnosticCategory.Error, "Invalid_value_for_jsxFactory_0_is_not_a_valid_identifier_or_qualified_name_5067", "Invalid value for 'jsxFactory'. '{0}' is not a valid identifier or qualified-name."),
        Adding_a_tsconfig_json_file_will_help_organize_projects_that_contain_both_TypeScript_and_JavaScript_files_Learn_more_at_https_Colon_Slash_Slashaka_ms_Slashtsconfig: diag(5068, ts.DiagnosticCategory.Error, "Adding_a_tsconfig_json_file_will_help_organize_projects_that_contain_both_TypeScript_and_JavaScript__5068", "Adding a tsconfig.json file will help organize projects that contain both TypeScript and JavaScript files. Learn more at https://aka.ms/tsconfig."),
        Option_0_cannot_be_specified_without_specifying_option_1_or_option_2: diag(5069, ts.DiagnosticCategory.Error, "Option_0_cannot_be_specified_without_specifying_option_1_or_option_2_5069", "Option '{0}' cannot be specified without specifying option '{1}' or option '{2}'."),
        Option_resolveJsonModule_cannot_be_specified_without_node_module_resolution_strategy: diag(5070, ts.DiagnosticCategory.Error, "Option_resolveJsonModule_cannot_be_specified_without_node_module_resolution_strategy_5070", "Option '--resolveJsonModule' cannot be specified without 'node' module resolution strategy."),
        Option_resolveJsonModule_can_only_be_specified_when_module_code_generation_is_commonjs_amd_es2015_or_esNext: diag(5071, ts.DiagnosticCategory.Error, "Option_resolveJsonModule_can_only_be_specified_when_module_code_generation_is_commonjs_amd_es2015_or_5071", "Option '--resolveJsonModule' can only be specified when module code generation is 'commonjs', 'amd', 'es2015' or 'esNext'."),
        Unknown_build_option_0: diag(5072, ts.DiagnosticCategory.Error, "Unknown_build_option_0_5072", "Unknown build option '{0}'."),
        Build_option_0_requires_a_value_of_type_1: diag(5073, ts.DiagnosticCategory.Error, "Build_option_0_requires_a_value_of_type_1_5073", "Build option '{0}' requires a value of type {1}."),
        Option_incremental_can_only_be_specified_using_tsconfig_emitting_to_single_file_or_when_option_tsBuildInfoFile_is_specified: diag(5074, ts.DiagnosticCategory.Error, "Option_incremental_can_only_be_specified_using_tsconfig_emitting_to_single_file_or_when_option_tsBui_5074", "Option '--incremental' can only be specified using tsconfig, emitting to single file or when option '--tsBuildInfoFile' is specified."),
        _0_is_assignable_to_the_constraint_of_type_1_but_1_could_be_instantiated_with_a_different_subtype_of_constraint_2: diag(5075, ts.DiagnosticCategory.Error, "_0_is_assignable_to_the_constraint_of_type_1_but_1_could_be_instantiated_with_a_different_subtype_of_5075", "'{0}' is assignable to the constraint of type '{1}', but '{1}' could be instantiated with a different subtype of constraint '{2}'."),
        _0_and_1_operations_cannot_be_mixed_without_parentheses: diag(5076, ts.DiagnosticCategory.Error, "_0_and_1_operations_cannot_be_mixed_without_parentheses_5076", "'{0}' and '{1}' operations cannot be mixed without parentheses."),
        Unknown_build_option_0_Did_you_mean_1: diag(5077, ts.DiagnosticCategory.Error, "Unknown_build_option_0_Did_you_mean_1_5077", "Unknown build option '{0}'. Did you mean '{1}'?"),
        Unknown_watch_option_0: diag(5078, ts.DiagnosticCategory.Error, "Unknown_watch_option_0_5078", "Unknown watch option '{0}'."),
        Unknown_watch_option_0_Did_you_mean_1: diag(5079, ts.DiagnosticCategory.Error, "Unknown_watch_option_0_Did_you_mean_1_5079", "Unknown watch option '{0}'. Did you mean '{1}'?"),
        Watch_option_0_requires_a_value_of_type_1: diag(5080, ts.DiagnosticCategory.Error, "Watch_option_0_requires_a_value_of_type_1_5080", "Watch option '{0}' requires a value of type {1}."),
        Cannot_find_a_tsconfig_json_file_at_the_current_directory_Colon_0: diag(5081, ts.DiagnosticCategory.Error, "Cannot_find_a_tsconfig_json_file_at_the_current_directory_Colon_0_5081", "Cannot find a tsconfig.json file at the current directory: {0}."),
        _0_could_be_instantiated_with_an_arbitrary_type_which_could_be_unrelated_to_1: diag(5082, ts.DiagnosticCategory.Error, "_0_could_be_instantiated_with_an_arbitrary_type_which_could_be_unrelated_to_1_5082", "'{0}' could be instantiated with an arbitrary type which could be unrelated to '{1}'."),
        Cannot_read_file_0: diag(5083, ts.DiagnosticCategory.Error, "Cannot_read_file_0_5083", "Cannot read file '{0}'."),
        Tuple_members_must_all_have_names_or_all_not_have_names: diag(5084, ts.DiagnosticCategory.Error, "Tuple_members_must_all_have_names_or_all_not_have_names_5084", "Tuple members must all have names or all not have names."),
        A_tuple_member_cannot_be_both_optional_and_rest: diag(5085, ts.DiagnosticCategory.Error, "A_tuple_member_cannot_be_both_optional_and_rest_5085", "A tuple member cannot be both optional and rest."),
        A_labeled_tuple_element_is_declared_as_optional_with_a_question_mark_after_the_name_and_before_the_colon_rather_than_after_the_type: diag(5086, ts.DiagnosticCategory.Error, "A_labeled_tuple_element_is_declared_as_optional_with_a_question_mark_after_the_name_and_before_the_c_5086", "A labeled tuple element is declared as optional with a question mark after the name and before the colon, rather than after the type."),
        A_labeled_tuple_element_is_declared_as_rest_with_a_before_the_name_rather_than_before_the_type: diag(5087, ts.DiagnosticCategory.Error, "A_labeled_tuple_element_is_declared_as_rest_with_a_before_the_name_rather_than_before_the_type_5087", "A labeled tuple element is declared as rest with a '...' before the name, rather than before the type."),
        The_inferred_type_of_0_references_a_type_with_a_cyclic_structure_which_cannot_be_trivially_serialized_A_type_annotation_is_necessary: diag(5088, ts.DiagnosticCategory.Error, "The_inferred_type_of_0_references_a_type_with_a_cyclic_structure_which_cannot_be_trivially_serialize_5088", "The inferred type of '{0}' references a type with a cyclic structure which cannot be trivially serialized. A type annotation is necessary."),
        Option_0_cannot_be_specified_when_option_jsx_is_1: diag(5089, ts.DiagnosticCategory.Error, "Option_0_cannot_be_specified_when_option_jsx_is_1_5089", "Option '{0}' cannot be specified when option 'jsx' is '{1}'."),
        Non_relative_paths_are_not_allowed_when_baseUrl_is_not_set_Did_you_forget_a_leading_Slash: diag(5090, ts.DiagnosticCategory.Error, "Non_relative_paths_are_not_allowed_when_baseUrl_is_not_set_Did_you_forget_a_leading_Slash_5090", "Non-relative paths are not allowed when 'baseUrl' is not set. Did you forget a leading './'?"),
        Option_preserveConstEnums_cannot_be_disabled_when_isolatedModules_is_enabled: diag(5091, ts.DiagnosticCategory.Error, "Option_preserveConstEnums_cannot_be_disabled_when_isolatedModules_is_enabled_5091", "Option 'preserveConstEnums' cannot be disabled when 'isolatedModules' is enabled."),
        The_root_value_of_a_0_file_must_be_an_object: diag(5092, ts.DiagnosticCategory.Error, "The_root_value_of_a_0_file_must_be_an_object_5092", "The root value of a '{0}' file must be an object."),
        Compiler_option_0_may_only_be_used_with_build: diag(5093, ts.DiagnosticCategory.Error, "Compiler_option_0_may_only_be_used_with_build_5093", "Compiler option '--{0}' may only be used with '--build'."),
        Compiler_option_0_may_not_be_used_with_build: diag(5094, ts.DiagnosticCategory.Error, "Compiler_option_0_may_not_be_used_with_build_5094", "Compiler option '--{0}' may not be used with '--build'."),
        Option_preserveValueImports_can_only_be_used_when_module_is_set_to_es2015_or_later: diag(5095, ts.DiagnosticCategory.Error, "Option_preserveValueImports_can_only_be_used_when_module_is_set_to_es2015_or_later_5095", "Option 'preserveValueImports' can only be used when 'module' is set to 'es2015' or later."),
        Generates_a_sourcemap_for_each_corresponding_d_ts_file: diag(6000, ts.DiagnosticCategory.Message, "Generates_a_sourcemap_for_each_corresponding_d_ts_file_6000", "Generates a sourcemap for each corresponding '.d.ts' file."),
        Concatenate_and_emit_output_to_single_file: diag(6001, ts.DiagnosticCategory.Message, "Concatenate_and_emit_output_to_single_file_6001", "Concatenate and emit output to single file."),
        Generates_corresponding_d_ts_file: diag(6002, ts.DiagnosticCategory.Message, "Generates_corresponding_d_ts_file_6002", "Generates corresponding '.d.ts' file."),
        Specify_the_location_where_debugger_should_locate_TypeScript_files_instead_of_source_locations: diag(6004, ts.DiagnosticCategory.Message, "Specify_the_location_where_debugger_should_locate_TypeScript_files_instead_of_source_locations_6004", "Specify the location where debugger should locate TypeScript files instead of source locations."),
        Watch_input_files: diag(6005, ts.DiagnosticCategory.Message, "Watch_input_files_6005", "Watch input files."),
        Redirect_output_structure_to_the_directory: diag(6006, ts.DiagnosticCategory.Message, "Redirect_output_structure_to_the_directory_6006", "Redirect output structure to the directory."),
        Do_not_erase_const_enum_declarations_in_generated_code: diag(6007, ts.DiagnosticCategory.Message, "Do_not_erase_const_enum_declarations_in_generated_code_6007", "Do not erase const enum declarations in generated code."),
        Do_not_emit_outputs_if_any_errors_were_reported: diag(6008, ts.DiagnosticCategory.Message, "Do_not_emit_outputs_if_any_errors_were_reported_6008", "Do not emit outputs if any errors were reported."),
        Do_not_emit_comments_to_output: diag(6009, ts.DiagnosticCategory.Message, "Do_not_emit_comments_to_output_6009", "Do not emit comments to output."),
        Do_not_emit_outputs: diag(6010, ts.DiagnosticCategory.Message, "Do_not_emit_outputs_6010", "Do not emit outputs."),
        Allow_default_imports_from_modules_with_no_default_export_This_does_not_affect_code_emit_just_typechecking: diag(6011, ts.DiagnosticCategory.Message, "Allow_default_imports_from_modules_with_no_default_export_This_does_not_affect_code_emit_just_typech_6011", "Allow default imports from modules with no default export. This does not affect code emit, just typechecking."),
        Skip_type_checking_of_declaration_files: diag(6012, ts.DiagnosticCategory.Message, "Skip_type_checking_of_declaration_files_6012", "Skip type checking of declaration files."),
        Do_not_resolve_the_real_path_of_symlinks: diag(6013, ts.DiagnosticCategory.Message, "Do_not_resolve_the_real_path_of_symlinks_6013", "Do not resolve the real path of symlinks."),
        Only_emit_d_ts_declaration_files: diag(6014, ts.DiagnosticCategory.Message, "Only_emit_d_ts_declaration_files_6014", "Only emit '.d.ts' declaration files."),
        Specify_ECMAScript_target_version: diag(6015, ts.DiagnosticCategory.Message, "Specify_ECMAScript_target_version_6015", "Specify ECMAScript target version."),
        Specify_module_code_generation: diag(6016, ts.DiagnosticCategory.Message, "Specify_module_code_generation_6016", "Specify module code generation."),
        Print_this_message: diag(6017, ts.DiagnosticCategory.Message, "Print_this_message_6017", "Print this message."),
        Print_the_compiler_s_version: diag(6019, ts.DiagnosticCategory.Message, "Print_the_compiler_s_version_6019", "Print the compiler's version."),
        Compile_the_project_given_the_path_to_its_configuration_file_or_to_a_folder_with_a_tsconfig_json: diag(6020, ts.DiagnosticCategory.Message, "Compile_the_project_given_the_path_to_its_configuration_file_or_to_a_folder_with_a_tsconfig_json_6020", "Compile the project given the path to its configuration file, or to a folder with a 'tsconfig.json'."),
        Syntax_Colon_0: diag(6023, ts.DiagnosticCategory.Message, "Syntax_Colon_0_6023", "Syntax: {0}"),
        options: diag(6024, ts.DiagnosticCategory.Message, "options_6024", "options"),
        file: diag(6025, ts.DiagnosticCategory.Message, "file_6025", "file"),
        Examples_Colon_0: diag(6026, ts.DiagnosticCategory.Message, "Examples_Colon_0_6026", "Examples: {0}"),
        Options_Colon: diag(6027, ts.DiagnosticCategory.Message, "Options_Colon_6027", "Options:"),
        Version_0: diag(6029, ts.DiagnosticCategory.Message, "Version_0_6029", "Version {0}"),
        Insert_command_line_options_and_files_from_a_file: diag(6030, ts.DiagnosticCategory.Message, "Insert_command_line_options_and_files_from_a_file_6030", "Insert command line options and files from a file."),
        Starting_compilation_in_watch_mode: diag(6031, ts.DiagnosticCategory.Message, "Starting_compilation_in_watch_mode_6031", "Starting compilation in watch mode..."),
        File_change_detected_Starting_incremental_compilation: diag(6032, ts.DiagnosticCategory.Message, "File_change_detected_Starting_incremental_compilation_6032", "File change detected. Starting incremental compilation..."),
        KIND: diag(6034, ts.DiagnosticCategory.Message, "KIND_6034", "KIND"),
        FILE: diag(6035, ts.DiagnosticCategory.Message, "FILE_6035", "FILE"),
        VERSION: diag(6036, ts.DiagnosticCategory.Message, "VERSION_6036", "VERSION"),
        LOCATION: diag(6037, ts.DiagnosticCategory.Message, "LOCATION_6037", "LOCATION"),
        DIRECTORY: diag(6038, ts.DiagnosticCategory.Message, "DIRECTORY_6038", "DIRECTORY"),
        STRATEGY: diag(6039, ts.DiagnosticCategory.Message, "STRATEGY_6039", "STRATEGY"),
        FILE_OR_DIRECTORY: diag(6040, ts.DiagnosticCategory.Message, "FILE_OR_DIRECTORY_6040", "FILE OR DIRECTORY"),
        Errors_Files: diag(6041, ts.DiagnosticCategory.Message, "Errors_Files_6041", "Errors  Files"),
        Generates_corresponding_map_file: diag(6043, ts.DiagnosticCategory.Message, "Generates_corresponding_map_file_6043", "Generates corresponding '.map' file."),
        Compiler_option_0_expects_an_argument: diag(6044, ts.DiagnosticCategory.Error, "Compiler_option_0_expects_an_argument_6044", "Compiler option '{0}' expects an argument."),
        Unterminated_quoted_string_in_response_file_0: diag(6045, ts.DiagnosticCategory.Error, "Unterminated_quoted_string_in_response_file_0_6045", "Unterminated quoted string in response file '{0}'."),
        Argument_for_0_option_must_be_Colon_1: diag(6046, ts.DiagnosticCategory.Error, "Argument_for_0_option_must_be_Colon_1_6046", "Argument for '{0}' option must be: {1}."),
        Locale_must_be_of_the_form_language_or_language_territory_For_example_0_or_1: diag(6048, ts.DiagnosticCategory.Error, "Locale_must_be_of_the_form_language_or_language_territory_For_example_0_or_1_6048", "Locale must be of the form <language> or <language>-<territory>. For example '{0}' or '{1}'."),
        Unable_to_open_file_0: diag(6050, ts.DiagnosticCategory.Error, "Unable_to_open_file_0_6050", "Unable to open file '{0}'."),
        Corrupted_locale_file_0: diag(6051, ts.DiagnosticCategory.Error, "Corrupted_locale_file_0_6051", "Corrupted locale file {0}."),
        Raise_error_on_expressions_and_declarations_with_an_implied_any_type: diag(6052, ts.DiagnosticCategory.Message, "Raise_error_on_expressions_and_declarations_with_an_implied_any_type_6052", "Raise error on expressions and declarations with an implied 'any' type."),
        File_0_not_found: diag(6053, ts.DiagnosticCategory.Error, "File_0_not_found_6053", "File '{0}' not found."),
        File_0_has_an_unsupported_extension_The_only_supported_extensions_are_1: diag(6054, ts.DiagnosticCategory.Error, "File_0_has_an_unsupported_extension_The_only_supported_extensions_are_1_6054", "File '{0}' has an unsupported extension. The only supported extensions are {1}."),
        Suppress_noImplicitAny_errors_for_indexing_objects_lacking_index_signatures: diag(6055, ts.DiagnosticCategory.Message, "Suppress_noImplicitAny_errors_for_indexing_objects_lacking_index_signatures_6055", "Suppress noImplicitAny errors for indexing objects lacking index signatures."),
        Do_not_emit_declarations_for_code_that_has_an_internal_annotation: diag(6056, ts.DiagnosticCategory.Message, "Do_not_emit_declarations_for_code_that_has_an_internal_annotation_6056", "Do not emit declarations for code that has an '@internal' annotation."),
        Specify_the_root_directory_of_input_files_Use_to_control_the_output_directory_structure_with_outDir: diag(6058, ts.DiagnosticCategory.Message, "Specify_the_root_directory_of_input_files_Use_to_control_the_output_directory_structure_with_outDir_6058", "Specify the root directory of input files. Use to control the output directory structure with --outDir."),
        File_0_is_not_under_rootDir_1_rootDir_is_expected_to_contain_all_source_files: diag(6059, ts.DiagnosticCategory.Error, "File_0_is_not_under_rootDir_1_rootDir_is_expected_to_contain_all_source_files_6059", "File '{0}' is not under 'rootDir' '{1}'. 'rootDir' is expected to contain all source files."),
        Specify_the_end_of_line_sequence_to_be_used_when_emitting_files_Colon_CRLF_dos_or_LF_unix: diag(6060, ts.DiagnosticCategory.Message, "Specify_the_end_of_line_sequence_to_be_used_when_emitting_files_Colon_CRLF_dos_or_LF_unix_6060", "Specify the end of line sequence to be used when emitting files: 'CRLF' (dos) or 'LF' (unix)."),
        NEWLINE: diag(6061, ts.DiagnosticCategory.Message, "NEWLINE_6061", "NEWLINE"),
        Option_0_can_only_be_specified_in_tsconfig_json_file_or_set_to_null_on_command_line: diag(6064, ts.DiagnosticCategory.Error, "Option_0_can_only_be_specified_in_tsconfig_json_file_or_set_to_null_on_command_line_6064", "Option '{0}' can only be specified in 'tsconfig.json' file or set to 'null' on command line."),
        Enables_experimental_support_for_ES7_decorators: diag(6065, ts.DiagnosticCategory.Message, "Enables_experimental_support_for_ES7_decorators_6065", "Enables experimental support for ES7 decorators."),
        Enables_experimental_support_for_emitting_type_metadata_for_decorators: diag(6066, ts.DiagnosticCategory.Message, "Enables_experimental_support_for_emitting_type_metadata_for_decorators_6066", "Enables experimental support for emitting type metadata for decorators."),
        Specify_module_resolution_strategy_Colon_node_Node_js_or_classic_TypeScript_pre_1_6: diag(6069, ts.DiagnosticCategory.Message, "Specify_module_resolution_strategy_Colon_node_Node_js_or_classic_TypeScript_pre_1_6_6069", "Specify module resolution strategy: 'node' (Node.js) or 'classic' (TypeScript pre-1.6)."),
        Initializes_a_TypeScript_project_and_creates_a_tsconfig_json_file: diag(6070, ts.DiagnosticCategory.Message, "Initializes_a_TypeScript_project_and_creates_a_tsconfig_json_file_6070", "Initializes a TypeScript project and creates a tsconfig.json file."),
        Successfully_created_a_tsconfig_json_file: diag(6071, ts.DiagnosticCategory.Message, "Successfully_created_a_tsconfig_json_file_6071", "Successfully created a tsconfig.json file."),
        Suppress_excess_property_checks_for_object_literals: diag(6072, ts.DiagnosticCategory.Message, "Suppress_excess_property_checks_for_object_literals_6072", "Suppress excess property checks for object literals."),
        Stylize_errors_and_messages_using_color_and_context_experimental: diag(6073, ts.DiagnosticCategory.Message, "Stylize_errors_and_messages_using_color_and_context_experimental_6073", "Stylize errors and messages using color and context (experimental)."),
        Do_not_report_errors_on_unused_labels: diag(6074, ts.DiagnosticCategory.Message, "Do_not_report_errors_on_unused_labels_6074", "Do not report errors on unused labels."),
        Report_error_when_not_all_code_paths_in_function_return_a_value: diag(6075, ts.DiagnosticCategory.Message, "Report_error_when_not_all_code_paths_in_function_return_a_value_6075", "Report error when not all code paths in function return a value."),
        Report_errors_for_fallthrough_cases_in_switch_statement: diag(6076, ts.DiagnosticCategory.Message, "Report_errors_for_fallthrough_cases_in_switch_statement_6076", "Report errors for fallthrough cases in switch statement."),
        Do_not_report_errors_on_unreachable_code: diag(6077, ts.DiagnosticCategory.Message, "Do_not_report_errors_on_unreachable_code_6077", "Do not report errors on unreachable code."),
        Disallow_inconsistently_cased_references_to_the_same_file: diag(6078, ts.DiagnosticCategory.Message, "Disallow_inconsistently_cased_references_to_the_same_file_6078", "Disallow inconsistently-cased references to the same file."),
        Specify_library_files_to_be_included_in_the_compilation: diag(6079, ts.DiagnosticCategory.Message, "Specify_library_files_to_be_included_in_the_compilation_6079", "Specify library files to be included in the compilation."),
        Specify_JSX_code_generation: diag(6080, ts.DiagnosticCategory.Message, "Specify_JSX_code_generation_6080", "Specify JSX code generation."),
        File_0_has_an_unsupported_extension_so_skipping_it: diag(6081, ts.DiagnosticCategory.Message, "File_0_has_an_unsupported_extension_so_skipping_it_6081", "File '{0}' has an unsupported extension, so skipping it."),
        Only_amd_and_system_modules_are_supported_alongside_0: diag(6082, ts.DiagnosticCategory.Error, "Only_amd_and_system_modules_are_supported_alongside_0_6082", "Only 'amd' and 'system' modules are supported alongside --{0}."),
        Base_directory_to_resolve_non_absolute_module_names: diag(6083, ts.DiagnosticCategory.Message, "Base_directory_to_resolve_non_absolute_module_names_6083", "Base directory to resolve non-absolute module names."),
        Deprecated_Use_jsxFactory_instead_Specify_the_object_invoked_for_createElement_when_targeting_react_JSX_emit: diag(6084, ts.DiagnosticCategory.Message, "Deprecated_Use_jsxFactory_instead_Specify_the_object_invoked_for_createElement_when_targeting_react__6084", "[Deprecated] Use '--jsxFactory' instead. Specify the object invoked for createElement when targeting 'react' JSX emit"),
        Enable_tracing_of_the_name_resolution_process: diag(6085, ts.DiagnosticCategory.Message, "Enable_tracing_of_the_name_resolution_process_6085", "Enable tracing of the name resolution process."),
        Resolving_module_0_from_1: diag(6086, ts.DiagnosticCategory.Message, "Resolving_module_0_from_1_6086", "======== Resolving module '{0}' from '{1}'. ========"),
        Explicitly_specified_module_resolution_kind_Colon_0: diag(6087, ts.DiagnosticCategory.Message, "Explicitly_specified_module_resolution_kind_Colon_0_6087", "Explicitly specified module resolution kind: '{0}'."),
        Module_resolution_kind_is_not_specified_using_0: diag(6088, ts.DiagnosticCategory.Message, "Module_resolution_kind_is_not_specified_using_0_6088", "Module resolution kind is not specified, using '{0}'."),
        Module_name_0_was_successfully_resolved_to_1: diag(6089, ts.DiagnosticCategory.Message, "Module_name_0_was_successfully_resolved_to_1_6089", "======== Module name '{0}' was successfully resolved to '{1}'. ========"),
        Module_name_0_was_not_resolved: diag(6090, ts.DiagnosticCategory.Message, "Module_name_0_was_not_resolved_6090", "======== Module name '{0}' was not resolved. ========"),
        paths_option_is_specified_looking_for_a_pattern_to_match_module_name_0: diag(6091, ts.DiagnosticCategory.Message, "paths_option_is_specified_looking_for_a_pattern_to_match_module_name_0_6091", "'paths' option is specified, looking for a pattern to match module name '{0}'."),
        Module_name_0_matched_pattern_1: diag(6092, ts.DiagnosticCategory.Message, "Module_name_0_matched_pattern_1_6092", "Module name '{0}', matched pattern '{1}'."),
        Trying_substitution_0_candidate_module_location_Colon_1: diag(6093, ts.DiagnosticCategory.Message, "Trying_substitution_0_candidate_module_location_Colon_1_6093", "Trying substitution '{0}', candidate module location: '{1}'."),
        Resolving_module_name_0_relative_to_base_url_1_2: diag(6094, ts.DiagnosticCategory.Message, "Resolving_module_name_0_relative_to_base_url_1_2_6094", "Resolving module name '{0}' relative to base url '{1}' - '{2}'."),
        Loading_module_as_file_Slash_folder_candidate_module_location_0_target_file_type_1: diag(6095, ts.DiagnosticCategory.Message, "Loading_module_as_file_Slash_folder_candidate_module_location_0_target_file_type_1_6095", "Loading module as file / folder, candidate module location '{0}', target file type '{1}'."),
        File_0_does_not_exist: diag(6096, ts.DiagnosticCategory.Message, "File_0_does_not_exist_6096", "File '{0}' does not exist."),
        File_0_exist_use_it_as_a_name_resolution_result: diag(6097, ts.DiagnosticCategory.Message, "File_0_exist_use_it_as_a_name_resolution_result_6097", "File '{0}' exist - use it as a name resolution result."),
        Loading_module_0_from_node_modules_folder_target_file_type_1: diag(6098, ts.DiagnosticCategory.Message, "Loading_module_0_from_node_modules_folder_target_file_type_1_6098", "Loading module '{0}' from 'node_modules' folder, target file type '{1}'."),
        Found_package_json_at_0: diag(6099, ts.DiagnosticCategory.Message, "Found_package_json_at_0_6099", "Found 'package.json' at '{0}'."),
        package_json_does_not_have_a_0_field: diag(6100, ts.DiagnosticCategory.Message, "package_json_does_not_have_a_0_field_6100", "'package.json' does not have a '{0}' field."),
        package_json_has_0_field_1_that_references_2: diag(6101, ts.DiagnosticCategory.Message, "package_json_has_0_field_1_that_references_2_6101", "'package.json' has '{0}' field '{1}' that references '{2}'."),
        Allow_javascript_files_to_be_compiled: diag(6102, ts.DiagnosticCategory.Message, "Allow_javascript_files_to_be_compiled_6102", "Allow javascript files to be compiled."),
        Checking_if_0_is_the_longest_matching_prefix_for_1_2: diag(6104, ts.DiagnosticCategory.Message, "Checking_if_0_is_the_longest_matching_prefix_for_1_2_6104", "Checking if '{0}' is the longest matching prefix for '{1}' - '{2}'."),
        Expected_type_of_0_field_in_package_json_to_be_1_got_2: diag(6105, ts.DiagnosticCategory.Message, "Expected_type_of_0_field_in_package_json_to_be_1_got_2_6105", "Expected type of '{0}' field in 'package.json' to be '{1}', got '{2}'."),
        baseUrl_option_is_set_to_0_using_this_value_to_resolve_non_relative_module_name_1: diag(6106, ts.DiagnosticCategory.Message, "baseUrl_option_is_set_to_0_using_this_value_to_resolve_non_relative_module_name_1_6106", "'baseUrl' option is set to '{0}', using this value to resolve non-relative module name '{1}'."),
        rootDirs_option_is_set_using_it_to_resolve_relative_module_name_0: diag(6107, ts.DiagnosticCategory.Message, "rootDirs_option_is_set_using_it_to_resolve_relative_module_name_0_6107", "'rootDirs' option is set, using it to resolve relative module name '{0}'."),
        Longest_matching_prefix_for_0_is_1: diag(6108, ts.DiagnosticCategory.Message, "Longest_matching_prefix_for_0_is_1_6108", "Longest matching prefix for '{0}' is '{1}'."),
        Loading_0_from_the_root_dir_1_candidate_location_2: diag(6109, ts.DiagnosticCategory.Message, "Loading_0_from_the_root_dir_1_candidate_location_2_6109", "Loading '{0}' from the root dir '{1}', candidate location '{2}'."),
        Trying_other_entries_in_rootDirs: diag(6110, ts.DiagnosticCategory.Message, "Trying_other_entries_in_rootDirs_6110", "Trying other entries in 'rootDirs'."),
        Module_resolution_using_rootDirs_has_failed: diag(6111, ts.DiagnosticCategory.Message, "Module_resolution_using_rootDirs_has_failed_6111", "Module resolution using 'rootDirs' has failed."),
        Do_not_emit_use_strict_directives_in_module_output: diag(6112, ts.DiagnosticCategory.Message, "Do_not_emit_use_strict_directives_in_module_output_6112", "Do not emit 'use strict' directives in module output."),
        Enable_strict_null_checks: diag(6113, ts.DiagnosticCategory.Message, "Enable_strict_null_checks_6113", "Enable strict null checks."),
        Unknown_option_excludes_Did_you_mean_exclude: diag(6114, ts.DiagnosticCategory.Error, "Unknown_option_excludes_Did_you_mean_exclude_6114", "Unknown option 'excludes'. Did you mean 'exclude'?"),
        Raise_error_on_this_expressions_with_an_implied_any_type: diag(6115, ts.DiagnosticCategory.Message, "Raise_error_on_this_expressions_with_an_implied_any_type_6115", "Raise error on 'this' expressions with an implied 'any' type."),
        Resolving_type_reference_directive_0_containing_file_1_root_directory_2: diag(6116, ts.DiagnosticCategory.Message, "Resolving_type_reference_directive_0_containing_file_1_root_directory_2_6116", "======== Resolving type reference directive '{0}', containing file '{1}', root directory '{2}'. ========"),
        Type_reference_directive_0_was_successfully_resolved_to_1_primary_Colon_2: diag(6119, ts.DiagnosticCategory.Message, "Type_reference_directive_0_was_successfully_resolved_to_1_primary_Colon_2_6119", "======== Type reference directive '{0}' was successfully resolved to '{1}', primary: {2}. ========"),
        Type_reference_directive_0_was_not_resolved: diag(6120, ts.DiagnosticCategory.Message, "Type_reference_directive_0_was_not_resolved_6120", "======== Type reference directive '{0}' was not resolved. ========"),
        Resolving_with_primary_search_path_0: diag(6121, ts.DiagnosticCategory.Message, "Resolving_with_primary_search_path_0_6121", "Resolving with primary search path '{0}'."),
        Root_directory_cannot_be_determined_skipping_primary_search_paths: diag(6122, ts.DiagnosticCategory.Message, "Root_directory_cannot_be_determined_skipping_primary_search_paths_6122", "Root directory cannot be determined, skipping primary search paths."),
        Resolving_type_reference_directive_0_containing_file_1_root_directory_not_set: diag(6123, ts.DiagnosticCategory.Message, "Resolving_type_reference_directive_0_containing_file_1_root_directory_not_set_6123", "======== Resolving type reference directive '{0}', containing file '{1}', root directory not set. ========"),
        Type_declaration_files_to_be_included_in_compilation: diag(6124, ts.DiagnosticCategory.Message, "Type_declaration_files_to_be_included_in_compilation_6124", "Type declaration files to be included in compilation."),
        Looking_up_in_node_modules_folder_initial_location_0: diag(6125, ts.DiagnosticCategory.Message, "Looking_up_in_node_modules_folder_initial_location_0_6125", "Looking up in 'node_modules' folder, initial location '{0}'."),
        Containing_file_is_not_specified_and_root_directory_cannot_be_determined_skipping_lookup_in_node_modules_folder: diag(6126, ts.DiagnosticCategory.Message, "Containing_file_is_not_specified_and_root_directory_cannot_be_determined_skipping_lookup_in_node_mod_6126", "Containing file is not specified and root directory cannot be determined, skipping lookup in 'node_modules' folder."),
        Resolving_type_reference_directive_0_containing_file_not_set_root_directory_1: diag(6127, ts.DiagnosticCategory.Message, "Resolving_type_reference_directive_0_containing_file_not_set_root_directory_1_6127", "======== Resolving type reference directive '{0}', containing file not set, root directory '{1}'. ========"),
        Resolving_type_reference_directive_0_containing_file_not_set_root_directory_not_set: diag(6128, ts.DiagnosticCategory.Message, "Resolving_type_reference_directive_0_containing_file_not_set_root_directory_not_set_6128", "======== Resolving type reference directive '{0}', containing file not set, root directory not set. ========"),
        Resolving_real_path_for_0_result_1: diag(6130, ts.DiagnosticCategory.Message, "Resolving_real_path_for_0_result_1_6130", "Resolving real path for '{0}', result '{1}'."),
        Cannot_compile_modules_using_option_0_unless_the_module_flag_is_amd_or_system: diag(6131, ts.DiagnosticCategory.Error, "Cannot_compile_modules_using_option_0_unless_the_module_flag_is_amd_or_system_6131", "Cannot compile modules using option '{0}' unless the '--module' flag is 'amd' or 'system'."),
        File_name_0_has_a_1_extension_stripping_it: diag(6132, ts.DiagnosticCategory.Message, "File_name_0_has_a_1_extension_stripping_it_6132", "File name '{0}' has a '{1}' extension - stripping it."),
        _0_is_declared_but_its_value_is_never_read: diag(6133, ts.DiagnosticCategory.Error, "_0_is_declared_but_its_value_is_never_read_6133", "'{0}' is declared but its value is never read.", true),
        Report_errors_on_unused_locals: diag(6134, ts.DiagnosticCategory.Message, "Report_errors_on_unused_locals_6134", "Report errors on unused locals."),
        Report_errors_on_unused_parameters: diag(6135, ts.DiagnosticCategory.Message, "Report_errors_on_unused_parameters_6135", "Report errors on unused parameters."),
        The_maximum_dependency_depth_to_search_under_node_modules_and_load_JavaScript_files: diag(6136, ts.DiagnosticCategory.Message, "The_maximum_dependency_depth_to_search_under_node_modules_and_load_JavaScript_files_6136", "The maximum dependency depth to search under node_modules and load JavaScript files."),
        Cannot_import_type_declaration_files_Consider_importing_0_instead_of_1: diag(6137, ts.DiagnosticCategory.Error, "Cannot_import_type_declaration_files_Consider_importing_0_instead_of_1_6137", "Cannot import type declaration files. Consider importing '{0}' instead of '{1}'."),
        Property_0_is_declared_but_its_value_is_never_read: diag(6138, ts.DiagnosticCategory.Error, "Property_0_is_declared_but_its_value_is_never_read_6138", "Property '{0}' is declared but its value is never read.", true),
        Import_emit_helpers_from_tslib: diag(6139, ts.DiagnosticCategory.Message, "Import_emit_helpers_from_tslib_6139", "Import emit helpers from 'tslib'."),
        Auto_discovery_for_typings_is_enabled_in_project_0_Running_extra_resolution_pass_for_module_1_using_cache_location_2: diag(6140, ts.DiagnosticCategory.Error, "Auto_discovery_for_typings_is_enabled_in_project_0_Running_extra_resolution_pass_for_module_1_using__6140", "Auto discovery for typings is enabled in project '{0}'. Running extra resolution pass for module '{1}' using cache location '{2}'."),
        Parse_in_strict_mode_and_emit_use_strict_for_each_source_file: diag(6141, ts.DiagnosticCategory.Message, "Parse_in_strict_mode_and_emit_use_strict_for_each_source_file_6141", "Parse in strict mode and emit \"use strict\" for each source file."),
        Module_0_was_resolved_to_1_but_jsx_is_not_set: diag(6142, ts.DiagnosticCategory.Error, "Module_0_was_resolved_to_1_but_jsx_is_not_set_6142", "Module '{0}' was resolved to '{1}', but '--jsx' is not set."),
        Module_0_was_resolved_as_locally_declared_ambient_module_in_file_1: diag(6144, ts.DiagnosticCategory.Message, "Module_0_was_resolved_as_locally_declared_ambient_module_in_file_1_6144", "Module '{0}' was resolved as locally declared ambient module in file '{1}'."),
        Module_0_was_resolved_as_ambient_module_declared_in_1_since_this_file_was_not_modified: diag(6145, ts.DiagnosticCategory.Message, "Module_0_was_resolved_as_ambient_module_declared_in_1_since_this_file_was_not_modified_6145", "Module '{0}' was resolved as ambient module declared in '{1}' since this file was not modified."),
        Specify_the_JSX_factory_function_to_use_when_targeting_react_JSX_emit_e_g_React_createElement_or_h: diag(6146, ts.DiagnosticCategory.Message, "Specify_the_JSX_factory_function_to_use_when_targeting_react_JSX_emit_e_g_React_createElement_or_h_6146", "Specify the JSX factory function to use when targeting 'react' JSX emit, e.g. 'React.createElement' or 'h'."),
        Resolution_for_module_0_was_found_in_cache_from_location_1: diag(6147, ts.DiagnosticCategory.Message, "Resolution_for_module_0_was_found_in_cache_from_location_1_6147", "Resolution for module '{0}' was found in cache from location '{1}'."),
        Directory_0_does_not_exist_skipping_all_lookups_in_it: diag(6148, ts.DiagnosticCategory.Message, "Directory_0_does_not_exist_skipping_all_lookups_in_it_6148", "Directory '{0}' does not exist, skipping all lookups in it."),
        Show_diagnostic_information: diag(6149, ts.DiagnosticCategory.Message, "Show_diagnostic_information_6149", "Show diagnostic information."),
        Show_verbose_diagnostic_information: diag(6150, ts.DiagnosticCategory.Message, "Show_verbose_diagnostic_information_6150", "Show verbose diagnostic information."),
        Emit_a_single_file_with_source_maps_instead_of_having_a_separate_file: diag(6151, ts.DiagnosticCategory.Message, "Emit_a_single_file_with_source_maps_instead_of_having_a_separate_file_6151", "Emit a single file with source maps instead of having a separate file."),
        Emit_the_source_alongside_the_sourcemaps_within_a_single_file_requires_inlineSourceMap_or_sourceMap_to_be_set: diag(6152, ts.DiagnosticCategory.Message, "Emit_the_source_alongside_the_sourcemaps_within_a_single_file_requires_inlineSourceMap_or_sourceMap__6152", "Emit the source alongside the sourcemaps within a single file; requires '--inlineSourceMap' or '--sourceMap' to be set."),
        Transpile_each_file_as_a_separate_module_similar_to_ts_transpileModule: diag(6153, ts.DiagnosticCategory.Message, "Transpile_each_file_as_a_separate_module_similar_to_ts_transpileModule_6153", "Transpile each file as a separate module (similar to 'ts.transpileModule')."),
        Print_names_of_generated_files_part_of_the_compilation: diag(6154, ts.DiagnosticCategory.Message, "Print_names_of_generated_files_part_of_the_compilation_6154", "Print names of generated files part of the compilation."),
        Print_names_of_files_part_of_the_compilation: diag(6155, ts.DiagnosticCategory.Message, "Print_names_of_files_part_of_the_compilation_6155", "Print names of files part of the compilation."),
        The_locale_used_when_displaying_messages_to_the_user_e_g_en_us: diag(6156, ts.DiagnosticCategory.Message, "The_locale_used_when_displaying_messages_to_the_user_e_g_en_us_6156", "The locale used when displaying messages to the user (e.g. 'en-us')"),
        Do_not_generate_custom_helper_functions_like_extends_in_compiled_output: diag(6157, ts.DiagnosticCategory.Message, "Do_not_generate_custom_helper_functions_like_extends_in_compiled_output_6157", "Do not generate custom helper functions like '__extends' in compiled output."),
        Do_not_include_the_default_library_file_lib_d_ts: diag(6158, ts.DiagnosticCategory.Message, "Do_not_include_the_default_library_file_lib_d_ts_6158", "Do not include the default library file (lib.d.ts)."),
        Do_not_add_triple_slash_references_or_imported_modules_to_the_list_of_compiled_files: diag(6159, ts.DiagnosticCategory.Message, "Do_not_add_triple_slash_references_or_imported_modules_to_the_list_of_compiled_files_6159", "Do not add triple-slash references or imported modules to the list of compiled files."),
        Deprecated_Use_skipLibCheck_instead_Skip_type_checking_of_default_library_declaration_files: diag(6160, ts.DiagnosticCategory.Message, "Deprecated_Use_skipLibCheck_instead_Skip_type_checking_of_default_library_declaration_files_6160", "[Deprecated] Use '--skipLibCheck' instead. Skip type checking of default library declaration files."),
        List_of_folders_to_include_type_definitions_from: diag(6161, ts.DiagnosticCategory.Message, "List_of_folders_to_include_type_definitions_from_6161", "List of folders to include type definitions from."),
        Disable_size_limitations_on_JavaScript_projects: diag(6162, ts.DiagnosticCategory.Message, "Disable_size_limitations_on_JavaScript_projects_6162", "Disable size limitations on JavaScript projects."),
        The_character_set_of_the_input_files: diag(6163, ts.DiagnosticCategory.Message, "The_character_set_of_the_input_files_6163", "The character set of the input files."),
        Do_not_truncate_error_messages: diag(6165, ts.DiagnosticCategory.Message, "Do_not_truncate_error_messages_6165", "Do not truncate error messages."),
        Output_directory_for_generated_declaration_files: diag(6166, ts.DiagnosticCategory.Message, "Output_directory_for_generated_declaration_files_6166", "Output directory for generated declaration files."),
        A_series_of_entries_which_re_map_imports_to_lookup_locations_relative_to_the_baseUrl: diag(6167, ts.DiagnosticCategory.Message, "A_series_of_entries_which_re_map_imports_to_lookup_locations_relative_to_the_baseUrl_6167", "A series of entries which re-map imports to lookup locations relative to the 'baseUrl'."),
        List_of_root_folders_whose_combined_content_represents_the_structure_of_the_project_at_runtime: diag(6168, ts.DiagnosticCategory.Message, "List_of_root_folders_whose_combined_content_represents_the_structure_of_the_project_at_runtime_6168", "List of root folders whose combined content represents the structure of the project at runtime."),
        Show_all_compiler_options: diag(6169, ts.DiagnosticCategory.Message, "Show_all_compiler_options_6169", "Show all compiler options."),
        Deprecated_Use_outFile_instead_Concatenate_and_emit_output_to_single_file: diag(6170, ts.DiagnosticCategory.Message, "Deprecated_Use_outFile_instead_Concatenate_and_emit_output_to_single_file_6170", "[Deprecated] Use '--outFile' instead. Concatenate and emit output to single file"),
        Command_line_Options: diag(6171, ts.DiagnosticCategory.Message, "Command_line_Options_6171", "Command-line Options"),
        Provide_full_support_for_iterables_in_for_of_spread_and_destructuring_when_targeting_ES5_or_ES3: diag(6179, ts.DiagnosticCategory.Message, "Provide_full_support_for_iterables_in_for_of_spread_and_destructuring_when_targeting_ES5_or_ES3_6179", "Provide full support for iterables in 'for-of', spread, and destructuring when targeting 'ES5' or 'ES3'."),
        Enable_all_strict_type_checking_options: diag(6180, ts.DiagnosticCategory.Message, "Enable_all_strict_type_checking_options_6180", "Enable all strict type-checking options."),
        Scoped_package_detected_looking_in_0: diag(6182, ts.DiagnosticCategory.Message, "Scoped_package_detected_looking_in_0_6182", "Scoped package detected, looking in '{0}'"),
        Reusing_resolution_of_module_0_from_1_of_old_program_it_was_successfully_resolved_to_2: diag(6183, ts.DiagnosticCategory.Message, "Reusing_resolution_of_module_0_from_1_of_old_program_it_was_successfully_resolved_to_2_6183", "Reusing resolution of module '{0}' from '{1}' of old program, it was successfully resolved to '{2}'."),
        Reusing_resolution_of_module_0_from_1_of_old_program_it_was_successfully_resolved_to_2_with_Package_ID_3: diag(6184, ts.DiagnosticCategory.Message, "Reusing_resolution_of_module_0_from_1_of_old_program_it_was_successfully_resolved_to_2_with_Package__6184", "Reusing resolution of module '{0}' from '{1}' of old program, it was successfully resolved to '{2}' with Package ID '{3}'."),
        Enable_strict_checking_of_function_types: diag(6186, ts.DiagnosticCategory.Message, "Enable_strict_checking_of_function_types_6186", "Enable strict checking of function types."),
        Enable_strict_checking_of_property_initialization_in_classes: diag(6187, ts.DiagnosticCategory.Message, "Enable_strict_checking_of_property_initialization_in_classes_6187", "Enable strict checking of property initialization in classes."),
        Numeric_separators_are_not_allowed_here: diag(6188, ts.DiagnosticCategory.Error, "Numeric_separators_are_not_allowed_here_6188", "Numeric separators are not allowed here."),
        Multiple_consecutive_numeric_separators_are_not_permitted: diag(6189, ts.DiagnosticCategory.Error, "Multiple_consecutive_numeric_separators_are_not_permitted_6189", "Multiple consecutive numeric separators are not permitted."),
        Whether_to_keep_outdated_console_output_in_watch_mode_instead_of_clearing_the_screen: diag(6191, ts.DiagnosticCategory.Message, "Whether_to_keep_outdated_console_output_in_watch_mode_instead_of_clearing_the_screen_6191", "Whether to keep outdated console output in watch mode instead of clearing the screen."),
        All_imports_in_import_declaration_are_unused: diag(6192, ts.DiagnosticCategory.Error, "All_imports_in_import_declaration_are_unused_6192", "All imports in import declaration are unused.", true),
        Found_1_error_Watching_for_file_changes: diag(6193, ts.DiagnosticCategory.Message, "Found_1_error_Watching_for_file_changes_6193", "Found 1 error. Watching for file changes."),
        Found_0_errors_Watching_for_file_changes: diag(6194, ts.DiagnosticCategory.Message, "Found_0_errors_Watching_for_file_changes_6194", "Found {0} errors. Watching for file changes."),
        Resolve_keyof_to_string_valued_property_names_only_no_numbers_or_symbols: diag(6195, ts.DiagnosticCategory.Message, "Resolve_keyof_to_string_valued_property_names_only_no_numbers_or_symbols_6195", "Resolve 'keyof' to string valued property names only (no numbers or symbols)."),
        _0_is_declared_but_never_used: diag(6196, ts.DiagnosticCategory.Error, "_0_is_declared_but_never_used_6196", "'{0}' is declared but never used.", true),
        Include_modules_imported_with_json_extension: diag(6197, ts.DiagnosticCategory.Message, "Include_modules_imported_with_json_extension_6197", "Include modules imported with '.json' extension"),
        All_destructured_elements_are_unused: diag(6198, ts.DiagnosticCategory.Error, "All_destructured_elements_are_unused_6198", "All destructured elements are unused.", true),
        All_variables_are_unused: diag(6199, ts.DiagnosticCategory.Error, "All_variables_are_unused_6199", "All variables are unused.", true),
        Definitions_of_the_following_identifiers_conflict_with_those_in_another_file_Colon_0: diag(6200, ts.DiagnosticCategory.Error, "Definitions_of_the_following_identifiers_conflict_with_those_in_another_file_Colon_0_6200", "Definitions of the following identifiers conflict with those in another file: {0}"),
        Conflicts_are_in_this_file: diag(6201, ts.DiagnosticCategory.Message, "Conflicts_are_in_this_file_6201", "Conflicts are in this file."),
        Project_references_may_not_form_a_circular_graph_Cycle_detected_Colon_0: diag(6202, ts.DiagnosticCategory.Error, "Project_references_may_not_form_a_circular_graph_Cycle_detected_Colon_0_6202", "Project references may not form a circular graph. Cycle detected: {0}"),
        _0_was_also_declared_here: diag(6203, ts.DiagnosticCategory.Message, "_0_was_also_declared_here_6203", "'{0}' was also declared here."),
        and_here: diag(6204, ts.DiagnosticCategory.Message, "and_here_6204", "and here."),
        All_type_parameters_are_unused: diag(6205, ts.DiagnosticCategory.Error, "All_type_parameters_are_unused_6205", "All type parameters are unused."),
        package_json_has_a_typesVersions_field_with_version_specific_path_mappings: diag(6206, ts.DiagnosticCategory.Message, "package_json_has_a_typesVersions_field_with_version_specific_path_mappings_6206", "'package.json' has a 'typesVersions' field with version-specific path mappings."),
        package_json_does_not_have_a_typesVersions_entry_that_matches_version_0: diag(6207, ts.DiagnosticCategory.Message, "package_json_does_not_have_a_typesVersions_entry_that_matches_version_0_6207", "'package.json' does not have a 'typesVersions' entry that matches version '{0}'."),
        package_json_has_a_typesVersions_entry_0_that_matches_compiler_version_1_looking_for_a_pattern_to_match_module_name_2: diag(6208, ts.DiagnosticCategory.Message, "package_json_has_a_typesVersions_entry_0_that_matches_compiler_version_1_looking_for_a_pattern_to_ma_6208", "'package.json' has a 'typesVersions' entry '{0}' that matches compiler version '{1}', looking for a pattern to match module name '{2}'."),
        package_json_has_a_typesVersions_entry_0_that_is_not_a_valid_semver_range: diag(6209, ts.DiagnosticCategory.Message, "package_json_has_a_typesVersions_entry_0_that_is_not_a_valid_semver_range_6209", "'package.json' has a 'typesVersions' entry '{0}' that is not a valid semver range."),
        An_argument_for_0_was_not_provided: diag(6210, ts.DiagnosticCategory.Message, "An_argument_for_0_was_not_provided_6210", "An argument for '{0}' was not provided."),
        An_argument_matching_this_binding_pattern_was_not_provided: diag(6211, ts.DiagnosticCategory.Message, "An_argument_matching_this_binding_pattern_was_not_provided_6211", "An argument matching this binding pattern was not provided."),
        Did_you_mean_to_call_this_expression: diag(6212, ts.DiagnosticCategory.Message, "Did_you_mean_to_call_this_expression_6212", "Did you mean to call this expression?"),
        Did_you_mean_to_use_new_with_this_expression: diag(6213, ts.DiagnosticCategory.Message, "Did_you_mean_to_use_new_with_this_expression_6213", "Did you mean to use 'new' with this expression?"),
        Enable_strict_bind_call_and_apply_methods_on_functions: diag(6214, ts.DiagnosticCategory.Message, "Enable_strict_bind_call_and_apply_methods_on_functions_6214", "Enable strict 'bind', 'call', and 'apply' methods on functions."),
        Using_compiler_options_of_project_reference_redirect_0: diag(6215, ts.DiagnosticCategory.Message, "Using_compiler_options_of_project_reference_redirect_0_6215", "Using compiler options of project reference redirect '{0}'."),
        Found_1_error: diag(6216, ts.DiagnosticCategory.Message, "Found_1_error_6216", "Found 1 error."),
        Found_0_errors: diag(6217, ts.DiagnosticCategory.Message, "Found_0_errors_6217", "Found {0} errors."),
        Module_name_0_was_successfully_resolved_to_1_with_Package_ID_2: diag(6218, ts.DiagnosticCategory.Message, "Module_name_0_was_successfully_resolved_to_1_with_Package_ID_2_6218", "======== Module name '{0}' was successfully resolved to '{1}' with Package ID '{2}'. ========"),
        Type_reference_directive_0_was_successfully_resolved_to_1_with_Package_ID_2_primary_Colon_3: diag(6219, ts.DiagnosticCategory.Message, "Type_reference_directive_0_was_successfully_resolved_to_1_with_Package_ID_2_primary_Colon_3_6219", "======== Type reference directive '{0}' was successfully resolved to '{1}' with Package ID '{2}', primary: {3}. ========"),
        package_json_had_a_falsy_0_field: diag(6220, ts.DiagnosticCategory.Message, "package_json_had_a_falsy_0_field_6220", "'package.json' had a falsy '{0}' field."),
        Disable_use_of_source_files_instead_of_declaration_files_from_referenced_projects: diag(6221, ts.DiagnosticCategory.Message, "Disable_use_of_source_files_instead_of_declaration_files_from_referenced_projects_6221", "Disable use of source files instead of declaration files from referenced projects."),
        Emit_class_fields_with_Define_instead_of_Set: diag(6222, ts.DiagnosticCategory.Message, "Emit_class_fields_with_Define_instead_of_Set_6222", "Emit class fields with Define instead of Set."),
        Generates_a_CPU_profile: diag(6223, ts.DiagnosticCategory.Message, "Generates_a_CPU_profile_6223", "Generates a CPU profile."),
        Disable_solution_searching_for_this_project: diag(6224, ts.DiagnosticCategory.Message, "Disable_solution_searching_for_this_project_6224", "Disable solution searching for this project."),
        Specify_strategy_for_watching_file_Colon_FixedPollingInterval_default_PriorityPollingInterval_DynamicPriorityPolling_FixedChunkSizePolling_UseFsEvents_UseFsEventsOnParentDirectory: diag(6225, ts.DiagnosticCategory.Message, "Specify_strategy_for_watching_file_Colon_FixedPollingInterval_default_PriorityPollingInterval_Dynami_6225", "Specify strategy for watching file: 'FixedPollingInterval' (default), 'PriorityPollingInterval', 'DynamicPriorityPolling', 'FixedChunkSizePolling', 'UseFsEvents', 'UseFsEventsOnParentDirectory'."),
        Specify_strategy_for_watching_directory_on_platforms_that_don_t_support_recursive_watching_natively_Colon_UseFsEvents_default_FixedPollingInterval_DynamicPriorityPolling_FixedChunkSizePolling: diag(6226, ts.DiagnosticCategory.Message, "Specify_strategy_for_watching_directory_on_platforms_that_don_t_support_recursive_watching_natively__6226", "Specify strategy for watching directory on platforms that don't support recursive watching natively: 'UseFsEvents' (default), 'FixedPollingInterval', 'DynamicPriorityPolling', 'FixedChunkSizePolling'."),
        Specify_strategy_for_creating_a_polling_watch_when_it_fails_to_create_using_file_system_events_Colon_FixedInterval_default_PriorityInterval_DynamicPriority_FixedChunkSize: diag(6227, ts.DiagnosticCategory.Message, "Specify_strategy_for_creating_a_polling_watch_when_it_fails_to_create_using_file_system_events_Colon_6227", "Specify strategy for creating a polling watch when it fails to create using file system events: 'FixedInterval' (default), 'PriorityInterval', 'DynamicPriority', 'FixedChunkSize'."),
        Tag_0_expects_at_least_1_arguments_but_the_JSX_factory_2_provides_at_most_3: diag(6229, ts.DiagnosticCategory.Error, "Tag_0_expects_at_least_1_arguments_but_the_JSX_factory_2_provides_at_most_3_6229", "Tag '{0}' expects at least '{1}' arguments, but the JSX factory '{2}' provides at most '{3}'."),
        Option_0_can_only_be_specified_in_tsconfig_json_file_or_set_to_false_or_null_on_command_line: diag(6230, ts.DiagnosticCategory.Error, "Option_0_can_only_be_specified_in_tsconfig_json_file_or_set_to_false_or_null_on_command_line_6230", "Option '{0}' can only be specified in 'tsconfig.json' file or set to 'false' or 'null' on command line."),
        Could_not_resolve_the_path_0_with_the_extensions_Colon_1: diag(6231, ts.DiagnosticCategory.Error, "Could_not_resolve_the_path_0_with_the_extensions_Colon_1_6231", "Could not resolve the path '{0}' with the extensions: {1}."),
        Declaration_augments_declaration_in_another_file_This_cannot_be_serialized: diag(6232, ts.DiagnosticCategory.Error, "Declaration_augments_declaration_in_another_file_This_cannot_be_serialized_6232", "Declaration augments declaration in another file. This cannot be serialized."),
        This_is_the_declaration_being_augmented_Consider_moving_the_augmenting_declaration_into_the_same_file: diag(6233, ts.DiagnosticCategory.Error, "This_is_the_declaration_being_augmented_Consider_moving_the_augmenting_declaration_into_the_same_fil_6233", "This is the declaration being augmented. Consider moving the augmenting declaration into the same file."),
        This_expression_is_not_callable_because_it_is_a_get_accessor_Did_you_mean_to_use_it_without: diag(6234, ts.DiagnosticCategory.Error, "This_expression_is_not_callable_because_it_is_a_get_accessor_Did_you_mean_to_use_it_without_6234", "This expression is not callable because it is a 'get' accessor. Did you mean to use it without '()'?"),
        Disable_loading_referenced_projects: diag(6235, ts.DiagnosticCategory.Message, "Disable_loading_referenced_projects_6235", "Disable loading referenced projects."),
        Arguments_for_the_rest_parameter_0_were_not_provided: diag(6236, ts.DiagnosticCategory.Error, "Arguments_for_the_rest_parameter_0_were_not_provided_6236", "Arguments for the rest parameter '{0}' were not provided."),
        Generates_an_event_trace_and_a_list_of_types: diag(6237, ts.DiagnosticCategory.Message, "Generates_an_event_trace_and_a_list_of_types_6237", "Generates an event trace and a list of types."),
        Specify_the_module_specifier_to_be_used_to_import_the_jsx_and_jsxs_factory_functions_from_eg_react: diag(6238, ts.DiagnosticCategory.Error, "Specify_the_module_specifier_to_be_used_to_import_the_jsx_and_jsxs_factory_functions_from_eg_react_6238", "Specify the module specifier to be used to import the 'jsx' and 'jsxs' factory functions from. eg, react"),
        File_0_exists_according_to_earlier_cached_lookups: diag(6239, ts.DiagnosticCategory.Message, "File_0_exists_according_to_earlier_cached_lookups_6239", "File '{0}' exists according to earlier cached lookups."),
        File_0_does_not_exist_according_to_earlier_cached_lookups: diag(6240, ts.DiagnosticCategory.Message, "File_0_does_not_exist_according_to_earlier_cached_lookups_6240", "File '{0}' does not exist according to earlier cached lookups."),
        Resolution_for_type_reference_directive_0_was_found_in_cache_from_location_1: diag(6241, ts.DiagnosticCategory.Message, "Resolution_for_type_reference_directive_0_was_found_in_cache_from_location_1_6241", "Resolution for type reference directive '{0}' was found in cache from location '{1}'."),
        Resolving_type_reference_directive_0_containing_file_1: diag(6242, ts.DiagnosticCategory.Message, "Resolving_type_reference_directive_0_containing_file_1_6242", "======== Resolving type reference directive '{0}', containing file '{1}'. ========"),
        Interpret_optional_property_types_as_written_rather_than_adding_undefined: diag(6243, ts.DiagnosticCategory.Message, "Interpret_optional_property_types_as_written_rather_than_adding_undefined_6243", "Interpret optional property types as written, rather than adding 'undefined'."),
        Modules: diag(6244, ts.DiagnosticCategory.Message, "Modules_6244", "Modules"),
        File_Management: diag(6245, ts.DiagnosticCategory.Message, "File_Management_6245", "File Management"),
        Emit: diag(6246, ts.DiagnosticCategory.Message, "Emit_6246", "Emit"),
        JavaScript_Support: diag(6247, ts.DiagnosticCategory.Message, "JavaScript_Support_6247", "JavaScript Support"),
        Type_Checking: diag(6248, ts.DiagnosticCategory.Message, "Type_Checking_6248", "Type Checking"),
        Editor_Support: diag(6249, ts.DiagnosticCategory.Message, "Editor_Support_6249", "Editor Support"),
        Watch_and_Build_Modes: diag(6250, ts.DiagnosticCategory.Message, "Watch_and_Build_Modes_6250", "Watch and Build Modes"),
        Compiler_Diagnostics: diag(6251, ts.DiagnosticCategory.Message, "Compiler_Diagnostics_6251", "Compiler Diagnostics"),
        Interop_Constraints: diag(6252, ts.DiagnosticCategory.Message, "Interop_Constraints_6252", "Interop Constraints"),
        Backwards_Compatibility: diag(6253, ts.DiagnosticCategory.Message, "Backwards_Compatibility_6253", "Backwards Compatibility"),
        Language_and_Environment: diag(6254, ts.DiagnosticCategory.Message, "Language_and_Environment_6254", "Language and Environment"),
        Projects: diag(6255, ts.DiagnosticCategory.Message, "Projects_6255", "Projects"),
        Output_Formatting: diag(6256, ts.DiagnosticCategory.Message, "Output_Formatting_6256", "Output Formatting"),
        Completeness: diag(6257, ts.DiagnosticCategory.Message, "Completeness_6257", "Completeness"),
        _0_should_be_set_inside_the_compilerOptions_object_of_the_config_json_file: diag(6258, ts.DiagnosticCategory.Error, "_0_should_be_set_inside_the_compilerOptions_object_of_the_config_json_file_6258", "'{0}' should be set inside the 'compilerOptions' object of the config json file"),
        Found_1_error_in_1: diag(6259, ts.DiagnosticCategory.Message, "Found_1_error_in_1_6259", "Found 1 error in {1}"),
        Found_0_errors_in_the_same_file_starting_at_Colon_1: diag(6260, ts.DiagnosticCategory.Message, "Found_0_errors_in_the_same_file_starting_at_Colon_1_6260", "Found {0} errors in the same file, starting at: {1}"),
        Found_0_errors_in_1_files: diag(6261, ts.DiagnosticCategory.Message, "Found_0_errors_in_1_files_6261", "Found {0} errors in {1} files."),
        Directory_0_has_no_containing_package_json_scope_Imports_will_not_resolve: diag(6270, ts.DiagnosticCategory.Message, "Directory_0_has_no_containing_package_json_scope_Imports_will_not_resolve_6270", "Directory '{0}' has no containing package.json scope. Imports will not resolve."),
        Import_specifier_0_does_not_exist_in_package_json_scope_at_path_1: diag(6271, ts.DiagnosticCategory.Message, "Import_specifier_0_does_not_exist_in_package_json_scope_at_path_1_6271", "Import specifier '{0}' does not exist in package.json scope at path '{1}'."),
        Invalid_import_specifier_0_has_no_possible_resolutions: diag(6272, ts.DiagnosticCategory.Message, "Invalid_import_specifier_0_has_no_possible_resolutions_6272", "Invalid import specifier '{0}' has no possible resolutions."),
        package_json_scope_0_has_no_imports_defined: diag(6273, ts.DiagnosticCategory.Message, "package_json_scope_0_has_no_imports_defined_6273", "package.json scope '{0}' has no imports defined."),
        package_json_scope_0_explicitly_maps_specifier_1_to_null: diag(6274, ts.DiagnosticCategory.Message, "package_json_scope_0_explicitly_maps_specifier_1_to_null_6274", "package.json scope '{0}' explicitly maps specifier '{1}' to null."),
        package_json_scope_0_has_invalid_type_for_target_of_specifier_1: diag(6275, ts.DiagnosticCategory.Message, "package_json_scope_0_has_invalid_type_for_target_of_specifier_1_6275", "package.json scope '{0}' has invalid type for target of specifier '{1}'"),
        Export_specifier_0_does_not_exist_in_package_json_scope_at_path_1: diag(6276, ts.DiagnosticCategory.Message, "Export_specifier_0_does_not_exist_in_package_json_scope_at_path_1_6276", "Export specifier '{0}' does not exist in package.json scope at path '{1}'."),
        Enable_project_compilation: diag(6302, ts.DiagnosticCategory.Message, "Enable_project_compilation_6302", "Enable project compilation"),
        Composite_projects_may_not_disable_declaration_emit: diag(6304, ts.DiagnosticCategory.Error, "Composite_projects_may_not_disable_declaration_emit_6304", "Composite projects may not disable declaration emit."),
        Output_file_0_has_not_been_built_from_source_file_1: diag(6305, ts.DiagnosticCategory.Error, "Output_file_0_has_not_been_built_from_source_file_1_6305", "Output file '{0}' has not been built from source file '{1}'."),
        Referenced_project_0_must_have_setting_composite_Colon_true: diag(6306, ts.DiagnosticCategory.Error, "Referenced_project_0_must_have_setting_composite_Colon_true_6306", "Referenced project '{0}' must have setting \"composite\": true."),
        File_0_is_not_listed_within_the_file_list_of_project_1_Projects_must_list_all_files_or_use_an_include_pattern: diag(6307, ts.DiagnosticCategory.Error, "File_0_is_not_listed_within_the_file_list_of_project_1_Projects_must_list_all_files_or_use_an_includ_6307", "File '{0}' is not listed within the file list of project '{1}'. Projects must list all files or use an 'include' pattern."),
        Cannot_prepend_project_0_because_it_does_not_have_outFile_set: diag(6308, ts.DiagnosticCategory.Error, "Cannot_prepend_project_0_because_it_does_not_have_outFile_set_6308", "Cannot prepend project '{0}' because it does not have 'outFile' set"),
        Output_file_0_from_project_1_does_not_exist: diag(6309, ts.DiagnosticCategory.Error, "Output_file_0_from_project_1_does_not_exist_6309", "Output file '{0}' from project '{1}' does not exist"),
        Referenced_project_0_may_not_disable_emit: diag(6310, ts.DiagnosticCategory.Error, "Referenced_project_0_may_not_disable_emit_6310", "Referenced project '{0}' may not disable emit."),
        Project_0_is_out_of_date_because_oldest_output_1_is_older_than_newest_input_2: diag(6350, ts.DiagnosticCategory.Message, "Project_0_is_out_of_date_because_oldest_output_1_is_older_than_newest_input_2_6350", "Project '{0}' is out of date because oldest output '{1}' is older than newest input '{2}'"),
        Project_0_is_up_to_date_because_newest_input_1_is_older_than_oldest_output_2: diag(6351, ts.DiagnosticCategory.Message, "Project_0_is_up_to_date_because_newest_input_1_is_older_than_oldest_output_2_6351", "Project '{0}' is up to date because newest input '{1}' is older than oldest output '{2}'"),
        Project_0_is_out_of_date_because_output_file_1_does_not_exist: diag(6352, ts.DiagnosticCategory.Message, "Project_0_is_out_of_date_because_output_file_1_does_not_exist_6352", "Project '{0}' is out of date because output file '{1}' does not exist"),
        Project_0_is_out_of_date_because_its_dependency_1_is_out_of_date: diag(6353, ts.DiagnosticCategory.Message, "Project_0_is_out_of_date_because_its_dependency_1_is_out_of_date_6353", "Project '{0}' is out of date because its dependency '{1}' is out of date"),
        Project_0_is_up_to_date_with_d_ts_files_from_its_dependencies: diag(6354, ts.DiagnosticCategory.Message, "Project_0_is_up_to_date_with_d_ts_files_from_its_dependencies_6354", "Project '{0}' is up to date with .d.ts files from its dependencies"),
        Projects_in_this_build_Colon_0: diag(6355, ts.DiagnosticCategory.Message, "Projects_in_this_build_Colon_0_6355", "Projects in this build: {0}"),
        A_non_dry_build_would_delete_the_following_files_Colon_0: diag(6356, ts.DiagnosticCategory.Message, "A_non_dry_build_would_delete_the_following_files_Colon_0_6356", "A non-dry build would delete the following files: {0}"),
        A_non_dry_build_would_build_project_0: diag(6357, ts.DiagnosticCategory.Message, "A_non_dry_build_would_build_project_0_6357", "A non-dry build would build project '{0}'"),
        Building_project_0: diag(6358, ts.DiagnosticCategory.Message, "Building_project_0_6358", "Building project '{0}'..."),
        Updating_output_timestamps_of_project_0: diag(6359, ts.DiagnosticCategory.Message, "Updating_output_timestamps_of_project_0_6359", "Updating output timestamps of project '{0}'..."),
        Project_0_is_up_to_date: diag(6361, ts.DiagnosticCategory.Message, "Project_0_is_up_to_date_6361", "Project '{0}' is up to date"),
        Skipping_build_of_project_0_because_its_dependency_1_has_errors: diag(6362, ts.DiagnosticCategory.Message, "Skipping_build_of_project_0_because_its_dependency_1_has_errors_6362", "Skipping build of project '{0}' because its dependency '{1}' has errors"),
        Project_0_can_t_be_built_because_its_dependency_1_has_errors: diag(6363, ts.DiagnosticCategory.Message, "Project_0_can_t_be_built_because_its_dependency_1_has_errors_6363", "Project '{0}' can't be built because its dependency '{1}' has errors"),
        Build_one_or_more_projects_and_their_dependencies_if_out_of_date: diag(6364, ts.DiagnosticCategory.Message, "Build_one_or_more_projects_and_their_dependencies_if_out_of_date_6364", "Build one or more projects and their dependencies, if out of date"),
        Delete_the_outputs_of_all_projects: diag(6365, ts.DiagnosticCategory.Message, "Delete_the_outputs_of_all_projects_6365", "Delete the outputs of all projects."),
        Show_what_would_be_built_or_deleted_if_specified_with_clean: diag(6367, ts.DiagnosticCategory.Message, "Show_what_would_be_built_or_deleted_if_specified_with_clean_6367", "Show what would be built (or deleted, if specified with '--clean')"),
        Option_build_must_be_the_first_command_line_argument: diag(6369, ts.DiagnosticCategory.Error, "Option_build_must_be_the_first_command_line_argument_6369", "Option '--build' must be the first command line argument."),
        Options_0_and_1_cannot_be_combined: diag(6370, ts.DiagnosticCategory.Error, "Options_0_and_1_cannot_be_combined_6370", "Options '{0}' and '{1}' cannot be combined."),
        Updating_unchanged_output_timestamps_of_project_0: diag(6371, ts.DiagnosticCategory.Message, "Updating_unchanged_output_timestamps_of_project_0_6371", "Updating unchanged output timestamps of project '{0}'..."),
        Project_0_is_out_of_date_because_output_of_its_dependency_1_has_changed: diag(6372, ts.DiagnosticCategory.Message, "Project_0_is_out_of_date_because_output_of_its_dependency_1_has_changed_6372", "Project '{0}' is out of date because output of its dependency '{1}' has changed"),
        Updating_output_of_project_0: diag(6373, ts.DiagnosticCategory.Message, "Updating_output_of_project_0_6373", "Updating output of project '{0}'..."),
        A_non_dry_build_would_update_timestamps_for_output_of_project_0: diag(6374, ts.DiagnosticCategory.Message, "A_non_dry_build_would_update_timestamps_for_output_of_project_0_6374", "A non-dry build would update timestamps for output of project '{0}'"),
        A_non_dry_build_would_update_output_of_project_0: diag(6375, ts.DiagnosticCategory.Message, "A_non_dry_build_would_update_output_of_project_0_6375", "A non-dry build would update output of project '{0}'"),
        Cannot_update_output_of_project_0_because_there_was_error_reading_file_1: diag(6376, ts.DiagnosticCategory.Message, "Cannot_update_output_of_project_0_because_there_was_error_reading_file_1_6376", "Cannot update output of project '{0}' because there was error reading file '{1}'"),
        Cannot_write_file_0_because_it_will_overwrite_tsbuildinfo_file_generated_by_referenced_project_1: diag(6377, ts.DiagnosticCategory.Error, "Cannot_write_file_0_because_it_will_overwrite_tsbuildinfo_file_generated_by_referenced_project_1_6377", "Cannot write file '{0}' because it will overwrite '.tsbuildinfo' file generated by referenced project '{1}'"),
        Composite_projects_may_not_disable_incremental_compilation: diag(6379, ts.DiagnosticCategory.Error, "Composite_projects_may_not_disable_incremental_compilation_6379", "Composite projects may not disable incremental compilation."),
        Specify_file_to_store_incremental_compilation_information: diag(6380, ts.DiagnosticCategory.Message, "Specify_file_to_store_incremental_compilation_information_6380", "Specify file to store incremental compilation information"),
        Project_0_is_out_of_date_because_output_for_it_was_generated_with_version_1_that_differs_with_current_version_2: diag(6381, ts.DiagnosticCategory.Message, "Project_0_is_out_of_date_because_output_for_it_was_generated_with_version_1_that_differs_with_curren_6381", "Project '{0}' is out of date because output for it was generated with version '{1}' that differs with current version '{2}'"),
        Skipping_build_of_project_0_because_its_dependency_1_was_not_built: diag(6382, ts.DiagnosticCategory.Message, "Skipping_build_of_project_0_because_its_dependency_1_was_not_built_6382", "Skipping build of project '{0}' because its dependency '{1}' was not built"),
        Project_0_can_t_be_built_because_its_dependency_1_was_not_built: diag(6383, ts.DiagnosticCategory.Message, "Project_0_can_t_be_built_because_its_dependency_1_was_not_built_6383", "Project '{0}' can't be built because its dependency '{1}' was not built"),
        Have_recompiles_in_incremental_and_watch_assume_that_changes_within_a_file_will_only_affect_files_directly_depending_on_it: diag(6384, ts.DiagnosticCategory.Message, "Have_recompiles_in_incremental_and_watch_assume_that_changes_within_a_file_will_only_affect_files_di_6384", "Have recompiles in '--incremental' and '--watch' assume that changes within a file will only affect files directly depending on it."),
        _0_is_deprecated: diag(6385, ts.DiagnosticCategory.Suggestion, "_0_is_deprecated_6385", "'{0}' is deprecated.", undefined, undefined, true),
        Performance_timings_for_diagnostics_or_extendedDiagnostics_are_not_available_in_this_session_A_native_implementation_of_the_Web_Performance_API_could_not_be_found: diag(6386, ts.DiagnosticCategory.Message, "Performance_timings_for_diagnostics_or_extendedDiagnostics_are_not_available_in_this_session_A_nativ_6386", "Performance timings for '--diagnostics' or '--extendedDiagnostics' are not available in this session. A native implementation of the Web Performance API could not be found."),
        The_signature_0_of_1_is_deprecated: diag(6387, ts.DiagnosticCategory.Suggestion, "The_signature_0_of_1_is_deprecated_6387", "The signature '{0}' of '{1}' is deprecated.", undefined, undefined, true),
        Project_0_is_being_forcibly_rebuilt: diag(6388, ts.DiagnosticCategory.Message, "Project_0_is_being_forcibly_rebuilt_6388", "Project '{0}' is being forcibly rebuilt"),
        Reusing_resolution_of_module_0_from_1_of_old_program_it_was_not_resolved: diag(6389, ts.DiagnosticCategory.Message, "Reusing_resolution_of_module_0_from_1_of_old_program_it_was_not_resolved_6389", "Reusing resolution of module '{0}' from '{1}' of old program, it was not resolved."),
        Reusing_resolution_of_type_reference_directive_0_from_1_of_old_program_it_was_successfully_resolved_to_2: diag(6390, ts.DiagnosticCategory.Message, "Reusing_resolution_of_type_reference_directive_0_from_1_of_old_program_it_was_successfully_resolved__6390", "Reusing resolution of type reference directive '{0}' from '{1}' of old program, it was successfully resolved to '{2}'."),
        Reusing_resolution_of_type_reference_directive_0_from_1_of_old_program_it_was_successfully_resolved_to_2_with_Package_ID_3: diag(6391, ts.DiagnosticCategory.Message, "Reusing_resolution_of_type_reference_directive_0_from_1_of_old_program_it_was_successfully_resolved__6391", "Reusing resolution of type reference directive '{0}' from '{1}' of old program, it was successfully resolved to '{2}' with Package ID '{3}'."),
        Reusing_resolution_of_type_reference_directive_0_from_1_of_old_program_it_was_not_resolved: diag(6392, ts.DiagnosticCategory.Message, "Reusing_resolution_of_type_reference_directive_0_from_1_of_old_program_it_was_not_resolved_6392", "Reusing resolution of type reference directive '{0}' from '{1}' of old program, it was not resolved."),
        Reusing_resolution_of_module_0_from_1_found_in_cache_from_location_2_it_was_successfully_resolved_to_3: diag(6393, ts.DiagnosticCategory.Message, "Reusing_resolution_of_module_0_from_1_found_in_cache_from_location_2_it_was_successfully_resolved_to_6393", "Reusing resolution of module '{0}' from '{1}' found in cache from location '{2}', it was successfully resolved to '{3}'."),
        Reusing_resolution_of_module_0_from_1_found_in_cache_from_location_2_it_was_successfully_resolved_to_3_with_Package_ID_4: diag(6394, ts.DiagnosticCategory.Message, "Reusing_resolution_of_module_0_from_1_found_in_cache_from_location_2_it_was_successfully_resolved_to_6394", "Reusing resolution of module '{0}' from '{1}' found in cache from location '{2}', it was successfully resolved to '{3}' with Package ID '{4}'."),
        Reusing_resolution_of_module_0_from_1_found_in_cache_from_location_2_it_was_not_resolved: diag(6395, ts.DiagnosticCategory.Message, "Reusing_resolution_of_module_0_from_1_found_in_cache_from_location_2_it_was_not_resolved_6395", "Reusing resolution of module '{0}' from '{1}' found in cache from location '{2}', it was not resolved."),
        Reusing_resolution_of_type_reference_directive_0_from_1_found_in_cache_from_location_2_it_was_successfully_resolved_to_3: diag(6396, ts.DiagnosticCategory.Message, "Reusing_resolution_of_type_reference_directive_0_from_1_found_in_cache_from_location_2_it_was_succes_6396", "Reusing resolution of type reference directive '{0}' from '{1}' found in cache from location '{2}', it was successfully resolved to '{3}'."),
        Reusing_resolution_of_type_reference_directive_0_from_1_found_in_cache_from_location_2_it_was_successfully_resolved_to_3_with_Package_ID_4: diag(6397, ts.DiagnosticCategory.Message, "Reusing_resolution_of_type_reference_directive_0_from_1_found_in_cache_from_location_2_it_was_succes_6397", "Reusing resolution of type reference directive '{0}' from '{1}' found in cache from location '{2}', it was successfully resolved to '{3}' with Package ID '{4}'."),
        Reusing_resolution_of_type_reference_directive_0_from_1_found_in_cache_from_location_2_it_was_not_resolved: diag(6398, ts.DiagnosticCategory.Message, "Reusing_resolution_of_type_reference_directive_0_from_1_found_in_cache_from_location_2_it_was_not_re_6398", "Reusing resolution of type reference directive '{0}' from '{1}' found in cache from location '{2}', it was not resolved."),
        The_expected_type_comes_from_property_0_which_is_declared_here_on_type_1: diag(6500, ts.DiagnosticCategory.Message, "The_expected_type_comes_from_property_0_which_is_declared_here_on_type_1_6500", "The expected type comes from property '{0}' which is declared here on type '{1}'"),
        The_expected_type_comes_from_this_index_signature: diag(6501, ts.DiagnosticCategory.Message, "The_expected_type_comes_from_this_index_signature_6501", "The expected type comes from this index signature."),
        The_expected_type_comes_from_the_return_type_of_this_signature: diag(6502, ts.DiagnosticCategory.Message, "The_expected_type_comes_from_the_return_type_of_this_signature_6502", "The expected type comes from the return type of this signature."),
        Print_names_of_files_that_are_part_of_the_compilation_and_then_stop_processing: diag(6503, ts.DiagnosticCategory.Message, "Print_names_of_files_that_are_part_of_the_compilation_and_then_stop_processing_6503", "Print names of files that are part of the compilation and then stop processing."),
        File_0_is_a_JavaScript_file_Did_you_mean_to_enable_the_allowJs_option: diag(6504, ts.DiagnosticCategory.Error, "File_0_is_a_JavaScript_file_Did_you_mean_to_enable_the_allowJs_option_6504", "File '{0}' is a JavaScript file. Did you mean to enable the 'allowJs' option?"),
        Print_names_of_files_and_the_reason_they_are_part_of_the_compilation: diag(6505, ts.DiagnosticCategory.Message, "Print_names_of_files_and_the_reason_they_are_part_of_the_compilation_6505", "Print names of files and the reason they are part of the compilation."),
        Consider_adding_a_declare_modifier_to_this_class: diag(6506, ts.DiagnosticCategory.Message, "Consider_adding_a_declare_modifier_to_this_class_6506", "Consider adding a 'declare' modifier to this class."),
        Allow_JavaScript_files_to_be_a_part_of_your_program_Use_the_checkJS_option_to_get_errors_from_these_files: diag(6600, ts.DiagnosticCategory.Message, "Allow_JavaScript_files_to_be_a_part_of_your_program_Use_the_checkJS_option_to_get_errors_from_these__6600", "Allow JavaScript files to be a part of your program. Use the 'checkJS' option to get errors from these files."),
        Allow_import_x_from_y_when_a_module_doesn_t_have_a_default_export: diag(6601, ts.DiagnosticCategory.Message, "Allow_import_x_from_y_when_a_module_doesn_t_have_a_default_export_6601", "Allow 'import x from y' when a module doesn't have a default export."),
        Allow_accessing_UMD_globals_from_modules: diag(6602, ts.DiagnosticCategory.Message, "Allow_accessing_UMD_globals_from_modules_6602", "Allow accessing UMD globals from modules."),
        Disable_error_reporting_for_unreachable_code: diag(6603, ts.DiagnosticCategory.Message, "Disable_error_reporting_for_unreachable_code_6603", "Disable error reporting for unreachable code."),
        Disable_error_reporting_for_unused_labels: diag(6604, ts.DiagnosticCategory.Message, "Disable_error_reporting_for_unused_labels_6604", "Disable error reporting for unused labels."),
        Ensure_use_strict_is_always_emitted: diag(6605, ts.DiagnosticCategory.Message, "Ensure_use_strict_is_always_emitted_6605", "Ensure 'use strict' is always emitted."),
        Have_recompiles_in_projects_that_use_incremental_and_watch_mode_assume_that_changes_within_a_file_will_only_affect_files_directly_depending_on_it: diag(6606, ts.DiagnosticCategory.Message, "Have_recompiles_in_projects_that_use_incremental_and_watch_mode_assume_that_changes_within_a_file_wi_6606", "Have recompiles in projects that use 'incremental' and 'watch' mode assume that changes within a file will only affect files directly depending on it."),
        Specify_the_base_directory_to_resolve_non_relative_module_names: diag(6607, ts.DiagnosticCategory.Message, "Specify_the_base_directory_to_resolve_non_relative_module_names_6607", "Specify the base directory to resolve non-relative module names."),
        No_longer_supported_In_early_versions_manually_set_the_text_encoding_for_reading_files: diag(6608, ts.DiagnosticCategory.Message, "No_longer_supported_In_early_versions_manually_set_the_text_encoding_for_reading_files_6608", "No longer supported. In early versions, manually set the text encoding for reading files."),
        Enable_error_reporting_in_type_checked_JavaScript_files: diag(6609, ts.DiagnosticCategory.Message, "Enable_error_reporting_in_type_checked_JavaScript_files_6609", "Enable error reporting in type-checked JavaScript files."),
        Enable_constraints_that_allow_a_TypeScript_project_to_be_used_with_project_references: diag(6611, ts.DiagnosticCategory.Message, "Enable_constraints_that_allow_a_TypeScript_project_to_be_used_with_project_references_6611", "Enable constraints that allow a TypeScript project to be used with project references."),
        Generate_d_ts_files_from_TypeScript_and_JavaScript_files_in_your_project: diag(6612, ts.DiagnosticCategory.Message, "Generate_d_ts_files_from_TypeScript_and_JavaScript_files_in_your_project_6612", "Generate .d.ts files from TypeScript and JavaScript files in your project."),
        Specify_the_output_directory_for_generated_declaration_files: diag(6613, ts.DiagnosticCategory.Message, "Specify_the_output_directory_for_generated_declaration_files_6613", "Specify the output directory for generated declaration files."),
        Create_sourcemaps_for_d_ts_files: diag(6614, ts.DiagnosticCategory.Message, "Create_sourcemaps_for_d_ts_files_6614", "Create sourcemaps for d.ts files."),
        Output_compiler_performance_information_after_building: diag(6615, ts.DiagnosticCategory.Message, "Output_compiler_performance_information_after_building_6615", "Output compiler performance information after building."),
        Disables_inference_for_type_acquisition_by_looking_at_filenames_in_a_project: diag(6616, ts.DiagnosticCategory.Message, "Disables_inference_for_type_acquisition_by_looking_at_filenames_in_a_project_6616", "Disables inference for type acquisition by looking at filenames in a project."),
        Reduce_the_number_of_projects_loaded_automatically_by_TypeScript: diag(6617, ts.DiagnosticCategory.Message, "Reduce_the_number_of_projects_loaded_automatically_by_TypeScript_6617", "Reduce the number of projects loaded automatically by TypeScript."),
        Remove_the_20mb_cap_on_total_source_code_size_for_JavaScript_files_in_the_TypeScript_language_server: diag(6618, ts.DiagnosticCategory.Message, "Remove_the_20mb_cap_on_total_source_code_size_for_JavaScript_files_in_the_TypeScript_language_server_6618", "Remove the 20mb cap on total source code size for JavaScript files in the TypeScript language server."),
        Opt_a_project_out_of_multi_project_reference_checking_when_editing: diag(6619, ts.DiagnosticCategory.Message, "Opt_a_project_out_of_multi_project_reference_checking_when_editing_6619", "Opt a project out of multi-project reference checking when editing."),
        Disable_preferring_source_files_instead_of_declaration_files_when_referencing_composite_projects: diag(6620, ts.DiagnosticCategory.Message, "Disable_preferring_source_files_instead_of_declaration_files_when_referencing_composite_projects_6620", "Disable preferring source files instead of declaration files when referencing composite projects."),
        Emit_more_compliant_but_verbose_and_less_performant_JavaScript_for_iteration: diag(6621, ts.DiagnosticCategory.Message, "Emit_more_compliant_but_verbose_and_less_performant_JavaScript_for_iteration_6621", "Emit more compliant, but verbose and less performant JavaScript for iteration."),
        Emit_a_UTF_8_Byte_Order_Mark_BOM_in_the_beginning_of_output_files: diag(6622, ts.DiagnosticCategory.Message, "Emit_a_UTF_8_Byte_Order_Mark_BOM_in_the_beginning_of_output_files_6622", "Emit a UTF-8 Byte Order Mark (BOM) in the beginning of output files."),
        Only_output_d_ts_files_and_not_JavaScript_files: diag(6623, ts.DiagnosticCategory.Message, "Only_output_d_ts_files_and_not_JavaScript_files_6623", "Only output d.ts files and not JavaScript files."),
        Emit_design_type_metadata_for_decorated_declarations_in_source_files: diag(6624, ts.DiagnosticCategory.Message, "Emit_design_type_metadata_for_decorated_declarations_in_source_files_6624", "Emit design-type metadata for decorated declarations in source files."),
        Disable_the_type_acquisition_for_JavaScript_projects: diag(6625, ts.DiagnosticCategory.Message, "Disable_the_type_acquisition_for_JavaScript_projects_6625", "Disable the type acquisition for JavaScript projects"),
        Emit_additional_JavaScript_to_ease_support_for_importing_CommonJS_modules_This_enables_allowSyntheticDefaultImports_for_type_compatibility: diag(6626, ts.DiagnosticCategory.Message, "Emit_additional_JavaScript_to_ease_support_for_importing_CommonJS_modules_This_enables_allowSyntheti_6626", "Emit additional JavaScript to ease support for importing CommonJS modules. This enables 'allowSyntheticDefaultImports' for type compatibility."),
        Filters_results_from_the_include_option: diag(6627, ts.DiagnosticCategory.Message, "Filters_results_from_the_include_option_6627", "Filters results from the `include` option."),
        Remove_a_list_of_directories_from_the_watch_process: diag(6628, ts.DiagnosticCategory.Message, "Remove_a_list_of_directories_from_the_watch_process_6628", "Remove a list of directories from the watch process."),
        Remove_a_list_of_files_from_the_watch_mode_s_processing: diag(6629, ts.DiagnosticCategory.Message, "Remove_a_list_of_files_from_the_watch_mode_s_processing_6629", "Remove a list of files from the watch mode's processing."),
        Enable_experimental_support_for_TC39_stage_2_draft_decorators: diag(6630, ts.DiagnosticCategory.Message, "Enable_experimental_support_for_TC39_stage_2_draft_decorators_6630", "Enable experimental support for TC39 stage 2 draft decorators."),
        Print_files_read_during_the_compilation_including_why_it_was_included: diag(6631, ts.DiagnosticCategory.Message, "Print_files_read_during_the_compilation_including_why_it_was_included_6631", "Print files read during the compilation including why it was included."),
        Output_more_detailed_compiler_performance_information_after_building: diag(6632, ts.DiagnosticCategory.Message, "Output_more_detailed_compiler_performance_information_after_building_6632", "Output more detailed compiler performance information after building."),
        Specify_one_or_more_path_or_node_module_references_to_base_configuration_files_from_which_settings_are_inherited: diag(6633, ts.DiagnosticCategory.Message, "Specify_one_or_more_path_or_node_module_references_to_base_configuration_files_from_which_settings_a_6633", "Specify one or more path or node module references to base configuration files from which settings are inherited."),
        Specify_what_approach_the_watcher_should_use_if_the_system_runs_out_of_native_file_watchers: diag(6634, ts.DiagnosticCategory.Message, "Specify_what_approach_the_watcher_should_use_if_the_system_runs_out_of_native_file_watchers_6634", "Specify what approach the watcher should use if the system runs out of native file watchers."),
        Include_a_list_of_files_This_does_not_support_glob_patterns_as_opposed_to_include: diag(6635, ts.DiagnosticCategory.Message, "Include_a_list_of_files_This_does_not_support_glob_patterns_as_opposed_to_include_6635", "Include a list of files. This does not support glob patterns, as opposed to `include`."),
        Build_all_projects_including_those_that_appear_to_be_up_to_date: diag(6636, ts.DiagnosticCategory.Message, "Build_all_projects_including_those_that_appear_to_be_up_to_date_6636", "Build all projects, including those that appear to be up to date."),
        Ensure_that_casing_is_correct_in_imports: diag(6637, ts.DiagnosticCategory.Message, "Ensure_that_casing_is_correct_in_imports_6637", "Ensure that casing is correct in imports."),
        Emit_a_v8_CPU_profile_of_the_compiler_run_for_debugging: diag(6638, ts.DiagnosticCategory.Message, "Emit_a_v8_CPU_profile_of_the_compiler_run_for_debugging_6638", "Emit a v8 CPU profile of the compiler run for debugging."),
        Allow_importing_helper_functions_from_tslib_once_per_project_instead_of_including_them_per_file: diag(6639, ts.DiagnosticCategory.Message, "Allow_importing_helper_functions_from_tslib_once_per_project_instead_of_including_them_per_file_6639", "Allow importing helper functions from tslib once per project, instead of including them per-file."),
        Specify_a_list_of_glob_patterns_that_match_files_to_be_included_in_compilation: diag(6641, ts.DiagnosticCategory.Message, "Specify_a_list_of_glob_patterns_that_match_files_to_be_included_in_compilation_6641", "Specify a list of glob patterns that match files to be included in compilation."),
        Save_tsbuildinfo_files_to_allow_for_incremental_compilation_of_projects: diag(6642, ts.DiagnosticCategory.Message, "Save_tsbuildinfo_files_to_allow_for_incremental_compilation_of_projects_6642", "Save .tsbuildinfo files to allow for incremental compilation of projects."),
        Include_sourcemap_files_inside_the_emitted_JavaScript: diag(6643, ts.DiagnosticCategory.Message, "Include_sourcemap_files_inside_the_emitted_JavaScript_6643", "Include sourcemap files inside the emitted JavaScript."),
        Include_source_code_in_the_sourcemaps_inside_the_emitted_JavaScript: diag(6644, ts.DiagnosticCategory.Message, "Include_source_code_in_the_sourcemaps_inside_the_emitted_JavaScript_6644", "Include source code in the sourcemaps inside the emitted JavaScript."),
        Ensure_that_each_file_can_be_safely_transpiled_without_relying_on_other_imports: diag(6645, ts.DiagnosticCategory.Message, "Ensure_that_each_file_can_be_safely_transpiled_without_relying_on_other_imports_6645", "Ensure that each file can be safely transpiled without relying on other imports."),
        Specify_what_JSX_code_is_generated: diag(6646, ts.DiagnosticCategory.Message, "Specify_what_JSX_code_is_generated_6646", "Specify what JSX code is generated."),
        Specify_the_JSX_factory_function_used_when_targeting_React_JSX_emit_e_g_React_createElement_or_h: diag(6647, ts.DiagnosticCategory.Message, "Specify_the_JSX_factory_function_used_when_targeting_React_JSX_emit_e_g_React_createElement_or_h_6647", "Specify the JSX factory function used when targeting React JSX emit, e.g. 'React.createElement' or 'h'."),
        Specify_the_JSX_Fragment_reference_used_for_fragments_when_targeting_React_JSX_emit_e_g_React_Fragment_or_Fragment: diag(6648, ts.DiagnosticCategory.Message, "Specify_the_JSX_Fragment_reference_used_for_fragments_when_targeting_React_JSX_emit_e_g_React_Fragme_6648", "Specify the JSX Fragment reference used for fragments when targeting React JSX emit e.g. 'React.Fragment' or 'Fragment'."),
        Specify_module_specifier_used_to_import_the_JSX_factory_functions_when_using_jsx_Colon_react_jsx_Asterisk: diag(6649, ts.DiagnosticCategory.Message, "Specify_module_specifier_used_to_import_the_JSX_factory_functions_when_using_jsx_Colon_react_jsx_Ast_6649", "Specify module specifier used to import the JSX factory functions when using 'jsx: react-jsx*'."),
        Make_keyof_only_return_strings_instead_of_string_numbers_or_symbols_Legacy_option: diag(6650, ts.DiagnosticCategory.Message, "Make_keyof_only_return_strings_instead_of_string_numbers_or_symbols_Legacy_option_6650", "Make keyof only return strings instead of string, numbers or symbols. Legacy option."),
        Specify_a_set_of_bundled_library_declaration_files_that_describe_the_target_runtime_environment: diag(6651, ts.DiagnosticCategory.Message, "Specify_a_set_of_bundled_library_declaration_files_that_describe_the_target_runtime_environment_6651", "Specify a set of bundled library declaration files that describe the target runtime environment."),
        Print_the_names_of_emitted_files_after_a_compilation: diag(6652, ts.DiagnosticCategory.Message, "Print_the_names_of_emitted_files_after_a_compilation_6652", "Print the names of emitted files after a compilation."),
        Print_all_of_the_files_read_during_the_compilation: diag(6653, ts.DiagnosticCategory.Message, "Print_all_of_the_files_read_during_the_compilation_6653", "Print all of the files read during the compilation."),
        Set_the_language_of_the_messaging_from_TypeScript_This_does_not_affect_emit: diag(6654, ts.DiagnosticCategory.Message, "Set_the_language_of_the_messaging_from_TypeScript_This_does_not_affect_emit_6654", "Set the language of the messaging from TypeScript. This does not affect emit."),
        Specify_the_location_where_debugger_should_locate_map_files_instead_of_generated_locations: diag(6655, ts.DiagnosticCategory.Message, "Specify_the_location_where_debugger_should_locate_map_files_instead_of_generated_locations_6655", "Specify the location where debugger should locate map files instead of generated locations."),
        Specify_the_maximum_folder_depth_used_for_checking_JavaScript_files_from_node_modules_Only_applicable_with_allowJs: diag(6656, ts.DiagnosticCategory.Message, "Specify_the_maximum_folder_depth_used_for_checking_JavaScript_files_from_node_modules_Only_applicabl_6656", "Specify the maximum folder depth used for checking JavaScript files from 'node_modules'. Only applicable with 'allowJs'."),
        Specify_what_module_code_is_generated: diag(6657, ts.DiagnosticCategory.Message, "Specify_what_module_code_is_generated_6657", "Specify what module code is generated."),
        Specify_how_TypeScript_looks_up_a_file_from_a_given_module_specifier: diag(6658, ts.DiagnosticCategory.Message, "Specify_how_TypeScript_looks_up_a_file_from_a_given_module_specifier_6658", "Specify how TypeScript looks up a file from a given module specifier."),
        Set_the_newline_character_for_emitting_files: diag(6659, ts.DiagnosticCategory.Message, "Set_the_newline_character_for_emitting_files_6659", "Set the newline character for emitting files."),
        Disable_emitting_files_from_a_compilation: diag(6660, ts.DiagnosticCategory.Message, "Disable_emitting_files_from_a_compilation_6660", "Disable emitting files from a compilation."),
        Disable_generating_custom_helper_functions_like_extends_in_compiled_output: diag(6661, ts.DiagnosticCategory.Message, "Disable_generating_custom_helper_functions_like_extends_in_compiled_output_6661", "Disable generating custom helper functions like '__extends' in compiled output."),
        Disable_emitting_files_if_any_type_checking_errors_are_reported: diag(6662, ts.DiagnosticCategory.Message, "Disable_emitting_files_if_any_type_checking_errors_are_reported_6662", "Disable emitting files if any type checking errors are reported."),
        Disable_truncating_types_in_error_messages: diag(6663, ts.DiagnosticCategory.Message, "Disable_truncating_types_in_error_messages_6663", "Disable truncating types in error messages."),
        Enable_error_reporting_for_fallthrough_cases_in_switch_statements: diag(6664, ts.DiagnosticCategory.Message, "Enable_error_reporting_for_fallthrough_cases_in_switch_statements_6664", "Enable error reporting for fallthrough cases in switch statements."),
        Enable_error_reporting_for_expressions_and_declarations_with_an_implied_any_type: diag(6665, ts.DiagnosticCategory.Message, "Enable_error_reporting_for_expressions_and_declarations_with_an_implied_any_type_6665", "Enable error reporting for expressions and declarations with an implied 'any' type."),
        Ensure_overriding_members_in_derived_classes_are_marked_with_an_override_modifier: diag(6666, ts.DiagnosticCategory.Message, "Ensure_overriding_members_in_derived_classes_are_marked_with_an_override_modifier_6666", "Ensure overriding members in derived classes are marked with an override modifier."),
        Enable_error_reporting_for_codepaths_that_do_not_explicitly_return_in_a_function: diag(6667, ts.DiagnosticCategory.Message, "Enable_error_reporting_for_codepaths_that_do_not_explicitly_return_in_a_function_6667", "Enable error reporting for codepaths that do not explicitly return in a function."),
        Enable_error_reporting_when_this_is_given_the_type_any: diag(6668, ts.DiagnosticCategory.Message, "Enable_error_reporting_when_this_is_given_the_type_any_6668", "Enable error reporting when 'this' is given the type 'any'."),
        Disable_adding_use_strict_directives_in_emitted_JavaScript_files: diag(6669, ts.DiagnosticCategory.Message, "Disable_adding_use_strict_directives_in_emitted_JavaScript_files_6669", "Disable adding 'use strict' directives in emitted JavaScript files."),
        Disable_including_any_library_files_including_the_default_lib_d_ts: diag(6670, ts.DiagnosticCategory.Message, "Disable_including_any_library_files_including_the_default_lib_d_ts_6670", "Disable including any library files, including the default lib.d.ts."),
        Enforces_using_indexed_accessors_for_keys_declared_using_an_indexed_type: diag(6671, ts.DiagnosticCategory.Message, "Enforces_using_indexed_accessors_for_keys_declared_using_an_indexed_type_6671", "Enforces using indexed accessors for keys declared using an indexed type."),
        Disallow_import_s_require_s_or_reference_s_from_expanding_the_number_of_files_TypeScript_should_add_to_a_project: diag(6672, ts.DiagnosticCategory.Message, "Disallow_import_s_require_s_or_reference_s_from_expanding_the_number_of_files_TypeScript_should_add__6672", "Disallow 'import's, 'require's or '<reference>'s from expanding the number of files TypeScript should add to a project."),
        Disable_strict_checking_of_generic_signatures_in_function_types: diag(6673, ts.DiagnosticCategory.Message, "Disable_strict_checking_of_generic_signatures_in_function_types_6673", "Disable strict checking of generic signatures in function types."),
        Add_undefined_to_a_type_when_accessed_using_an_index: diag(6674, ts.DiagnosticCategory.Message, "Add_undefined_to_a_type_when_accessed_using_an_index_6674", "Add 'undefined' to a type when accessed using an index."),
        Enable_error_reporting_when_local_variables_aren_t_read: diag(6675, ts.DiagnosticCategory.Message, "Enable_error_reporting_when_local_variables_aren_t_read_6675", "Enable error reporting when local variables aren't read."),
        Raise_an_error_when_a_function_parameter_isn_t_read: diag(6676, ts.DiagnosticCategory.Message, "Raise_an_error_when_a_function_parameter_isn_t_read_6676", "Raise an error when a function parameter isn't read."),
        Deprecated_setting_Use_outFile_instead: diag(6677, ts.DiagnosticCategory.Message, "Deprecated_setting_Use_outFile_instead_6677", "Deprecated setting. Use 'outFile' instead."),
        Specify_an_output_folder_for_all_emitted_files: diag(6678, ts.DiagnosticCategory.Message, "Specify_an_output_folder_for_all_emitted_files_6678", "Specify an output folder for all emitted files."),
        Specify_a_file_that_bundles_all_outputs_into_one_JavaScript_file_If_declaration_is_true_also_designates_a_file_that_bundles_all_d_ts_output: diag(6679, ts.DiagnosticCategory.Message, "Specify_a_file_that_bundles_all_outputs_into_one_JavaScript_file_If_declaration_is_true_also_designa_6679", "Specify a file that bundles all outputs into one JavaScript file. If 'declaration' is true, also designates a file that bundles all .d.ts output."),
        Specify_a_set_of_entries_that_re_map_imports_to_additional_lookup_locations: diag(6680, ts.DiagnosticCategory.Message, "Specify_a_set_of_entries_that_re_map_imports_to_additional_lookup_locations_6680", "Specify a set of entries that re-map imports to additional lookup locations."),
        Specify_a_list_of_language_service_plugins_to_include: diag(6681, ts.DiagnosticCategory.Message, "Specify_a_list_of_language_service_plugins_to_include_6681", "Specify a list of language service plugins to include."),
        Disable_erasing_const_enum_declarations_in_generated_code: diag(6682, ts.DiagnosticCategory.Message, "Disable_erasing_const_enum_declarations_in_generated_code_6682", "Disable erasing 'const enum' declarations in generated code."),
        Disable_resolving_symlinks_to_their_realpath_This_correlates_to_the_same_flag_in_node: diag(6683, ts.DiagnosticCategory.Message, "Disable_resolving_symlinks_to_their_realpath_This_correlates_to_the_same_flag_in_node_6683", "Disable resolving symlinks to their realpath. This correlates to the same flag in node."),
        Disable_wiping_the_console_in_watch_mode: diag(6684, ts.DiagnosticCategory.Message, "Disable_wiping_the_console_in_watch_mode_6684", "Disable wiping the console in watch mode."),
        Enable_color_and_formatting_in_TypeScript_s_output_to_make_compiler_errors_easier_to_read: diag(6685, ts.DiagnosticCategory.Message, "Enable_color_and_formatting_in_TypeScript_s_output_to_make_compiler_errors_easier_to_read_6685", "Enable color and formatting in TypeScript's output to make compiler errors easier to read."),
        Specify_the_object_invoked_for_createElement_This_only_applies_when_targeting_react_JSX_emit: diag(6686, ts.DiagnosticCategory.Message, "Specify_the_object_invoked_for_createElement_This_only_applies_when_targeting_react_JSX_emit_6686", "Specify the object invoked for 'createElement'. This only applies when targeting 'react' JSX emit."),
        Specify_an_array_of_objects_that_specify_paths_for_projects_Used_in_project_references: diag(6687, ts.DiagnosticCategory.Message, "Specify_an_array_of_objects_that_specify_paths_for_projects_Used_in_project_references_6687", "Specify an array of objects that specify paths for projects. Used in project references."),
        Disable_emitting_comments: diag(6688, ts.DiagnosticCategory.Message, "Disable_emitting_comments_6688", "Disable emitting comments."),
        Enable_importing_json_files: diag(6689, ts.DiagnosticCategory.Message, "Enable_importing_json_files_6689", "Enable importing .json files."),
        Specify_the_root_folder_within_your_source_files: diag(6690, ts.DiagnosticCategory.Message, "Specify_the_root_folder_within_your_source_files_6690", "Specify the root folder within your source files."),
        Allow_multiple_folders_to_be_treated_as_one_when_resolving_modules: diag(6691, ts.DiagnosticCategory.Message, "Allow_multiple_folders_to_be_treated_as_one_when_resolving_modules_6691", "Allow multiple folders to be treated as one when resolving modules."),
        Skip_type_checking_d_ts_files_that_are_included_with_TypeScript: diag(6692, ts.DiagnosticCategory.Message, "Skip_type_checking_d_ts_files_that_are_included_with_TypeScript_6692", "Skip type checking .d.ts files that are included with TypeScript."),
        Skip_type_checking_all_d_ts_files: diag(6693, ts.DiagnosticCategory.Message, "Skip_type_checking_all_d_ts_files_6693", "Skip type checking all .d.ts files."),
        Create_source_map_files_for_emitted_JavaScript_files: diag(6694, ts.DiagnosticCategory.Message, "Create_source_map_files_for_emitted_JavaScript_files_6694", "Create source map files for emitted JavaScript files."),
        Specify_the_root_path_for_debuggers_to_find_the_reference_source_code: diag(6695, ts.DiagnosticCategory.Message, "Specify_the_root_path_for_debuggers_to_find_the_reference_source_code_6695", "Specify the root path for debuggers to find the reference source code."),
        Check_that_the_arguments_for_bind_call_and_apply_methods_match_the_original_function: diag(6697, ts.DiagnosticCategory.Message, "Check_that_the_arguments_for_bind_call_and_apply_methods_match_the_original_function_6697", "Check that the arguments for 'bind', 'call', and 'apply' methods match the original function."),
        When_assigning_functions_check_to_ensure_parameters_and_the_return_values_are_subtype_compatible: diag(6698, ts.DiagnosticCategory.Message, "When_assigning_functions_check_to_ensure_parameters_and_the_return_values_are_subtype_compatible_6698", "When assigning functions, check to ensure parameters and the return values are subtype-compatible."),
        When_type_checking_take_into_account_null_and_undefined: diag(6699, ts.DiagnosticCategory.Message, "When_type_checking_take_into_account_null_and_undefined_6699", "When type checking, take into account 'null' and 'undefined'."),
        Check_for_class_properties_that_are_declared_but_not_set_in_the_constructor: diag(6700, ts.DiagnosticCategory.Message, "Check_for_class_properties_that_are_declared_but_not_set_in_the_constructor_6700", "Check for class properties that are declared but not set in the constructor."),
        Disable_emitting_declarations_that_have_internal_in_their_JSDoc_comments: diag(6701, ts.DiagnosticCategory.Message, "Disable_emitting_declarations_that_have_internal_in_their_JSDoc_comments_6701", "Disable emitting declarations that have '@internal' in their JSDoc comments."),
        Disable_reporting_of_excess_property_errors_during_the_creation_of_object_literals: diag(6702, ts.DiagnosticCategory.Message, "Disable_reporting_of_excess_property_errors_during_the_creation_of_object_literals_6702", "Disable reporting of excess property errors during the creation of object literals."),
        Suppress_noImplicitAny_errors_when_indexing_objects_that_lack_index_signatures: diag(6703, ts.DiagnosticCategory.Message, "Suppress_noImplicitAny_errors_when_indexing_objects_that_lack_index_signatures_6703", "Suppress 'noImplicitAny' errors when indexing objects that lack index signatures."),
        Synchronously_call_callbacks_and_update_the_state_of_directory_watchers_on_platforms_that_don_t_support_recursive_watching_natively: diag(6704, ts.DiagnosticCategory.Message, "Synchronously_call_callbacks_and_update_the_state_of_directory_watchers_on_platforms_that_don_t_supp_6704", "Synchronously call callbacks and update the state of directory watchers on platforms that don`t support recursive watching natively."),
        Set_the_JavaScript_language_version_for_emitted_JavaScript_and_include_compatible_library_declarations: diag(6705, ts.DiagnosticCategory.Message, "Set_the_JavaScript_language_version_for_emitted_JavaScript_and_include_compatible_library_declaratio_6705", "Set the JavaScript language version for emitted JavaScript and include compatible library declarations."),
        Log_paths_used_during_the_moduleResolution_process: diag(6706, ts.DiagnosticCategory.Message, "Log_paths_used_during_the_moduleResolution_process_6706", "Log paths used during the 'moduleResolution' process."),
        Specify_the_path_to_tsbuildinfo_incremental_compilation_file: diag(6707, ts.DiagnosticCategory.Message, "Specify_the_path_to_tsbuildinfo_incremental_compilation_file_6707", "Specify the path to .tsbuildinfo incremental compilation file."),
        Specify_options_for_automatic_acquisition_of_declaration_files: diag(6709, ts.DiagnosticCategory.Message, "Specify_options_for_automatic_acquisition_of_declaration_files_6709", "Specify options for automatic acquisition of declaration files."),
        Specify_multiple_folders_that_act_like_Slashnode_modules_Slash_types: diag(6710, ts.DiagnosticCategory.Message, "Specify_multiple_folders_that_act_like_Slashnode_modules_Slash_types_6710", "Specify multiple folders that act like './node_modules/@types'."),
        Specify_type_package_names_to_be_included_without_being_referenced_in_a_source_file: diag(6711, ts.DiagnosticCategory.Message, "Specify_type_package_names_to_be_included_without_being_referenced_in_a_source_file_6711", "Specify type package names to be included without being referenced in a source file."),
        Emit_ECMAScript_standard_compliant_class_fields: diag(6712, ts.DiagnosticCategory.Message, "Emit_ECMAScript_standard_compliant_class_fields_6712", "Emit ECMAScript-standard-compliant class fields."),
        Enable_verbose_logging: diag(6713, ts.DiagnosticCategory.Message, "Enable_verbose_logging_6713", "Enable verbose logging."),
        Specify_how_directories_are_watched_on_systems_that_lack_recursive_file_watching_functionality: diag(6714, ts.DiagnosticCategory.Message, "Specify_how_directories_are_watched_on_systems_that_lack_recursive_file_watching_functionality_6714", "Specify how directories are watched on systems that lack recursive file-watching functionality."),
        Specify_how_the_TypeScript_watch_mode_works: diag(6715, ts.DiagnosticCategory.Message, "Specify_how_the_TypeScript_watch_mode_works_6715", "Specify how the TypeScript watch mode works."),
        Require_undeclared_properties_from_index_signatures_to_use_element_accesses: diag(6717, ts.DiagnosticCategory.Message, "Require_undeclared_properties_from_index_signatures_to_use_element_accesses_6717", "Require undeclared properties from index signatures to use element accesses."),
        Specify_emit_Slashchecking_behavior_for_imports_that_are_only_used_for_types: diag(6718, ts.DiagnosticCategory.Message, "Specify_emit_Slashchecking_behavior_for_imports_that_are_only_used_for_types_6718", "Specify emit/checking behavior for imports that are only used for types."),
        Default_catch_clause_variables_as_unknown_instead_of_any: diag(6803, ts.DiagnosticCategory.Message, "Default_catch_clause_variables_as_unknown_instead_of_any_6803", "Default catch clause variables as 'unknown' instead of 'any'."),
        one_of_Colon: diag(6900, ts.DiagnosticCategory.Message, "one_of_Colon_6900", "one of:"),
        one_or_more_Colon: diag(6901, ts.DiagnosticCategory.Message, "one_or_more_Colon_6901", "one or more:"),
        type_Colon: diag(6902, ts.DiagnosticCategory.Message, "type_Colon_6902", "type:"),
        default_Colon: diag(6903, ts.DiagnosticCategory.Message, "default_Colon_6903", "default:"),
        module_system_or_esModuleInterop: diag(6904, ts.DiagnosticCategory.Message, "module_system_or_esModuleInterop_6904", "module === \"system\" or esModuleInterop"),
        false_unless_strict_is_set: diag(6905, ts.DiagnosticCategory.Message, "false_unless_strict_is_set_6905", "`false`, unless `strict` is set"),
        false_unless_composite_is_set: diag(6906, ts.DiagnosticCategory.Message, "false_unless_composite_is_set_6906", "`false`, unless `composite` is set"),
        node_modules_bower_components_jspm_packages_plus_the_value_of_outDir_if_one_is_specified: diag(6907, ts.DiagnosticCategory.Message, "node_modules_bower_components_jspm_packages_plus_the_value_of_outDir_if_one_is_specified_6907", "`[\"node_modules\", \"bower_components\", \"jspm_packages\"]`, plus the value of `outDir` if one is specified."),
        if_files_is_specified_otherwise_Asterisk_Asterisk_Slash_Asterisk: diag(6908, ts.DiagnosticCategory.Message, "if_files_is_specified_otherwise_Asterisk_Asterisk_Slash_Asterisk_6908", "`[]` if `files` is specified, otherwise `[\"**/*\"]`"),
        true_if_composite_false_otherwise: diag(6909, ts.DiagnosticCategory.Message, "true_if_composite_false_otherwise_6909", "`true` if `composite`, `false` otherwise"),
        module_AMD_or_UMD_or_System_or_ES6_then_Classic_Otherwise_Node: diag(69010, ts.DiagnosticCategory.Message, "module_AMD_or_UMD_or_System_or_ES6_then_Classic_Otherwise_Node_69010", "module === `AMD` or `UMD` or `System` or `ES6`, then `Classic`, Otherwise `Node`"),
        Computed_from_the_list_of_input_files: diag(6911, ts.DiagnosticCategory.Message, "Computed_from_the_list_of_input_files_6911", "Computed from the list of input files"),
        Platform_specific: diag(6912, ts.DiagnosticCategory.Message, "Platform_specific_6912", "Platform specific"),
        You_can_learn_about_all_of_the_compiler_options_at_0: diag(6913, ts.DiagnosticCategory.Message, "You_can_learn_about_all_of_the_compiler_options_at_0_6913", "You can learn about all of the compiler options at {0}"),
        Including_watch_w_will_start_watching_the_current_project_for_the_file_changes_Once_set_you_can_config_watch_mode_with_Colon: diag(6914, ts.DiagnosticCategory.Message, "Including_watch_w_will_start_watching_the_current_project_for_the_file_changes_Once_set_you_can_conf_6914", "Including --watch, -w will start watching the current project for the file changes. Once set, you can config watch mode with:"),
        Using_build_b_will_make_tsc_behave_more_like_a_build_orchestrator_than_a_compiler_This_is_used_to_trigger_building_composite_projects_which_you_can_learn_more_about_at_0: diag(6915, ts.DiagnosticCategory.Message, "Using_build_b_will_make_tsc_behave_more_like_a_build_orchestrator_than_a_compiler_This_is_used_to_tr_6915", "Using --build, -b will make tsc behave more like a build orchestrator than a compiler. This is used to trigger building composite projects which you can learn more about at {0}"),
        COMMON_COMMANDS: diag(6916, ts.DiagnosticCategory.Message, "COMMON_COMMANDS_6916", "COMMON COMMANDS"),
        ALL_COMPILER_OPTIONS: diag(6917, ts.DiagnosticCategory.Message, "ALL_COMPILER_OPTIONS_6917", "ALL COMPILER OPTIONS"),
        WATCH_OPTIONS: diag(6918, ts.DiagnosticCategory.Message, "WATCH_OPTIONS_6918", "WATCH OPTIONS"),
        BUILD_OPTIONS: diag(6919, ts.DiagnosticCategory.Message, "BUILD_OPTIONS_6919", "BUILD OPTIONS"),
        COMMON_COMPILER_OPTIONS: diag(6920, ts.DiagnosticCategory.Message, "COMMON_COMPILER_OPTIONS_6920", "COMMON COMPILER OPTIONS"),
        COMMAND_LINE_FLAGS: diag(6921, ts.DiagnosticCategory.Message, "COMMAND_LINE_FLAGS_6921", "COMMAND LINE FLAGS"),
        tsc_Colon_The_TypeScript_Compiler: diag(6922, ts.DiagnosticCategory.Message, "tsc_Colon_The_TypeScript_Compiler_6922", "tsc: The TypeScript Compiler"),
        Compiles_the_current_project_tsconfig_json_in_the_working_directory: diag(6923, ts.DiagnosticCategory.Message, "Compiles_the_current_project_tsconfig_json_in_the_working_directory_6923", "Compiles the current project (tsconfig.json in the working directory.)"),
        Ignoring_tsconfig_json_compiles_the_specified_files_with_default_compiler_options: diag(6924, ts.DiagnosticCategory.Message, "Ignoring_tsconfig_json_compiles_the_specified_files_with_default_compiler_options_6924", "Ignoring tsconfig.json, compiles the specified files with default compiler options."),
        Build_a_composite_project_in_the_working_directory: diag(6925, ts.DiagnosticCategory.Message, "Build_a_composite_project_in_the_working_directory_6925", "Build a composite project in the working directory."),
        Creates_a_tsconfig_json_with_the_recommended_settings_in_the_working_directory: diag(6926, ts.DiagnosticCategory.Message, "Creates_a_tsconfig_json_with_the_recommended_settings_in_the_working_directory_6926", "Creates a tsconfig.json with the recommended settings in the working directory."),
        Compiles_the_TypeScript_project_located_at_the_specified_path: diag(6927, ts.DiagnosticCategory.Message, "Compiles_the_TypeScript_project_located_at_the_specified_path_6927", "Compiles the TypeScript project located at the specified path."),
        An_expanded_version_of_this_information_showing_all_possible_compiler_options: diag(6928, ts.DiagnosticCategory.Message, "An_expanded_version_of_this_information_showing_all_possible_compiler_options_6928", "An expanded version of this information, showing all possible compiler options"),
        Compiles_the_current_project_with_additional_settings: diag(6929, ts.DiagnosticCategory.Message, "Compiles_the_current_project_with_additional_settings_6929", "Compiles the current project, with additional settings."),
        true_for_ES2022_and_above_including_ESNext: diag(6930, ts.DiagnosticCategory.Message, "true_for_ES2022_and_above_including_ESNext_6930", "`true` for ES2022 and above, including ESNext."),
        List_of_file_name_suffixes_to_search_when_resolving_a_module: diag(6931, ts.DiagnosticCategory.Error, "List_of_file_name_suffixes_to_search_when_resolving_a_module_6931", "List of file name suffixes to search when resolving a module."),
        Variable_0_implicitly_has_an_1_type: diag(7005, ts.DiagnosticCategory.Error, "Variable_0_implicitly_has_an_1_type_7005", "Variable '{0}' implicitly has an '{1}' type."),
        Parameter_0_implicitly_has_an_1_type: diag(7006, ts.DiagnosticCategory.Error, "Parameter_0_implicitly_has_an_1_type_7006", "Parameter '{0}' implicitly has an '{1}' type."),
        Member_0_implicitly_has_an_1_type: diag(7008, ts.DiagnosticCategory.Error, "Member_0_implicitly_has_an_1_type_7008", "Member '{0}' implicitly has an '{1}' type."),
        new_expression_whose_target_lacks_a_construct_signature_implicitly_has_an_any_type: diag(7009, ts.DiagnosticCategory.Error, "new_expression_whose_target_lacks_a_construct_signature_implicitly_has_an_any_type_7009", "'new' expression, whose target lacks a construct signature, implicitly has an 'any' type."),
        _0_which_lacks_return_type_annotation_implicitly_has_an_1_return_type: diag(7010, ts.DiagnosticCategory.Error, "_0_which_lacks_return_type_annotation_implicitly_has_an_1_return_type_7010", "'{0}', which lacks return-type annotation, implicitly has an '{1}' return type."),
        Function_expression_which_lacks_return_type_annotation_implicitly_has_an_0_return_type: diag(7011, ts.DiagnosticCategory.Error, "Function_expression_which_lacks_return_type_annotation_implicitly_has_an_0_return_type_7011", "Function expression, which lacks return-type annotation, implicitly has an '{0}' return type."),
        Construct_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type: diag(7013, ts.DiagnosticCategory.Error, "Construct_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type_7013", "Construct signature, which lacks return-type annotation, implicitly has an 'any' return type."),
        Function_type_which_lacks_return_type_annotation_implicitly_has_an_0_return_type: diag(7014, ts.DiagnosticCategory.Error, "Function_type_which_lacks_return_type_annotation_implicitly_has_an_0_return_type_7014", "Function type, which lacks return-type annotation, implicitly has an '{0}' return type."),
        Element_implicitly_has_an_any_type_because_index_expression_is_not_of_type_number: diag(7015, ts.DiagnosticCategory.Error, "Element_implicitly_has_an_any_type_because_index_expression_is_not_of_type_number_7015", "Element implicitly has an 'any' type because index expression is not of type 'number'."),
        Could_not_find_a_declaration_file_for_module_0_1_implicitly_has_an_any_type: diag(7016, ts.DiagnosticCategory.Error, "Could_not_find_a_declaration_file_for_module_0_1_implicitly_has_an_any_type_7016", "Could not find a declaration file for module '{0}'. '{1}' implicitly has an 'any' type."),
        Element_implicitly_has_an_any_type_because_type_0_has_no_index_signature: diag(7017, ts.DiagnosticCategory.Error, "Element_implicitly_has_an_any_type_because_type_0_has_no_index_signature_7017", "Element implicitly has an 'any' type because type '{0}' has no index signature."),
        Object_literal_s_property_0_implicitly_has_an_1_type: diag(7018, ts.DiagnosticCategory.Error, "Object_literal_s_property_0_implicitly_has_an_1_type_7018", "Object literal's property '{0}' implicitly has an '{1}' type."),
        Rest_parameter_0_implicitly_has_an_any_type: diag(7019, ts.DiagnosticCategory.Error, "Rest_parameter_0_implicitly_has_an_any_type_7019", "Rest parameter '{0}' implicitly has an 'any[]' type."),
        Call_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type: diag(7020, ts.DiagnosticCategory.Error, "Call_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type_7020", "Call signature, which lacks return-type annotation, implicitly has an 'any' return type."),
        _0_implicitly_has_type_any_because_it_does_not_have_a_type_annotation_and_is_referenced_directly_or_indirectly_in_its_own_initializer: diag(7022, ts.DiagnosticCategory.Error, "_0_implicitly_has_type_any_because_it_does_not_have_a_type_annotation_and_is_referenced_directly_or__7022", "'{0}' implicitly has type 'any' because it does not have a type annotation and is referenced directly or indirectly in its own initializer."),
        _0_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions: diag(7023, ts.DiagnosticCategory.Error, "_0_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_reference_7023", "'{0}' implicitly has return type 'any' because it does not have a return type annotation and is referenced directly or indirectly in one of its return expressions."),
        Function_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions: diag(7024, ts.DiagnosticCategory.Error, "Function_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_ref_7024", "Function implicitly has return type 'any' because it does not have a return type annotation and is referenced directly or indirectly in one of its return expressions."),
        Generator_implicitly_has_yield_type_0_because_it_does_not_yield_any_values_Consider_supplying_a_return_type_annotation: diag(7025, ts.DiagnosticCategory.Error, "Generator_implicitly_has_yield_type_0_because_it_does_not_yield_any_values_Consider_supplying_a_retu_7025", "Generator implicitly has yield type '{0}' because it does not yield any values. Consider supplying a return type annotation."),
        JSX_element_implicitly_has_type_any_because_no_interface_JSX_0_exists: diag(7026, ts.DiagnosticCategory.Error, "JSX_element_implicitly_has_type_any_because_no_interface_JSX_0_exists_7026", "JSX element implicitly has type 'any' because no interface 'JSX.{0}' exists."),
        Unreachable_code_detected: diag(7027, ts.DiagnosticCategory.Error, "Unreachable_code_detected_7027", "Unreachable code detected.", true),
        Unused_label: diag(7028, ts.DiagnosticCategory.Error, "Unused_label_7028", "Unused label.", true),
        Fallthrough_case_in_switch: diag(7029, ts.DiagnosticCategory.Error, "Fallthrough_case_in_switch_7029", "Fallthrough case in switch."),
        Not_all_code_paths_return_a_value: diag(7030, ts.DiagnosticCategory.Error, "Not_all_code_paths_return_a_value_7030", "Not all code paths return a value."),
        Binding_element_0_implicitly_has_an_1_type: diag(7031, ts.DiagnosticCategory.Error, "Binding_element_0_implicitly_has_an_1_type_7031", "Binding element '{0}' implicitly has an '{1}' type."),
        Property_0_implicitly_has_type_any_because_its_set_accessor_lacks_a_parameter_type_annotation: diag(7032, ts.DiagnosticCategory.Error, "Property_0_implicitly_has_type_any_because_its_set_accessor_lacks_a_parameter_type_annotation_7032", "Property '{0}' implicitly has type 'any', because its set accessor lacks a parameter type annotation."),
        Property_0_implicitly_has_type_any_because_its_get_accessor_lacks_a_return_type_annotation: diag(7033, ts.DiagnosticCategory.Error, "Property_0_implicitly_has_type_any_because_its_get_accessor_lacks_a_return_type_annotation_7033", "Property '{0}' implicitly has type 'any', because its get accessor lacks a return type annotation."),
        Variable_0_implicitly_has_type_1_in_some_locations_where_its_type_cannot_be_determined: diag(7034, ts.DiagnosticCategory.Error, "Variable_0_implicitly_has_type_1_in_some_locations_where_its_type_cannot_be_determined_7034", "Variable '{0}' implicitly has type '{1}' in some locations where its type cannot be determined."),
        Try_npm_i_save_dev_types_Slash_1_if_it_exists_or_add_a_new_declaration_d_ts_file_containing_declare_module_0: diag(7035, ts.DiagnosticCategory.Error, "Try_npm_i_save_dev_types_Slash_1_if_it_exists_or_add_a_new_declaration_d_ts_file_containing_declare__7035", "Try `npm i --save-dev @types/{1}` if it exists or add a new declaration (.d.ts) file containing `declare module '{0}';`"),
        Dynamic_import_s_specifier_must_be_of_type_string_but_here_has_type_0: diag(7036, ts.DiagnosticCategory.Error, "Dynamic_import_s_specifier_must_be_of_type_string_but_here_has_type_0_7036", "Dynamic import's specifier must be of type 'string', but here has type '{0}'."),
        Enables_emit_interoperability_between_CommonJS_and_ES_Modules_via_creation_of_namespace_objects_for_all_imports_Implies_allowSyntheticDefaultImports: diag(7037, ts.DiagnosticCategory.Message, "Enables_emit_interoperability_between_CommonJS_and_ES_Modules_via_creation_of_namespace_objects_for__7037", "Enables emit interoperability between CommonJS and ES Modules via creation of namespace objects for all imports. Implies 'allowSyntheticDefaultImports'."),
        Type_originates_at_this_import_A_namespace_style_import_cannot_be_called_or_constructed_and_will_cause_a_failure_at_runtime_Consider_using_a_default_import_or_import_require_here_instead: diag(7038, ts.DiagnosticCategory.Message, "Type_originates_at_this_import_A_namespace_style_import_cannot_be_called_or_constructed_and_will_cau_7038", "Type originates at this import. A namespace-style import cannot be called or constructed, and will cause a failure at runtime. Consider using a default import or import require here instead."),
        Mapped_object_type_implicitly_has_an_any_template_type: diag(7039, ts.DiagnosticCategory.Error, "Mapped_object_type_implicitly_has_an_any_template_type_7039", "Mapped object type implicitly has an 'any' template type."),
        If_the_0_package_actually_exposes_this_module_consider_sending_a_pull_request_to_amend_https_Colon_Slash_Slashgithub_com_SlashDefinitelyTyped_SlashDefinitelyTyped_Slashtree_Slashmaster_Slashtypes_Slash_1: diag(7040, ts.DiagnosticCategory.Error, "If_the_0_package_actually_exposes_this_module_consider_sending_a_pull_request_to_amend_https_Colon_S_7040", "If the '{0}' package actually exposes this module, consider sending a pull request to amend 'https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/{1}'"),
        The_containing_arrow_function_captures_the_global_value_of_this: diag(7041, ts.DiagnosticCategory.Error, "The_containing_arrow_function_captures_the_global_value_of_this_7041", "The containing arrow function captures the global value of 'this'."),
        Module_0_was_resolved_to_1_but_resolveJsonModule_is_not_used: diag(7042, ts.DiagnosticCategory.Error, "Module_0_was_resolved_to_1_but_resolveJsonModule_is_not_used_7042", "Module '{0}' was resolved to '{1}', but '--resolveJsonModule' is not used."),
        Variable_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage: diag(7043, ts.DiagnosticCategory.Suggestion, "Variable_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage_7043", "Variable '{0}' implicitly has an '{1}' type, but a better type may be inferred from usage."),
        Parameter_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage: diag(7044, ts.DiagnosticCategory.Suggestion, "Parameter_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage_7044", "Parameter '{0}' implicitly has an '{1}' type, but a better type may be inferred from usage."),
        Member_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage: diag(7045, ts.DiagnosticCategory.Suggestion, "Member_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage_7045", "Member '{0}' implicitly has an '{1}' type, but a better type may be inferred from usage."),
        Variable_0_implicitly_has_type_1_in_some_locations_but_a_better_type_may_be_inferred_from_usage: diag(7046, ts.DiagnosticCategory.Suggestion, "Variable_0_implicitly_has_type_1_in_some_locations_but_a_better_type_may_be_inferred_from_usage_7046", "Variable '{0}' implicitly has type '{1}' in some locations, but a better type may be inferred from usage."),
        Rest_parameter_0_implicitly_has_an_any_type_but_a_better_type_may_be_inferred_from_usage: diag(7047, ts.DiagnosticCategory.Suggestion, "Rest_parameter_0_implicitly_has_an_any_type_but_a_better_type_may_be_inferred_from_usage_7047", "Rest parameter '{0}' implicitly has an 'any[]' type, but a better type may be inferred from usage."),
        Property_0_implicitly_has_type_any_but_a_better_type_for_its_get_accessor_may_be_inferred_from_usage: diag(7048, ts.DiagnosticCategory.Suggestion, "Property_0_implicitly_has_type_any_but_a_better_type_for_its_get_accessor_may_be_inferred_from_usage_7048", "Property '{0}' implicitly has type 'any', but a better type for its get accessor may be inferred from usage."),
        Property_0_implicitly_has_type_any_but_a_better_type_for_its_set_accessor_may_be_inferred_from_usage: diag(7049, ts.DiagnosticCategory.Suggestion, "Property_0_implicitly_has_type_any_but_a_better_type_for_its_set_accessor_may_be_inferred_from_usage_7049", "Property '{0}' implicitly has type 'any', but a better type for its set accessor may be inferred from usage."),
        _0_implicitly_has_an_1_return_type_but_a_better_type_may_be_inferred_from_usage: diag(7050, ts.DiagnosticCategory.Suggestion, "_0_implicitly_has_an_1_return_type_but_a_better_type_may_be_inferred_from_usage_7050", "'{0}' implicitly has an '{1}' return type, but a better type may be inferred from usage."),
        Parameter_has_a_name_but_no_type_Did_you_mean_0_Colon_1: diag(7051, ts.DiagnosticCategory.Error, "Parameter_has_a_name_but_no_type_Did_you_mean_0_Colon_1_7051", "Parameter has a name but no type. Did you mean '{0}: {1}'?"),
        Element_implicitly_has_an_any_type_because_type_0_has_no_index_signature_Did_you_mean_to_call_1: diag(7052, ts.DiagnosticCategory.Error, "Element_implicitly_has_an_any_type_because_type_0_has_no_index_signature_Did_you_mean_to_call_1_7052", "Element implicitly has an 'any' type because type '{0}' has no index signature. Did you mean to call '{1}'?"),
        Element_implicitly_has_an_any_type_because_expression_of_type_0_can_t_be_used_to_index_type_1: diag(7053, ts.DiagnosticCategory.Error, "Element_implicitly_has_an_any_type_because_expression_of_type_0_can_t_be_used_to_index_type_1_7053", "Element implicitly has an 'any' type because expression of type '{0}' can't be used to index type '{1}'."),
        No_index_signature_with_a_parameter_of_type_0_was_found_on_type_1: diag(7054, ts.DiagnosticCategory.Error, "No_index_signature_with_a_parameter_of_type_0_was_found_on_type_1_7054", "No index signature with a parameter of type '{0}' was found on type '{1}'."),
        _0_which_lacks_return_type_annotation_implicitly_has_an_1_yield_type: diag(7055, ts.DiagnosticCategory.Error, "_0_which_lacks_return_type_annotation_implicitly_has_an_1_yield_type_7055", "'{0}', which lacks return-type annotation, implicitly has an '{1}' yield type."),
        The_inferred_type_of_this_node_exceeds_the_maximum_length_the_compiler_will_serialize_An_explicit_type_annotation_is_needed: diag(7056, ts.DiagnosticCategory.Error, "The_inferred_type_of_this_node_exceeds_the_maximum_length_the_compiler_will_serialize_An_explicit_ty_7056", "The inferred type of this node exceeds the maximum length the compiler will serialize. An explicit type annotation is needed."),
        yield_expression_implicitly_results_in_an_any_type_because_its_containing_generator_lacks_a_return_type_annotation: diag(7057, ts.DiagnosticCategory.Error, "yield_expression_implicitly_results_in_an_any_type_because_its_containing_generator_lacks_a_return_t_7057", "'yield' expression implicitly results in an 'any' type because its containing generator lacks a return-type annotation."),
        If_the_0_package_actually_exposes_this_module_try_adding_a_new_declaration_d_ts_file_containing_declare_module_1: diag(7058, ts.DiagnosticCategory.Error, "If_the_0_package_actually_exposes_this_module_try_adding_a_new_declaration_d_ts_file_containing_decl_7058", "If the '{0}' package actually exposes this module, try adding a new declaration (.d.ts) file containing `declare module '{1}';`"),
        This_syntax_is_reserved_in_files_with_the_mts_or_cts_extension_Use_an_as_expression_instead: diag(7059, ts.DiagnosticCategory.Error, "This_syntax_is_reserved_in_files_with_the_mts_or_cts_extension_Use_an_as_expression_instead_7059", "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead."),
        This_syntax_is_reserved_in_files_with_the_mts_or_cts_extension_Add_a_trailing_comma_or_explicit_constraint: diag(7060, ts.DiagnosticCategory.Error, "This_syntax_is_reserved_in_files_with_the_mts_or_cts_extension_Add_a_trailing_comma_or_explicit_cons_7060", "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma or explicit constraint."),
        A_mapped_type_may_not_declare_properties_or_methods: diag(7061, ts.DiagnosticCategory.Error, "A_mapped_type_may_not_declare_properties_or_methods_7061", "A mapped type may not declare properties or methods."),
        You_cannot_rename_this_element: diag(8000, ts.DiagnosticCategory.Error, "You_cannot_rename_this_element_8000", "You cannot rename this element."),
        You_cannot_rename_elements_that_are_defined_in_the_standard_TypeScript_library: diag(8001, ts.DiagnosticCategory.Error, "You_cannot_rename_elements_that_are_defined_in_the_standard_TypeScript_library_8001", "You cannot rename elements that are defined in the standard TypeScript library."),
        import_can_only_be_used_in_TypeScript_files: diag(8002, ts.DiagnosticCategory.Error, "import_can_only_be_used_in_TypeScript_files_8002", "'import ... =' can only be used in TypeScript files."),
        export_can_only_be_used_in_TypeScript_files: diag(8003, ts.DiagnosticCategory.Error, "export_can_only_be_used_in_TypeScript_files_8003", "'export =' can only be used in TypeScript files."),
        Type_parameter_declarations_can_only_be_used_in_TypeScript_files: diag(8004, ts.DiagnosticCategory.Error, "Type_parameter_declarations_can_only_be_used_in_TypeScript_files_8004", "Type parameter declarations can only be used in TypeScript files."),
        implements_clauses_can_only_be_used_in_TypeScript_files: diag(8005, ts.DiagnosticCategory.Error, "implements_clauses_can_only_be_used_in_TypeScript_files_8005", "'implements' clauses can only be used in TypeScript files."),
        _0_declarations_can_only_be_used_in_TypeScript_files: diag(8006, ts.DiagnosticCategory.Error, "_0_declarations_can_only_be_used_in_TypeScript_files_8006", "'{0}' declarations can only be used in TypeScript files."),
        Type_aliases_can_only_be_used_in_TypeScript_files: diag(8008, ts.DiagnosticCategory.Error, "Type_aliases_can_only_be_used_in_TypeScript_files_8008", "Type aliases can only be used in TypeScript files."),
        The_0_modifier_can_only_be_used_in_TypeScript_files: diag(8009, ts.DiagnosticCategory.Error, "The_0_modifier_can_only_be_used_in_TypeScript_files_8009", "The '{0}' modifier can only be used in TypeScript files."),
        Type_annotations_can_only_be_used_in_TypeScript_files: diag(8010, ts.DiagnosticCategory.Error, "Type_annotations_can_only_be_used_in_TypeScript_files_8010", "Type annotations can only be used in TypeScript files."),
        Type_arguments_can_only_be_used_in_TypeScript_files: diag(8011, ts.DiagnosticCategory.Error, "Type_arguments_can_only_be_used_in_TypeScript_files_8011", "Type arguments can only be used in TypeScript files."),
        Parameter_modifiers_can_only_be_used_in_TypeScript_files: diag(8012, ts.DiagnosticCategory.Error, "Parameter_modifiers_can_only_be_used_in_TypeScript_files_8012", "Parameter modifiers can only be used in TypeScript files."),
        Non_null_assertions_can_only_be_used_in_TypeScript_files: diag(8013, ts.DiagnosticCategory.Error, "Non_null_assertions_can_only_be_used_in_TypeScript_files_8013", "Non-null assertions can only be used in TypeScript files."),
        Type_assertion_expressions_can_only_be_used_in_TypeScript_files: diag(8016, ts.DiagnosticCategory.Error, "Type_assertion_expressions_can_only_be_used_in_TypeScript_files_8016", "Type assertion expressions can only be used in TypeScript files."),
        Octal_literal_types_must_use_ES2015_syntax_Use_the_syntax_0: diag(8017, ts.DiagnosticCategory.Error, "Octal_literal_types_must_use_ES2015_syntax_Use_the_syntax_0_8017", "Octal literal types must use ES2015 syntax. Use the syntax '{0}'."),
        Octal_literals_are_not_allowed_in_enums_members_initializer_Use_the_syntax_0: diag(8018, ts.DiagnosticCategory.Error, "Octal_literals_are_not_allowed_in_enums_members_initializer_Use_the_syntax_0_8018", "Octal literals are not allowed in enums members initializer. Use the syntax '{0}'."),
        Report_errors_in_js_files: diag(8019, ts.DiagnosticCategory.Message, "Report_errors_in_js_files_8019", "Report errors in .js files."),
        JSDoc_types_can_only_be_used_inside_documentation_comments: diag(8020, ts.DiagnosticCategory.Error, "JSDoc_types_can_only_be_used_inside_documentation_comments_8020", "JSDoc types can only be used inside documentation comments."),
        JSDoc_typedef_tag_should_either_have_a_type_annotation_or_be_followed_by_property_or_member_tags: diag(8021, ts.DiagnosticCategory.Error, "JSDoc_typedef_tag_should_either_have_a_type_annotation_or_be_followed_by_property_or_member_tags_8021", "JSDoc '@typedef' tag should either have a type annotation or be followed by '@property' or '@member' tags."),
        JSDoc_0_is_not_attached_to_a_class: diag(8022, ts.DiagnosticCategory.Error, "JSDoc_0_is_not_attached_to_a_class_8022", "JSDoc '@{0}' is not attached to a class."),
        JSDoc_0_1_does_not_match_the_extends_2_clause: diag(8023, ts.DiagnosticCategory.Error, "JSDoc_0_1_does_not_match_the_extends_2_clause_8023", "JSDoc '@{0} {1}' does not match the 'extends {2}' clause."),
        JSDoc_param_tag_has_name_0_but_there_is_no_parameter_with_that_name: diag(8024, ts.DiagnosticCategory.Error, "JSDoc_param_tag_has_name_0_but_there_is_no_parameter_with_that_name_8024", "JSDoc '@param' tag has name '{0}', but there is no parameter with that name."),
        Class_declarations_cannot_have_more_than_one_augments_or_extends_tag: diag(8025, ts.DiagnosticCategory.Error, "Class_declarations_cannot_have_more_than_one_augments_or_extends_tag_8025", "Class declarations cannot have more than one '@augments' or '@extends' tag."),
        Expected_0_type_arguments_provide_these_with_an_extends_tag: diag(8026, ts.DiagnosticCategory.Error, "Expected_0_type_arguments_provide_these_with_an_extends_tag_8026", "Expected {0} type arguments; provide these with an '@extends' tag."),
        Expected_0_1_type_arguments_provide_these_with_an_extends_tag: diag(8027, ts.DiagnosticCategory.Error, "Expected_0_1_type_arguments_provide_these_with_an_extends_tag_8027", "Expected {0}-{1} type arguments; provide these with an '@extends' tag."),
        JSDoc_may_only_appear_in_the_last_parameter_of_a_signature: diag(8028, ts.DiagnosticCategory.Error, "JSDoc_may_only_appear_in_the_last_parameter_of_a_signature_8028", "JSDoc '...' may only appear in the last parameter of a signature."),
        JSDoc_param_tag_has_name_0_but_there_is_no_parameter_with_that_name_It_would_match_arguments_if_it_had_an_array_type: diag(8029, ts.DiagnosticCategory.Error, "JSDoc_param_tag_has_name_0_but_there_is_no_parameter_with_that_name_It_would_match_arguments_if_it_h_8029", "JSDoc '@param' tag has name '{0}', but there is no parameter with that name. It would match 'arguments' if it had an array type."),
        The_type_of_a_function_declaration_must_match_the_function_s_signature: diag(8030, ts.DiagnosticCategory.Error, "The_type_of_a_function_declaration_must_match_the_function_s_signature_8030", "The type of a function declaration must match the function's signature."),
        You_cannot_rename_a_module_via_a_global_import: diag(8031, ts.DiagnosticCategory.Error, "You_cannot_rename_a_module_via_a_global_import_8031", "You cannot rename a module via a global import."),
        Qualified_name_0_is_not_allowed_without_a_leading_param_object_1: diag(8032, ts.DiagnosticCategory.Error, "Qualified_name_0_is_not_allowed_without_a_leading_param_object_1_8032", "Qualified name '{0}' is not allowed without a leading '@param {object} {1}'."),
        A_JSDoc_typedef_comment_may_not_contain_multiple_type_tags: diag(8033, ts.DiagnosticCategory.Error, "A_JSDoc_typedef_comment_may_not_contain_multiple_type_tags_8033", "A JSDoc '@typedef' comment may not contain multiple '@type' tags."),
        The_tag_was_first_specified_here: diag(8034, ts.DiagnosticCategory.Error, "The_tag_was_first_specified_here_8034", "The tag was first specified here."),
        Declaration_emit_for_this_file_requires_using_private_name_0_An_explicit_type_annotation_may_unblock_declaration_emit: diag(9005, ts.DiagnosticCategory.Error, "Declaration_emit_for_this_file_requires_using_private_name_0_An_explicit_type_annotation_may_unblock_9005", "Declaration emit for this file requires using private name '{0}'. An explicit type annotation may unblock declaration emit."),
        Declaration_emit_for_this_file_requires_using_private_name_0_from_module_1_An_explicit_type_annotation_may_unblock_declaration_emit: diag(9006, ts.DiagnosticCategory.Error, "Declaration_emit_for_this_file_requires_using_private_name_0_from_module_1_An_explicit_type_annotati_9006", "Declaration emit for this file requires using private name '{0}' from module '{1}'. An explicit type annotation may unblock declaration emit."),
        JSX_attributes_must_only_be_assigned_a_non_empty_expression: diag(17000, ts.DiagnosticCategory.Error, "JSX_attributes_must_only_be_assigned_a_non_empty_expression_17000", "JSX attributes must only be assigned a non-empty 'expression'."),
        JSX_elements_cannot_have_multiple_attributes_with_the_same_name: diag(17001, ts.DiagnosticCategory.Error, "JSX_elements_cannot_have_multiple_attributes_with_the_same_name_17001", "JSX elements cannot have multiple attributes with the same name."),
        Expected_corresponding_JSX_closing_tag_for_0: diag(17002, ts.DiagnosticCategory.Error, "Expected_corresponding_JSX_closing_tag_for_0_17002", "Expected corresponding JSX closing tag for '{0}'."),
        Cannot_use_JSX_unless_the_jsx_flag_is_provided: diag(17004, ts.DiagnosticCategory.Error, "Cannot_use_JSX_unless_the_jsx_flag_is_provided_17004", "Cannot use JSX unless the '--jsx' flag is provided."),
        A_constructor_cannot_contain_a_super_call_when_its_class_extends_null: diag(17005, ts.DiagnosticCategory.Error, "A_constructor_cannot_contain_a_super_call_when_its_class_extends_null_17005", "A constructor cannot contain a 'super' call when its class extends 'null'."),
        An_unary_expression_with_the_0_operator_is_not_allowed_in_the_left_hand_side_of_an_exponentiation_expression_Consider_enclosing_the_expression_in_parentheses: diag(17006, ts.DiagnosticCategory.Error, "An_unary_expression_with_the_0_operator_is_not_allowed_in_the_left_hand_side_of_an_exponentiation_ex_17006", "An unary expression with the '{0}' operator is not allowed in the left-hand side of an exponentiation expression. Consider enclosing the expression in parentheses."),
        A_type_assertion_expression_is_not_allowed_in_the_left_hand_side_of_an_exponentiation_expression_Consider_enclosing_the_expression_in_parentheses: diag(17007, ts.DiagnosticCategory.Error, "A_type_assertion_expression_is_not_allowed_in_the_left_hand_side_of_an_exponentiation_expression_Con_17007", "A type assertion expression is not allowed in the left-hand side of an exponentiation expression. Consider enclosing the expression in parentheses."),
        JSX_element_0_has_no_corresponding_closing_tag: diag(17008, ts.DiagnosticCategory.Error, "JSX_element_0_has_no_corresponding_closing_tag_17008", "JSX element '{0}' has no corresponding closing tag."),
        super_must_be_called_before_accessing_this_in_the_constructor_of_a_derived_class: diag(17009, ts.DiagnosticCategory.Error, "super_must_be_called_before_accessing_this_in_the_constructor_of_a_derived_class_17009", "'super' must be called before accessing 'this' in the constructor of a derived class."),
        Unknown_type_acquisition_option_0: diag(17010, ts.DiagnosticCategory.Error, "Unknown_type_acquisition_option_0_17010", "Unknown type acquisition option '{0}'."),
        super_must_be_called_before_accessing_a_property_of_super_in_the_constructor_of_a_derived_class: diag(17011, ts.DiagnosticCategory.Error, "super_must_be_called_before_accessing_a_property_of_super_in_the_constructor_of_a_derived_class_17011", "'super' must be called before accessing a property of 'super' in the constructor of a derived class."),
        _0_is_not_a_valid_meta_property_for_keyword_1_Did_you_mean_2: diag(17012, ts.DiagnosticCategory.Error, "_0_is_not_a_valid_meta_property_for_keyword_1_Did_you_mean_2_17012", "'{0}' is not a valid meta-property for keyword '{1}'. Did you mean '{2}'?"),
        Meta_property_0_is_only_allowed_in_the_body_of_a_function_declaration_function_expression_or_constructor: diag(17013, ts.DiagnosticCategory.Error, "Meta_property_0_is_only_allowed_in_the_body_of_a_function_declaration_function_expression_or_constru_17013", "Meta-property '{0}' is only allowed in the body of a function declaration, function expression, or constructor."),
        JSX_fragment_has_no_corresponding_closing_tag: diag(17014, ts.DiagnosticCategory.Error, "JSX_fragment_has_no_corresponding_closing_tag_17014", "JSX fragment has no corresponding closing tag."),
        Expected_corresponding_closing_tag_for_JSX_fragment: diag(17015, ts.DiagnosticCategory.Error, "Expected_corresponding_closing_tag_for_JSX_fragment_17015", "Expected corresponding closing tag for JSX fragment."),
        The_jsxFragmentFactory_compiler_option_must_be_provided_to_use_JSX_fragments_with_the_jsxFactory_compiler_option: diag(17016, ts.DiagnosticCategory.Error, "The_jsxFragmentFactory_compiler_option_must_be_provided_to_use_JSX_fragments_with_the_jsxFactory_com_17016", "The 'jsxFragmentFactory' compiler option must be provided to use JSX fragments with the 'jsxFactory' compiler option."),
        An_jsxFrag_pragma_is_required_when_using_an_jsx_pragma_with_JSX_fragments: diag(17017, ts.DiagnosticCategory.Error, "An_jsxFrag_pragma_is_required_when_using_an_jsx_pragma_with_JSX_fragments_17017", "An @jsxFrag pragma is required when using an @jsx pragma with JSX fragments."),
        Unknown_type_acquisition_option_0_Did_you_mean_1: diag(17018, ts.DiagnosticCategory.Error, "Unknown_type_acquisition_option_0_Did_you_mean_1_17018", "Unknown type acquisition option '{0}'. Did you mean '{1}'?"),
        Circularity_detected_while_resolving_configuration_Colon_0: diag(18000, ts.DiagnosticCategory.Error, "Circularity_detected_while_resolving_configuration_Colon_0_18000", "Circularity detected while resolving configuration: {0}"),
        The_files_list_in_config_file_0_is_empty: diag(18002, ts.DiagnosticCategory.Error, "The_files_list_in_config_file_0_is_empty_18002", "The 'files' list in config file '{0}' is empty."),
        No_inputs_were_found_in_config_file_0_Specified_include_paths_were_1_and_exclude_paths_were_2: diag(18003, ts.DiagnosticCategory.Error, "No_inputs_were_found_in_config_file_0_Specified_include_paths_were_1_and_exclude_paths_were_2_18003", "No inputs were found in config file '{0}'. Specified 'include' paths were '{1}' and 'exclude' paths were '{2}'."),
        File_is_a_CommonJS_module_it_may_be_converted_to_an_ES_module: diag(80001, ts.DiagnosticCategory.Suggestion, "File_is_a_CommonJS_module_it_may_be_converted_to_an_ES_module_80001", "File is a CommonJS module; it may be converted to an ES module."),
        This_constructor_function_may_be_converted_to_a_class_declaration: diag(80002, ts.DiagnosticCategory.Suggestion, "This_constructor_function_may_be_converted_to_a_class_declaration_80002", "This constructor function may be converted to a class declaration."),
        Import_may_be_converted_to_a_default_import: diag(80003, ts.DiagnosticCategory.Suggestion, "Import_may_be_converted_to_a_default_import_80003", "Import may be converted to a default import."),
        JSDoc_types_may_be_moved_to_TypeScript_types: diag(80004, ts.DiagnosticCategory.Suggestion, "JSDoc_types_may_be_moved_to_TypeScript_types_80004", "JSDoc types may be moved to TypeScript types."),
        require_call_may_be_converted_to_an_import: diag(80005, ts.DiagnosticCategory.Suggestion, "require_call_may_be_converted_to_an_import_80005", "'require' call may be converted to an import."),
        This_may_be_converted_to_an_async_function: diag(80006, ts.DiagnosticCategory.Suggestion, "This_may_be_converted_to_an_async_function_80006", "This may be converted to an async function."),
        await_has_no_effect_on_the_type_of_this_expression: diag(80007, ts.DiagnosticCategory.Suggestion, "await_has_no_effect_on_the_type_of_this_expression_80007", "'await' has no effect on the type of this expression."),
        Numeric_literals_with_absolute_values_equal_to_2_53_or_greater_are_too_large_to_be_represented_accurately_as_integers: diag(80008, ts.DiagnosticCategory.Suggestion, "Numeric_literals_with_absolute_values_equal_to_2_53_or_greater_are_too_large_to_be_represented_accur_80008", "Numeric literals with absolute values equal to 2^53 or greater are too large to be represented accurately as integers."),
        Add_missing_super_call: diag(90001, ts.DiagnosticCategory.Message, "Add_missing_super_call_90001", "Add missing 'super()' call"),
        Make_super_call_the_first_statement_in_the_constructor: diag(90002, ts.DiagnosticCategory.Message, "Make_super_call_the_first_statement_in_the_constructor_90002", "Make 'super()' call the first statement in the constructor"),
        Change_extends_to_implements: diag(90003, ts.DiagnosticCategory.Message, "Change_extends_to_implements_90003", "Change 'extends' to 'implements'"),
        Remove_unused_declaration_for_Colon_0: diag(90004, ts.DiagnosticCategory.Message, "Remove_unused_declaration_for_Colon_0_90004", "Remove unused declaration for: '{0}'"),
        Remove_import_from_0: diag(90005, ts.DiagnosticCategory.Message, "Remove_import_from_0_90005", "Remove import from '{0}'"),
        Implement_interface_0: diag(90006, ts.DiagnosticCategory.Message, "Implement_interface_0_90006", "Implement interface '{0}'"),
        Implement_inherited_abstract_class: diag(90007, ts.DiagnosticCategory.Message, "Implement_inherited_abstract_class_90007", "Implement inherited abstract class"),
        Add_0_to_unresolved_variable: diag(90008, ts.DiagnosticCategory.Message, "Add_0_to_unresolved_variable_90008", "Add '{0}.' to unresolved variable"),
        Remove_variable_statement: diag(90010, ts.DiagnosticCategory.Message, "Remove_variable_statement_90010", "Remove variable statement"),
        Remove_template_tag: diag(90011, ts.DiagnosticCategory.Message, "Remove_template_tag_90011", "Remove template tag"),
        Remove_type_parameters: diag(90012, ts.DiagnosticCategory.Message, "Remove_type_parameters_90012", "Remove type parameters"),
        Import_0_from_1: diag(90013, ts.DiagnosticCategory.Message, "Import_0_from_1_90013", "Import '{0}' from \"{1}\""),
        Change_0_to_1: diag(90014, ts.DiagnosticCategory.Message, "Change_0_to_1_90014", "Change '{0}' to '{1}'"),
        Declare_property_0: diag(90016, ts.DiagnosticCategory.Message, "Declare_property_0_90016", "Declare property '{0}'"),
        Add_index_signature_for_property_0: diag(90017, ts.DiagnosticCategory.Message, "Add_index_signature_for_property_0_90017", "Add index signature for property '{0}'"),
        Disable_checking_for_this_file: diag(90018, ts.DiagnosticCategory.Message, "Disable_checking_for_this_file_90018", "Disable checking for this file"),
        Ignore_this_error_message: diag(90019, ts.DiagnosticCategory.Message, "Ignore_this_error_message_90019", "Ignore this error message"),
        Initialize_property_0_in_the_constructor: diag(90020, ts.DiagnosticCategory.Message, "Initialize_property_0_in_the_constructor_90020", "Initialize property '{0}' in the constructor"),
        Initialize_static_property_0: diag(90021, ts.DiagnosticCategory.Message, "Initialize_static_property_0_90021", "Initialize static property '{0}'"),
        Change_spelling_to_0: diag(90022, ts.DiagnosticCategory.Message, "Change_spelling_to_0_90022", "Change spelling to '{0}'"),
        Declare_method_0: diag(90023, ts.DiagnosticCategory.Message, "Declare_method_0_90023", "Declare method '{0}'"),
        Declare_static_method_0: diag(90024, ts.DiagnosticCategory.Message, "Declare_static_method_0_90024", "Declare static method '{0}'"),
        Prefix_0_with_an_underscore: diag(90025, ts.DiagnosticCategory.Message, "Prefix_0_with_an_underscore_90025", "Prefix '{0}' with an underscore"),
        Rewrite_as_the_indexed_access_type_0: diag(90026, ts.DiagnosticCategory.Message, "Rewrite_as_the_indexed_access_type_0_90026", "Rewrite as the indexed access type '{0}'"),
        Declare_static_property_0: diag(90027, ts.DiagnosticCategory.Message, "Declare_static_property_0_90027", "Declare static property '{0}'"),
        Call_decorator_expression: diag(90028, ts.DiagnosticCategory.Message, "Call_decorator_expression_90028", "Call decorator expression"),
        Add_async_modifier_to_containing_function: diag(90029, ts.DiagnosticCategory.Message, "Add_async_modifier_to_containing_function_90029", "Add async modifier to containing function"),
        Replace_infer_0_with_unknown: diag(90030, ts.DiagnosticCategory.Message, "Replace_infer_0_with_unknown_90030", "Replace 'infer {0}' with 'unknown'"),
        Replace_all_unused_infer_with_unknown: diag(90031, ts.DiagnosticCategory.Message, "Replace_all_unused_infer_with_unknown_90031", "Replace all unused 'infer' with 'unknown'"),
        Add_parameter_name: diag(90034, ts.DiagnosticCategory.Message, "Add_parameter_name_90034", "Add parameter name"),
        Declare_private_property_0: diag(90035, ts.DiagnosticCategory.Message, "Declare_private_property_0_90035", "Declare private property '{0}'"),
        Replace_0_with_Promise_1: diag(90036, ts.DiagnosticCategory.Message, "Replace_0_with_Promise_1_90036", "Replace '{0}' with 'Promise<{1}>'"),
        Fix_all_incorrect_return_type_of_an_async_functions: diag(90037, ts.DiagnosticCategory.Message, "Fix_all_incorrect_return_type_of_an_async_functions_90037", "Fix all incorrect return type of an async functions"),
        Declare_private_method_0: diag(90038, ts.DiagnosticCategory.Message, "Declare_private_method_0_90038", "Declare private method '{0}'"),
        Remove_unused_destructuring_declaration: diag(90039, ts.DiagnosticCategory.Message, "Remove_unused_destructuring_declaration_90039", "Remove unused destructuring declaration"),
        Remove_unused_declarations_for_Colon_0: diag(90041, ts.DiagnosticCategory.Message, "Remove_unused_declarations_for_Colon_0_90041", "Remove unused declarations for: '{0}'"),
        Declare_a_private_field_named_0: diag(90053, ts.DiagnosticCategory.Message, "Declare_a_private_field_named_0_90053", "Declare a private field named '{0}'."),
        Includes_imports_of_types_referenced_by_0: diag(90054, ts.DiagnosticCategory.Message, "Includes_imports_of_types_referenced_by_0_90054", "Includes imports of types referenced by '{0}'"),
        Remove_type_from_import_declaration_from_0: diag(90055, ts.DiagnosticCategory.Message, "Remove_type_from_import_declaration_from_0_90055", "Remove 'type' from import declaration from \"{0}\""),
        Remove_type_from_import_of_0_from_1: diag(90056, ts.DiagnosticCategory.Message, "Remove_type_from_import_of_0_from_1_90056", "Remove 'type' from import of '{0}' from \"{1}\""),
        Add_import_from_0: diag(90057, ts.DiagnosticCategory.Message, "Add_import_from_0_90057", "Add import from \"{0}\""),
        Update_import_from_0: diag(90058, ts.DiagnosticCategory.Message, "Update_import_from_0_90058", "Update import from \"{0}\""),
        Convert_function_to_an_ES2015_class: diag(95001, ts.DiagnosticCategory.Message, "Convert_function_to_an_ES2015_class_95001", "Convert function to an ES2015 class"),
        Convert_0_to_1_in_0: diag(95003, ts.DiagnosticCategory.Message, "Convert_0_to_1_in_0_95003", "Convert '{0}' to '{1} in {0}'"),
        Extract_to_0_in_1: diag(95004, ts.DiagnosticCategory.Message, "Extract_to_0_in_1_95004", "Extract to {0} in {1}"),
        Extract_function: diag(95005, ts.DiagnosticCategory.Message, "Extract_function_95005", "Extract function"),
        Extract_constant: diag(95006, ts.DiagnosticCategory.Message, "Extract_constant_95006", "Extract constant"),
        Extract_to_0_in_enclosing_scope: diag(95007, ts.DiagnosticCategory.Message, "Extract_to_0_in_enclosing_scope_95007", "Extract to {0} in enclosing scope"),
        Extract_to_0_in_1_scope: diag(95008, ts.DiagnosticCategory.Message, "Extract_to_0_in_1_scope_95008", "Extract to {0} in {1} scope"),
        Annotate_with_type_from_JSDoc: diag(95009, ts.DiagnosticCategory.Message, "Annotate_with_type_from_JSDoc_95009", "Annotate with type from JSDoc"),
        Infer_type_of_0_from_usage: diag(95011, ts.DiagnosticCategory.Message, "Infer_type_of_0_from_usage_95011", "Infer type of '{0}' from usage"),
        Infer_parameter_types_from_usage: diag(95012, ts.DiagnosticCategory.Message, "Infer_parameter_types_from_usage_95012", "Infer parameter types from usage"),
        Convert_to_default_import: diag(95013, ts.DiagnosticCategory.Message, "Convert_to_default_import_95013", "Convert to default import"),
        Install_0: diag(95014, ts.DiagnosticCategory.Message, "Install_0_95014", "Install '{0}'"),
        Replace_import_with_0: diag(95015, ts.DiagnosticCategory.Message, "Replace_import_with_0_95015", "Replace import with '{0}'."),
        Use_synthetic_default_member: diag(95016, ts.DiagnosticCategory.Message, "Use_synthetic_default_member_95016", "Use synthetic 'default' member."),
        Convert_to_ES_module: diag(95017, ts.DiagnosticCategory.Message, "Convert_to_ES_module_95017", "Convert to ES module"),
        Add_undefined_type_to_property_0: diag(95018, ts.DiagnosticCategory.Message, "Add_undefined_type_to_property_0_95018", "Add 'undefined' type to property '{0}'"),
        Add_initializer_to_property_0: diag(95019, ts.DiagnosticCategory.Message, "Add_initializer_to_property_0_95019", "Add initializer to property '{0}'"),
        Add_definite_assignment_assertion_to_property_0: diag(95020, ts.DiagnosticCategory.Message, "Add_definite_assignment_assertion_to_property_0_95020", "Add definite assignment assertion to property '{0}'"),
        Convert_all_type_literals_to_mapped_type: diag(95021, ts.DiagnosticCategory.Message, "Convert_all_type_literals_to_mapped_type_95021", "Convert all type literals to mapped type"),
        Add_all_missing_members: diag(95022, ts.DiagnosticCategory.Message, "Add_all_missing_members_95022", "Add all missing members"),
        Infer_all_types_from_usage: diag(95023, ts.DiagnosticCategory.Message, "Infer_all_types_from_usage_95023", "Infer all types from usage"),
        Delete_all_unused_declarations: diag(95024, ts.DiagnosticCategory.Message, "Delete_all_unused_declarations_95024", "Delete all unused declarations"),
        Prefix_all_unused_declarations_with_where_possible: diag(95025, ts.DiagnosticCategory.Message, "Prefix_all_unused_declarations_with_where_possible_95025", "Prefix all unused declarations with '_' where possible"),
        Fix_all_detected_spelling_errors: diag(95026, ts.DiagnosticCategory.Message, "Fix_all_detected_spelling_errors_95026", "Fix all detected spelling errors"),
        Add_initializers_to_all_uninitialized_properties: diag(95027, ts.DiagnosticCategory.Message, "Add_initializers_to_all_uninitialized_properties_95027", "Add initializers to all uninitialized properties"),
        Add_definite_assignment_assertions_to_all_uninitialized_properties: diag(95028, ts.DiagnosticCategory.Message, "Add_definite_assignment_assertions_to_all_uninitialized_properties_95028", "Add definite assignment assertions to all uninitialized properties"),
        Add_undefined_type_to_all_uninitialized_properties: diag(95029, ts.DiagnosticCategory.Message, "Add_undefined_type_to_all_uninitialized_properties_95029", "Add undefined type to all uninitialized properties"),
        Change_all_jsdoc_style_types_to_TypeScript: diag(95030, ts.DiagnosticCategory.Message, "Change_all_jsdoc_style_types_to_TypeScript_95030", "Change all jsdoc-style types to TypeScript"),
        Change_all_jsdoc_style_types_to_TypeScript_and_add_undefined_to_nullable_types: diag(95031, ts.DiagnosticCategory.Message, "Change_all_jsdoc_style_types_to_TypeScript_and_add_undefined_to_nullable_types_95031", "Change all jsdoc-style types to TypeScript (and add '| undefined' to nullable types)"),
        Implement_all_unimplemented_interfaces: diag(95032, ts.DiagnosticCategory.Message, "Implement_all_unimplemented_interfaces_95032", "Implement all unimplemented interfaces"),
        Install_all_missing_types_packages: diag(95033, ts.DiagnosticCategory.Message, "Install_all_missing_types_packages_95033", "Install all missing types packages"),
        Rewrite_all_as_indexed_access_types: diag(95034, ts.DiagnosticCategory.Message, "Rewrite_all_as_indexed_access_types_95034", "Rewrite all as indexed access types"),
        Convert_all_to_default_imports: diag(95035, ts.DiagnosticCategory.Message, "Convert_all_to_default_imports_95035", "Convert all to default imports"),
        Make_all_super_calls_the_first_statement_in_their_constructor: diag(95036, ts.DiagnosticCategory.Message, "Make_all_super_calls_the_first_statement_in_their_constructor_95036", "Make all 'super()' calls the first statement in their constructor"),
        Add_qualifier_to_all_unresolved_variables_matching_a_member_name: diag(95037, ts.DiagnosticCategory.Message, "Add_qualifier_to_all_unresolved_variables_matching_a_member_name_95037", "Add qualifier to all unresolved variables matching a member name"),
        Change_all_extended_interfaces_to_implements: diag(95038, ts.DiagnosticCategory.Message, "Change_all_extended_interfaces_to_implements_95038", "Change all extended interfaces to 'implements'"),
        Add_all_missing_super_calls: diag(95039, ts.DiagnosticCategory.Message, "Add_all_missing_super_calls_95039", "Add all missing super calls"),
        Implement_all_inherited_abstract_classes: diag(95040, ts.DiagnosticCategory.Message, "Implement_all_inherited_abstract_classes_95040", "Implement all inherited abstract classes"),
        Add_all_missing_async_modifiers: diag(95041, ts.DiagnosticCategory.Message, "Add_all_missing_async_modifiers_95041", "Add all missing 'async' modifiers"),
        Add_ts_ignore_to_all_error_messages: diag(95042, ts.DiagnosticCategory.Message, "Add_ts_ignore_to_all_error_messages_95042", "Add '@ts-ignore' to all error messages"),
        Annotate_everything_with_types_from_JSDoc: diag(95043, ts.DiagnosticCategory.Message, "Annotate_everything_with_types_from_JSDoc_95043", "Annotate everything with types from JSDoc"),
        Add_to_all_uncalled_decorators: diag(95044, ts.DiagnosticCategory.Message, "Add_to_all_uncalled_decorators_95044", "Add '()' to all uncalled decorators"),
        Convert_all_constructor_functions_to_classes: diag(95045, ts.DiagnosticCategory.Message, "Convert_all_constructor_functions_to_classes_95045", "Convert all constructor functions to classes"),
        Generate_get_and_set_accessors: diag(95046, ts.DiagnosticCategory.Message, "Generate_get_and_set_accessors_95046", "Generate 'get' and 'set' accessors"),
        Convert_require_to_import: diag(95047, ts.DiagnosticCategory.Message, "Convert_require_to_import_95047", "Convert 'require' to 'import'"),
        Convert_all_require_to_import: diag(95048, ts.DiagnosticCategory.Message, "Convert_all_require_to_import_95048", "Convert all 'require' to 'import'"),
        Move_to_a_new_file: diag(95049, ts.DiagnosticCategory.Message, "Move_to_a_new_file_95049", "Move to a new file"),
        Remove_unreachable_code: diag(95050, ts.DiagnosticCategory.Message, "Remove_unreachable_code_95050", "Remove unreachable code"),
        Remove_all_unreachable_code: diag(95051, ts.DiagnosticCategory.Message, "Remove_all_unreachable_code_95051", "Remove all unreachable code"),
        Add_missing_typeof: diag(95052, ts.DiagnosticCategory.Message, "Add_missing_typeof_95052", "Add missing 'typeof'"),
        Remove_unused_label: diag(95053, ts.DiagnosticCategory.Message, "Remove_unused_label_95053", "Remove unused label"),
        Remove_all_unused_labels: diag(95054, ts.DiagnosticCategory.Message, "Remove_all_unused_labels_95054", "Remove all unused labels"),
        Convert_0_to_mapped_object_type: diag(95055, ts.DiagnosticCategory.Message, "Convert_0_to_mapped_object_type_95055", "Convert '{0}' to mapped object type"),
        Convert_namespace_import_to_named_imports: diag(95056, ts.DiagnosticCategory.Message, "Convert_namespace_import_to_named_imports_95056", "Convert namespace import to named imports"),
        Convert_named_imports_to_namespace_import: diag(95057, ts.DiagnosticCategory.Message, "Convert_named_imports_to_namespace_import_95057", "Convert named imports to namespace import"),
        Add_or_remove_braces_in_an_arrow_function: diag(95058, ts.DiagnosticCategory.Message, "Add_or_remove_braces_in_an_arrow_function_95058", "Add or remove braces in an arrow function"),
        Add_braces_to_arrow_function: diag(95059, ts.DiagnosticCategory.Message, "Add_braces_to_arrow_function_95059", "Add braces to arrow function"),
        Remove_braces_from_arrow_function: diag(95060, ts.DiagnosticCategory.Message, "Remove_braces_from_arrow_function_95060", "Remove braces from arrow function"),
        Convert_default_export_to_named_export: diag(95061, ts.DiagnosticCategory.Message, "Convert_default_export_to_named_export_95061", "Convert default export to named export"),
        Convert_named_export_to_default_export: diag(95062, ts.DiagnosticCategory.Message, "Convert_named_export_to_default_export_95062", "Convert named export to default export"),
        Add_missing_enum_member_0: diag(95063, ts.DiagnosticCategory.Message, "Add_missing_enum_member_0_95063", "Add missing enum member '{0}'"),
        Add_all_missing_imports: diag(95064, ts.DiagnosticCategory.Message, "Add_all_missing_imports_95064", "Add all missing imports"),
        Convert_to_async_function: diag(95065, ts.DiagnosticCategory.Message, "Convert_to_async_function_95065", "Convert to async function"),
        Convert_all_to_async_functions: diag(95066, ts.DiagnosticCategory.Message, "Convert_all_to_async_functions_95066", "Convert all to async functions"),
        Add_missing_call_parentheses: diag(95067, ts.DiagnosticCategory.Message, "Add_missing_call_parentheses_95067", "Add missing call parentheses"),
        Add_all_missing_call_parentheses: diag(95068, ts.DiagnosticCategory.Message, "Add_all_missing_call_parentheses_95068", "Add all missing call parentheses"),
        Add_unknown_conversion_for_non_overlapping_types: diag(95069, ts.DiagnosticCategory.Message, "Add_unknown_conversion_for_non_overlapping_types_95069", "Add 'unknown' conversion for non-overlapping types"),
        Add_unknown_to_all_conversions_of_non_overlapping_types: diag(95070, ts.DiagnosticCategory.Message, "Add_unknown_to_all_conversions_of_non_overlapping_types_95070", "Add 'unknown' to all conversions of non-overlapping types"),
        Add_missing_new_operator_to_call: diag(95071, ts.DiagnosticCategory.Message, "Add_missing_new_operator_to_call_95071", "Add missing 'new' operator to call"),
        Add_missing_new_operator_to_all_calls: diag(95072, ts.DiagnosticCategory.Message, "Add_missing_new_operator_to_all_calls_95072", "Add missing 'new' operator to all calls"),
        Add_names_to_all_parameters_without_names: diag(95073, ts.DiagnosticCategory.Message, "Add_names_to_all_parameters_without_names_95073", "Add names to all parameters without names"),
        Enable_the_experimentalDecorators_option_in_your_configuration_file: diag(95074, ts.DiagnosticCategory.Message, "Enable_the_experimentalDecorators_option_in_your_configuration_file_95074", "Enable the 'experimentalDecorators' option in your configuration file"),
        Convert_parameters_to_destructured_object: diag(95075, ts.DiagnosticCategory.Message, "Convert_parameters_to_destructured_object_95075", "Convert parameters to destructured object"),
        Extract_type: diag(95077, ts.DiagnosticCategory.Message, "Extract_type_95077", "Extract type"),
        Extract_to_type_alias: diag(95078, ts.DiagnosticCategory.Message, "Extract_to_type_alias_95078", "Extract to type alias"),
        Extract_to_typedef: diag(95079, ts.DiagnosticCategory.Message, "Extract_to_typedef_95079", "Extract to typedef"),
        Infer_this_type_of_0_from_usage: diag(95080, ts.DiagnosticCategory.Message, "Infer_this_type_of_0_from_usage_95080", "Infer 'this' type of '{0}' from usage"),
        Add_const_to_unresolved_variable: diag(95081, ts.DiagnosticCategory.Message, "Add_const_to_unresolved_variable_95081", "Add 'const' to unresolved variable"),
        Add_const_to_all_unresolved_variables: diag(95082, ts.DiagnosticCategory.Message, "Add_const_to_all_unresolved_variables_95082", "Add 'const' to all unresolved variables"),
        Add_await: diag(95083, ts.DiagnosticCategory.Message, "Add_await_95083", "Add 'await'"),
        Add_await_to_initializer_for_0: diag(95084, ts.DiagnosticCategory.Message, "Add_await_to_initializer_for_0_95084", "Add 'await' to initializer for '{0}'"),
        Fix_all_expressions_possibly_missing_await: diag(95085, ts.DiagnosticCategory.Message, "Fix_all_expressions_possibly_missing_await_95085", "Fix all expressions possibly missing 'await'"),
        Remove_unnecessary_await: diag(95086, ts.DiagnosticCategory.Message, "Remove_unnecessary_await_95086", "Remove unnecessary 'await'"),
        Remove_all_unnecessary_uses_of_await: diag(95087, ts.DiagnosticCategory.Message, "Remove_all_unnecessary_uses_of_await_95087", "Remove all unnecessary uses of 'await'"),
        Enable_the_jsx_flag_in_your_configuration_file: diag(95088, ts.DiagnosticCategory.Message, "Enable_the_jsx_flag_in_your_configuration_file_95088", "Enable the '--jsx' flag in your configuration file"),
        Add_await_to_initializers: diag(95089, ts.DiagnosticCategory.Message, "Add_await_to_initializers_95089", "Add 'await' to initializers"),
        Extract_to_interface: diag(95090, ts.DiagnosticCategory.Message, "Extract_to_interface_95090", "Extract to interface"),
        Convert_to_a_bigint_numeric_literal: diag(95091, ts.DiagnosticCategory.Message, "Convert_to_a_bigint_numeric_literal_95091", "Convert to a bigint numeric literal"),
        Convert_all_to_bigint_numeric_literals: diag(95092, ts.DiagnosticCategory.Message, "Convert_all_to_bigint_numeric_literals_95092", "Convert all to bigint numeric literals"),
        Convert_const_to_let: diag(95093, ts.DiagnosticCategory.Message, "Convert_const_to_let_95093", "Convert 'const' to 'let'"),
        Prefix_with_declare: diag(95094, ts.DiagnosticCategory.Message, "Prefix_with_declare_95094", "Prefix with 'declare'"),
        Prefix_all_incorrect_property_declarations_with_declare: diag(95095, ts.DiagnosticCategory.Message, "Prefix_all_incorrect_property_declarations_with_declare_95095", "Prefix all incorrect property declarations with 'declare'"),
        Convert_to_template_string: diag(95096, ts.DiagnosticCategory.Message, "Convert_to_template_string_95096", "Convert to template string"),
        Add_export_to_make_this_file_into_a_module: diag(95097, ts.DiagnosticCategory.Message, "Add_export_to_make_this_file_into_a_module_95097", "Add 'export {}' to make this file into a module"),
        Set_the_target_option_in_your_configuration_file_to_0: diag(95098, ts.DiagnosticCategory.Message, "Set_the_target_option_in_your_configuration_file_to_0_95098", "Set the 'target' option in your configuration file to '{0}'"),
        Set_the_module_option_in_your_configuration_file_to_0: diag(95099, ts.DiagnosticCategory.Message, "Set_the_module_option_in_your_configuration_file_to_0_95099", "Set the 'module' option in your configuration file to '{0}'"),
        Convert_invalid_character_to_its_html_entity_code: diag(95100, ts.DiagnosticCategory.Message, "Convert_invalid_character_to_its_html_entity_code_95100", "Convert invalid character to its html entity code"),
        Convert_all_invalid_characters_to_HTML_entity_code: diag(95101, ts.DiagnosticCategory.Message, "Convert_all_invalid_characters_to_HTML_entity_code_95101", "Convert all invalid characters to HTML entity code"),
        Convert_function_expression_0_to_arrow_function: diag(95105, ts.DiagnosticCategory.Message, "Convert_function_expression_0_to_arrow_function_95105", "Convert function expression '{0}' to arrow function"),
        Convert_function_declaration_0_to_arrow_function: diag(95106, ts.DiagnosticCategory.Message, "Convert_function_declaration_0_to_arrow_function_95106", "Convert function declaration '{0}' to arrow function"),
        Fix_all_implicit_this_errors: diag(95107, ts.DiagnosticCategory.Message, "Fix_all_implicit_this_errors_95107", "Fix all implicit-'this' errors"),
        Wrap_invalid_character_in_an_expression_container: diag(95108, ts.DiagnosticCategory.Message, "Wrap_invalid_character_in_an_expression_container_95108", "Wrap invalid character in an expression container"),
        Wrap_all_invalid_characters_in_an_expression_container: diag(95109, ts.DiagnosticCategory.Message, "Wrap_all_invalid_characters_in_an_expression_container_95109", "Wrap all invalid characters in an expression container"),
        Visit_https_Colon_Slash_Slashaka_ms_Slashtsconfig_to_read_more_about_this_file: diag(95110, ts.DiagnosticCategory.Message, "Visit_https_Colon_Slash_Slashaka_ms_Slashtsconfig_to_read_more_about_this_file_95110", "Visit https://aka.ms/tsconfig to read more about this file"),
        Add_a_return_statement: diag(95111, ts.DiagnosticCategory.Message, "Add_a_return_statement_95111", "Add a return statement"),
        Remove_braces_from_arrow_function_body: diag(95112, ts.DiagnosticCategory.Message, "Remove_braces_from_arrow_function_body_95112", "Remove braces from arrow function body"),
        Wrap_the_following_body_with_parentheses_which_should_be_an_object_literal: diag(95113, ts.DiagnosticCategory.Message, "Wrap_the_following_body_with_parentheses_which_should_be_an_object_literal_95113", "Wrap the following body with parentheses which should be an object literal"),
        Add_all_missing_return_statement: diag(95114, ts.DiagnosticCategory.Message, "Add_all_missing_return_statement_95114", "Add all missing return statement"),
        Remove_braces_from_all_arrow_function_bodies_with_relevant_issues: diag(95115, ts.DiagnosticCategory.Message, "Remove_braces_from_all_arrow_function_bodies_with_relevant_issues_95115", "Remove braces from all arrow function bodies with relevant issues"),
        Wrap_all_object_literal_with_parentheses: diag(95116, ts.DiagnosticCategory.Message, "Wrap_all_object_literal_with_parentheses_95116", "Wrap all object literal with parentheses"),
        Move_labeled_tuple_element_modifiers_to_labels: diag(95117, ts.DiagnosticCategory.Message, "Move_labeled_tuple_element_modifiers_to_labels_95117", "Move labeled tuple element modifiers to labels"),
        Convert_overload_list_to_single_signature: diag(95118, ts.DiagnosticCategory.Message, "Convert_overload_list_to_single_signature_95118", "Convert overload list to single signature"),
        Generate_get_and_set_accessors_for_all_overriding_properties: diag(95119, ts.DiagnosticCategory.Message, "Generate_get_and_set_accessors_for_all_overriding_properties_95119", "Generate 'get' and 'set' accessors for all overriding properties"),
        Wrap_in_JSX_fragment: diag(95120, ts.DiagnosticCategory.Message, "Wrap_in_JSX_fragment_95120", "Wrap in JSX fragment"),
        Wrap_all_unparented_JSX_in_JSX_fragment: diag(95121, ts.DiagnosticCategory.Message, "Wrap_all_unparented_JSX_in_JSX_fragment_95121", "Wrap all unparented JSX in JSX fragment"),
        Convert_arrow_function_or_function_expression: diag(95122, ts.DiagnosticCategory.Message, "Convert_arrow_function_or_function_expression_95122", "Convert arrow function or function expression"),
        Convert_to_anonymous_function: diag(95123, ts.DiagnosticCategory.Message, "Convert_to_anonymous_function_95123", "Convert to anonymous function"),
        Convert_to_named_function: diag(95124, ts.DiagnosticCategory.Message, "Convert_to_named_function_95124", "Convert to named function"),
        Convert_to_arrow_function: diag(95125, ts.DiagnosticCategory.Message, "Convert_to_arrow_function_95125", "Convert to arrow function"),
        Remove_parentheses: diag(95126, ts.DiagnosticCategory.Message, "Remove_parentheses_95126", "Remove parentheses"),
        Could_not_find_a_containing_arrow_function: diag(95127, ts.DiagnosticCategory.Message, "Could_not_find_a_containing_arrow_function_95127", "Could not find a containing arrow function"),
        Containing_function_is_not_an_arrow_function: diag(95128, ts.DiagnosticCategory.Message, "Containing_function_is_not_an_arrow_function_95128", "Containing function is not an arrow function"),
        Could_not_find_export_statement: diag(95129, ts.DiagnosticCategory.Message, "Could_not_find_export_statement_95129", "Could not find export statement"),
        This_file_already_has_a_default_export: diag(95130, ts.DiagnosticCategory.Message, "This_file_already_has_a_default_export_95130", "This file already has a default export"),
        Could_not_find_import_clause: diag(95131, ts.DiagnosticCategory.Message, "Could_not_find_import_clause_95131", "Could not find import clause"),
        Could_not_find_namespace_import_or_named_imports: diag(95132, ts.DiagnosticCategory.Message, "Could_not_find_namespace_import_or_named_imports_95132", "Could not find namespace import or named imports"),
        Selection_is_not_a_valid_type_node: diag(95133, ts.DiagnosticCategory.Message, "Selection_is_not_a_valid_type_node_95133", "Selection is not a valid type node"),
        No_type_could_be_extracted_from_this_type_node: diag(95134, ts.DiagnosticCategory.Message, "No_type_could_be_extracted_from_this_type_node_95134", "No type could be extracted from this type node"),
        Could_not_find_property_for_which_to_generate_accessor: diag(95135, ts.DiagnosticCategory.Message, "Could_not_find_property_for_which_to_generate_accessor_95135", "Could not find property for which to generate accessor"),
        Name_is_not_valid: diag(95136, ts.DiagnosticCategory.Message, "Name_is_not_valid_95136", "Name is not valid"),
        Can_only_convert_property_with_modifier: diag(95137, ts.DiagnosticCategory.Message, "Can_only_convert_property_with_modifier_95137", "Can only convert property with modifier"),
        Switch_each_misused_0_to_1: diag(95138, ts.DiagnosticCategory.Message, "Switch_each_misused_0_to_1_95138", "Switch each misused '{0}' to '{1}'"),
        Convert_to_optional_chain_expression: diag(95139, ts.DiagnosticCategory.Message, "Convert_to_optional_chain_expression_95139", "Convert to optional chain expression"),
        Could_not_find_convertible_access_expression: diag(95140, ts.DiagnosticCategory.Message, "Could_not_find_convertible_access_expression_95140", "Could not find convertible access expression"),
        Could_not_find_matching_access_expressions: diag(95141, ts.DiagnosticCategory.Message, "Could_not_find_matching_access_expressions_95141", "Could not find matching access expressions"),
        Can_only_convert_logical_AND_access_chains: diag(95142, ts.DiagnosticCategory.Message, "Can_only_convert_logical_AND_access_chains_95142", "Can only convert logical AND access chains"),
        Add_void_to_Promise_resolved_without_a_value: diag(95143, ts.DiagnosticCategory.Message, "Add_void_to_Promise_resolved_without_a_value_95143", "Add 'void' to Promise resolved without a value"),
        Add_void_to_all_Promises_resolved_without_a_value: diag(95144, ts.DiagnosticCategory.Message, "Add_void_to_all_Promises_resolved_without_a_value_95144", "Add 'void' to all Promises resolved without a value"),
        Use_element_access_for_0: diag(95145, ts.DiagnosticCategory.Message, "Use_element_access_for_0_95145", "Use element access for '{0}'"),
        Use_element_access_for_all_undeclared_properties: diag(95146, ts.DiagnosticCategory.Message, "Use_element_access_for_all_undeclared_properties_95146", "Use element access for all undeclared properties."),
        Delete_all_unused_imports: diag(95147, ts.DiagnosticCategory.Message, "Delete_all_unused_imports_95147", "Delete all unused imports"),
        Infer_function_return_type: diag(95148, ts.DiagnosticCategory.Message, "Infer_function_return_type_95148", "Infer function return type"),
        Return_type_must_be_inferred_from_a_function: diag(95149, ts.DiagnosticCategory.Message, "Return_type_must_be_inferred_from_a_function_95149", "Return type must be inferred from a function"),
        Could_not_determine_function_return_type: diag(95150, ts.DiagnosticCategory.Message, "Could_not_determine_function_return_type_95150", "Could not determine function return type"),
        Could_not_convert_to_arrow_function: diag(95151, ts.DiagnosticCategory.Message, "Could_not_convert_to_arrow_function_95151", "Could not convert to arrow function"),
        Could_not_convert_to_named_function: diag(95152, ts.DiagnosticCategory.Message, "Could_not_convert_to_named_function_95152", "Could not convert to named function"),
        Could_not_convert_to_anonymous_function: diag(95153, ts.DiagnosticCategory.Message, "Could_not_convert_to_anonymous_function_95153", "Could not convert to anonymous function"),
        Can_only_convert_string_concatenation: diag(95154, ts.DiagnosticCategory.Message, "Can_only_convert_string_concatenation_95154", "Can only convert string concatenation"),
        Selection_is_not_a_valid_statement_or_statements: diag(95155, ts.DiagnosticCategory.Message, "Selection_is_not_a_valid_statement_or_statements_95155", "Selection is not a valid statement or statements"),
        Add_missing_function_declaration_0: diag(95156, ts.DiagnosticCategory.Message, "Add_missing_function_declaration_0_95156", "Add missing function declaration '{0}'"),
        Add_all_missing_function_declarations: diag(95157, ts.DiagnosticCategory.Message, "Add_all_missing_function_declarations_95157", "Add all missing function declarations"),
        Method_not_implemented: diag(95158, ts.DiagnosticCategory.Message, "Method_not_implemented_95158", "Method not implemented."),
        Function_not_implemented: diag(95159, ts.DiagnosticCategory.Message, "Function_not_implemented_95159", "Function not implemented."),
        Add_override_modifier: diag(95160, ts.DiagnosticCategory.Message, "Add_override_modifier_95160", "Add 'override' modifier"),
        Remove_override_modifier: diag(95161, ts.DiagnosticCategory.Message, "Remove_override_modifier_95161", "Remove 'override' modifier"),
        Add_all_missing_override_modifiers: diag(95162, ts.DiagnosticCategory.Message, "Add_all_missing_override_modifiers_95162", "Add all missing 'override' modifiers"),
        Remove_all_unnecessary_override_modifiers: diag(95163, ts.DiagnosticCategory.Message, "Remove_all_unnecessary_override_modifiers_95163", "Remove all unnecessary 'override' modifiers"),
        Can_only_convert_named_export: diag(95164, ts.DiagnosticCategory.Message, "Can_only_convert_named_export_95164", "Can only convert named export"),
        Add_missing_properties: diag(95165, ts.DiagnosticCategory.Message, "Add_missing_properties_95165", "Add missing properties"),
        Add_all_missing_properties: diag(95166, ts.DiagnosticCategory.Message, "Add_all_missing_properties_95166", "Add all missing properties"),
        Add_missing_attributes: diag(95167, ts.DiagnosticCategory.Message, "Add_missing_attributes_95167", "Add missing attributes"),
        Add_all_missing_attributes: diag(95168, ts.DiagnosticCategory.Message, "Add_all_missing_attributes_95168", "Add all missing attributes"),
        Add_undefined_to_optional_property_type: diag(95169, ts.DiagnosticCategory.Message, "Add_undefined_to_optional_property_type_95169", "Add 'undefined' to optional property type"),
        Convert_named_imports_to_default_import: diag(95170, ts.DiagnosticCategory.Message, "Convert_named_imports_to_default_import_95170", "Convert named imports to default import"),
        Delete_unused_param_tag_0: diag(95171, ts.DiagnosticCategory.Message, "Delete_unused_param_tag_0_95171", "Delete unused '@param' tag '{0}'"),
        Delete_all_unused_param_tags: diag(95172, ts.DiagnosticCategory.Message, "Delete_all_unused_param_tags_95172", "Delete all unused '@param' tags"),
        Rename_param_tag_name_0_to_1: diag(95173, ts.DiagnosticCategory.Message, "Rename_param_tag_name_0_to_1_95173", "Rename '@param' tag name '{0}' to '{1}'"),
        No_value_exists_in_scope_for_the_shorthand_property_0_Either_declare_one_or_provide_an_initializer: diag(18004, ts.DiagnosticCategory.Error, "No_value_exists_in_scope_for_the_shorthand_property_0_Either_declare_one_or_provide_an_initializer_18004", "No value exists in scope for the shorthand property '{0}'. Either declare one or provide an initializer."),
        Classes_may_not_have_a_field_named_constructor: diag(18006, ts.DiagnosticCategory.Error, "Classes_may_not_have_a_field_named_constructor_18006", "Classes may not have a field named 'constructor'."),
        JSX_expressions_may_not_use_the_comma_operator_Did_you_mean_to_write_an_array: diag(18007, ts.DiagnosticCategory.Error, "JSX_expressions_may_not_use_the_comma_operator_Did_you_mean_to_write_an_array_18007", "JSX expressions may not use the comma operator. Did you mean to write an array?"),
        Private_identifiers_cannot_be_used_as_parameters: diag(18009, ts.DiagnosticCategory.Error, "Private_identifiers_cannot_be_used_as_parameters_18009", "Private identifiers cannot be used as parameters."),
        An_accessibility_modifier_cannot_be_used_with_a_private_identifier: diag(18010, ts.DiagnosticCategory.Error, "An_accessibility_modifier_cannot_be_used_with_a_private_identifier_18010", "An accessibility modifier cannot be used with a private identifier."),
        The_operand_of_a_delete_operator_cannot_be_a_private_identifier: diag(18011, ts.DiagnosticCategory.Error, "The_operand_of_a_delete_operator_cannot_be_a_private_identifier_18011", "The operand of a 'delete' operator cannot be a private identifier."),
        constructor_is_a_reserved_word: diag(18012, ts.DiagnosticCategory.Error, "constructor_is_a_reserved_word_18012", "'#constructor' is a reserved word."),
        Property_0_is_not_accessible_outside_class_1_because_it_has_a_private_identifier: diag(18013, ts.DiagnosticCategory.Error, "Property_0_is_not_accessible_outside_class_1_because_it_has_a_private_identifier_18013", "Property '{0}' is not accessible outside class '{1}' because it has a private identifier."),
        The_property_0_cannot_be_accessed_on_type_1_within_this_class_because_it_is_shadowed_by_another_private_identifier_with_the_same_spelling: diag(18014, ts.DiagnosticCategory.Error, "The_property_0_cannot_be_accessed_on_type_1_within_this_class_because_it_is_shadowed_by_another_priv_18014", "The property '{0}' cannot be accessed on type '{1}' within this class because it is shadowed by another private identifier with the same spelling."),
        Property_0_in_type_1_refers_to_a_different_member_that_cannot_be_accessed_from_within_type_2: diag(18015, ts.DiagnosticCategory.Error, "Property_0_in_type_1_refers_to_a_different_member_that_cannot_be_accessed_from_within_type_2_18015", "Property '{0}' in type '{1}' refers to a different member that cannot be accessed from within type '{2}'."),
        Private_identifiers_are_not_allowed_outside_class_bodies: diag(18016, ts.DiagnosticCategory.Error, "Private_identifiers_are_not_allowed_outside_class_bodies_18016", "Private identifiers are not allowed outside class bodies."),
        The_shadowing_declaration_of_0_is_defined_here: diag(18017, ts.DiagnosticCategory.Error, "The_shadowing_declaration_of_0_is_defined_here_18017", "The shadowing declaration of '{0}' is defined here"),
        The_declaration_of_0_that_you_probably_intended_to_use_is_defined_here: diag(18018, ts.DiagnosticCategory.Error, "The_declaration_of_0_that_you_probably_intended_to_use_is_defined_here_18018", "The declaration of '{0}' that you probably intended to use is defined here"),
        _0_modifier_cannot_be_used_with_a_private_identifier: diag(18019, ts.DiagnosticCategory.Error, "_0_modifier_cannot_be_used_with_a_private_identifier_18019", "'{0}' modifier cannot be used with a private identifier."),
        An_enum_member_cannot_be_named_with_a_private_identifier: diag(18024, ts.DiagnosticCategory.Error, "An_enum_member_cannot_be_named_with_a_private_identifier_18024", "An enum member cannot be named with a private identifier."),
        can_only_be_used_at_the_start_of_a_file: diag(18026, ts.DiagnosticCategory.Error, "can_only_be_used_at_the_start_of_a_file_18026", "'#!' can only be used at the start of a file."),
        Compiler_reserves_name_0_when_emitting_private_identifier_downlevel: diag(18027, ts.DiagnosticCategory.Error, "Compiler_reserves_name_0_when_emitting_private_identifier_downlevel_18027", "Compiler reserves name '{0}' when emitting private identifier downlevel."),
        Private_identifiers_are_only_available_when_targeting_ECMAScript_2015_and_higher: diag(18028, ts.DiagnosticCategory.Error, "Private_identifiers_are_only_available_when_targeting_ECMAScript_2015_and_higher_18028", "Private identifiers are only available when targeting ECMAScript 2015 and higher."),
        Private_identifiers_are_not_allowed_in_variable_declarations: diag(18029, ts.DiagnosticCategory.Error, "Private_identifiers_are_not_allowed_in_variable_declarations_18029", "Private identifiers are not allowed in variable declarations."),
        An_optional_chain_cannot_contain_private_identifiers: diag(18030, ts.DiagnosticCategory.Error, "An_optional_chain_cannot_contain_private_identifiers_18030", "An optional chain cannot contain private identifiers."),
        The_intersection_0_was_reduced_to_never_because_property_1_has_conflicting_types_in_some_constituents: diag(18031, ts.DiagnosticCategory.Error, "The_intersection_0_was_reduced_to_never_because_property_1_has_conflicting_types_in_some_constituent_18031", "The intersection '{0}' was reduced to 'never' because property '{1}' has conflicting types in some constituents."),
        The_intersection_0_was_reduced_to_never_because_property_1_exists_in_multiple_constituents_and_is_private_in_some: diag(18032, ts.DiagnosticCategory.Error, "The_intersection_0_was_reduced_to_never_because_property_1_exists_in_multiple_constituents_and_is_pr_18032", "The intersection '{0}' was reduced to 'never' because property '{1}' exists in multiple constituents and is private in some."),
        Only_numeric_enums_can_have_computed_members_but_this_expression_has_type_0_If_you_do_not_need_exhaustiveness_checks_consider_using_an_object_literal_instead: diag(18033, ts.DiagnosticCategory.Error, "Only_numeric_enums_can_have_computed_members_but_this_expression_has_type_0_If_you_do_not_need_exhau_18033", "Only numeric enums can have computed members, but this expression has type '{0}'. If you do not need exhaustiveness checks, consider using an object literal instead."),
        Specify_the_JSX_fragment_factory_function_to_use_when_targeting_react_JSX_emit_with_jsxFactory_compiler_option_is_specified_e_g_Fragment: diag(18034, ts.DiagnosticCategory.Message, "Specify_the_JSX_fragment_factory_function_to_use_when_targeting_react_JSX_emit_with_jsxFactory_compi_18034", "Specify the JSX fragment factory function to use when targeting 'react' JSX emit with 'jsxFactory' compiler option is specified, e.g. 'Fragment'."),
        Invalid_value_for_jsxFragmentFactory_0_is_not_a_valid_identifier_or_qualified_name: diag(18035, ts.DiagnosticCategory.Error, "Invalid_value_for_jsxFragmentFactory_0_is_not_a_valid_identifier_or_qualified_name_18035", "Invalid value for 'jsxFragmentFactory'. '{0}' is not a valid identifier or qualified-name."),
        Class_decorators_can_t_be_used_with_static_private_identifier_Consider_removing_the_experimental_decorator: diag(18036, ts.DiagnosticCategory.Error, "Class_decorators_can_t_be_used_with_static_private_identifier_Consider_removing_the_experimental_dec_18036", "Class decorators can't be used with static private identifier. Consider removing the experimental decorator."),
        Await_expression_cannot_be_used_inside_a_class_static_block: diag(18037, ts.DiagnosticCategory.Error, "Await_expression_cannot_be_used_inside_a_class_static_block_18037", "Await expression cannot be used inside a class static block."),
        For_await_loops_cannot_be_used_inside_a_class_static_block: diag(18038, ts.DiagnosticCategory.Error, "For_await_loops_cannot_be_used_inside_a_class_static_block_18038", "'For await' loops cannot be used inside a class static block."),
        Invalid_use_of_0_It_cannot_be_used_inside_a_class_static_block: diag(18039, ts.DiagnosticCategory.Error, "Invalid_use_of_0_It_cannot_be_used_inside_a_class_static_block_18039", "Invalid use of '{0}'. It cannot be used inside a class static block."),
        A_return_statement_cannot_be_used_inside_a_class_static_block: diag(18041, ts.DiagnosticCategory.Error, "A_return_statement_cannot_be_used_inside_a_class_static_block_18041", "A 'return' statement cannot be used inside a class static block."),
    };
})(ts || (ts = {}));
var ts;
(function (ts) {
    var _a;
    function tokenIsIdentifierOrKeyword(token) {
        return token >= 79;
    }
    ts.tokenIsIdentifierOrKeyword = tokenIsIdentifierOrKeyword;
    function tokenIsIdentifierOrKeywordOrGreaterThan(token) {
        return token === 31 || tokenIsIdentifierOrKeyword(token);
    }
    ts.tokenIsIdentifierOrKeywordOrGreaterThan = tokenIsIdentifierOrKeywordOrGreaterThan;
    ts.textToKeywordObj = (_a = {
            abstract: 126,
            any: 130,
            as: 127,
            asserts: 128,
            assert: 129,
            bigint: 158,
            boolean: 133,
            break: 81,
            case: 82,
            catch: 83,
            class: 84,
            continue: 86,
            const: 85
        },
        _a["" + "constructor"] = 134,
        _a.debugger = 87,
        _a.declare = 135,
        _a.default = 88,
        _a.delete = 89,
        _a.do = 90,
        _a.else = 91,
        _a.enum = 92,
        _a.export = 93,
        _a.extends = 94,
        _a.false = 95,
        _a.finally = 96,
        _a.for = 97,
        _a.from = 156,
        _a.function = 98,
        _a.get = 136,
        _a.if = 99,
        _a.implements = 117,
        _a.import = 100,
        _a.in = 101,
        _a.infer = 137,
        _a.instanceof = 102,
        _a.interface = 118,
        _a.intrinsic = 138,
        _a.is = 139,
        _a.keyof = 140,
        _a.let = 119,
        _a.module = 141,
        _a.namespace = 142,
        _a.never = 143,
        _a.new = 103,
        _a.null = 104,
        _a.number = 147,
        _a.object = 148,
        _a.package = 120,
        _a.private = 121,
        _a.protected = 122,
        _a.public = 123,
        _a.override = 159,
        _a.out = 144,
        _a.readonly = 145,
        _a.require = 146,
        _a.global = 157,
        _a.return = 105,
        _a.set = 149,
        _a.static = 124,
        _a.string = 150,
        _a.super = 106,
        _a.switch = 107,
        _a.symbol = 151,
        _a.this = 108,
        _a.throw = 109,
        _a.true = 110,
        _a.try = 111,
        _a.type = 152,
        _a.typeof = 112,
        _a.undefined = 153,
        _a.unique = 154,
        _a.unknown = 155,
        _a.var = 113,
        _a.void = 114,
        _a.while = 115,
        _a.with = 116,
        _a.yield = 125,
        _a.async = 131,
        _a.await = 132,
        _a.of = 160,
        _a);
    var textToKeyword = new ts.Map(ts.getEntries(ts.textToKeywordObj));
    var textToToken = new ts.Map(ts.getEntries(__assign(__assign({}, ts.textToKeywordObj), { "{": 18, "}": 19, "(": 20, ")": 21, "[": 22, "]": 23, ".": 24, "...": 25, ";": 26, ",": 27, "<": 29, ">": 31, "<=": 32, ">=": 33, "==": 34, "!=": 35, "===": 36, "!==": 37, "=>": 38, "+": 39, "-": 40, "**": 42, "*": 41, "/": 43, "%": 44, "++": 45, "--": 46, "<<": 47, "</": 30, ">>": 48, ">>>": 49, "&": 50, "|": 51, "^": 52, "!": 53, "~": 54, "&&": 55, "||": 56, "?": 57, "??": 60, "?.": 28, ":": 58, "=": 63, "+=": 64, "-=": 65, "*=": 66, "**=": 67, "/=": 68, "%=": 69, "<<=": 70, ">>=": 71, ">>>=": 72, "&=": 73, "|=": 74, "^=": 78, "||=": 75, "&&=": 76, "??=": 77, "@": 59, "#": 62, "`": 61 })));
    var unicodeES3IdentifierStart = [170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 543, 546, 563, 592, 685, 688, 696, 699, 705, 720, 721, 736, 740, 750, 750, 890, 890, 902, 902, 904, 906, 908, 908, 910, 929, 931, 974, 976, 983, 986, 1011, 1024, 1153, 1164, 1220, 1223, 1224, 1227, 1228, 1232, 1269, 1272, 1273, 1329, 1366, 1369, 1369, 1377, 1415, 1488, 1514, 1520, 1522, 1569, 1594, 1600, 1610, 1649, 1747, 1749, 1749, 1765, 1766, 1786, 1788, 1808, 1808, 1810, 1836, 1920, 1957, 2309, 2361, 2365, 2365, 2384, 2384, 2392, 2401, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2524, 2525, 2527, 2529, 2544, 2545, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2649, 2652, 2654, 2654, 2674, 2676, 2693, 2699, 2701, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2749, 2749, 2768, 2768, 2784, 2784, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2870, 2873, 2877, 2877, 2908, 2909, 2911, 2913, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 2997, 2999, 3001, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3168, 3169, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3294, 3294, 3296, 3297, 3333, 3340, 3342, 3344, 3346, 3368, 3370, 3385, 3424, 3425, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3585, 3632, 3634, 3635, 3648, 3654, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3760, 3762, 3763, 3773, 3773, 3776, 3780, 3782, 3782, 3804, 3805, 3840, 3840, 3904, 3911, 3913, 3946, 3976, 3979, 4096, 4129, 4131, 4135, 4137, 4138, 4176, 4181, 4256, 4293, 4304, 4342, 4352, 4441, 4447, 4514, 4520, 4601, 4608, 4614, 4616, 4678, 4680, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4742, 4744, 4744, 4746, 4749, 4752, 4782, 4784, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4814, 4816, 4822, 4824, 4846, 4848, 4878, 4880, 4880, 4882, 4885, 4888, 4894, 4896, 4934, 4936, 4954, 5024, 5108, 5121, 5740, 5743, 5750, 5761, 5786, 5792, 5866, 6016, 6067, 6176, 6263, 6272, 6312, 7680, 7835, 7840, 7929, 7936, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8319, 8319, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8497, 8499, 8505, 8544, 8579, 12293, 12295, 12321, 12329, 12337, 12341, 12344, 12346, 12353, 12436, 12445, 12446, 12449, 12538, 12540, 12542, 12549, 12588, 12593, 12686, 12704, 12727, 13312, 19893, 19968, 40869, 40960, 42124, 44032, 55203, 63744, 64045, 64256, 64262, 64275, 64279, 64285, 64285, 64287, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65136, 65138, 65140, 65140, 65142, 65276, 65313, 65338, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500,];
    var unicodeES3IdentifierPart = [170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 543, 546, 563, 592, 685, 688, 696, 699, 705, 720, 721, 736, 740, 750, 750, 768, 846, 864, 866, 890, 890, 902, 902, 904, 906, 908, 908, 910, 929, 931, 974, 976, 983, 986, 1011, 1024, 1153, 1155, 1158, 1164, 1220, 1223, 1224, 1227, 1228, 1232, 1269, 1272, 1273, 1329, 1366, 1369, 1369, 1377, 1415, 1425, 1441, 1443, 1465, 1467, 1469, 1471, 1471, 1473, 1474, 1476, 1476, 1488, 1514, 1520, 1522, 1569, 1594, 1600, 1621, 1632, 1641, 1648, 1747, 1749, 1756, 1759, 1768, 1770, 1773, 1776, 1788, 1808, 1836, 1840, 1866, 1920, 1968, 2305, 2307, 2309, 2361, 2364, 2381, 2384, 2388, 2392, 2403, 2406, 2415, 2433, 2435, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2492, 2492, 2494, 2500, 2503, 2504, 2507, 2509, 2519, 2519, 2524, 2525, 2527, 2531, 2534, 2545, 2562, 2562, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2620, 2620, 2622, 2626, 2631, 2632, 2635, 2637, 2649, 2652, 2654, 2654, 2662, 2676, 2689, 2691, 2693, 2699, 2701, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2748, 2757, 2759, 2761, 2763, 2765, 2768, 2768, 2784, 2784, 2790, 2799, 2817, 2819, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2870, 2873, 2876, 2883, 2887, 2888, 2891, 2893, 2902, 2903, 2908, 2909, 2911, 2913, 2918, 2927, 2946, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 2997, 2999, 3001, 3006, 3010, 3014, 3016, 3018, 3021, 3031, 3031, 3047, 3055, 3073, 3075, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3134, 3140, 3142, 3144, 3146, 3149, 3157, 3158, 3168, 3169, 3174, 3183, 3202, 3203, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3262, 3268, 3270, 3272, 3274, 3277, 3285, 3286, 3294, 3294, 3296, 3297, 3302, 3311, 3330, 3331, 3333, 3340, 3342, 3344, 3346, 3368, 3370, 3385, 3390, 3395, 3398, 3400, 3402, 3405, 3415, 3415, 3424, 3425, 3430, 3439, 3458, 3459, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3530, 3530, 3535, 3540, 3542, 3542, 3544, 3551, 3570, 3571, 3585, 3642, 3648, 3662, 3664, 3673, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3769, 3771, 3773, 3776, 3780, 3782, 3782, 3784, 3789, 3792, 3801, 3804, 3805, 3840, 3840, 3864, 3865, 3872, 3881, 3893, 3893, 3895, 3895, 3897, 3897, 3902, 3911, 3913, 3946, 3953, 3972, 3974, 3979, 3984, 3991, 3993, 4028, 4038, 4038, 4096, 4129, 4131, 4135, 4137, 4138, 4140, 4146, 4150, 4153, 4160, 4169, 4176, 4185, 4256, 4293, 4304, 4342, 4352, 4441, 4447, 4514, 4520, 4601, 4608, 4614, 4616, 4678, 4680, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4742, 4744, 4744, 4746, 4749, 4752, 4782, 4784, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4814, 4816, 4822, 4824, 4846, 4848, 4878, 4880, 4880, 4882, 4885, 4888, 4894, 4896, 4934, 4936, 4954, 4969, 4977, 5024, 5108, 5121, 5740, 5743, 5750, 5761, 5786, 5792, 5866, 6016, 6099, 6112, 6121, 6160, 6169, 6176, 6263, 6272, 6313, 7680, 7835, 7840, 7929, 7936, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8255, 8256, 8319, 8319, 8400, 8412, 8417, 8417, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8497, 8499, 8505, 8544, 8579, 12293, 12295, 12321, 12335, 12337, 12341, 12344, 12346, 12353, 12436, 12441, 12442, 12445, 12446, 12449, 12542, 12549, 12588, 12593, 12686, 12704, 12727, 13312, 19893, 19968, 40869, 40960, 42124, 44032, 55203, 63744, 64045, 64256, 64262, 64275, 64279, 64285, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65056, 65059, 65075, 65076, 65101, 65103, 65136, 65138, 65140, 65140, 65142, 65276, 65296, 65305, 65313, 65338, 65343, 65343, 65345, 65370, 65381, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500,];
    var unicodeES5IdentifierStart = [170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 705, 710, 721, 736, 740, 748, 748, 750, 750, 880, 884, 886, 887, 890, 893, 902, 902, 904, 906, 908, 908, 910, 929, 931, 1013, 1015, 1153, 1162, 1319, 1329, 1366, 1369, 1369, 1377, 1415, 1488, 1514, 1520, 1522, 1568, 1610, 1646, 1647, 1649, 1747, 1749, 1749, 1765, 1766, 1774, 1775, 1786, 1788, 1791, 1791, 1808, 1808, 1810, 1839, 1869, 1957, 1969, 1969, 1994, 2026, 2036, 2037, 2042, 2042, 2048, 2069, 2074, 2074, 2084, 2084, 2088, 2088, 2112, 2136, 2208, 2208, 2210, 2220, 2308, 2361, 2365, 2365, 2384, 2384, 2392, 2401, 2417, 2423, 2425, 2431, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2493, 2493, 2510, 2510, 2524, 2525, 2527, 2529, 2544, 2545, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2649, 2652, 2654, 2654, 2674, 2676, 2693, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2749, 2749, 2768, 2768, 2784, 2785, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2869, 2873, 2877, 2877, 2908, 2909, 2911, 2913, 2929, 2929, 2947, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 3001, 3024, 3024, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3133, 3133, 3160, 3161, 3168, 3169, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3261, 3261, 3294, 3294, 3296, 3297, 3313, 3314, 3333, 3340, 3342, 3344, 3346, 3386, 3389, 3389, 3406, 3406, 3424, 3425, 3450, 3455, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3585, 3632, 3634, 3635, 3648, 3654, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3760, 3762, 3763, 3773, 3773, 3776, 3780, 3782, 3782, 3804, 3807, 3840, 3840, 3904, 3911, 3913, 3948, 3976, 3980, 4096, 4138, 4159, 4159, 4176, 4181, 4186, 4189, 4193, 4193, 4197, 4198, 4206, 4208, 4213, 4225, 4238, 4238, 4256, 4293, 4295, 4295, 4301, 4301, 4304, 4346, 4348, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4744, 4746, 4749, 4752, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4822, 4824, 4880, 4882, 4885, 4888, 4954, 4992, 5007, 5024, 5108, 5121, 5740, 5743, 5759, 5761, 5786, 5792, 5866, 5870, 5872, 5888, 5900, 5902, 5905, 5920, 5937, 5952, 5969, 5984, 5996, 5998, 6000, 6016, 6067, 6103, 6103, 6108, 6108, 6176, 6263, 6272, 6312, 6314, 6314, 6320, 6389, 6400, 6428, 6480, 6509, 6512, 6516, 6528, 6571, 6593, 6599, 6656, 6678, 6688, 6740, 6823, 6823, 6917, 6963, 6981, 6987, 7043, 7072, 7086, 7087, 7098, 7141, 7168, 7203, 7245, 7247, 7258, 7293, 7401, 7404, 7406, 7409, 7413, 7414, 7424, 7615, 7680, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8305, 8305, 8319, 8319, 8336, 8348, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8505, 8508, 8511, 8517, 8521, 8526, 8526, 8544, 8584, 11264, 11310, 11312, 11358, 11360, 11492, 11499, 11502, 11506, 11507, 11520, 11557, 11559, 11559, 11565, 11565, 11568, 11623, 11631, 11631, 11648, 11670, 11680, 11686, 11688, 11694, 11696, 11702, 11704, 11710, 11712, 11718, 11720, 11726, 11728, 11734, 11736, 11742, 11823, 11823, 12293, 12295, 12321, 12329, 12337, 12341, 12344, 12348, 12353, 12438, 12445, 12447, 12449, 12538, 12540, 12543, 12549, 12589, 12593, 12686, 12704, 12730, 12784, 12799, 13312, 19893, 19968, 40908, 40960, 42124, 42192, 42237, 42240, 42508, 42512, 42527, 42538, 42539, 42560, 42606, 42623, 42647, 42656, 42735, 42775, 42783, 42786, 42888, 42891, 42894, 42896, 42899, 42912, 42922, 43000, 43009, 43011, 43013, 43015, 43018, 43020, 43042, 43072, 43123, 43138, 43187, 43250, 43255, 43259, 43259, 43274, 43301, 43312, 43334, 43360, 43388, 43396, 43442, 43471, 43471, 43520, 43560, 43584, 43586, 43588, 43595, 43616, 43638, 43642, 43642, 43648, 43695, 43697, 43697, 43701, 43702, 43705, 43709, 43712, 43712, 43714, 43714, 43739, 43741, 43744, 43754, 43762, 43764, 43777, 43782, 43785, 43790, 43793, 43798, 43808, 43814, 43816, 43822, 43968, 44002, 44032, 55203, 55216, 55238, 55243, 55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275, 64279, 64285, 64285, 64287, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65136, 65140, 65142, 65276, 65313, 65338, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500,];
    var unicodeES5IdentifierPart = [170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 705, 710, 721, 736, 740, 748, 748, 750, 750, 768, 884, 886, 887, 890, 893, 902, 902, 904, 906, 908, 908, 910, 929, 931, 1013, 1015, 1153, 1155, 1159, 1162, 1319, 1329, 1366, 1369, 1369, 1377, 1415, 1425, 1469, 1471, 1471, 1473, 1474, 1476, 1477, 1479, 1479, 1488, 1514, 1520, 1522, 1552, 1562, 1568, 1641, 1646, 1747, 1749, 1756, 1759, 1768, 1770, 1788, 1791, 1791, 1808, 1866, 1869, 1969, 1984, 2037, 2042, 2042, 2048, 2093, 2112, 2139, 2208, 2208, 2210, 2220, 2276, 2302, 2304, 2403, 2406, 2415, 2417, 2423, 2425, 2431, 2433, 2435, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2492, 2500, 2503, 2504, 2507, 2510, 2519, 2519, 2524, 2525, 2527, 2531, 2534, 2545, 2561, 2563, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2620, 2620, 2622, 2626, 2631, 2632, 2635, 2637, 2641, 2641, 2649, 2652, 2654, 2654, 2662, 2677, 2689, 2691, 2693, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2748, 2757, 2759, 2761, 2763, 2765, 2768, 2768, 2784, 2787, 2790, 2799, 2817, 2819, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2869, 2873, 2876, 2884, 2887, 2888, 2891, 2893, 2902, 2903, 2908, 2909, 2911, 2915, 2918, 2927, 2929, 2929, 2946, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 3001, 3006, 3010, 3014, 3016, 3018, 3021, 3024, 3024, 3031, 3031, 3046, 3055, 3073, 3075, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3133, 3140, 3142, 3144, 3146, 3149, 3157, 3158, 3160, 3161, 3168, 3171, 3174, 3183, 3202, 3203, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3260, 3268, 3270, 3272, 3274, 3277, 3285, 3286, 3294, 3294, 3296, 3299, 3302, 3311, 3313, 3314, 3330, 3331, 3333, 3340, 3342, 3344, 3346, 3386, 3389, 3396, 3398, 3400, 3402, 3406, 3415, 3415, 3424, 3427, 3430, 3439, 3450, 3455, 3458, 3459, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3530, 3530, 3535, 3540, 3542, 3542, 3544, 3551, 3570, 3571, 3585, 3642, 3648, 3662, 3664, 3673, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3769, 3771, 3773, 3776, 3780, 3782, 3782, 3784, 3789, 3792, 3801, 3804, 3807, 3840, 3840, 3864, 3865, 3872, 3881, 3893, 3893, 3895, 3895, 3897, 3897, 3902, 3911, 3913, 3948, 3953, 3972, 3974, 3991, 3993, 4028, 4038, 4038, 4096, 4169, 4176, 4253, 4256, 4293, 4295, 4295, 4301, 4301, 4304, 4346, 4348, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4744, 4746, 4749, 4752, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4822, 4824, 4880, 4882, 4885, 4888, 4954, 4957, 4959, 4992, 5007, 5024, 5108, 5121, 5740, 5743, 5759, 5761, 5786, 5792, 5866, 5870, 5872, 5888, 5900, 5902, 5908, 5920, 5940, 5952, 5971, 5984, 5996, 5998, 6000, 6002, 6003, 6016, 6099, 6103, 6103, 6108, 6109, 6112, 6121, 6155, 6157, 6160, 6169, 6176, 6263, 6272, 6314, 6320, 6389, 6400, 6428, 6432, 6443, 6448, 6459, 6470, 6509, 6512, 6516, 6528, 6571, 6576, 6601, 6608, 6617, 6656, 6683, 6688, 6750, 6752, 6780, 6783, 6793, 6800, 6809, 6823, 6823, 6912, 6987, 6992, 7001, 7019, 7027, 7040, 7155, 7168, 7223, 7232, 7241, 7245, 7293, 7376, 7378, 7380, 7414, 7424, 7654, 7676, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8204, 8205, 8255, 8256, 8276, 8276, 8305, 8305, 8319, 8319, 8336, 8348, 8400, 8412, 8417, 8417, 8421, 8432, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8505, 8508, 8511, 8517, 8521, 8526, 8526, 8544, 8584, 11264, 11310, 11312, 11358, 11360, 11492, 11499, 11507, 11520, 11557, 11559, 11559, 11565, 11565, 11568, 11623, 11631, 11631, 11647, 11670, 11680, 11686, 11688, 11694, 11696, 11702, 11704, 11710, 11712, 11718, 11720, 11726, 11728, 11734, 11736, 11742, 11744, 11775, 11823, 11823, 12293, 12295, 12321, 12335, 12337, 12341, 12344, 12348, 12353, 12438, 12441, 12442, 12445, 12447, 12449, 12538, 12540, 12543, 12549, 12589, 12593, 12686, 12704, 12730, 12784, 12799, 13312, 19893, 19968, 40908, 40960, 42124, 42192, 42237, 42240, 42508, 42512, 42539, 42560, 42607, 42612, 42621, 42623, 42647, 42655, 42737, 42775, 42783, 42786, 42888, 42891, 42894, 42896, 42899, 42912, 42922, 43000, 43047, 43072, 43123, 43136, 43204, 43216, 43225, 43232, 43255, 43259, 43259, 43264, 43309, 43312, 43347, 43360, 43388, 43392, 43456, 43471, 43481, 43520, 43574, 43584, 43597, 43600, 43609, 43616, 43638, 43642, 43643, 43648, 43714, 43739, 43741, 43744, 43759, 43762, 43766, 43777, 43782, 43785, 43790, 43793, 43798, 43808, 43814, 43816, 43822, 43968, 44010, 44012, 44013, 44016, 44025, 44032, 55203, 55216, 55238, 55243, 55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275, 64279, 64285, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65024, 65039, 65056, 65062, 65075, 65076, 65101, 65103, 65136, 65140, 65142, 65276, 65296, 65305, 65313, 65338, 65343, 65343, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500,];
    var unicodeESNextIdentifierStart = [65, 90, 97, 122, 170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 705, 710, 721, 736, 740, 748, 748, 750, 750, 880, 884, 886, 887, 890, 893, 895, 895, 902, 902, 904, 906, 908, 908, 910, 929, 931, 1013, 1015, 1153, 1162, 1327, 1329, 1366, 1369, 1369, 1376, 1416, 1488, 1514, 1519, 1522, 1568, 1610, 1646, 1647, 1649, 1747, 1749, 1749, 1765, 1766, 1774, 1775, 1786, 1788, 1791, 1791, 1808, 1808, 1810, 1839, 1869, 1957, 1969, 1969, 1994, 2026, 2036, 2037, 2042, 2042, 2048, 2069, 2074, 2074, 2084, 2084, 2088, 2088, 2112, 2136, 2144, 2154, 2208, 2228, 2230, 2237, 2308, 2361, 2365, 2365, 2384, 2384, 2392, 2401, 2417, 2432, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2493, 2493, 2510, 2510, 2524, 2525, 2527, 2529, 2544, 2545, 2556, 2556, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2649, 2652, 2654, 2654, 2674, 2676, 2693, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2749, 2749, 2768, 2768, 2784, 2785, 2809, 2809, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2869, 2873, 2877, 2877, 2908, 2909, 2911, 2913, 2929, 2929, 2947, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 3001, 3024, 3024, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3129, 3133, 3133, 3160, 3162, 3168, 3169, 3200, 3200, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3261, 3261, 3294, 3294, 3296, 3297, 3313, 3314, 3333, 3340, 3342, 3344, 3346, 3386, 3389, 3389, 3406, 3406, 3412, 3414, 3423, 3425, 3450, 3455, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3585, 3632, 3634, 3635, 3648, 3654, 3713, 3714, 3716, 3716, 3718, 3722, 3724, 3747, 3749, 3749, 3751, 3760, 3762, 3763, 3773, 3773, 3776, 3780, 3782, 3782, 3804, 3807, 3840, 3840, 3904, 3911, 3913, 3948, 3976, 3980, 4096, 4138, 4159, 4159, 4176, 4181, 4186, 4189, 4193, 4193, 4197, 4198, 4206, 4208, 4213, 4225, 4238, 4238, 4256, 4293, 4295, 4295, 4301, 4301, 4304, 4346, 4348, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4744, 4746, 4749, 4752, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4822, 4824, 4880, 4882, 4885, 4888, 4954, 4992, 5007, 5024, 5109, 5112, 5117, 5121, 5740, 5743, 5759, 5761, 5786, 5792, 5866, 5870, 5880, 5888, 5900, 5902, 5905, 5920, 5937, 5952, 5969, 5984, 5996, 5998, 6000, 6016, 6067, 6103, 6103, 6108, 6108, 6176, 6264, 6272, 6312, 6314, 6314, 6320, 6389, 6400, 6430, 6480, 6509, 6512, 6516, 6528, 6571, 6576, 6601, 6656, 6678, 6688, 6740, 6823, 6823, 6917, 6963, 6981, 6987, 7043, 7072, 7086, 7087, 7098, 7141, 7168, 7203, 7245, 7247, 7258, 7293, 7296, 7304, 7312, 7354, 7357, 7359, 7401, 7404, 7406, 7411, 7413, 7414, 7418, 7418, 7424, 7615, 7680, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8305, 8305, 8319, 8319, 8336, 8348, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8472, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8505, 8508, 8511, 8517, 8521, 8526, 8526, 8544, 8584, 11264, 11310, 11312, 11358, 11360, 11492, 11499, 11502, 11506, 11507, 11520, 11557, 11559, 11559, 11565, 11565, 11568, 11623, 11631, 11631, 11648, 11670, 11680, 11686, 11688, 11694, 11696, 11702, 11704, 11710, 11712, 11718, 11720, 11726, 11728, 11734, 11736, 11742, 12293, 12295, 12321, 12329, 12337, 12341, 12344, 12348, 12353, 12438, 12443, 12447, 12449, 12538, 12540, 12543, 12549, 12591, 12593, 12686, 12704, 12730, 12784, 12799, 13312, 19893, 19968, 40943, 40960, 42124, 42192, 42237, 42240, 42508, 42512, 42527, 42538, 42539, 42560, 42606, 42623, 42653, 42656, 42735, 42775, 42783, 42786, 42888, 42891, 42943, 42946, 42950, 42999, 43009, 43011, 43013, 43015, 43018, 43020, 43042, 43072, 43123, 43138, 43187, 43250, 43255, 43259, 43259, 43261, 43262, 43274, 43301, 43312, 43334, 43360, 43388, 43396, 43442, 43471, 43471, 43488, 43492, 43494, 43503, 43514, 43518, 43520, 43560, 43584, 43586, 43588, 43595, 43616, 43638, 43642, 43642, 43646, 43695, 43697, 43697, 43701, 43702, 43705, 43709, 43712, 43712, 43714, 43714, 43739, 43741, 43744, 43754, 43762, 43764, 43777, 43782, 43785, 43790, 43793, 43798, 43808, 43814, 43816, 43822, 43824, 43866, 43868, 43879, 43888, 44002, 44032, 55203, 55216, 55238, 55243, 55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275, 64279, 64285, 64285, 64287, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65136, 65140, 65142, 65276, 65313, 65338, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500, 65536, 65547, 65549, 65574, 65576, 65594, 65596, 65597, 65599, 65613, 65616, 65629, 65664, 65786, 65856, 65908, 66176, 66204, 66208, 66256, 66304, 66335, 66349, 66378, 66384, 66421, 66432, 66461, 66464, 66499, 66504, 66511, 66513, 66517, 66560, 66717, 66736, 66771, 66776, 66811, 66816, 66855, 66864, 66915, 67072, 67382, 67392, 67413, 67424, 67431, 67584, 67589, 67592, 67592, 67594, 67637, 67639, 67640, 67644, 67644, 67647, 67669, 67680, 67702, 67712, 67742, 67808, 67826, 67828, 67829, 67840, 67861, 67872, 67897, 67968, 68023, 68030, 68031, 68096, 68096, 68112, 68115, 68117, 68119, 68121, 68149, 68192, 68220, 68224, 68252, 68288, 68295, 68297, 68324, 68352, 68405, 68416, 68437, 68448, 68466, 68480, 68497, 68608, 68680, 68736, 68786, 68800, 68850, 68864, 68899, 69376, 69404, 69415, 69415, 69424, 69445, 69600, 69622, 69635, 69687, 69763, 69807, 69840, 69864, 69891, 69926, 69956, 69956, 69968, 70002, 70006, 70006, 70019, 70066, 70081, 70084, 70106, 70106, 70108, 70108, 70144, 70161, 70163, 70187, 70272, 70278, 70280, 70280, 70282, 70285, 70287, 70301, 70303, 70312, 70320, 70366, 70405, 70412, 70415, 70416, 70419, 70440, 70442, 70448, 70450, 70451, 70453, 70457, 70461, 70461, 70480, 70480, 70493, 70497, 70656, 70708, 70727, 70730, 70751, 70751, 70784, 70831, 70852, 70853, 70855, 70855, 71040, 71086, 71128, 71131, 71168, 71215, 71236, 71236, 71296, 71338, 71352, 71352, 71424, 71450, 71680, 71723, 71840, 71903, 71935, 71935, 72096, 72103, 72106, 72144, 72161, 72161, 72163, 72163, 72192, 72192, 72203, 72242, 72250, 72250, 72272, 72272, 72284, 72329, 72349, 72349, 72384, 72440, 72704, 72712, 72714, 72750, 72768, 72768, 72818, 72847, 72960, 72966, 72968, 72969, 72971, 73008, 73030, 73030, 73056, 73061, 73063, 73064, 73066, 73097, 73112, 73112, 73440, 73458, 73728, 74649, 74752, 74862, 74880, 75075, 77824, 78894, 82944, 83526, 92160, 92728, 92736, 92766, 92880, 92909, 92928, 92975, 92992, 92995, 93027, 93047, 93053, 93071, 93760, 93823, 93952, 94026, 94032, 94032, 94099, 94111, 94176, 94177, 94179, 94179, 94208, 100343, 100352, 101106, 110592, 110878, 110928, 110930, 110948, 110951, 110960, 111355, 113664, 113770, 113776, 113788, 113792, 113800, 113808, 113817, 119808, 119892, 119894, 119964, 119966, 119967, 119970, 119970, 119973, 119974, 119977, 119980, 119982, 119993, 119995, 119995, 119997, 120003, 120005, 120069, 120071, 120074, 120077, 120084, 120086, 120092, 120094, 120121, 120123, 120126, 120128, 120132, 120134, 120134, 120138, 120144, 120146, 120485, 120488, 120512, 120514, 120538, 120540, 120570, 120572, 120596, 120598, 120628, 120630, 120654, 120656, 120686, 120688, 120712, 120714, 120744, 120746, 120770, 120772, 120779, 123136, 123180, 123191, 123197, 123214, 123214, 123584, 123627, 124928, 125124, 125184, 125251, 125259, 125259, 126464, 126467, 126469, 126495, 126497, 126498, 126500, 126500, 126503, 126503, 126505, 126514, 126516, 126519, 126521, 126521, 126523, 126523, 126530, 126530, 126535, 126535, 126537, 126537, 126539, 126539, 126541, 126543, 126545, 126546, 126548, 126548, 126551, 126551, 126553, 126553, 126555, 126555, 126557, 126557, 126559, 126559, 126561, 126562, 126564, 126564, 126567, 126570, 126572, 126578, 126580, 126583, 126585, 126588, 126590, 126590, 126592, 126601, 126603, 126619, 126625, 126627, 126629, 126633, 126635, 126651, 131072, 173782, 173824, 177972, 177984, 178205, 178208, 183969, 183984, 191456, 194560, 195101];
    var unicodeESNextIdentifierPart = [48, 57, 65, 90, 95, 95, 97, 122, 170, 170, 181, 181, 183, 183, 186, 186, 192, 214, 216, 246, 248, 705, 710, 721, 736, 740, 748, 748, 750, 750, 768, 884, 886, 887, 890, 893, 895, 895, 902, 906, 908, 908, 910, 929, 931, 1013, 1015, 1153, 1155, 1159, 1162, 1327, 1329, 1366, 1369, 1369, 1376, 1416, 1425, 1469, 1471, 1471, 1473, 1474, 1476, 1477, 1479, 1479, 1488, 1514, 1519, 1522, 1552, 1562, 1568, 1641, 1646, 1747, 1749, 1756, 1759, 1768, 1770, 1788, 1791, 1791, 1808, 1866, 1869, 1969, 1984, 2037, 2042, 2042, 2045, 2045, 2048, 2093, 2112, 2139, 2144, 2154, 2208, 2228, 2230, 2237, 2259, 2273, 2275, 2403, 2406, 2415, 2417, 2435, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2492, 2500, 2503, 2504, 2507, 2510, 2519, 2519, 2524, 2525, 2527, 2531, 2534, 2545, 2556, 2556, 2558, 2558, 2561, 2563, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2620, 2620, 2622, 2626, 2631, 2632, 2635, 2637, 2641, 2641, 2649, 2652, 2654, 2654, 2662, 2677, 2689, 2691, 2693, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2748, 2757, 2759, 2761, 2763, 2765, 2768, 2768, 2784, 2787, 2790, 2799, 2809, 2815, 2817, 2819, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2869, 2873, 2876, 2884, 2887, 2888, 2891, 2893, 2902, 2903, 2908, 2909, 2911, 2915, 2918, 2927, 2929, 2929, 2946, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 3001, 3006, 3010, 3014, 3016, 3018, 3021, 3024, 3024, 3031, 3031, 3046, 3055, 3072, 3084, 3086, 3088, 3090, 3112, 3114, 3129, 3133, 3140, 3142, 3144, 3146, 3149, 3157, 3158, 3160, 3162, 3168, 3171, 3174, 3183, 3200, 3203, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3260, 3268, 3270, 3272, 3274, 3277, 3285, 3286, 3294, 3294, 3296, 3299, 3302, 3311, 3313, 3314, 3328, 3331, 3333, 3340, 3342, 3344, 3346, 3396, 3398, 3400, 3402, 3406, 3412, 3415, 3423, 3427, 3430, 3439, 3450, 3455, 3458, 3459, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3530, 3530, 3535, 3540, 3542, 3542, 3544, 3551, 3558, 3567, 3570, 3571, 3585, 3642, 3648, 3662, 3664, 3673, 3713, 3714, 3716, 3716, 3718, 3722, 3724, 3747, 3749, 3749, 3751, 3773, 3776, 3780, 3782, 3782, 3784, 3789, 3792, 3801, 3804, 3807, 3840, 3840, 3864, 3865, 3872, 3881, 3893, 3893, 3895, 3895, 3897, 3897, 3902, 3911, 3913, 3948, 3953, 3972, 3974, 3991, 3993, 4028, 4038, 4038, 4096, 4169, 4176, 4253, 4256, 4293, 4295, 4295, 4301, 4301, 4304, 4346, 4348, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4744, 4746, 4749, 4752, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4822, 4824, 4880, 4882, 4885, 4888, 4954, 4957, 4959, 4969, 4977, 4992, 5007, 5024, 5109, 5112, 5117, 5121, 5740, 5743, 5759, 5761, 5786, 5792, 5866, 5870, 5880, 5888, 5900, 5902, 5908, 5920, 5940, 5952, 5971, 5984, 5996, 5998, 6000, 6002, 6003, 6016, 6099, 6103, 6103, 6108, 6109, 6112, 6121, 6155, 6157, 6160, 6169, 6176, 6264, 6272, 6314, 6320, 6389, 6400, 6430, 6432, 6443, 6448, 6459, 6470, 6509, 6512, 6516, 6528, 6571, 6576, 6601, 6608, 6618, 6656, 6683, 6688, 6750, 6752, 6780, 6783, 6793, 6800, 6809, 6823, 6823, 6832, 6845, 6912, 6987, 6992, 7001, 7019, 7027, 7040, 7155, 7168, 7223, 7232, 7241, 7245, 7293, 7296, 7304, 7312, 7354, 7357, 7359, 7376, 7378, 7380, 7418, 7424, 7673, 7675, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8255, 8256, 8276, 8276, 8305, 8305, 8319, 8319, 8336, 8348, 8400, 8412, 8417, 8417, 8421, 8432, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8472, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8505, 8508, 8511, 8517, 8521, 8526, 8526, 8544, 8584, 11264, 11310, 11312, 11358, 11360, 11492, 11499, 11507, 11520, 11557, 11559, 11559, 11565, 11565, 11568, 11623, 11631, 11631, 11647, 11670, 11680, 11686, 11688, 11694, 11696, 11702, 11704, 11710, 11712, 11718, 11720, 11726, 11728, 11734, 11736, 11742, 11744, 11775, 12293, 12295, 12321, 12335, 12337, 12341, 12344, 12348, 12353, 12438, 12441, 12447, 12449, 12538, 12540, 12543, 12549, 12591, 12593, 12686, 12704, 12730, 12784, 12799, 13312, 19893, 19968, 40943, 40960, 42124, 42192, 42237, 42240, 42508, 42512, 42539, 42560, 42607, 42612, 42621, 42623, 42737, 42775, 42783, 42786, 42888, 42891, 42943, 42946, 42950, 42999, 43047, 43072, 43123, 43136, 43205, 43216, 43225, 43232, 43255, 43259, 43259, 43261, 43309, 43312, 43347, 43360, 43388, 43392, 43456, 43471, 43481, 43488, 43518, 43520, 43574, 43584, 43597, 43600, 43609, 43616, 43638, 43642, 43714, 43739, 43741, 43744, 43759, 43762, 43766, 43777, 43782, 43785, 43790, 43793, 43798, 43808, 43814, 43816, 43822, 43824, 43866, 43868, 43879, 43888, 44010, 44012, 44013, 44016, 44025, 44032, 55203, 55216, 55238, 55243, 55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275, 64279, 64285, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65024, 65039, 65056, 65071, 65075, 65076, 65101, 65103, 65136, 65140, 65142, 65276, 65296, 65305, 65313, 65338, 65343, 65343, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500, 65536, 65547, 65549, 65574, 65576, 65594, 65596, 65597, 65599, 65613, 65616, 65629, 65664, 65786, 65856, 65908, 66045, 66045, 66176, 66204, 66208, 66256, 66272, 66272, 66304, 66335, 66349, 66378, 66384, 66426, 66432, 66461, 66464, 66499, 66504, 66511, 66513, 66517, 66560, 66717, 66720, 66729, 66736, 66771, 66776, 66811, 66816, 66855, 66864, 66915, 67072, 67382, 67392, 67413, 67424, 67431, 67584, 67589, 67592, 67592, 67594, 67637, 67639, 67640, 67644, 67644, 67647, 67669, 67680, 67702, 67712, 67742, 67808, 67826, 67828, 67829, 67840, 67861, 67872, 67897, 67968, 68023, 68030, 68031, 68096, 68099, 68101, 68102, 68108, 68115, 68117, 68119, 68121, 68149, 68152, 68154, 68159, 68159, 68192, 68220, 68224, 68252, 68288, 68295, 68297, 68326, 68352, 68405, 68416, 68437, 68448, 68466, 68480, 68497, 68608, 68680, 68736, 68786, 68800, 68850, 68864, 68903, 68912, 68921, 69376, 69404, 69415, 69415, 69424, 69456, 69600, 69622, 69632, 69702, 69734, 69743, 69759, 69818, 69840, 69864, 69872, 69881, 69888, 69940, 69942, 69951, 69956, 69958, 69968, 70003, 70006, 70006, 70016, 70084, 70089, 70092, 70096, 70106, 70108, 70108, 70144, 70161, 70163, 70199, 70206, 70206, 70272, 70278, 70280, 70280, 70282, 70285, 70287, 70301, 70303, 70312, 70320, 70378, 70384, 70393, 70400, 70403, 70405, 70412, 70415, 70416, 70419, 70440, 70442, 70448, 70450, 70451, 70453, 70457, 70459, 70468, 70471, 70472, 70475, 70477, 70480, 70480, 70487, 70487, 70493, 70499, 70502, 70508, 70512, 70516, 70656, 70730, 70736, 70745, 70750, 70751, 70784, 70853, 70855, 70855, 70864, 70873, 71040, 71093, 71096, 71104, 71128, 71133, 71168, 71232, 71236, 71236, 71248, 71257, 71296, 71352, 71360, 71369, 71424, 71450, 71453, 71467, 71472, 71481, 71680, 71738, 71840, 71913, 71935, 71935, 72096, 72103, 72106, 72151, 72154, 72161, 72163, 72164, 72192, 72254, 72263, 72263, 72272, 72345, 72349, 72349, 72384, 72440, 72704, 72712, 72714, 72758, 72760, 72768, 72784, 72793, 72818, 72847, 72850, 72871, 72873, 72886, 72960, 72966, 72968, 72969, 72971, 73014, 73018, 73018, 73020, 73021, 73023, 73031, 73040, 73049, 73056, 73061, 73063, 73064, 73066, 73102, 73104, 73105, 73107, 73112, 73120, 73129, 73440, 73462, 73728, 74649, 74752, 74862, 74880, 75075, 77824, 78894, 82944, 83526, 92160, 92728, 92736, 92766, 92768, 92777, 92880, 92909, 92912, 92916, 92928, 92982, 92992, 92995, 93008, 93017, 93027, 93047, 93053, 93071, 93760, 93823, 93952, 94026, 94031, 94087, 94095, 94111, 94176, 94177, 94179, 94179, 94208, 100343, 100352, 101106, 110592, 110878, 110928, 110930, 110948, 110951, 110960, 111355, 113664, 113770, 113776, 113788, 113792, 113800, 113808, 113817, 113821, 113822, 119141, 119145, 119149, 119154, 119163, 119170, 119173, 119179, 119210, 119213, 119362, 119364, 119808, 119892, 119894, 119964, 119966, 119967, 119970, 119970, 119973, 119974, 119977, 119980, 119982, 119993, 119995, 119995, 119997, 120003, 120005, 120069, 120071, 120074, 120077, 120084, 120086, 120092, 120094, 120121, 120123, 120126, 120128, 120132, 120134, 120134, 120138, 120144, 120146, 120485, 120488, 120512, 120514, 120538, 120540, 120570, 120572, 120596, 120598, 120628, 120630, 120654, 120656, 120686, 120688, 120712, 120714, 120744, 120746, 120770, 120772, 120779, 120782, 120831, 121344, 121398, 121403, 121452, 121461, 121461, 121476, 121476, 121499, 121503, 121505, 121519, 122880, 122886, 122888, 122904, 122907, 122913, 122915, 122916, 122918, 122922, 123136, 123180, 123184, 123197, 123200, 123209, 123214, 123214, 123584, 123641, 124928, 125124, 125136, 125142, 125184, 125259, 125264, 125273, 126464, 126467, 126469, 126495, 126497, 126498, 126500, 126500, 126503, 126503, 126505, 126514, 126516, 126519, 126521, 126521, 126523, 126523, 126530, 126530, 126535, 126535, 126537, 126537, 126539, 126539, 126541, 126543, 126545, 126546, 126548, 126548, 126551, 126551, 126553, 126553, 126555, 126555, 126557, 126557, 126559, 126559, 126561, 126562, 126564, 126564, 126567, 126570, 126572, 126578, 126580, 126583, 126585, 126588, 126590, 126590, 126592, 126601, 126603, 126619, 126625, 126627, 126629, 126633, 126635, 126651, 131072, 173782, 173824, 177972, 177984, 178205, 178208, 183969, 183984, 191456, 194560, 195101, 917760, 917999];
    var commentDirectiveRegExSingleLine = /^\/\/\/?\s*@(ts-expect-error|ts-ignore)/;
    var commentDirectiveRegExMultiLine = /^(?:\/|\*)*\s*@(ts-expect-error|ts-ignore)/;
    function lookupInUnicodeMap(code, map) {
        if (code < map[0]) {
            return false;
        }
        var lo = 0;
        var hi = map.length;
        var mid;
        while (lo + 1 < hi) {
            mid = lo + (hi - lo) / 2;
            mid -= mid % 2;
            if (map[mid] <= code && code <= map[mid + 1]) {
                return true;
            }
            if (code < map[mid]) {
                hi = mid;
            }
            else {
                lo = mid + 2;
            }
        }
        return false;
    }
    function isUnicodeIdentifierStart(code, languageVersion) {
        return languageVersion >= 2 ?
            lookupInUnicodeMap(code, unicodeESNextIdentifierStart) :
            languageVersion === 1 ? lookupInUnicodeMap(code, unicodeES5IdentifierStart) :
                lookupInUnicodeMap(code, unicodeES3IdentifierStart);
    }
    ts.isUnicodeIdentifierStart = isUnicodeIdentifierStart;
    function isUnicodeIdentifierPart(code, languageVersion) {
        return languageVersion >= 2 ?
            lookupInUnicodeMap(code, unicodeESNextIdentifierPart) :
            languageVersion === 1 ? lookupInUnicodeMap(code, unicodeES5IdentifierPart) :
                lookupInUnicodeMap(code, unicodeES3IdentifierPart);
    }
    function makeReverseMap(source) {
        var result = [];
        source.forEach(function (value, name) {
            result[value] = name;
        });
        return result;
    }
    var tokenStrings = makeReverseMap(textToToken);
    function tokenToString(t) {
        return tokenStrings[t];
    }
    ts.tokenToString = tokenToString;
    function stringToToken(s) {
        return textToToken.get(s);
    }
    ts.stringToToken = stringToToken;
    function computeLineStarts(text) {
        var result = new Array();
        var pos = 0;
        var lineStart = 0;
        while (pos < text.length) {
            var ch = text.charCodeAt(pos);
            pos++;
            switch (ch) {
                case 13:
                    if (text.charCodeAt(pos) === 10) {
                        pos++;
                    }
                case 10:
                    result.push(lineStart);
                    lineStart = pos;
                    break;
                default:
                    if (ch > 127 && isLineBreak(ch)) {
                        result.push(lineStart);
                        lineStart = pos;
                    }
                    break;
            }
        }
        result.push(lineStart);
        return result;
    }
    ts.computeLineStarts = computeLineStarts;
    function getPositionOfLineAndCharacter(sourceFile, line, character, allowEdits) {
        return sourceFile.getPositionOfLineAndCharacter ?
            sourceFile.getPositionOfLineAndCharacter(line, character, allowEdits) :
            computePositionOfLineAndCharacter(getLineStarts(sourceFile), line, character, sourceFile.text, allowEdits);
    }
    ts.getPositionOfLineAndCharacter = getPositionOfLineAndCharacter;
    function computePositionOfLineAndCharacter(lineStarts, line, character, debugText, allowEdits) {
        if (line < 0 || line >= lineStarts.length) {
            if (allowEdits) {
                line = line < 0 ? 0 : line >= lineStarts.length ? lineStarts.length - 1 : line;
            }
            else {
                ts.Debug.fail("Bad line number. Line: ".concat(line, ", lineStarts.length: ").concat(lineStarts.length, " , line map is correct? ").concat(debugText !== undefined ? ts.arraysEqual(lineStarts, computeLineStarts(debugText)) : "unknown"));
            }
        }
        var res = lineStarts[line] + character;
        if (allowEdits) {
            return res > lineStarts[line + 1] ? lineStarts[line + 1] : typeof debugText === "string" && res > debugText.length ? debugText.length : res;
        }
        if (line < lineStarts.length - 1) {
            ts.Debug.assert(res < lineStarts[line + 1]);
        }
        else if (debugText !== undefined) {
            ts.Debug.assert(res <= debugText.length);
        }
        return res;
    }
    ts.computePositionOfLineAndCharacter = computePositionOfLineAndCharacter;
    function getLineStarts(sourceFile) {
        return sourceFile.lineMap || (sourceFile.lineMap = computeLineStarts(sourceFile.text));
    }
    ts.getLineStarts = getLineStarts;
    function computeLineAndCharacterOfPosition(lineStarts, position) {
        var lineNumber = computeLineOfPosition(lineStarts, position);
        return {
            line: lineNumber,
            character: position - lineStarts[lineNumber]
        };
    }
    ts.computeLineAndCharacterOfPosition = computeLineAndCharacterOfPosition;
    function computeLineOfPosition(lineStarts, position, lowerBound) {
        var lineNumber = ts.binarySearch(lineStarts, position, ts.identity, ts.compareValues, lowerBound);
        if (lineNumber < 0) {
            lineNumber = ~lineNumber - 1;
            ts.Debug.assert(lineNumber !== -1, "position cannot precede the beginning of the file");
        }
        return lineNumber;
    }
    ts.computeLineOfPosition = computeLineOfPosition;
    function getLinesBetweenPositions(sourceFile, pos1, pos2) {
        if (pos1 === pos2)
            return 0;
        var lineStarts = getLineStarts(sourceFile);
        var lower = Math.min(pos1, pos2);
        var isNegative = lower === pos2;
        var upper = isNegative ? pos1 : pos2;
        var lowerLine = computeLineOfPosition(lineStarts, lower);
        var upperLine = computeLineOfPosition(lineStarts, upper, lowerLine);
        return isNegative ? lowerLine - upperLine : upperLine - lowerLine;
    }
    ts.getLinesBetweenPositions = getLinesBetweenPositions;
    function getLineAndCharacterOfPosition(sourceFile, position) {
        return computeLineAndCharacterOfPosition(getLineStarts(sourceFile), position);
    }
    ts.getLineAndCharacterOfPosition = getLineAndCharacterOfPosition;
    function isWhiteSpaceLike(ch) {
        return isWhiteSpaceSingleLine(ch) || isLineBreak(ch);
    }
    ts.isWhiteSpaceLike = isWhiteSpaceLike;
    function isWhiteSpaceSingleLine(ch) {
        return ch === 32 ||
            ch === 9 ||
            ch === 11 ||
            ch === 12 ||
            ch === 160 ||
            ch === 133 ||
            ch === 5760 ||
            ch >= 8192 && ch <= 8203 ||
            ch === 8239 ||
            ch === 8287 ||
            ch === 12288 ||
            ch === 65279;
    }
    ts.isWhiteSpaceSingleLine = isWhiteSpaceSingleLine;
    function isLineBreak(ch) {
        return ch === 10 ||
            ch === 13 ||
            ch === 8232 ||
            ch === 8233;
    }
    ts.isLineBreak = isLineBreak;
    function isDigit(ch) {
        return ch >= 48 && ch <= 57;
    }
    function isHexDigit(ch) {
        return isDigit(ch) || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102;
    }
    function isCodePoint(code) {
        return code <= 0x10FFFF;
    }
    function isOctalDigit(ch) {
        return ch >= 48 && ch <= 55;
    }
    ts.isOctalDigit = isOctalDigit;
    function couldStartTrivia(text, pos) {
        var ch = text.charCodeAt(pos);
        switch (ch) {
            case 13:
            case 10:
            case 9:
            case 11:
            case 12:
            case 32:
            case 47:
            case 60:
            case 124:
            case 61:
            case 62:
                return true;
            case 35:
                return pos === 0;
            default:
                return ch > 127;
        }
    }
    ts.couldStartTrivia = couldStartTrivia;
    function skipTrivia(text, pos, stopAfterLineBreak, stopAtComments, inJSDoc) {
        if (ts.positionIsSynthesized(pos)) {
            return pos;
        }
        var canConsumeStar = false;
        while (true) {
            var ch = text.charCodeAt(pos);
            switch (ch) {
                case 13:
                    if (text.charCodeAt(pos + 1) === 10) {
                        pos++;
                    }
                case 10:
                    pos++;
                    if (stopAfterLineBreak) {
                        return pos;
                    }
                    canConsumeStar = !!inJSDoc;
                    continue;
                case 9:
                case 11:
                case 12:
                case 32:
                    pos++;
                    continue;
                case 47:
                    if (stopAtComments) {
                        break;
                    }
                    if (text.charCodeAt(pos + 1) === 47) {
                        pos += 2;
                        while (pos < text.length) {
                            if (isLineBreak(text.charCodeAt(pos))) {
                                break;
                            }
                            pos++;
                        }
                        canConsumeStar = false;
                        continue;
                    }
                    if (text.charCodeAt(pos + 1) === 42) {
                        pos += 2;
                        while (pos < text.length) {
                            if (text.charCodeAt(pos) === 42 && text.charCodeAt(pos + 1) === 47) {
                                pos += 2;
                                break;
                            }
                            pos++;
                        }
                        canConsumeStar = false;
                        continue;
                    }
                    break;
                case 60:
                case 124:
                case 61:
                case 62:
                    if (isConflictMarkerTrivia(text, pos)) {
                        pos = scanConflictMarkerTrivia(text, pos);
                        canConsumeStar = false;
                        continue;
                    }
                    break;
                case 35:
                    if (pos === 0 && isShebangTrivia(text, pos)) {
                        pos = scanShebangTrivia(text, pos);
                        canConsumeStar = false;
                        continue;
                    }
                    break;
                case 42:
                    if (canConsumeStar) {
                        pos++;
                        canConsumeStar = false;
                        continue;
                    }
                    break;
                default:
                    if (ch > 127 && (isWhiteSpaceLike(ch))) {
                        pos++;
                        continue;
                    }
                    break;
            }
            return pos;
        }
    }
    ts.skipTrivia = skipTrivia;
    var mergeConflictMarkerLength = "<<<<<<<".length;
    function isConflictMarkerTrivia(text, pos) {
        ts.Debug.assert(pos >= 0);
        if (pos === 0 || isLineBreak(text.charCodeAt(pos - 1))) {
            var ch = text.charCodeAt(pos);
            if ((pos + mergeConflictMarkerLength) < text.length) {
                for (var i = 0; i < mergeConflictMarkerLength; i++) {
                    if (text.charCodeAt(pos + i) !== ch) {
                        return false;
                    }
                }
                return ch === 61 ||
                    text.charCodeAt(pos + mergeConflictMarkerLength) === 32;
            }
        }
        return false;
    }
    function scanConflictMarkerTrivia(text, pos, error) {
        if (error) {
            error(ts.Diagnostics.Merge_conflict_marker_encountered, pos, mergeConflictMarkerLength);
        }
        var ch = text.charCodeAt(pos);
        var len = text.length;
        if (ch === 60 || ch === 62) {
            while (pos < len && !isLineBreak(text.charCodeAt(pos))) {
                pos++;
            }
        }
        else {
            ts.Debug.assert(ch === 124 || ch === 61);
            while (pos < len) {
                var currentChar = text.charCodeAt(pos);
                if ((currentChar === 61 || currentChar === 62) && currentChar !== ch && isConflictMarkerTrivia(text, pos)) {
                    break;
                }
                pos++;
            }
        }
        return pos;
    }
    var shebangTriviaRegex = /^#!.*/;
    function isShebangTrivia(text, pos) {
        ts.Debug.assert(pos === 0);
        return shebangTriviaRegex.test(text);
    }
    ts.isShebangTrivia = isShebangTrivia;
    function scanShebangTrivia(text, pos) {
        var shebang = shebangTriviaRegex.exec(text)[0];
        pos = pos + shebang.length;
        return pos;
    }
    ts.scanShebangTrivia = scanShebangTrivia;
    function iterateCommentRanges(reduce, text, pos, trailing, cb, state, initial) {
        var pendingPos;
        var pendingEnd;
        var pendingKind;
        var pendingHasTrailingNewLine;
        var hasPendingCommentRange = false;
        var collecting = trailing;
        var accumulator = initial;
        if (pos === 0) {
            collecting = true;
            var shebang = getShebang(text);
            if (shebang) {
                pos = shebang.length;
            }
        }
        scan: while (pos >= 0 && pos < text.length) {
            var ch = text.charCodeAt(pos);
            switch (ch) {
                case 13:
                    if (text.charCodeAt(pos + 1) === 10) {
                        pos++;
                    }
                case 10:
                    pos++;
                    if (trailing) {
                        break scan;
                    }
                    collecting = true;
                    if (hasPendingCommentRange) {
                        pendingHasTrailingNewLine = true;
                    }
                    continue;
                case 9:
                case 11:
                case 12:
                case 32:
                    pos++;
                    continue;
                case 47:
                    var nextChar = text.charCodeAt(pos + 1);
                    var hasTrailingNewLine = false;
                    if (nextChar === 47 || nextChar === 42) {
                        var kind = nextChar === 47 ? 2 : 3;
                        var startPos = pos;
                        pos += 2;
                        if (nextChar === 47) {
                            while (pos < text.length) {
                                if (isLineBreak(text.charCodeAt(pos))) {
                                    hasTrailingNewLine = true;
                                    break;
                                }
                                pos++;
                            }
                        }
                        else {
                            while (pos < text.length) {
                                if (text.charCodeAt(pos) === 42 && text.charCodeAt(pos + 1) === 47) {
                                    pos += 2;
                                    break;
                                }
                                pos++;
                            }
                        }
                        if (collecting) {
                            if (hasPendingCommentRange) {
                                accumulator = cb(pendingPos, pendingEnd, pendingKind, pendingHasTrailingNewLine, state, accumulator);
                                if (!reduce && accumulator) {
                                    return accumulator;
                                }
                            }
                            pendingPos = startPos;
                            pendingEnd = pos;
                            pendingKind = kind;
                            pendingHasTrailingNewLine = hasTrailingNewLine;
                            hasPendingCommentRange = true;
                        }
                        continue;
                    }
                    break scan;
                default:
                    if (ch > 127 && (isWhiteSpaceLike(ch))) {
                        if (hasPendingCommentRange && isLineBreak(ch)) {
                            pendingHasTrailingNewLine = true;
                        }
                        pos++;
                        continue;
                    }
                    break scan;
            }
        }
        if (hasPendingCommentRange) {
            accumulator = cb(pendingPos, pendingEnd, pendingKind, pendingHasTrailingNewLine, state, accumulator);
        }
        return accumulator;
    }
    function forEachLeadingCommentRange(text, pos, cb, state) {
        return iterateCommentRanges(false, text, pos, false, cb, state);
    }
    ts.forEachLeadingCommentRange = forEachLeadingCommentRange;
    function forEachTrailingCommentRange(text, pos, cb, state) {
        return iterateCommentRanges(false, text, pos, true, cb, state);
    }
    ts.forEachTrailingCommentRange = forEachTrailingCommentRange;
    function reduceEachLeadingCommentRange(text, pos, cb, state, initial) {
        return iterateCommentRanges(true, text, pos, false, cb, state, initial);
    }
    ts.reduceEachLeadingCommentRange = reduceEachLeadingCommentRange;
    function reduceEachTrailingCommentRange(text, pos, cb, state, initial) {
        return iterateCommentRanges(true, text, pos, true, cb, state, initial);
    }
    ts.reduceEachTrailingCommentRange = reduceEachTrailingCommentRange;
    function appendCommentRange(pos, end, kind, hasTrailingNewLine, _state, comments) {
        if (!comments) {
            comments = [];
        }
        comments.push({ kind: kind, pos: pos, end: end, hasTrailingNewLine: hasTrailingNewLine });
        return comments;
    }
    function getLeadingCommentRanges(text, pos) {
        return reduceEachLeadingCommentRange(text, pos, appendCommentRange, undefined, undefined);
    }
    ts.getLeadingCommentRanges = getLeadingCommentRanges;
    function getTrailingCommentRanges(text, pos) {
        return reduceEachTrailingCommentRange(text, pos, appendCommentRange, undefined, undefined);
    }
    ts.getTrailingCommentRanges = getTrailingCommentRanges;
    function getShebang(text) {
        var match = shebangTriviaRegex.exec(text);
        if (match) {
            return match[0];
        }
    }
    ts.getShebang = getShebang;
    function isIdentifierStart(ch, languageVersion) {
        return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122 ||
            ch === 36 || ch === 95 ||
            ch > 127 && isUnicodeIdentifierStart(ch, languageVersion);
    }
    ts.isIdentifierStart = isIdentifierStart;
    function isIdentifierPart(ch, languageVersion, identifierVariant) {
        return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122 ||
            ch >= 48 && ch <= 57 || ch === 36 || ch === 95 ||
            (identifierVariant === 1 ? (ch === 45 || ch === 58) : false) ||
            ch > 127 && isUnicodeIdentifierPart(ch, languageVersion);
    }
    ts.isIdentifierPart = isIdentifierPart;
    function isIdentifierText(name, languageVersion, identifierVariant) {
        var ch = codePointAt(name, 0);
        if (!isIdentifierStart(ch, languageVersion)) {
            return false;
        }
        for (var i = charSize(ch); i < name.length; i += charSize(ch)) {
            if (!isIdentifierPart(ch = codePointAt(name, i), languageVersion, identifierVariant)) {
                return false;
            }
        }
        return true;
    }
    ts.isIdentifierText = isIdentifierText;
    function createScanner(languageVersion, skipTrivia, languageVariant, textInitial, onError, start, length) {
        if (languageVariant === void 0) { languageVariant = 0; }
        var text = textInitial;
        var pos;
        var end;
        var startPos;
        var tokenPos;
        var token;
        var tokenValue;
        var tokenFlags;
        var commentDirectives;
        var inJSDocType = 0;
        setText(text, start, length);
        var scanner = {
            getStartPos: function () { return startPos; },
            getTextPos: function () { return pos; },
            getToken: function () { return token; },
            getTokenPos: function () { return tokenPos; },
            getTokenText: function () { return text.substring(tokenPos, pos); },
            getTokenValue: function () { return tokenValue; },
            hasUnicodeEscape: function () { return (tokenFlags & 1024) !== 0; },
            hasExtendedUnicodeEscape: function () { return (tokenFlags & 8) !== 0; },
            hasPrecedingLineBreak: function () { return (tokenFlags & 1) !== 0; },
            hasPrecedingJSDocComment: function () { return (tokenFlags & 2) !== 0; },
            isIdentifier: function () { return token === 79 || token > 116; },
            isReservedWord: function () { return token >= 81 && token <= 116; },
            isUnterminated: function () { return (tokenFlags & 4) !== 0; },
            getCommentDirectives: function () { return commentDirectives; },
            getNumericLiteralFlags: function () { return tokenFlags & 1008; },
            getTokenFlags: function () { return tokenFlags; },
            reScanGreaterToken: reScanGreaterToken,
            reScanAsteriskEqualsToken: reScanAsteriskEqualsToken,
            reScanSlashToken: reScanSlashToken,
            reScanTemplateToken: reScanTemplateToken,
            reScanTemplateHeadOrNoSubstitutionTemplate: reScanTemplateHeadOrNoSubstitutionTemplate,
            scanJsxIdentifier: scanJsxIdentifier,
            scanJsxAttributeValue: scanJsxAttributeValue,
            reScanJsxAttributeValue: reScanJsxAttributeValue,
            reScanJsxToken: reScanJsxToken,
            reScanLessThanToken: reScanLessThanToken,
            reScanHashToken: reScanHashToken,
            reScanQuestionToken: reScanQuestionToken,
            reScanInvalidIdentifier: reScanInvalidIdentifier,
            scanJsxToken: scanJsxToken,
            scanJsDocToken: scanJsDocToken,
            scan: scan,
            getText: getText,
            clearCommentDirectives: clearCommentDirectives,
            setText: setText,
            setScriptTarget: setScriptTarget,
            setLanguageVariant: setLanguageVariant,
            setOnError: setOnError,
            setTextPos: setTextPos,
            setInJSDocType: setInJSDocType,
            tryScan: tryScan,
            lookAhead: lookAhead,
            scanRange: scanRange,
        };
        if (ts.Debug.isDebugging) {
            Object.defineProperty(scanner, "__debugShowCurrentPositionInText", {
                get: function () {
                    var text = scanner.getText();
                    return text.slice(0, scanner.getStartPos()) + "" + text.slice(scanner.getStartPos());
                },
            });
        }
        return scanner;
        function error(message, errPos, length) {
            if (errPos === void 0) { errPos = pos; }
            if (onError) {
                var oldPos = pos;
                pos = errPos;
                onError(message, length || 0);
                pos = oldPos;
            }
        }
        function scanNumberFragment() {
            var start = pos;
            var allowSeparator = false;
            var isPreviousTokenSeparator = false;
            var result = "";
            while (true) {
                var ch = text.charCodeAt(pos);
                if (ch === 95) {
                    tokenFlags |= 512;
                    if (allowSeparator) {
                        allowSeparator = false;
                        isPreviousTokenSeparator = true;
                        result += text.substring(start, pos);
                    }
                    else if (isPreviousTokenSeparator) {
                        error(ts.Diagnostics.Multiple_consecutive_numeric_separators_are_not_permitted, pos, 1);
                    }
                    else {
                        error(ts.Diagnostics.Numeric_separators_are_not_allowed_here, pos, 1);
                    }
                    pos++;
                    start = pos;
                    continue;
                }
                if (isDigit(ch)) {
                    allowSeparator = true;
                    isPreviousTokenSeparator = false;
                    pos++;
                    continue;
                }
                break;
            }
            if (text.charCodeAt(pos - 1) === 95) {
                error(ts.Diagnostics.Numeric_separators_are_not_allowed_here, pos - 1, 1);
            }
            return result + text.substring(start, pos);
        }
        function scanNumber() {
            var start = pos;
            var mainFragment = scanNumberFragment();
            var decimalFragment;
            var scientificFragment;
            if (text.charCodeAt(pos) === 46) {
                pos++;
                decimalFragment = scanNumberFragment();
            }
            var end = pos;
            if (text.charCodeAt(pos) === 69 || text.charCodeAt(pos) === 101) {
                pos++;
                tokenFlags |= 16;
                if (text.charCodeAt(pos) === 43 || text.charCodeAt(pos) === 45)
                    pos++;
                var preNumericPart = pos;
                var finalFragment = scanNumberFragment();
                if (!finalFragment) {
                    error(ts.Diagnostics.Digit_expected);
                }
                else {
                    scientificFragment = text.substring(end, preNumericPart) + finalFragment;
                    end = pos;
                }
            }
            var result;
            if (tokenFlags & 512) {
                result = mainFragment;
                if (decimalFragment) {
                    result += "." + decimalFragment;
                }
                if (scientificFragment) {
                    result += scientificFragment;
                }
            }
            else {
                result = text.substring(start, end);
            }
            if (decimalFragment !== undefined || tokenFlags & 16) {
                checkForIdentifierStartAfterNumericLiteral(start, decimalFragment === undefined && !!(tokenFlags & 16));
                return {
                    type: 8,
                    value: "" + +result
                };
            }
            else {
                tokenValue = result;
                var type = checkBigIntSuffix();
                checkForIdentifierStartAfterNumericLiteral(start);
                return { type: type, value: tokenValue };
            }
        }
        function checkForIdentifierStartAfterNumericLiteral(numericStart, isScientific) {
            if (!isIdentifierStart(codePointAt(text, pos), languageVersion)) {
                return;
            }
            var identifierStart = pos;
            var length = scanIdentifierParts().length;
            if (length === 1 && text[identifierStart] === "n") {
                if (isScientific) {
                    error(ts.Diagnostics.A_bigint_literal_cannot_use_exponential_notation, numericStart, identifierStart - numericStart + 1);
                }
                else {
                    error(ts.Diagnostics.A_bigint_literal_must_be_an_integer, numericStart, identifierStart - numericStart + 1);
                }
            }
            else {
                error(ts.Diagnostics.An_identifier_or_keyword_cannot_immediately_follow_a_numeric_literal, identifierStart, length);
                pos = identifierStart;
            }
        }
        function scanOctalDigits() {
            var start = pos;
            while (isOctalDigit(text.charCodeAt(pos))) {
                pos++;
            }
            return +(text.substring(start, pos));
        }
        function scanExactNumberOfHexDigits(count, canHaveSeparators) {
            var valueString = scanHexDigits(count, false, canHaveSeparators);
            return valueString ? parseInt(valueString, 16) : -1;
        }
        function scanMinimumNumberOfHexDigits(count, canHaveSeparators) {
            return scanHexDigits(count, true, canHaveSeparators);
        }
        function scanHexDigits(minCount, scanAsManyAsPossible, canHaveSeparators) {
            var valueChars = [];
            var allowSeparator = false;
            var isPreviousTokenSeparator = false;
            while (valueChars.length < minCount || scanAsManyAsPossible) {
                var ch = text.charCodeAt(pos);
                if (canHaveSeparators && ch === 95) {
                    tokenFlags |= 512;
                    if (allowSeparator) {
                        allowSeparator = false;
                        isPreviousTokenSeparator = true;
                    }
                    else if (isPreviousTokenSeparator) {
                        error(ts.Diagnostics.Multiple_consecutive_numeric_separators_are_not_permitted, pos, 1);
                    }
                    else {
                        error(ts.Diagnostics.Numeric_separators_are_not_allowed_here, pos, 1);
                    }
                    pos++;
                    continue;
                }
                allowSeparator = canHaveSeparators;
                if (ch >= 65 && ch <= 70) {
                    ch += 97 - 65;
                }
                else if (!((ch >= 48 && ch <= 57) ||
                    (ch >= 97 && ch <= 102))) {
                    break;
                }
                valueChars.push(ch);
                pos++;
                isPreviousTokenSeparator = false;
            }
            if (valueChars.length < minCount) {
                valueChars = [];
            }
            if (text.charCodeAt(pos - 1) === 95) {
                error(ts.Diagnostics.Numeric_separators_are_not_allowed_here, pos - 1, 1);
            }
            return String.fromCharCode.apply(String, valueChars);
        }
        function scanString(jsxAttributeString) {
            if (jsxAttributeString === void 0) { jsxAttributeString = false; }
            var quote = text.charCodeAt(pos);
            pos++;
            var result = "";
            var start = pos;
            while (true) {
                if (pos >= end) {
                    result += text.substring(start, pos);
                    tokenFlags |= 4;
                    error(ts.Diagnostics.Unterminated_string_literal);
                    break;
                }
                var ch = text.charCodeAt(pos);
                if (ch === quote) {
                    result += text.substring(start, pos);
                    pos++;
                    break;
                }
                if (ch === 92 && !jsxAttributeString) {
                    result += text.substring(start, pos);
                    result += scanEscapeSequence();
                    start = pos;
                    continue;
                }
                if (isLineBreak(ch) && !jsxAttributeString) {
                    result += text.substring(start, pos);
                    tokenFlags |= 4;
                    error(ts.Diagnostics.Unterminated_string_literal);
                    break;
                }
                pos++;
            }
            return result;
        }
        function scanTemplateAndSetTokenValue(isTaggedTemplate) {
            var startedWithBacktick = text.charCodeAt(pos) === 96;
            pos++;
            var start = pos;
            var contents = "";
            var resultingToken;
            while (true) {
                if (pos >= end) {
                    contents += text.substring(start, pos);
                    tokenFlags |= 4;
                    error(ts.Diagnostics.Unterminated_template_literal);
                    resultingToken = startedWithBacktick ? 14 : 17;
                    break;
                }
                var currChar = text.charCodeAt(pos);
                if (currChar === 96) {
                    contents += text.substring(start, pos);
                    pos++;
                    resultingToken = startedWithBacktick ? 14 : 17;
                    break;
                }
                if (currChar === 36 && pos + 1 < end && text.charCodeAt(pos + 1) === 123) {
                    contents += text.substring(start, pos);
                    pos += 2;
                    resultingToken = startedWithBacktick ? 15 : 16;
                    break;
                }
                if (currChar === 92) {
                    contents += text.substring(start, pos);
                    contents += scanEscapeSequence(isTaggedTemplate);
                    start = pos;
                    continue;
                }
                if (currChar === 13) {
                    contents += text.substring(start, pos);
                    pos++;
                    if (pos < end && text.charCodeAt(pos) === 10) {
                        pos++;
                    }
                    contents += "\n";
                    start = pos;
                    continue;
                }
                pos++;
            }
            ts.Debug.assert(resultingToken !== undefined);
            tokenValue = contents;
            return resultingToken;
        }
        function scanEscapeSequence(isTaggedTemplate) {
            var start = pos;
            pos++;
            if (pos >= end) {
                error(ts.Diagnostics.Unexpected_end_of_text);
                return "";
            }
            var ch = text.charCodeAt(pos);
            pos++;
            switch (ch) {
                case 48:
                    if (isTaggedTemplate && pos < end && isDigit(text.charCodeAt(pos))) {
                        pos++;
                        tokenFlags |= 2048;
                        return text.substring(start, pos);
                    }
                    return "\0";
                case 98:
                    return "\b";
                case 116:
                    return "\t";
                case 110:
                    return "\n";
                case 118:
                    return "\v";
                case 102:
                    return "\f";
                case 114:
                    return "\r";
                case 39:
                    return "\'";
                case 34:
                    return "\"";
                case 117:
                    if (isTaggedTemplate) {
                        for (var escapePos = pos; escapePos < pos + 4; escapePos++) {
                            if (escapePos < end && !isHexDigit(text.charCodeAt(escapePos)) && text.charCodeAt(escapePos) !== 123) {
                                pos = escapePos;
                                tokenFlags |= 2048;
                                return text.substring(start, pos);
                            }
                        }
                    }
                    if (pos < end && text.charCodeAt(pos) === 123) {
                        pos++;
                        if (isTaggedTemplate && !isHexDigit(text.charCodeAt(pos))) {
                            tokenFlags |= 2048;
                            return text.substring(start, pos);
                        }
                        if (isTaggedTemplate) {
                            var savePos = pos;
                            var escapedValueString = scanMinimumNumberOfHexDigits(1, false);
                            var escapedValue = escapedValueString ? parseInt(escapedValueString, 16) : -1;
                            if (!isCodePoint(escapedValue) || text.charCodeAt(pos) !== 125) {
                                tokenFlags |= 2048;
                                return text.substring(start, pos);
                            }
                            else {
                                pos = savePos;
                            }
                        }
                        tokenFlags |= 8;
                        return scanExtendedUnicodeEscape();
                    }
                    tokenFlags |= 1024;
                    return scanHexadecimalEscape(4);
                case 120:
                    if (isTaggedTemplate) {
                        if (!isHexDigit(text.charCodeAt(pos))) {
                            tokenFlags |= 2048;
                            return text.substring(start, pos);
                        }
                        else if (!isHexDigit(text.charCodeAt(pos + 1))) {
                            pos++;
                            tokenFlags |= 2048;
                            return text.substring(start, pos);
                        }
                    }
                    return scanHexadecimalEscape(2);
                case 13:
                    if (pos < end && text.charCodeAt(pos) === 10) {
                        pos++;
                    }
                case 10:
                case 8232:
                case 8233:
                    return "";
                default:
                    return String.fromCharCode(ch);
            }
        }
        function scanHexadecimalEscape(numDigits) {
            var escapedValue = scanExactNumberOfHexDigits(numDigits, false);
            if (escapedValue >= 0) {
                return String.fromCharCode(escapedValue);
            }
            else {
                error(ts.Diagnostics.Hexadecimal_digit_expected);
                return "";
            }
        }
        function scanExtendedUnicodeEscape() {
            var escapedValueString = scanMinimumNumberOfHexDigits(1, false);
            var escapedValue = escapedValueString ? parseInt(escapedValueString, 16) : -1;
            var isInvalidExtendedEscape = false;
            if (escapedValue < 0) {
                error(ts.Diagnostics.Hexadecimal_digit_expected);
                isInvalidExtendedEscape = true;
            }
            else if (escapedValue > 0x10FFFF) {
                error(ts.Diagnostics.An_extended_Unicode_escape_value_must_be_between_0x0_and_0x10FFFF_inclusive);
                isInvalidExtendedEscape = true;
            }
            if (pos >= end) {
                error(ts.Diagnostics.Unexpected_end_of_text);
                isInvalidExtendedEscape = true;
            }
            else if (text.charCodeAt(pos) === 125) {
                pos++;
            }
            else {
                error(ts.Diagnostics.Unterminated_Unicode_escape_sequence);
                isInvalidExtendedEscape = true;
            }
            if (isInvalidExtendedEscape) {
                return "";
            }
            return utf16EncodeAsString(escapedValue);
        }
        function peekUnicodeEscape() {
            if (pos + 5 < end && text.charCodeAt(pos + 1) === 117) {
                var start_1 = pos;
                pos += 2;
                var value = scanExactNumberOfHexDigits(4, false);
                pos = start_1;
                return value;
            }
            return -1;
        }
        function peekExtendedUnicodeEscape() {
            if (languageVersion >= 2 && codePointAt(text, pos + 1) === 117 && codePointAt(text, pos + 2) === 123) {
                var start_2 = pos;
                pos += 3;
                var escapedValueString = scanMinimumNumberOfHexDigits(1, false);
                var escapedValue = escapedValueString ? parseInt(escapedValueString, 16) : -1;
                pos = start_2;
                return escapedValue;
            }
            return -1;
        }
        function scanIdentifierParts() {
            var result = "";
            var start = pos;
            while (pos < end) {
                var ch = codePointAt(text, pos);
                if (isIdentifierPart(ch, languageVersion)) {
                    pos += charSize(ch);
                }
                else if (ch === 92) {
                    ch = peekExtendedUnicodeEscape();
                    if (ch >= 0 && isIdentifierPart(ch, languageVersion)) {
                        pos += 3;
                        tokenFlags |= 8;
                        result += scanExtendedUnicodeEscape();
                        start = pos;
                        continue;
                    }
                    ch = peekUnicodeEscape();
                    if (!(ch >= 0 && isIdentifierPart(ch, languageVersion))) {
                        break;
                    }
                    tokenFlags |= 1024;
                    result += text.substring(start, pos);
                    result += utf16EncodeAsString(ch);
                    pos += 6;
                    start = pos;
                }
                else {
                    break;
                }
            }
            result += text.substring(start, pos);
            return result;
        }
        function getIdentifierToken() {
            var len = tokenValue.length;
            if (len >= 2 && len <= 12) {
                var ch = tokenValue.charCodeAt(0);
                if (ch >= 97 && ch <= 122) {
                    var keyword = textToKeyword.get(tokenValue);
                    if (keyword !== undefined) {
                        return token = keyword;
                    }
                }
            }
            return token = 79;
        }
        function scanBinaryOrOctalDigits(base) {
            var value = "";
            var separatorAllowed = false;
            var isPreviousTokenSeparator = false;
            while (true) {
                var ch = text.charCodeAt(pos);
                if (ch === 95) {
                    tokenFlags |= 512;
                    if (separatorAllowed) {
                        separatorAllowed = false;
                        isPreviousTokenSeparator = true;
                    }
                    else if (isPreviousTokenSeparator) {
                        error(ts.Diagnostics.Multiple_consecutive_numeric_separators_are_not_permitted, pos, 1);
                    }
                    else {
                        error(ts.Diagnostics.Numeric_separators_are_not_allowed_here, pos, 1);
                    }
                    pos++;
                    continue;
                }
                separatorAllowed = true;
                if (!isDigit(ch) || ch - 48 >= base) {
                    break;
                }
                value += text[pos];
                pos++;
                isPreviousTokenSeparator = false;
            }
            if (text.charCodeAt(pos - 1) === 95) {
                error(ts.Diagnostics.Numeric_separators_are_not_allowed_here, pos - 1, 1);
            }
            return value;
        }
        function checkBigIntSuffix() {
            if (text.charCodeAt(pos) === 110) {
                tokenValue += "n";
                if (tokenFlags & 384) {
                    tokenValue = ts.parsePseudoBigInt(tokenValue) + "n";
                }
                pos++;
                return 9;
            }
            else {
                var numericValue = tokenFlags & 128
                    ? parseInt(tokenValue.slice(2), 2)
                    : tokenFlags & 256
                        ? parseInt(tokenValue.slice(2), 8)
                        : +tokenValue;
                tokenValue = "" + numericValue;
                return 8;
            }
        }
        function scan() {
            var _a;
            startPos = pos;
            tokenFlags = 0;
            var asteriskSeen = false;
            while (true) {
                tokenPos = pos;
                if (pos >= end) {
                    return token = 1;
                }
                var ch = codePointAt(text, pos);
                if (ch === 35 && pos === 0 && isShebangTrivia(text, pos)) {
                    pos = scanShebangTrivia(text, pos);
                    if (skipTrivia) {
                        continue;
                    }
                    else {
                        return token = 6;
                    }
                }
                switch (ch) {
                    case 10:
                    case 13:
                        tokenFlags |= 1;
                        if (skipTrivia) {
                            pos++;
                            continue;
                        }
                        else {
                            if (ch === 13 && pos + 1 < end && text.charCodeAt(pos + 1) === 10) {
                                pos += 2;
                            }
                            else {
                                pos++;
                            }
                            return token = 4;
                        }
                    case 9:
                    case 11:
                    case 12:
                    case 32:
                    case 160:
                    case 5760:
                    case 8192:
                    case 8193:
                    case 8194:
                    case 8195:
                    case 8196:
                    case 8197:
                    case 8198:
                    case 8199:
                    case 8200:
                    case 8201:
                    case 8202:
                    case 8203:
                    case 8239:
                    case 8287:
                    case 12288:
                    case 65279:
                        if (skipTrivia) {
                            pos++;
                            continue;
                        }
                        else {
                            while (pos < end && isWhiteSpaceSingleLine(text.charCodeAt(pos))) {
                                pos++;
                            }
                            return token = 5;
                        }
                    case 33:
                        if (text.charCodeAt(pos + 1) === 61) {
                            if (text.charCodeAt(pos + 2) === 61) {
                                return pos += 3, token = 37;
                            }
                            return pos += 2, token = 35;
                        }
                        pos++;
                        return token = 53;
                    case 34:
                    case 39:
                        tokenValue = scanString();
                        return token = 10;
                    case 96:
                        return token = scanTemplateAndSetTokenValue(false);
                    case 37:
                        if (text.charCodeAt(pos + 1) === 61) {
                            return pos += 2, token = 69;
                        }
                        pos++;
                        return token = 44;
                    case 38:
                        if (text.charCodeAt(pos + 1) === 38) {
                            if (text.charCodeAt(pos + 2) === 61) {
                                return pos += 3, token = 76;
                            }
                            return pos += 2, token = 55;
                        }
                        if (text.charCodeAt(pos + 1) === 61) {
                            return pos += 2, token = 73;
                        }
                        pos++;
                        return token = 50;
                    case 40:
                        pos++;
                        return token = 20;
                    case 41:
                        pos++;
                        return token = 21;
                    case 42:
                        if (text.charCodeAt(pos + 1) === 61) {
                            return pos += 2, token = 66;
                        }
                        if (text.charCodeAt(pos + 1) === 42) {
                            if (text.charCodeAt(pos + 2) === 61) {
                                return pos += 3, token = 67;
                            }
                            return pos += 2, token = 42;
                        }
                        pos++;
                        if (inJSDocType && !asteriskSeen && (tokenFlags & 1)) {
                            asteriskSeen = true;
                            continue;
                        }
                        return token = 41;
                    case 43:
                        if (text.charCodeAt(pos + 1) === 43) {
                            return pos += 2, token = 45;
                        }
                        if (text.charCodeAt(pos + 1) === 61) {
                            return pos += 2, token = 64;
                        }
                        pos++;
                        return token = 39;
                    case 44:
                        pos++;
                        return token = 27;
                    case 45:
                        if (text.charCodeAt(pos + 1) === 45) {
                            return pos += 2, token = 46;
                        }
                        if (text.charCodeAt(pos + 1) === 61) {
                            return pos += 2, token = 65;
                        }
                        pos++;
                        return token = 40;
                    case 46:
                        if (isDigit(text.charCodeAt(pos + 1))) {
                            tokenValue = scanNumber().value;
                            return token = 8;
                        }
                        if (text.charCodeAt(pos + 1) === 46 && text.charCodeAt(pos + 2) === 46) {
                            return pos += 3, token = 25;
                        }
                        pos++;
                        return token = 24;
                    case 47:
                        if (text.charCodeAt(pos + 1) === 47) {
                            pos += 2;
                            while (pos < end) {
                                if (isLineBreak(text.charCodeAt(pos))) {
                                    break;
                                }
                                pos++;
                            }
                            commentDirectives = appendIfCommentDirective(commentDirectives, text.slice(tokenPos, pos), commentDirectiveRegExSingleLine, tokenPos);
                            if (skipTrivia) {
                                continue;
                            }
                            else {
                                return token = 2;
                            }
                        }
                        if (text.charCodeAt(pos + 1) === 42) {
                            pos += 2;
                            if (text.charCodeAt(pos) === 42 && text.charCodeAt(pos + 1) !== 47) {
                                tokenFlags |= 2;
                            }
                            var commentClosed = false;
                            var lastLineStart = tokenPos;
                            while (pos < end) {
                                var ch_1 = text.charCodeAt(pos);
                                if (ch_1 === 42 && text.charCodeAt(pos + 1) === 47) {
                                    pos += 2;
                                    commentClosed = true;
                                    break;
                                }
                                pos++;
                                if (isLineBreak(ch_1)) {
                                    lastLineStart = pos;
                                    tokenFlags |= 1;
                                }
                            }
                            commentDirectives = appendIfCommentDirective(commentDirectives, text.slice(lastLineStart, pos), commentDirectiveRegExMultiLine, lastLineStart);
                            if (!commentClosed) {
                                error(ts.Diagnostics.Asterisk_Slash_expected);
                            }
                            if (skipTrivia) {
                                continue;
                            }
                            else {
                                if (!commentClosed) {
                                    tokenFlags |= 4;
                                }
                                return token = 3;
                            }
                        }
                        if (text.charCodeAt(pos + 1) === 61) {
                            return pos += 2, token = 68;
                        }
                        pos++;
                        return token = 43;
                    case 48:
                        if (pos + 2 < end && (text.charCodeAt(pos + 1) === 88 || text.charCodeAt(pos + 1) === 120)) {
                            pos += 2;
                            tokenValue = scanMinimumNumberOfHexDigits(1, true);
                            if (!tokenValue) {
                                error(ts.Diagnostics.Hexadecimal_digit_expected);
                                tokenValue = "0";
                            }
                            tokenValue = "0x" + tokenValue;
                            tokenFlags |= 64;
                            return token = checkBigIntSuffix();
                        }
                        else if (pos + 2 < end && (text.charCodeAt(pos + 1) === 66 || text.charCodeAt(pos + 1) === 98)) {
                            pos += 2;
                            tokenValue = scanBinaryOrOctalDigits(2);
                            if (!tokenValue) {
                                error(ts.Diagnostics.Binary_digit_expected);
                                tokenValue = "0";
                            }
                            tokenValue = "0b" + tokenValue;
                            tokenFlags |= 128;
                            return token = checkBigIntSuffix();
                        }
                        else if (pos + 2 < end && (text.charCodeAt(pos + 1) === 79 || text.charCodeAt(pos + 1) === 111)) {
                            pos += 2;
                            tokenValue = scanBinaryOrOctalDigits(8);
                            if (!tokenValue) {
                                error(ts.Diagnostics.Octal_digit_expected);
                                tokenValue = "0";
                            }
                            tokenValue = "0o" + tokenValue;
                            tokenFlags |= 256;
                            return token = checkBigIntSuffix();
                        }
                        if (pos + 1 < end && isOctalDigit(text.charCodeAt(pos + 1))) {
                            tokenValue = "" + scanOctalDigits();
                            tokenFlags |= 32;
                            return token = 8;
                        }
                    case 49:
                    case 50:
                    case 51:
                    case 52:
                    case 53:
                    case 54:
                    case 55:
                    case 56:
                    case 57:
                        (_a = scanNumber(), token = _a.type, tokenValue = _a.value);
                        return token;
                    case 58:
                        pos++;
                        return token = 58;
                    case 59:
                        pos++;
                        return token = 26;
                    case 60:
                        if (isConflictMarkerTrivia(text, pos)) {
                            pos = scanConflictMarkerTrivia(text, pos, error);
                            if (skipTrivia) {
                                continue;
                            }
                            else {
                                return token = 7;
                            }
                        }
                        if (text.charCodeAt(pos + 1) === 60) {
                            if (text.charCodeAt(pos + 2) === 61) {
                                return pos += 3, token = 70;
                            }
                            return pos += 2, token = 47;
                        }
                        if (text.charCodeAt(pos + 1) === 61) {
                            return pos += 2, token = 32;
                        }
                        if (languageVariant === 1 &&
                            text.charCodeAt(pos + 1) === 47 &&
                            text.charCodeAt(pos + 2) !== 42) {
                            return pos += 2, token = 30;
                        }
                        pos++;
                        return token = 29;
                    case 61:
                        if (isConflictMarkerTrivia(text, pos)) {
                            pos = scanConflictMarkerTrivia(text, pos, error);
                            if (skipTrivia) {
                                continue;
                            }
                            else {
                                return token = 7;
                            }
                        }
                        if (text.charCodeAt(pos + 1) === 61) {
                            if (text.charCodeAt(pos + 2) === 61) {
                                return pos += 3, token = 36;
                            }
                            return pos += 2, token = 34;
                        }
                        if (text.charCodeAt(pos + 1) === 62) {
                            return pos += 2, token = 38;
                        }
                        pos++;
                        return token = 63;
                    case 62:
                        if (isConflictMarkerTrivia(text, pos)) {
                            pos = scanConflictMarkerTrivia(text, pos, error);
                            if (skipTrivia) {
                                continue;
                            }
                            else {
                                return token = 7;
                            }
                        }
                        pos++;
                        return token = 31;
                    case 63:
                        if (text.charCodeAt(pos + 1) === 46 && !isDigit(text.charCodeAt(pos + 2))) {
                            return pos += 2, token = 28;
                        }
                        if (text.charCodeAt(pos + 1) === 63) {
                            if (text.charCodeAt(pos + 2) === 61) {
                                return pos += 3, token = 77;
                            }
                            return pos += 2, token = 60;
                        }
                        pos++;
                        return token = 57;
                    case 91:
                        pos++;
                        return token = 22;
                    case 93:
                        pos++;
                        return token = 23;
                    case 94:
                        if (text.charCodeAt(pos + 1) === 61) {
                            return pos += 2, token = 78;
                        }
                        pos++;
                        return token = 52;
                    case 123:
                        pos++;
                        return token = 18;
                    case 124:
                        if (isConflictMarkerTrivia(text, pos)) {
                            pos = scanConflictMarkerTrivia(text, pos, error);
                            if (skipTrivia) {
                                continue;
                            }
                            else {
                                return token = 7;
                            }
                        }
                        if (text.charCodeAt(pos + 1) === 124) {
                            if (text.charCodeAt(pos + 2) === 61) {
                                return pos += 3, token = 75;
                            }
                            return pos += 2, token = 56;
                        }
                        if (text.charCodeAt(pos + 1) === 61) {
                            return pos += 2, token = 74;
                        }
                        pos++;
                        return token = 51;
                    case 125:
                        pos++;
                        return token = 19;
                    case 126:
                        pos++;
                        return token = 54;
                    case 64:
                        pos++;
                        return token = 59;
                    case 92:
                        var extendedCookedChar = peekExtendedUnicodeEscape();
                        if (extendedCookedChar >= 0 && isIdentifierStart(extendedCookedChar, languageVersion)) {
                            pos += 3;
                            tokenFlags |= 8;
                            tokenValue = scanExtendedUnicodeEscape() + scanIdentifierParts();
                            return token = getIdentifierToken();
                        }
                        var cookedChar = peekUnicodeEscape();
                        if (cookedChar >= 0 && isIdentifierStart(cookedChar, languageVersion)) {
                            pos += 6;
                            tokenFlags |= 1024;
                            tokenValue = String.fromCharCode(cookedChar) + scanIdentifierParts();
                            return token = getIdentifierToken();
                        }
                        error(ts.Diagnostics.Invalid_character);
                        pos++;
                        return token = 0;
                    case 35:
                        if (pos !== 0 && text[pos + 1] === "!") {
                            error(ts.Diagnostics.can_only_be_used_at_the_start_of_a_file);
                            pos++;
                            return token = 0;
                        }
                        if (isIdentifierStart(codePointAt(text, pos + 1), languageVersion)) {
                            pos++;
                            scanIdentifier(codePointAt(text, pos), languageVersion);
                        }
                        else {
                            tokenValue = String.fromCharCode(codePointAt(text, pos));
                            error(ts.Diagnostics.Invalid_character, pos++, charSize(ch));
                        }
                        return token = 80;
                    default:
                        var identifierKind = scanIdentifier(ch, languageVersion);
                        if (identifierKind) {
                            return token = identifierKind;
                        }
                        else if (isWhiteSpaceSingleLine(ch)) {
                            pos += charSize(ch);
                            continue;
                        }
                        else if (isLineBreak(ch)) {
                            tokenFlags |= 1;
                            pos += charSize(ch);
                            continue;
                        }
                        var size = charSize(ch);
                        error(ts.Diagnostics.Invalid_character, pos, size);
                        pos += size;
                        return token = 0;
                }
            }
        }
        function reScanInvalidIdentifier() {
            ts.Debug.assert(token === 0, "'reScanInvalidIdentifier' should only be called when the current token is 'SyntaxKind.Unknown'.");
            pos = tokenPos = startPos;
            tokenFlags = 0;
            var ch = codePointAt(text, pos);
            var identifierKind = scanIdentifier(ch, 99);
            if (identifierKind) {
                return token = identifierKind;
            }
            pos += charSize(ch);
            return token;
        }
        function scanIdentifier(startCharacter, languageVersion) {
            var ch = startCharacter;
            if (isIdentifierStart(ch, languageVersion)) {
                pos += charSize(ch);
                while (pos < end && isIdentifierPart(ch = codePointAt(text, pos), languageVersion))
                    pos += charSize(ch);
                tokenValue = text.substring(tokenPos, pos);
                if (ch === 92) {
                    tokenValue += scanIdentifierParts();
                }
                return getIdentifierToken();
            }
        }
        function reScanGreaterToken() {
            if (token === 31) {
                if (text.charCodeAt(pos) === 62) {
                    if (text.charCodeAt(pos + 1) === 62) {
                        if (text.charCodeAt(pos + 2) === 61) {
                            return pos += 3, token = 72;
                        }
                        return pos += 2, token = 49;
                    }
                    if (text.charCodeAt(pos + 1) === 61) {
                        return pos += 2, token = 71;
                    }
                    pos++;
                    return token = 48;
                }
                if (text.charCodeAt(pos) === 61) {
                    pos++;
                    return token = 33;
                }
            }
            return token;
        }
        function reScanAsteriskEqualsToken() {
            ts.Debug.assert(token === 66, "'reScanAsteriskEqualsToken' should only be called on a '*='");
            pos = tokenPos + 1;
            return token = 63;
        }
        function reScanSlashToken() {
            if (token === 43 || token === 68) {
                var p = tokenPos + 1;
                var inEscape = false;
                var inCharacterClass = false;
                while (true) {
                    if (p >= end) {
                        tokenFlags |= 4;
                        error(ts.Diagnostics.Unterminated_regular_expression_literal);
                        break;
                    }
                    var ch = text.charCodeAt(p);
                    if (isLineBreak(ch)) {
                        tokenFlags |= 4;
                        error(ts.Diagnostics.Unterminated_regular_expression_literal);
                        break;
                    }
                    if (inEscape) {
                        inEscape = false;
                    }
                    else if (ch === 47 && !inCharacterClass) {
                        p++;
                        break;
                    }
                    else if (ch === 91) {
                        inCharacterClass = true;
                    }
                    else if (ch === 92) {
                        inEscape = true;
                    }
                    else if (ch === 93) {
                        inCharacterClass = false;
                    }
                    p++;
                }
                while (p < end && isIdentifierPart(text.charCodeAt(p), languageVersion)) {
                    p++;
                }
                pos = p;
                tokenValue = text.substring(tokenPos, pos);
                token = 13;
            }
            return token;
        }
        function appendIfCommentDirective(commentDirectives, text, commentDirectiveRegEx, lineStart) {
            var type = getDirectiveFromComment(ts.trimStringStart(text), commentDirectiveRegEx);
            if (type === undefined) {
                return commentDirectives;
            }
            return ts.append(commentDirectives, {
                range: { pos: lineStart, end: pos },
                type: type,
            });
        }
        function getDirectiveFromComment(text, commentDirectiveRegEx) {
            var match = commentDirectiveRegEx.exec(text);
            if (!match) {
                return undefined;
            }
            switch (match[1]) {
                case "ts-expect-error":
                    return 0;
                case "ts-ignore":
                    return 1;
            }
            return undefined;
        }
        function reScanTemplateToken(isTaggedTemplate) {
            ts.Debug.assert(token === 19, "'reScanTemplateToken' should only be called on a '}'");
            pos = tokenPos;
            return token = scanTemplateAndSetTokenValue(isTaggedTemplate);
        }
        function reScanTemplateHeadOrNoSubstitutionTemplate() {
            pos = tokenPos;
            return token = scanTemplateAndSetTokenValue(true);
        }
        function reScanJsxToken(allowMultilineJsxText) {
            if (allowMultilineJsxText === void 0) { allowMultilineJsxText = true; }
            pos = tokenPos = startPos;
            return token = scanJsxToken(allowMultilineJsxText);
        }
        function reScanLessThanToken() {
            if (token === 47) {
                pos = tokenPos + 1;
                return token = 29;
            }
            return token;
        }
        function reScanHashToken() {
            if (token === 80) {
                pos = tokenPos + 1;
                return token = 62;
            }
            return token;
        }
        function reScanQuestionToken() {
            ts.Debug.assert(token === 60, "'reScanQuestionToken' should only be called on a '??'");
            pos = tokenPos + 1;
            return token = 57;
        }
        function scanJsxToken(allowMultilineJsxText) {
            if (allowMultilineJsxText === void 0) { allowMultilineJsxText = true; }
            startPos = tokenPos = pos;
            if (pos >= end) {
                return token = 1;
            }
            var char = text.charCodeAt(pos);
            if (char === 60) {
                if (text.charCodeAt(pos + 1) === 47) {
                    pos += 2;
                    return token = 30;
                }
                pos++;
                return token = 29;
            }
            if (char === 123) {
                pos++;
                return token = 18;
            }
            var firstNonWhitespace = 0;
            while (pos < end) {
                char = text.charCodeAt(pos);
                if (char === 123) {
                    break;
                }
                if (char === 60) {
                    if (isConflictMarkerTrivia(text, pos)) {
                        pos = scanConflictMarkerTrivia(text, pos, error);
                        return token = 7;
                    }
                    break;
                }
                if (char === 62) {
                    error(ts.Diagnostics.Unexpected_token_Did_you_mean_or_gt, pos, 1);
                }
                if (char === 125) {
                    error(ts.Diagnostics.Unexpected_token_Did_you_mean_or_rbrace, pos, 1);
                }
                if (isLineBreak(char) && firstNonWhitespace === 0) {
                    firstNonWhitespace = -1;
                }
                else if (!allowMultilineJsxText && isLineBreak(char) && firstNonWhitespace > 0) {
                    break;
                }
                else if (!isWhiteSpaceLike(char)) {
                    firstNonWhitespace = pos;
                }
                pos++;
            }
            tokenValue = text.substring(startPos, pos);
            return firstNonWhitespace === -1 ? 12 : 11;
        }
        function scanJsxIdentifier() {
            if (tokenIsIdentifierOrKeyword(token)) {
                var namespaceSeparator = false;
                while (pos < end) {
                    var ch = text.charCodeAt(pos);
                    if (ch === 45) {
                        tokenValue += "-";
                        pos++;
                        continue;
                    }
                    else if (ch === 58 && !namespaceSeparator) {
                        tokenValue += ":";
                        pos++;
                        namespaceSeparator = true;
                        token = 79;
                        continue;
                    }
                    var oldPos = pos;
                    tokenValue += scanIdentifierParts();
                    if (pos === oldPos) {
                        break;
                    }
                }
                if (tokenValue.slice(-1) === ":") {
                    tokenValue = tokenValue.slice(0, -1);
                    pos--;
                }
                return getIdentifierToken();
            }
            return token;
        }
        function scanJsxAttributeValue() {
            startPos = pos;
            switch (text.charCodeAt(pos)) {
                case 34:
                case 39:
                    tokenValue = scanString(true);
                    return token = 10;
                default:
                    return scan();
            }
        }
        function reScanJsxAttributeValue() {
            pos = tokenPos = startPos;
            return scanJsxAttributeValue();
        }
        function scanJsDocToken() {
            startPos = tokenPos = pos;
            tokenFlags = 0;
            if (pos >= end) {
                return token = 1;
            }
            var ch = codePointAt(text, pos);
            pos += charSize(ch);
            switch (ch) {
                case 9:
                case 11:
                case 12:
                case 32:
                    while (pos < end && isWhiteSpaceSingleLine(text.charCodeAt(pos))) {
                        pos++;
                    }
                    return token = 5;
                case 64:
                    return token = 59;
                case 13:
                    if (text.charCodeAt(pos) === 10) {
                        pos++;
                    }
                case 10:
                    tokenFlags |= 1;
                    return token = 4;
                case 42:
                    return token = 41;
                case 123:
                    return token = 18;
                case 125:
                    return token = 19;
                case 91:
                    return token = 22;
                case 93:
                    return token = 23;
                case 60:
                    return token = 29;
                case 62:
                    return token = 31;
                case 61:
                    return token = 63;
                case 44:
                    return token = 27;
                case 46:
                    return token = 24;
                case 96:
                    return token = 61;
                case 35:
                    return token = 62;
                case 92:
                    pos--;
                    var extendedCookedChar = peekExtendedUnicodeEscape();
                    if (extendedCookedChar >= 0 && isIdentifierStart(extendedCookedChar, languageVersion)) {
                        pos += 3;
                        tokenFlags |= 8;
                        tokenValue = scanExtendedUnicodeEscape() + scanIdentifierParts();
                        return token = getIdentifierToken();
                    }
                    var cookedChar = peekUnicodeEscape();
                    if (cookedChar >= 0 && isIdentifierStart(cookedChar, languageVersion)) {
                        pos += 6;
                        tokenFlags |= 1024;
                        tokenValue = String.fromCharCode(cookedChar) + scanIdentifierParts();
                        return token = getIdentifierToken();
                    }
                    pos++;
                    return token = 0;
            }
            if (isIdentifierStart(ch, languageVersion)) {
                var char = ch;
                while (pos < end && isIdentifierPart(char = codePointAt(text, pos), languageVersion) || text.charCodeAt(pos) === 45)
                    pos += charSize(char);
                tokenValue = text.substring(tokenPos, pos);
                if (char === 92) {
                    tokenValue += scanIdentifierParts();
                }
                return token = getIdentifierToken();
            }
            else {
                return token = 0;
            }
        }
        function speculationHelper(callback, isLookahead) {
            var savePos = pos;
            var saveStartPos = startPos;
            var saveTokenPos = tokenPos;
            var saveToken = token;
            var saveTokenValue = tokenValue;
            var saveTokenFlags = tokenFlags;
            var result = callback();
            if (!result || isLookahead) {
                pos = savePos;
                startPos = saveStartPos;
                tokenPos = saveTokenPos;
                token = saveToken;
                tokenValue = saveTokenValue;
                tokenFlags = saveTokenFlags;
            }
            return result;
        }
        function scanRange(start, length, callback) {
            var saveEnd = end;
            var savePos = pos;
            var saveStartPos = startPos;
            var saveTokenPos = tokenPos;
            var saveToken = token;
            var saveTokenValue = tokenValue;
            var saveTokenFlags = tokenFlags;
            var saveErrorExpectations = commentDirectives;
            setText(text, start, length);
            var result = callback();
            end = saveEnd;
            pos = savePos;
            startPos = saveStartPos;
            tokenPos = saveTokenPos;
            token = saveToken;
            tokenValue = saveTokenValue;
            tokenFlags = saveTokenFlags;
            commentDirectives = saveErrorExpectations;
            return result;
        }
        function lookAhead(callback) {
            return speculationHelper(callback, true);
        }
        function tryScan(callback) {
            return speculationHelper(callback, false);
        }
        function getText() {
            return text;
        }
        function clearCommentDirectives() {
            commentDirectives = undefined;
        }
        function setText(newText, start, length) {
            text = newText || "";
            end = length === undefined ? text.length : start + length;
            setTextPos(start || 0);
        }
        function setOnError(errorCallback) {
            onError = errorCallback;
        }
        function setScriptTarget(scriptTarget) {
            languageVersion = scriptTarget;
        }
        function setLanguageVariant(variant) {
            languageVariant = variant;
        }
        function setTextPos(textPos) {
            ts.Debug.assert(textPos >= 0);
            pos = textPos;
            startPos = textPos;
            tokenPos = textPos;
            token = 0;
            tokenValue = undefined;
            tokenFlags = 0;
        }
        function setInJSDocType(inType) {
            inJSDocType += inType ? 1 : -1;
        }
    }
    ts.createScanner = createScanner;
    var codePointAt = String.prototype.codePointAt ? function (s, i) { return s.codePointAt(i); } : function codePointAt(str, i) {
        var size = str.length;
        if (i < 0 || i >= size) {
            return undefined;
        }
        var first = str.charCodeAt(i);
        if (first >= 0xD800 && first <= 0xDBFF && size > i + 1) {
            var second = str.charCodeAt(i + 1);
            if (second >= 0xDC00 && second <= 0xDFFF) {
                return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
            }
        }
        return first;
    };
    function charSize(ch) {
        if (ch >= 0x10000) {
            return 2;
        }
        return 1;
    }
    function utf16EncodeAsStringFallback(codePoint) {
        ts.Debug.assert(0x0 <= codePoint && codePoint <= 0x10FFFF);
        if (codePoint <= 65535) {
            return String.fromCharCode(codePoint);
        }
        var codeUnit1 = Math.floor((codePoint - 65536) / 1024) + 0xD800;
        var codeUnit2 = ((codePoint - 65536) % 1024) + 0xDC00;
        return String.fromCharCode(codeUnit1, codeUnit2);
    }
    var utf16EncodeAsStringWorker = String.fromCodePoint ? function (codePoint) { return String.fromCodePoint(codePoint); } : utf16EncodeAsStringFallback;
    function utf16EncodeAsString(codePoint) {
        return utf16EncodeAsStringWorker(codePoint);
    }
    ts.utf16EncodeAsString = utf16EncodeAsString;
})(ts || (ts = {}));
var ts;
(function (ts) {
    function isExternalModuleNameRelative(moduleName) {
        return ts.pathIsRelative(moduleName) || ts.isRootedDiskPath(moduleName);
    }
    ts.isExternalModuleNameRelative = isExternalModuleNameRelative;
    function sortAndDeduplicateDiagnostics(diagnostics) {
        return ts.sortAndDeduplicate(diagnostics, ts.compareDiagnostics);
    }
    ts.sortAndDeduplicateDiagnostics = sortAndDeduplicateDiagnostics;
    function getDefaultLibFileName(options) {
        switch (ts.getEmitScriptTarget(options)) {
            case 99:
                return "lib.esnext.full.d.ts";
            case 9:
                return "lib.es2022.full.d.ts";
            case 8:
                return "lib.es2021.full.d.ts";
            case 7:
                return "lib.es2020.full.d.ts";
            case 6:
                return "lib.es2019.full.d.ts";
            case 5:
                return "lib.es2018.full.d.ts";
            case 4:
                return "lib.es2017.full.d.ts";
            case 3:
                return "lib.es2016.full.d.ts";
            case 2:
                return "lib.es6.d.ts";
            default:
                return "lib.d.ts";
        }
    }
    ts.getDefaultLibFileName = getDefaultLibFileName;
    function textSpanEnd(span) {
        return span.start + span.length;
    }
    ts.textSpanEnd = textSpanEnd;
    function textSpanIsEmpty(span) {
        return span.length === 0;
    }
    ts.textSpanIsEmpty = textSpanIsEmpty;
    function textSpanContainsPosition(span, position) {
        return position >= span.start && position < textSpanEnd(span);
    }
    ts.textSpanContainsPosition = textSpanContainsPosition;
    function textRangeContainsPositionInclusive(span, position) {
        return position >= span.pos && position <= span.end;
    }
    ts.textRangeContainsPositionInclusive = textRangeContainsPositionInclusive;
    function textSpanContainsTextSpan(span, other) {
        return other.start >= span.start && textSpanEnd(other) <= textSpanEnd(span);
    }
    ts.textSpanContainsTextSpan = textSpanContainsTextSpan;
    function textSpanOverlapsWith(span, other) {
        return textSpanOverlap(span, other) !== undefined;
    }
    ts.textSpanOverlapsWith = textSpanOverlapsWith;
    function textSpanOverlap(span1, span2) {
        var overlap = textSpanIntersection(span1, span2);
        return overlap && overlap.length === 0 ? undefined : overlap;
    }
    ts.textSpanOverlap = textSpanOverlap;
    function textSpanIntersectsWithTextSpan(span, other) {
        return decodedTextSpanIntersectsWith(span.start, span.length, other.start, other.length);
    }
    ts.textSpanIntersectsWithTextSpan = textSpanIntersectsWithTextSpan;
    function textSpanIntersectsWith(span, start, length) {
        return decodedTextSpanIntersectsWith(span.start, span.length, start, length);
    }
    ts.textSpanIntersectsWith = textSpanIntersectsWith;
    function decodedTextSpanIntersectsWith(start1, length1, start2, length2) {
        var end1 = start1 + length1;
        var end2 = start2 + length2;
        return start2 <= end1 && end2 >= start1;
    }
    ts.decodedTextSpanIntersectsWith = decodedTextSpanIntersectsWith;
    function textSpanIntersectsWithPosition(span, position) {
        return position <= textSpanEnd(span) && position >= span.start;
    }
    ts.textSpanIntersectsWithPosition = textSpanIntersectsWithPosition;
    function textSpanIntersection(span1, span2) {
        var start = Math.max(span1.start, span2.start);
        var end = Math.min(textSpanEnd(span1), textSpanEnd(span2));
        return start <= end ? createTextSpanFromBounds(start, end) : undefined;
    }
    ts.textSpanIntersection = textSpanIntersection;
    function createTextSpan(start, length) {
        if (start < 0) {
            throw new Error("start < 0");
        }
        if (length < 0) {
            throw new Error("length < 0");
        }
        return { start: start, length: length };
    }
    ts.createTextSpan = createTextSpan;
    function createTextSpanFromBounds(start, end) {
        return createTextSpan(start, end - start);
    }
    ts.createTextSpanFromBounds = createTextSpanFromBounds;
    function textChangeRangeNewSpan(range) {
        return createTextSpan(range.span.start, range.newLength);
    }
    ts.textChangeRangeNewSpan = textChangeRangeNewSpan;
    function textChangeRangeIsUnchanged(range) {
        return textSpanIsEmpty(range.span) && range.newLength === 0;
    }
    ts.textChangeRangeIsUnchanged = textChangeRangeIsUnchanged;
    function createTextChangeRange(span, newLength) {
        if (newLength < 0) {
            throw new Error("newLength < 0");
        }
        return { span: span, newLength: newLength };
    }
    ts.createTextChangeRange = createTextChangeRange;
    ts.unchangedTextChangeRange = createTextChangeRange(createTextSpan(0, 0), 0);
    function collapseTextChangeRangesAcrossMultipleVersions(changes) {
        if (changes.length === 0) {
            return ts.unchangedTextChangeRange;
        }
        if (changes.length === 1) {
            return changes[0];
        }
        var change0 = changes[0];
        var oldStartN = change0.span.start;
        var oldEndN = textSpanEnd(change0.span);
        var newEndN = oldStartN + change0.newLength;
        for (var i = 1; i < changes.length; i++) {
            var nextChange = changes[i];
            var oldStart1 = oldStartN;
            var oldEnd1 = oldEndN;
            var newEnd1 = newEndN;
            var oldStart2 = nextChange.span.start;
            var oldEnd2 = textSpanEnd(nextChange.span);
            var newEnd2 = oldStart2 + nextChange.newLength;
            oldStartN = Math.min(oldStart1, oldStart2);
            oldEndN = Math.max(oldEnd1, oldEnd1 + (oldEnd2 - newEnd1));
            newEndN = Math.max(newEnd2, newEnd2 + (newEnd1 - oldEnd2));
        }
        return createTextChangeRange(createTextSpanFromBounds(oldStartN, oldEndN), newEndN - oldStartN);
    }
    ts.collapseTextChangeRangesAcrossMultipleVersions = collapseTextChangeRangesAcrossMultipleVersions;
    function getTypeParameterOwner(d) {
        if (d && d.kind === 163) {
            for (var current = d; current; current = current.parent) {
                if (isFunctionLike(current) || isClassLike(current) || current.kind === 258) {
                    return current;
                }
            }
        }
    }
    ts.getTypeParameterOwner = getTypeParameterOwner;
    function isParameterPropertyDeclaration(node, parent) {
        return ts.hasSyntacticModifier(node, 16476) && parent.kind === 171;
    }
    ts.isParameterPropertyDeclaration = isParameterPropertyDeclaration;
    function isEmptyBindingPattern(node) {
        if (isBindingPattern(node)) {
            return ts.every(node.elements, isEmptyBindingElement);
        }
        return false;
    }
    ts.isEmptyBindingPattern = isEmptyBindingPattern;
    function isEmptyBindingElement(node) {
        if (ts.isOmittedExpression(node)) {
            return true;
        }
        return isEmptyBindingPattern(node.name);
    }
    ts.isEmptyBindingElement = isEmptyBindingElement;
    function walkUpBindingElementsAndPatterns(binding) {
        var node = binding.parent;
        while (ts.isBindingElement(node.parent)) {
            node = node.parent.parent;
        }
        return node.parent;
    }
    ts.walkUpBindingElementsAndPatterns = walkUpBindingElementsAndPatterns;
    function getCombinedFlags(node, getFlags) {
        if (ts.isBindingElement(node)) {
            node = walkUpBindingElementsAndPatterns(node);
        }
        var flags = getFlags(node);
        if (node.kind === 254) {
            node = node.parent;
        }
        if (node && node.kind === 255) {
            flags |= getFlags(node);
            node = node.parent;
        }
        if (node && node.kind === 237) {
            flags |= getFlags(node);
        }
        return flags;
    }
    function getCombinedModifierFlags(node) {
        return getCombinedFlags(node, ts.getEffectiveModifierFlags);
    }
    ts.getCombinedModifierFlags = getCombinedModifierFlags;
    function getCombinedNodeFlagsAlwaysIncludeJSDoc(node) {
        return getCombinedFlags(node, ts.getEffectiveModifierFlagsAlwaysIncludeJSDoc);
    }
    ts.getCombinedNodeFlagsAlwaysIncludeJSDoc = getCombinedNodeFlagsAlwaysIncludeJSDoc;
    function getCombinedNodeFlags(node) {
        return getCombinedFlags(node, function (n) { return n.flags; });
    }
    ts.getCombinedNodeFlags = getCombinedNodeFlags;
    ts.supportedLocaleDirectories = ["cs", "de", "es", "fr", "it", "ja", "ko", "pl", "pt-br", "ru", "tr", "zh-cn", "zh-tw"];
    function validateLocaleAndSetLanguage(locale, sys, errors) {
        var lowerCaseLocale = locale.toLowerCase();
        var matchResult = /^([a-z]+)([_\-]([a-z]+))?$/.exec(lowerCaseLocale);
        if (!matchResult) {
            if (errors) {
                errors.push(ts.createCompilerDiagnostic(ts.Diagnostics.Locale_must_be_of_the_form_language_or_language_territory_For_example_0_or_1, "en", "ja-jp"));
            }
            return;
        }
        var language = matchResult[1];
        var territory = matchResult[3];
        if (ts.contains(ts.supportedLocaleDirectories, lowerCaseLocale) && !trySetLanguageAndTerritory(language, territory, errors)) {
            trySetLanguageAndTerritory(language, undefined, errors);
        }
        ts.setUILocale(locale);
        function trySetLanguageAndTerritory(language, territory, errors) {
            var compilerFilePath = ts.normalizePath(sys.getExecutingFilePath());
            var containingDirectoryPath = ts.getDirectoryPath(compilerFilePath);
            var filePath = ts.combinePaths(containingDirectoryPath, language);
            if (territory) {
                filePath = filePath + "-" + territory;
            }
            filePath = sys.resolvePath(ts.combinePaths(filePath, "diagnosticMessages.generated.json"));
            if (!sys.fileExists(filePath)) {
                return false;
            }
            var fileContents = "";
            try {
                fileContents = sys.readFile(filePath);
            }
            catch (e) {
                if (errors) {
                    errors.push(ts.createCompilerDiagnostic(ts.Diagnostics.Unable_to_open_file_0, filePath));
                }
                return false;
            }
            try {
                ts.setLocalizedDiagnosticMessages(JSON.parse(fileContents));
            }
            catch (_a) {
                if (errors) {
                    errors.push(ts.createCompilerDiagnostic(ts.Diagnostics.Corrupted_locale_file_0, filePath));
                }
                return false;
            }
            return true;
        }
    }
    ts.validateLocaleAndSetLanguage = validateLocaleAndSetLanguage;
    function getOriginalNode(node, nodeTest) {
        if (node) {
            while (node.original !== undefined) {
                node = node.original;
            }
        }
        return !nodeTest || nodeTest(node) ? node : undefined;
    }
    ts.getOriginalNode = getOriginalNode;
    function findAncestor(node, callback) {
        while (node) {
            var result = callback(node);
            if (result === "quit") {
                return undefined;
            }
            else if (result) {
                return node;
            }
            node = node.parent;
        }
        return undefined;
    }
    ts.findAncestor = findAncestor;
    function isParseTreeNode(node) {
        return (node.flags & 8) === 0;
    }
    ts.isParseTreeNode = isParseTreeNode;
    function getParseTreeNode(node, nodeTest) {
        if (node === undefined || isParseTreeNode(node)) {
            return node;
        }
        node = node.original;
        while (node) {
            if (isParseTreeNode(node)) {
                return !nodeTest || nodeTest(node) ? node : undefined;
            }
            node = node.original;
        }
    }
    ts.getParseTreeNode = getParseTreeNode;
    function escapeLeadingUnderscores(identifier) {
        return (identifier.length >= 2 && identifier.charCodeAt(0) === 95 && identifier.charCodeAt(1) === 95 ? "_" + identifier : identifier);
    }
    ts.escapeLeadingUnderscores = escapeLeadingUnderscores;
    function unescapeLeadingUnderscores(identifier) {
        var id = identifier;
        return id.length >= 3 && id.charCodeAt(0) === 95 && id.charCodeAt(1) === 95 && id.charCodeAt(2) === 95 ? id.substr(1) : id;
    }
    ts.unescapeLeadingUnderscores = unescapeLeadingUnderscores;
    function idText(identifierOrPrivateName) {
        return unescapeLeadingUnderscores(identifierOrPrivateName.escapedText);
    }
    ts.idText = idText;
    function symbolName(symbol) {
        if (symbol.valueDeclaration && isPrivateIdentifierClassElementDeclaration(symbol.valueDeclaration)) {
            return idText(symbol.valueDeclaration.name);
        }
        return unescapeLeadingUnderscores(symbol.escapedName);
    }
    ts.symbolName = symbolName;
    function nameForNamelessJSDocTypedef(declaration) {
        var hostNode = declaration.parent.parent;
        if (!hostNode) {
            return undefined;
        }
        if (isDeclaration(hostNode)) {
            return getDeclarationIdentifier(hostNode);
        }
        switch (hostNode.kind) {
            case 237:
                if (hostNode.declarationList && hostNode.declarationList.declarations[0]) {
                    return getDeclarationIdentifier(hostNode.declarationList.declarations[0]);
                }
                break;
            case 238:
                var expr = hostNode.expression;
                if (expr.kind === 221 && expr.operatorToken.kind === 63) {
                    expr = expr.left;
                }
                switch (expr.kind) {
                    case 206:
                        return expr.name;
                    case 207:
                        var arg = expr.argumentExpression;
                        if (ts.isIdentifier(arg)) {
                            return arg;
                        }
                }
                break;
            case 212: {
                return getDeclarationIdentifier(hostNode.expression);
            }
            case 250: {
                if (isDeclaration(hostNode.statement) || isExpression(hostNode.statement)) {
                    return getDeclarationIdentifier(hostNode.statement);
                }
                break;
            }
        }
    }
    function getDeclarationIdentifier(node) {
        var name = getNameOfDeclaration(node);
        return name && ts.isIdentifier(name) ? name : undefined;
    }
    function nodeHasName(statement, name) {
        if (isNamedDeclaration(statement) && ts.isIdentifier(statement.name) && idText(statement.name) === idText(name)) {
            return true;
        }
        if (ts.isVariableStatement(statement) && ts.some(statement.declarationList.declarations, function (d) { return nodeHasName(d, name); })) {
            return true;
        }
        return false;
    }
    ts.nodeHasName = nodeHasName;
    function getNameOfJSDocTypedef(declaration) {
        return declaration.name || nameForNamelessJSDocTypedef(declaration);
    }
    ts.getNameOfJSDocTypedef = getNameOfJSDocTypedef;
    function isNamedDeclaration(node) {
        return !!node.name;
    }
    ts.isNamedDeclaration = isNamedDeclaration;
    function getNonAssignedNameOfDeclaration(declaration) {
        switch (declaration.kind) {
            case 79:
                return declaration;
            case 347:
            case 340: {
                var name = declaration.name;
                if (name.kind === 161) {
                    return name.right;
                }
                break;
            }
            case 208:
            case 221: {
                var expr_1 = declaration;
                switch (ts.getAssignmentDeclarationKind(expr_1)) {
                    case 1:
                    case 4:
                    case 5:
                    case 3:
                        return ts.getElementOrPropertyAccessArgumentExpressionOrName(expr_1.left);
                    case 7:
                    case 8:
                    case 9:
                        return expr_1.arguments[1];
                    default:
                        return undefined;
                }
            }
            case 345:
                return getNameOfJSDocTypedef(declaration);
            case 339:
                return nameForNamelessJSDocTypedef(declaration);
            case 271: {
                var expression = declaration.expression;
                return ts.isIdentifier(expression) ? expression : undefined;
            }
            case 207:
                var expr = declaration;
                if (ts.isBindableStaticElementAccessExpression(expr)) {
                    return expr.argumentExpression;
                }
        }
        return declaration.name;
    }
    ts.getNonAssignedNameOfDeclaration = getNonAssignedNameOfDeclaration;
    function getNameOfDeclaration(declaration) {
        if (declaration === undefined)
            return undefined;
        return getNonAssignedNameOfDeclaration(declaration) ||
            (ts.isFunctionExpression(declaration) || ts.isArrowFunction(declaration) || ts.isClassExpression(declaration) ? getAssignedName(declaration) : undefined);
    }
    ts.getNameOfDeclaration = getNameOfDeclaration;
    function getAssignedName(node) {
        if (!node.parent) {
            return undefined;
        }
        else if (ts.isPropertyAssignment(node.parent) || ts.isBindingElement(node.parent)) {
            return node.parent.name;
        }
        else if (ts.isBinaryExpression(node.parent) && node === node.parent.right) {
            if (ts.isIdentifier(node.parent.left)) {
                return node.parent.left;
            }
            else if (ts.isAccessExpression(node.parent.left)) {
                return ts.getElementOrPropertyAccessArgumentExpressionOrName(node.parent.left);
            }
        }
        else if (ts.isVariableDeclaration(node.parent) && ts.isIdentifier(node.parent.name)) {
            return node.parent.name;
        }
    }
    ts.getAssignedName = getAssignedName;
    function getJSDocParameterTagsWorker(param, noCache) {
        if (param.name) {
            if (ts.isIdentifier(param.name)) {
                var name_1 = param.name.escapedText;
                return getJSDocTagsWorker(param.parent, noCache).filter(function (tag) { return ts.isJSDocParameterTag(tag) && ts.isIdentifier(tag.name) && tag.name.escapedText === name_1; });
            }
            else {
                var i = param.parent.parameters.indexOf(param);
                ts.Debug.assert(i > -1, "Parameters should always be in their parents' parameter list");
                var paramTags = getJSDocTagsWorker(param.parent, noCache).filter(ts.isJSDocParameterTag);
                if (i < paramTags.length) {
                    return [paramTags[i]];
                }
            }
        }
        return ts.emptyArray;
    }
    function getJSDocParameterTags(param) {
        return getJSDocParameterTagsWorker(param, false);
    }
    ts.getJSDocParameterTags = getJSDocParameterTags;
    function getJSDocParameterTagsNoCache(param) {
        return getJSDocParameterTagsWorker(param, true);
    }
    ts.getJSDocParameterTagsNoCache = getJSDocParameterTagsNoCache;
    function getJSDocTypeParameterTagsWorker(param, noCache) {
        var name = param.name.escapedText;
        return getJSDocTagsWorker(param.parent, noCache).filter(function (tag) {
            return ts.isJSDocTemplateTag(tag) && tag.typeParameters.some(function (tp) { return tp.name.escapedText === name; });
        });
    }
    function getJSDocTypeParameterTags(param) {
        return getJSDocTypeParameterTagsWorker(param, false);
    }
    ts.getJSDocTypeParameterTags = getJSDocTypeParameterTags;
    function getJSDocTypeParameterTagsNoCache(param) {
        return getJSDocTypeParameterTagsWorker(param, true);
    }
    ts.getJSDocTypeParameterTagsNoCache = getJSDocTypeParameterTagsNoCache;
    function hasJSDocParameterTags(node) {
        return !!getFirstJSDocTag(node, ts.isJSDocParameterTag);
    }
    ts.hasJSDocParameterTags = hasJSDocParameterTags;
    function getJSDocAugmentsTag(node) {
        return getFirstJSDocTag(node, ts.isJSDocAugmentsTag);
    }
    ts.getJSDocAugmentsTag = getJSDocAugmentsTag;
    function getJSDocImplementsTags(node) {
        return getAllJSDocTags(node, ts.isJSDocImplementsTag);
    }
    ts.getJSDocImplementsTags = getJSDocImplementsTags;
    function getJSDocClassTag(node) {
        return getFirstJSDocTag(node, ts.isJSDocClassTag);
    }
    ts.getJSDocClassTag = getJSDocClassTag;
    function getJSDocPublicTag(node) {
        return getFirstJSDocTag(node, ts.isJSDocPublicTag);
    }
    ts.getJSDocPublicTag = getJSDocPublicTag;
    function getJSDocPublicTagNoCache(node) {
        return getFirstJSDocTag(node, ts.isJSDocPublicTag, true);
    }
    ts.getJSDocPublicTagNoCache = getJSDocPublicTagNoCache;
    function getJSDocPrivateTag(node) {
        return getFirstJSDocTag(node, ts.isJSDocPrivateTag);
    }
    ts.getJSDocPrivateTag = getJSDocPrivateTag;
    function getJSDocPrivateTagNoCache(node) {
        return getFirstJSDocTag(node, ts.isJSDocPrivateTag, true);
    }
    ts.getJSDocPrivateTagNoCache = getJSDocPrivateTagNoCache;
    function getJSDocProtectedTag(node) {
        return getFirstJSDocTag(node, ts.isJSDocProtectedTag);
    }
    ts.getJSDocProtectedTag = getJSDocProtectedTag;
    function getJSDocProtectedTagNoCache(node) {
        return getFirstJSDocTag(node, ts.isJSDocProtectedTag, true);
    }
    ts.getJSDocProtectedTagNoCache = getJSDocProtectedTagNoCache;
    function getJSDocReadonlyTag(node) {
        return getFirstJSDocTag(node, ts.isJSDocReadonlyTag);
    }
    ts.getJSDocReadonlyTag = getJSDocReadonlyTag;
    function getJSDocReadonlyTagNoCache(node) {
        return getFirstJSDocTag(node, ts.isJSDocReadonlyTag, true);
    }
    ts.getJSDocReadonlyTagNoCache = getJSDocReadonlyTagNoCache;
    function getJSDocOverrideTagNoCache(node) {
        return getFirstJSDocTag(node, ts.isJSDocOverrideTag, true);
    }
    ts.getJSDocOverrideTagNoCache = getJSDocOverrideTagNoCache;
    function getJSDocDeprecatedTag(node) {
        return getFirstJSDocTag(node, ts.isJSDocDeprecatedTag);
    }
    ts.getJSDocDeprecatedTag = getJSDocDeprecatedTag;
    function getJSDocDeprecatedTagNoCache(node) {
        return getFirstJSDocTag(node, ts.isJSDocDeprecatedTag, true);
    }
    ts.getJSDocDeprecatedTagNoCache = getJSDocDeprecatedTagNoCache;
    function getJSDocEnumTag(node) {
        return getFirstJSDocTag(node, ts.isJSDocEnumTag);
    }
    ts.getJSDocEnumTag = getJSDocEnumTag;
    function getJSDocThisTag(node) {
        return getFirstJSDocTag(node, ts.isJSDocThisTag);
    }
    ts.getJSDocThisTag = getJSDocThisTag;
    function getJSDocReturnTag(node) {
        return getFirstJSDocTag(node, ts.isJSDocReturnTag);
    }
    ts.getJSDocReturnTag = getJSDocReturnTag;
    function getJSDocTemplateTag(node) {
        return getFirstJSDocTag(node, ts.isJSDocTemplateTag);
    }
    ts.getJSDocTemplateTag = getJSDocTemplateTag;
    function getJSDocTypeTag(node) {
        var tag = getFirstJSDocTag(node, ts.isJSDocTypeTag);
        if (tag && tag.typeExpression && tag.typeExpression.type) {
            return tag;
        }
        return undefined;
    }
    ts.getJSDocTypeTag = getJSDocTypeTag;
    function getJSDocType(node) {
        var tag = getFirstJSDocTag(node, ts.isJSDocTypeTag);
        if (!tag && ts.isParameter(node)) {
            tag = ts.find(getJSDocParameterTags(node), function (tag) { return !!tag.typeExpression; });
        }
        return tag && tag.typeExpression && tag.typeExpression.type;
    }
    ts.getJSDocType = getJSDocType;
    function getJSDocReturnType(node) {
        var returnTag = getJSDocReturnTag(node);
        if (returnTag && returnTag.typeExpression) {
            return returnTag.typeExpression.type;
        }
        var typeTag = getJSDocTypeTag(node);
        if (typeTag && typeTag.typeExpression) {
            var type = typeTag.typeExpression.type;
            if (ts.isTypeLiteralNode(type)) {
                var sig = ts.find(type.members, ts.isCallSignatureDeclaration);
                return sig && sig.type;
            }
            if (ts.isFunctionTypeNode(type) || ts.isJSDocFunctionType(type)) {
                return type.type;
            }
        }
    }
    ts.getJSDocReturnType = getJSDocReturnType;
    function getJSDocTagsWorker(node, noCache) {
        var tags = node.jsDocCache;
        if (tags === undefined || noCache) {
            var comments = ts.getJSDocCommentsAndTags(node, noCache);
            ts.Debug.assert(comments.length < 2 || comments[0] !== comments[1]);
            tags = ts.flatMap(comments, function (j) { return ts.isJSDoc(j) ? j.tags : j; });
            if (!noCache) {
                node.jsDocCache = tags;
            }
        }
        return tags;
    }
    function getJSDocTags(node) {
        return getJSDocTagsWorker(node, false);
    }
    ts.getJSDocTags = getJSDocTags;
    function getJSDocTagsNoCache(node) {
        return getJSDocTagsWorker(node, true);
    }
    ts.getJSDocTagsNoCache = getJSDocTagsNoCache;
    function getFirstJSDocTag(node, predicate, noCache) {
        return ts.find(getJSDocTagsWorker(node, noCache), predicate);
    }
    function getAllJSDocTags(node, predicate) {
        return getJSDocTags(node).filter(predicate);
    }
    ts.getAllJSDocTags = getAllJSDocTags;
    function getAllJSDocTagsOfKind(node, kind) {
        return getJSDocTags(node).filter(function (doc) { return doc.kind === kind; });
    }
    ts.getAllJSDocTagsOfKind = getAllJSDocTagsOfKind;
    function getTextOfJSDocComment(comment) {
        return typeof comment === "string" ? comment
            : comment === null || comment === void 0 ? void 0 : comment.map(function (c) { return c.kind === 321 ? c.text : formatJSDocLink(c); }).join("");
    }
    ts.getTextOfJSDocComment = getTextOfJSDocComment;
    function formatJSDocLink(link) {
        var kind = link.kind === 324 ? "link"
            : link.kind === 325 ? "linkcode"
                : "linkplain";
        var name = link.name ? ts.entityNameToString(link.name) : "";
        var space = link.name && link.text.startsWith("://") ? "" : " ";
        return "{@".concat(kind, " ").concat(name).concat(space).concat(link.text, "}");
    }
    function getEffectiveTypeParameterDeclarations(node) {
        if (ts.isJSDocSignature(node)) {
            return ts.emptyArray;
        }
        if (ts.isJSDocTypeAlias(node)) {
            ts.Debug.assert(node.parent.kind === 320);
            return ts.flatMap(node.parent.tags, function (tag) { return ts.isJSDocTemplateTag(tag) ? tag.typeParameters : undefined; });
        }
        if (node.typeParameters) {
            return node.typeParameters;
        }
        if (ts.isInJSFile(node)) {
            var decls = ts.getJSDocTypeParameterDeclarations(node);
            if (decls.length) {
                return decls;
            }
            var typeTag = getJSDocType(node);
            if (typeTag && ts.isFunctionTypeNode(typeTag) && typeTag.typeParameters) {
                return typeTag.typeParameters;
            }
        }
        return ts.emptyArray;
    }
    ts.getEffectiveTypeParameterDeclarations = getEffectiveTypeParameterDeclarations;
    function getEffectiveConstraintOfTypeParameter(node) {
        return node.constraint ? node.constraint :
            ts.isJSDocTemplateTag(node.parent) && node === node.parent.typeParameters[0] ? node.parent.constraint :
                undefined;
    }
    ts.getEffectiveConstraintOfTypeParameter = getEffectiveConstraintOfTypeParameter;
    function isMemberName(node) {
        return node.kind === 79 || node.kind === 80;
    }
    ts.isMemberName = isMemberName;
    function isGetOrSetAccessorDeclaration(node) {
        return node.kind === 173 || node.kind === 172;
    }
    ts.isGetOrSetAccessorDeclaration = isGetOrSetAccessorDeclaration;
    function isPropertyAccessChain(node) {
        return ts.isPropertyAccessExpression(node) && !!(node.flags & 32);
    }
    ts.isPropertyAccessChain = isPropertyAccessChain;
    function isElementAccessChain(node) {
        return ts.isElementAccessExpression(node) && !!(node.flags & 32);
    }
    ts.isElementAccessChain = isElementAccessChain;
    function isCallChain(node) {
        return ts.isCallExpression(node) && !!(node.flags & 32);
    }
    ts.isCallChain = isCallChain;
    function isOptionalChain(node) {
        var kind = node.kind;
        return !!(node.flags & 32) &&
            (kind === 206
                || kind === 207
                || kind === 208
                || kind === 230);
    }
    ts.isOptionalChain = isOptionalChain;
    function isOptionalChainRoot(node) {
        return isOptionalChain(node) && !ts.isNonNullExpression(node) && !!node.questionDotToken;
    }
    ts.isOptionalChainRoot = isOptionalChainRoot;
    function isExpressionOfOptionalChainRoot(node) {
        return isOptionalChainRoot(node.parent) && node.parent.expression === node;
    }
    ts.isExpressionOfOptionalChainRoot = isExpressionOfOptionalChainRoot;
    function isOutermostOptionalChain(node) {
        return !isOptionalChain(node.parent)
            || isOptionalChainRoot(node.parent)
            || node !== node.parent.expression;
    }
    ts.isOutermostOptionalChain = isOutermostOptionalChain;
    function isNullishCoalesce(node) {
        return node.kind === 221 && node.operatorToken.kind === 60;
    }
    ts.isNullishCoalesce = isNullishCoalesce;
    function isConstTypeReference(node) {
        return ts.isTypeReferenceNode(node) && ts.isIdentifier(node.typeName) &&
            node.typeName.escapedText === "const" && !node.typeArguments;
    }
    ts.isConstTypeReference = isConstTypeReference;
    function skipPartiallyEmittedExpressions(node) {
        return ts.skipOuterExpressions(node, 8);
    }
    ts.skipPartiallyEmittedExpressions = skipPartiallyEmittedExpressions;
    function isNonNullChain(node) {
        return ts.isNonNullExpression(node) && !!(node.flags & 32);
    }
    ts.isNonNullChain = isNonNullChain;
    function isBreakOrContinueStatement(node) {
        return node.kind === 246 || node.kind === 245;
    }
    ts.isBreakOrContinueStatement = isBreakOrContinueStatement;
    function isNamedExportBindings(node) {
        return node.kind === 274 || node.kind === 273;
    }
    ts.isNamedExportBindings = isNamedExportBindings;
    function isUnparsedTextLike(node) {
        switch (node.kind) {
            case 302:
            case 303:
                return true;
            default:
                return false;
        }
    }
    ts.isUnparsedTextLike = isUnparsedTextLike;
    function isUnparsedNode(node) {
        return isUnparsedTextLike(node) ||
            node.kind === 300 ||
            node.kind === 304;
    }
    ts.isUnparsedNode = isUnparsedNode;
    function isJSDocPropertyLikeTag(node) {
        return node.kind === 347 || node.kind === 340;
    }
    ts.isJSDocPropertyLikeTag = isJSDocPropertyLikeTag;
    function isNode(node) {
        return isNodeKind(node.kind);
    }
    ts.isNode = isNode;
    function isNodeKind(kind) {
        return kind >= 161;
    }
    ts.isNodeKind = isNodeKind;
    function isTokenKind(kind) {
        return kind >= 0 && kind <= 160;
    }
    ts.isTokenKind = isTokenKind;
    function isToken(n) {
        return isTokenKind(n.kind);
    }
    ts.isToken = isToken;
    function isNodeArray(array) {
        return array.hasOwnProperty("pos") && array.hasOwnProperty("end");
    }
    ts.isNodeArray = isNodeArray;
    function isLiteralKind(kind) {
        return 8 <= kind && kind <= 14;
    }
    ts.isLiteralKind = isLiteralKind;
    function isLiteralExpression(node) {
        return isLiteralKind(node.kind);
    }
    ts.isLiteralExpression = isLiteralExpression;
    function isTemplateLiteralKind(kind) {
        return 14 <= kind && kind <= 17;
    }
    ts.isTemplateLiteralKind = isTemplateLiteralKind;
    function isTemplateLiteralToken(node) {
        return isTemplateLiteralKind(node.kind);
    }
    ts.isTemplateLiteralToken = isTemplateLiteralToken;
    function isTemplateMiddleOrTemplateTail(node) {
        var kind = node.kind;
        return kind === 16
            || kind === 17;
    }
    ts.isTemplateMiddleOrTemplateTail = isTemplateMiddleOrTemplateTail;
    function isImportOrExportSpecifier(node) {
        return ts.isImportSpecifier(node) || ts.isExportSpecifier(node);
    }
    ts.isImportOrExportSpecifier = isImportOrExportSpecifier;
    function isTypeOnlyImportOrExportDeclaration(node) {
        switch (node.kind) {
            case 270:
            case 275:
                return node.isTypeOnly || node.parent.parent.isTypeOnly;
            case 268:
                return node.parent.isTypeOnly;
            case 267:
            case 265:
                return node.isTypeOnly;
            default:
                return false;
        }
    }
    ts.isTypeOnlyImportOrExportDeclaration = isTypeOnlyImportOrExportDeclaration;
    function isAssertionKey(node) {
        return ts.isStringLiteral(node) || ts.isIdentifier(node);
    }
    ts.isAssertionKey = isAssertionKey;
    function isStringTextContainingNode(node) {
        return node.kind === 10 || isTemplateLiteralKind(node.kind);
    }
    ts.isStringTextContainingNode = isStringTextContainingNode;
    function isGeneratedIdentifier(node) {
        return ts.isIdentifier(node) && (node.autoGenerateFlags & 7) > 0;
    }
    ts.isGeneratedIdentifier = isGeneratedIdentifier;
    function isPrivateIdentifierClassElementDeclaration(node) {
        return (ts.isPropertyDeclaration(node) || isMethodOrAccessor(node)) && ts.isPrivateIdentifier(node.name);
    }
    ts.isPrivateIdentifierClassElementDeclaration = isPrivateIdentifierClassElementDeclaration;
    function isPrivateIdentifierPropertyAccessExpression(node) {
        return ts.isPropertyAccessExpression(node) && ts.isPrivateIdentifier(node.name);
    }
    ts.isPrivateIdentifierPropertyAccessExpression = isPrivateIdentifierPropertyAccessExpression;
    function isModifierKind(token) {
        switch (token) {
            case 126:
            case 131:
            case 85:
            case 135:
            case 88:
            case 93:
            case 101:
            case 123:
            case 121:
            case 122:
            case 145:
            case 124:
            case 144:
            case 159:
                return true;
        }
        return false;
    }
    ts.isModifierKind = isModifierKind;
    function isParameterPropertyModifier(kind) {
        return !!(ts.modifierToFlag(kind) & 16476);
    }
    ts.isParameterPropertyModifier = isParameterPropertyModifier;
    function isClassMemberModifier(idToken) {
        return isParameterPropertyModifier(idToken) || idToken === 124 || idToken === 159;
    }
    ts.isClassMemberModifier = isClassMemberModifier;
    function isModifier(node) {
        return isModifierKind(node.kind);
    }
    ts.isModifier = isModifier;
    function isEntityName(node) {
        var kind = node.kind;
        return kind === 161
            || kind === 79;
    }
    ts.isEntityName = isEntityName;
    function isPropertyName(node) {
        var kind = node.kind;
        return kind === 79
            || kind === 80
            || kind === 10
            || kind === 8
            || kind === 162;
    }
    ts.isPropertyName = isPropertyName;
    function isBindingName(node) {
        var kind = node.kind;
        return kind === 79
            || kind === 201
            || kind === 202;
    }
    ts.isBindingName = isBindingName;
    function isFunctionLike(node) {
        return !!node && isFunctionLikeKind(node.kind);
    }
    ts.isFunctionLike = isFunctionLike;
    function isFunctionLikeOrClassStaticBlockDeclaration(node) {
        return !!node && (isFunctionLikeKind(node.kind) || ts.isClassStaticBlockDeclaration(node));
    }
    ts.isFunctionLikeOrClassStaticBlockDeclaration = isFunctionLikeOrClassStaticBlockDeclaration;
    function isFunctionLikeDeclaration(node) {
        return node && isFunctionLikeDeclarationKind(node.kind);
    }
    ts.isFunctionLikeDeclaration = isFunctionLikeDeclaration;
    function isBooleanLiteral(node) {
        return node.kind === 110 || node.kind === 95;
    }
    ts.isBooleanLiteral = isBooleanLiteral;
    function isFunctionLikeDeclarationKind(kind) {
        switch (kind) {
            case 256:
            case 169:
            case 171:
            case 172:
            case 173:
            case 213:
            case 214:
                return true;
            default:
                return false;
        }
    }
    function isFunctionLikeKind(kind) {
        switch (kind) {
            case 168:
            case 174:
            case 323:
            case 175:
            case 176:
            case 179:
            case 317:
            case 180:
                return true;
            default:
                return isFunctionLikeDeclarationKind(kind);
        }
    }
    ts.isFunctionLikeKind = isFunctionLikeKind;
    function isFunctionOrModuleBlock(node) {
        return ts.isSourceFile(node) || ts.isModuleBlock(node) || ts.isBlock(node) && isFunctionLike(node.parent);
    }
    ts.isFunctionOrModuleBlock = isFunctionOrModuleBlock;
    function isClassElement(node) {
        var kind = node.kind;
        return kind === 171
            || kind === 167
            || kind === 169
            || kind === 172
            || kind === 173
            || kind === 176
            || kind === 170
            || kind === 234;
    }
    ts.isClassElement = isClassElement;
    function isClassLike(node) {
        return node && (node.kind === 257 || node.kind === 226);
    }
    ts.isClassLike = isClassLike;
    function isAccessor(node) {
        return node && (node.kind === 172 || node.kind === 173);
    }
    ts.isAccessor = isAccessor;
    function isMethodOrAccessor(node) {
        switch (node.kind) {
            case 169:
            case 172:
            case 173:
                return true;
            default:
                return false;
        }
    }
    ts.isMethodOrAccessor = isMethodOrAccessor;
    function isTypeElement(node) {
        var kind = node.kind;
        return kind === 175
            || kind === 174
            || kind === 166
            || kind === 168
            || kind === 176
            || kind === 172
            || kind === 173;
    }
    ts.isTypeElement = isTypeElement;
    function isClassOrTypeElement(node) {
        return isTypeElement(node) || isClassElement(node);
    }
    ts.isClassOrTypeElement = isClassOrTypeElement;
    function isObjectLiteralElementLike(node) {
        var kind = node.kind;
        return kind === 296
            || kind === 297
            || kind === 298
            || kind === 169
            || kind === 172
            || kind === 173;
    }
    ts.isObjectLiteralElementLike = isObjectLiteralElementLike;
    function isTypeNode(node) {
        return ts.isTypeNodeKind(node.kind);
    }
    ts.isTypeNode = isTypeNode;
    function isFunctionOrConstructorTypeNode(node) {
        switch (node.kind) {
            case 179:
            case 180:
                return true;
        }
        return false;
    }
    ts.isFunctionOrConstructorTypeNode = isFunctionOrConstructorTypeNode;
    function isBindingPattern(node) {
        if (node) {
            var kind = node.kind;
            return kind === 202
                || kind === 201;
        }
        return false;
    }
    ts.isBindingPattern = isBindingPattern;
    function isAssignmentPattern(node) {
        var kind = node.kind;
        return kind === 204
            || kind === 205;
    }
    ts.isAssignmentPattern = isAssignmentPattern;
    function isArrayBindingElement(node) {
        var kind = node.kind;
        return kind === 203
            || kind === 227;
    }
    ts.isArrayBindingElement = isArrayBindingElement;
    function isDeclarationBindingElement(bindingElement) {
        switch (bindingElement.kind) {
            case 254:
            case 164:
            case 203:
                return true;
        }
        return false;
    }
    ts.isDeclarationBindingElement = isDeclarationBindingElement;
    function isBindingOrAssignmentPattern(node) {
        return isObjectBindingOrAssignmentPattern(node)
            || isArrayBindingOrAssignmentPattern(node);
    }
    ts.isBindingOrAssignmentPattern = isBindingOrAssignmentPattern;
    function isObjectBindingOrAssignmentPattern(node) {
        switch (node.kind) {
            case 201:
            case 205:
                return true;
        }
        return false;
    }
    ts.isObjectBindingOrAssignmentPattern = isObjectBindingOrAssignmentPattern;
    function isObjectBindingOrAssignmentElement(node) {
        switch (node.kind) {
            case 203:
            case 296:
            case 297:
            case 298:
                return true;
        }
        return false;
    }
    ts.isObjectBindingOrAssignmentElement = isObjectBindingOrAssignmentElement;
    function isArrayBindingOrAssignmentPattern(node) {
        switch (node.kind) {
            case 202:
            case 204:
                return true;
        }
        return false;
    }
    ts.isArrayBindingOrAssignmentPattern = isArrayBindingOrAssignmentPattern;
    function isPropertyAccessOrQualifiedNameOrImportTypeNode(node) {
        var kind = node.kind;
        return kind === 206
            || kind === 161
            || kind === 200;
    }
    ts.isPropertyAccessOrQualifiedNameOrImportTypeNode = isPropertyAccessOrQualifiedNameOrImportTypeNode;
    function isPropertyAccessOrQualifiedName(node) {
        var kind = node.kind;
        return kind === 206
            || kind === 161;
    }
    ts.isPropertyAccessOrQualifiedName = isPropertyAccessOrQualifiedName;
    function isCallLikeExpression(node) {
        switch (node.kind) {
            case 280:
            case 279:
            case 208:
            case 209:
            case 210:
            case 165:
                return true;
            default:
                return false;
        }
    }
    ts.isCallLikeExpression = isCallLikeExpression;
    function isCallOrNewExpression(node) {
        return node.kind === 208 || node.kind === 209;
    }
    ts.isCallOrNewExpression = isCallOrNewExpression;
    function isTemplateLiteral(node) {
        var kind = node.kind;
        return kind === 223
            || kind === 14;
    }
    ts.isTemplateLiteral = isTemplateLiteral;
    function isLeftHandSideExpression(node) {
        return isLeftHandSideExpressionKind(skipPartiallyEmittedExpressions(node).kind);
    }
    ts.isLeftHandSideExpression = isLeftHandSideExpression;
    function isLeftHandSideExpressionKind(kind) {
        switch (kind) {
            case 206:
            case 207:
            case 209:
            case 208:
            case 278:
            case 279:
            case 282:
            case 210:
            case 204:
            case 212:
            case 205:
            case 226:
            case 213:
            case 79:
            case 80:
            case 13:
            case 8:
            case 9:
            case 10:
            case 14:
            case 223:
            case 95:
            case 104:
            case 108:
            case 110:
            case 106:
            case 230:
            case 228:
            case 231:
            case 100:
                return true;
            default:
                return false;
        }
    }
    function isUnaryExpression(node) {
        return isUnaryExpressionKind(skipPartiallyEmittedExpressions(node).kind);
    }
    ts.isUnaryExpression = isUnaryExpression;
    function isUnaryExpressionKind(kind) {
        switch (kind) {
            case 219:
            case 220:
            case 215:
            case 216:
            case 217:
            case 218:
            case 211:
                return true;
            default:
                return isLeftHandSideExpressionKind(kind);
        }
    }
    function isUnaryExpressionWithWrite(expr) {
        switch (expr.kind) {
            case 220:
                return true;
            case 219:
                return expr.operator === 45 ||
                    expr.operator === 46;
            default:
                return false;
        }
    }
    ts.isUnaryExpressionWithWrite = isUnaryExpressionWithWrite;
    function isExpression(node) {
        return isExpressionKind(skipPartiallyEmittedExpressions(node).kind);
    }
    ts.isExpression = isExpression;
    function isExpressionKind(kind) {
        switch (kind) {
            case 222:
            case 224:
            case 214:
            case 221:
            case 225:
            case 229:
            case 227:
            case 351:
            case 350:
                return true;
            default:
                return isUnaryExpressionKind(kind);
        }
    }
    function isAssertionExpression(node) {
        var kind = node.kind;
        return kind === 211
            || kind === 229;
    }
    ts.isAssertionExpression = isAssertionExpression;
    function isNotEmittedOrPartiallyEmittedNode(node) {
        return ts.isNotEmittedStatement(node)
            || ts.isPartiallyEmittedExpression(node);
    }
    ts.isNotEmittedOrPartiallyEmittedNode = isNotEmittedOrPartiallyEmittedNode;
    function isIterationStatement(node, lookInLabeledStatements) {
        switch (node.kind) {
            case 242:
            case 243:
            case 244:
            case 240:
            case 241:
                return true;
            case 250:
                return lookInLabeledStatements && isIterationStatement(node.statement, lookInLabeledStatements);
        }
        return false;
    }
    ts.isIterationStatement = isIterationStatement;
    function isScopeMarker(node) {
        return ts.isExportAssignment(node) || ts.isExportDeclaration(node);
    }
    ts.isScopeMarker = isScopeMarker;
    function hasScopeMarker(statements) {
        return ts.some(statements, isScopeMarker);
    }
    ts.hasScopeMarker = hasScopeMarker;
    function needsScopeMarker(result) {
        return !ts.isAnyImportOrReExport(result) && !ts.isExportAssignment(result) && !ts.hasSyntacticModifier(result, 1) && !ts.isAmbientModule(result);
    }
    ts.needsScopeMarker = needsScopeMarker;
    function isExternalModuleIndicator(result) {
        return ts.isAnyImportOrReExport(result) || ts.isExportAssignment(result) || ts.hasSyntacticModifier(result, 1);
    }
    ts.isExternalModuleIndicator = isExternalModuleIndicator;
    function isForInOrOfStatement(node) {
        return node.kind === 243 || node.kind === 244;
    }
    ts.isForInOrOfStatement = isForInOrOfStatement;
    function isConciseBody(node) {
        return ts.isBlock(node)
            || isExpression(node);
    }
    ts.isConciseBody = isConciseBody;
    function isFunctionBody(node) {
        return ts.isBlock(node);
    }
    ts.isFunctionBody = isFunctionBody;
    function isForInitializer(node) {
        return ts.isVariableDeclarationList(node)
            || isExpression(node);
    }
    ts.isForInitializer = isForInitializer;
    function isModuleBody(node) {
        var kind = node.kind;
        return kind === 262
            || kind === 261
            || kind === 79;
    }
    ts.isModuleBody = isModuleBody;
    function isNamespaceBody(node) {
        var kind = node.kind;
        return kind === 262
            || kind === 261;
    }
    ts.isNamespaceBody = isNamespaceBody;
    function isJSDocNamespaceBody(node) {
        var kind = node.kind;
        return kind === 79
            || kind === 261;
    }
    ts.isJSDocNamespaceBody = isJSDocNamespaceBody;
    function isNamedImportBindings(node) {
        var kind = node.kind;
        return kind === 269
            || kind === 268;
    }
    ts.isNamedImportBindings = isNamedImportBindings;
    function isModuleOrEnumDeclaration(node) {
        return node.kind === 261 || node.kind === 260;
    }
    ts.isModuleOrEnumDeclaration = isModuleOrEnumDeclaration;
    function isDeclarationKind(kind) {
        return kind === 214
            || kind === 203
            || kind === 257
            || kind === 226
            || kind === 170
            || kind === 171
            || kind === 260
            || kind === 299
            || kind === 275
            || kind === 256
            || kind === 213
            || kind === 172
            || kind === 267
            || kind === 265
            || kind === 270
            || kind === 258
            || kind === 285
            || kind === 169
            || kind === 168
            || kind === 261
            || kind === 264
            || kind === 268
            || kind === 274
            || kind === 164
            || kind === 296
            || kind === 167
            || kind === 166
            || kind === 173
            || kind === 297
            || kind === 259
            || kind === 163
            || kind === 254
            || kind === 345
            || kind === 338
            || kind === 347;
    }
    function isDeclarationStatementKind(kind) {
        return kind === 256
            || kind === 276
            || kind === 257
            || kind === 258
            || kind === 259
            || kind === 260
            || kind === 261
            || kind === 266
            || kind === 265
            || kind === 272
            || kind === 271
            || kind === 264;
    }
    function isStatementKindButNotDeclarationKind(kind) {
        return kind === 246
            || kind === 245
            || kind === 253
            || kind === 240
            || kind === 238
            || kind === 236
            || kind === 243
            || kind === 244
            || kind === 242
            || kind === 239
            || kind === 250
            || kind === 247
            || kind === 249
            || kind === 251
            || kind === 252
            || kind === 237
            || kind === 241
            || kind === 248
            || kind === 349
            || kind === 353
            || kind === 352;
    }
    function isDeclaration(node) {
        if (node.kind === 163) {
            return (node.parent && node.parent.kind !== 344) || ts.isInJSFile(node);
        }
        return isDeclarationKind(node.kind);
    }
    ts.isDeclaration = isDeclaration;
    function isDeclarationStatement(node) {
        return isDeclarationStatementKind(node.kind);
    }
    ts.isDeclarationStatement = isDeclarationStatement;
    function isStatementButNotDeclaration(node) {
        return isStatementKindButNotDeclarationKind(node.kind);
    }
    ts.isStatementButNotDeclaration = isStatementButNotDeclaration;
    function isStatement(node) {
        var kind = node.kind;
        return isStatementKindButNotDeclarationKind(kind)
            || isDeclarationStatementKind(kind)
            || isBlockStatement(node);
    }
    ts.isStatement = isStatement;
    function isBlockStatement(node) {
        if (node.kind !== 235)
            return false;
        if (node.parent !== undefined) {
            if (node.parent.kind === 252 || node.parent.kind === 292) {
                return false;
            }
        }
        return !ts.isFunctionBlock(node);
    }
    function isStatementOrBlock(node) {
        var kind = node.kind;
        return isStatementKindButNotDeclarationKind(kind)
            || isDeclarationStatementKind(kind)
            || kind === 235;
    }
    ts.isStatementOrBlock = isStatementOrBlock;
    function isModuleReference(node) {
        var kind = node.kind;
        return kind === 277
            || kind === 161
            || kind === 79;
    }
    ts.isModuleReference = isModuleReference;
    function isJsxTagNameExpression(node) {
        var kind = node.kind;
        return kind === 108
            || kind === 79
            || kind === 206;
    }
    ts.isJsxTagNameExpression = isJsxTagNameExpression;
    function isJsxChild(node) {
        var kind = node.kind;
        return kind === 278
            || kind === 288
            || kind === 279
            || kind === 11
            || kind === 282;
    }
    ts.isJsxChild = isJsxChild;
    function isJsxAttributeLike(node) {
        var kind = node.kind;
        return kind === 285
            || kind === 287;
    }
    ts.isJsxAttributeLike = isJsxAttributeLike;
    function isStringLiteralOrJsxExpression(node) {
        var kind = node.kind;
        return kind === 10
            || kind === 288;
    }
    ts.isStringLiteralOrJsxExpression = isStringLiteralOrJsxExpression;
    function isJsxOpeningLikeElement(node) {
        var kind = node.kind;
        return kind === 280
            || kind === 279;
    }
    ts.isJsxOpeningLikeElement = isJsxOpeningLikeElement;
    function isCaseOrDefaultClause(node) {
        var kind = node.kind;
        return kind === 289
            || kind === 290;
    }
    ts.isCaseOrDefaultClause = isCaseOrDefaultClause;
    function isJSDocNode(node) {
        return node.kind >= 309 && node.kind <= 347;
    }
    ts.isJSDocNode = isJSDocNode;
    function isJSDocCommentContainingNode(node) {
        return node.kind === 320
            || node.kind === 319
            || node.kind === 321
            || isJSDocLinkLike(node)
            || isJSDocTag(node)
            || ts.isJSDocTypeLiteral(node)
            || ts.isJSDocSignature(node);
    }
    ts.isJSDocCommentContainingNode = isJSDocCommentContainingNode;
    function isJSDocTag(node) {
        return node.kind >= 327 && node.kind <= 347;
    }
    ts.isJSDocTag = isJSDocTag;
    function isSetAccessor(node) {
        return node.kind === 173;
    }
    ts.isSetAccessor = isSetAccessor;
    function isGetAccessor(node) {
        return node.kind === 172;
    }
    ts.isGetAccessor = isGetAccessor;
    function hasJSDocNodes(node) {
        var jsDoc = node.jsDoc;
        return !!jsDoc && jsDoc.length > 0;
    }
    ts.hasJSDocNodes = hasJSDocNodes;
    function hasType(node) {
        return !!node.type;
    }
    ts.hasType = hasType;
    function hasInitializer(node) {
        return !!node.initializer;
    }
    ts.hasInitializer = hasInitializer;
    function hasOnlyExpressionInitializer(node) {
        switch (node.kind) {
            case 254:
            case 164:
            case 203:
            case 166:
            case 167:
            case 296:
            case 299:
                return true;
            default:
                return false;
        }
    }
    ts.hasOnlyExpressionInitializer = hasOnlyExpressionInitializer;
    function isObjectLiteralElement(node) {
        return node.kind === 285 || node.kind === 287 || isObjectLiteralElementLike(node);
    }
    ts.isObjectLiteralElement = isObjectLiteralElement;
    function isTypeReferenceType(node) {
        return node.kind === 178 || node.kind === 228;
    }
    ts.isTypeReferenceType = isTypeReferenceType;
    var MAX_SMI_X86 = 1073741823;
    function guessIndentation(lines) {
        var indentation = MAX_SMI_X86;
        for (var _i = 0, lines_1 = lines; _i < lines_1.length; _i++) {
            var line = lines_1[_i];
            if (!line.length) {
                continue;
            }
            var i = 0;
            for (; i < line.length && i < indentation; i++) {
                if (!ts.isWhiteSpaceLike(line.charCodeAt(i))) {
                    break;
                }
            }
            if (i < indentation) {
                indentation = i;
            }
            if (indentation === 0) {
                return 0;
            }
        }
        return indentation === MAX_SMI_X86 ? undefined : indentation;
    }
    ts.guessIndentation = guessIndentation;
    function isStringLiteralLike(node) {
        return node.kind === 10 || node.kind === 14;
    }
    ts.isStringLiteralLike = isStringLiteralLike;
    function isJSDocLinkLike(node) {
        return node.kind === 324 || node.kind === 325 || node.kind === 326;
    }
    ts.isJSDocLinkLike = isJSDocLinkLike;
})(ts || (ts = {}));
var ts;
(function (ts) {
    ts.resolvingEmptyArray = [];
    ts.externalHelpersModuleNameText = "tslib";
    ts.defaultMaximumTruncationLength = 160;
    ts.noTruncationMaximumTruncationLength = 1000000;
    function getDeclarationOfKind(symbol, kind) {
        var declarations = symbol.declarations;
        if (declarations) {
            for (var _i = 0, declarations_1 = declarations; _i < declarations_1.length; _i++) {
                var declaration = declarations_1[_i];
                if (declaration.kind === kind) {
                    return declaration;
                }
            }
        }
        return undefined;
    }
    ts.getDeclarationOfKind = getDeclarationOfKind;
    function getDeclarationsOfKind(symbol, kind) {
        return ts.filter(symbol.declarations || ts.emptyArray, function (d) { return d.kind === kind; });
    }
    ts.getDeclarationsOfKind = getDeclarationsOfKind;
    function createSymbolTable(symbols) {
        var result = new ts.Map();
        if (symbols) {
            for (var _i = 0, symbols_1 = symbols; _i < symbols_1.length; _i++) {
                var symbol = symbols_1[_i];
                result.set(symbol.escapedName, symbol);
            }
        }
        return result;
    }
    ts.createSymbolTable = createSymbolTable;
    function isTransientSymbol(symbol) {
        return (symbol.flags & 33554432) !== 0;
    }
    ts.isTransientSymbol = isTransientSymbol;
    var stringWriter = createSingleLineStringWriter();
    function createSingleLineStringWriter() {
        var str = "";
        var writeText = function (text) { return str += text; };
        return {
            getText: function () { return str; },
            write: writeText,
            rawWrite: writeText,
            writeKeyword: writeText,
            writeOperator: writeText,
            writePunctuation: writeText,
            writeSpace: writeText,
            writeStringLiteral: writeText,
            writeLiteral: writeText,
            writeParameter: writeText,
            writeProperty: writeText,
            writeSymbol: function (s, _) { return writeText(s); },
            writeTrailingSemicolon: writeText,
            writeComment: writeText,
            getTextPos: function () { return str.length; },
            getLine: function () { return 0; },
            getColumn: function () { return 0; },
            getIndent: function () { return 0; },
            isAtStartOfLine: function () { return false; },
            hasTrailingComment: function () { return false; },
            hasTrailingWhitespace: function () { return !!str.length && ts.isWhiteSpaceLike(str.charCodeAt(str.length - 1)); },
            writeLine: function () { return str += " "; },
            increaseIndent: ts.noop,
            decreaseIndent: ts.noop,
            clear: function () { return str = ""; },
            trackSymbol: function () { return false; },
            reportInaccessibleThisError: ts.noop,
            reportInaccessibleUniqueSymbolError: ts.noop,
            reportPrivateInBaseOfClassExpression: ts.noop,
        };
    }
    function changesAffectModuleResolution(oldOptions, newOptions) {
        return oldOptions.configFilePath !== newOptions.configFilePath ||
            optionsHaveModuleResolutionChanges(oldOptions, newOptions);
    }
    ts.changesAffectModuleResolution = changesAffectModuleResolution;
    function optionsHaveModuleResolutionChanges(oldOptions, newOptions) {
        return optionsHaveChanges(oldOptions, newOptions, ts.moduleResolutionOptionDeclarations);
    }
    ts.optionsHaveModuleResolutionChanges = optionsHaveModuleResolutionChanges;
    function changesAffectingProgramStructure(oldOptions, newOptions) {
        return optionsHaveChanges(oldOptions, newOptions, ts.optionsAffectingProgramStructure);
    }
    ts.changesAffectingProgramStructure = changesAffectingProgramStructure;
    function optionsHaveChanges(oldOptions, newOptions, optionDeclarations) {
        return oldOptions !== newOptions && optionDeclarations.some(function (o) {
            return !isJsonEqual(getCompilerOptionValue(oldOptions, o), getCompilerOptionValue(newOptions, o));
        });
    }
    ts.optionsHaveChanges = optionsHaveChanges;
    function forEachAncestor(node, callback) {
        while (true) {
            var res = callback(node);
            if (res === "quit")
                return undefined;
            if (res !== undefined)
                return res;
            if (ts.isSourceFile(node))
                return undefined;
            node = node.parent;
        }
    }
    ts.forEachAncestor = forEachAncestor;
    function forEachEntry(map, callback) {
        var iterator = map.entries();
        for (var iterResult = iterator.next(); !iterResult.done; iterResult = iterator.next()) {
            var _a = iterResult.value, key = _a[0], value = _a[1];
            var result = callback(value, key);
            if (result) {
                return result;
            }
        }
        return undefined;
    }
    ts.forEachEntry = forEachEntry;
    function forEachKey(map, callback) {
        var iterator = map.keys();
        for (var iterResult = iterator.next(); !iterResult.done; iterResult = iterator.next()) {
            var result = callback(iterResult.value);
            if (result) {
                return result;
            }
        }
        return undefined;
    }
    ts.forEachKey = forEachKey;
    function copyEntries(source, target) {
        source.forEach(function (value, key) {
            target.set(key, value);
        });
    }
    ts.copyEntries = copyEntries;
    function usingSingleLineStringWriter(action) {
        var oldString = stringWriter.getText();
        try {
            action(stringWriter);
            return stringWriter.getText();
        }
        finally {
            stringWriter.clear();
            stringWriter.writeKeyword(oldString);
        }
    }
    ts.usingSingleLineStringWriter = usingSingleLineStringWriter;
    function getFullWidth(node) {
        return node.end - node.pos;
    }
    ts.getFullWidth = getFullWidth;
    function getResolvedModule(sourceFile, moduleNameText, mode) {
        return sourceFile && sourceFile.resolvedModules && sourceFile.resolvedModules.get(moduleNameText, mode);
    }
    ts.getResolvedModule = getResolvedModule;
    function setResolvedModule(sourceFile, moduleNameText, resolvedModule, mode) {
        if (!sourceFile.resolvedModules) {
            sourceFile.resolvedModules = ts.createModeAwareCache();
        }
        sourceFile.resolvedModules.set(moduleNameText, mode, resolvedModule);
    }
    ts.setResolvedModule = setResolvedModule;
    function setResolvedTypeReferenceDirective(sourceFile, typeReferenceDirectiveName, resolvedTypeReferenceDirective) {
        if (!sourceFile.resolvedTypeReferenceDirectiveNames) {
            sourceFile.resolvedTypeReferenceDirectiveNames = ts.createModeAwareCache();
        }
        sourceFile.resolvedTypeReferenceDirectiveNames.set(typeReferenceDirectiveName, undefined, resolvedTypeReferenceDirective);
    }
    ts.setResolvedTypeReferenceDirective = setResolvedTypeReferenceDirective;
    function projectReferenceIsEqualTo(oldRef, newRef) {
        return oldRef.path === newRef.path &&
            !oldRef.prepend === !newRef.prepend &&
            !oldRef.circular === !newRef.circular;
    }
    ts.projectReferenceIsEqualTo = projectReferenceIsEqualTo;
    function moduleResolutionIsEqualTo(oldResolution, newResolution) {
        return oldResolution.isExternalLibraryImport === newResolution.isExternalLibraryImport &&
            oldResolution.extension === newResolution.extension &&
            oldResolution.resolvedFileName === newResolution.resolvedFileName &&
            oldResolution.originalPath === newResolution.originalPath &&
            packageIdIsEqual(oldResolution.packageId, newResolution.packageId);
    }
    ts.moduleResolutionIsEqualTo = moduleResolutionIsEqualTo;
    function packageIdIsEqual(a, b) {
        return a === b || !!a && !!b && a.name === b.name && a.subModuleName === b.subModuleName && a.version === b.version;
    }
    function packageIdToPackageName(_a) {
        var name = _a.name, subModuleName = _a.subModuleName;
        return subModuleName ? "".concat(name, "/").concat(subModuleName) : name;
    }
    ts.packageIdToPackageName = packageIdToPackageName;
    function packageIdToString(packageId) {
        return "".concat(packageIdToPackageName(packageId), "@").concat(packageId.version);
    }
    ts.packageIdToString = packageIdToString;
    function typeDirectiveIsEqualTo(oldResolution, newResolution) {
        return oldResolution.resolvedFileName === newResolution.resolvedFileName
            && oldResolution.primary === newResolution.primary
            && oldResolution.originalPath === newResolution.originalPath;
    }
    ts.typeDirectiveIsEqualTo = typeDirectiveIsEqualTo;
    function hasChangesInResolutions(names, newResolutions, oldResolutions, oldSourceFile, comparer) {
        ts.Debug.assert(names.length === newResolutions.length);
        for (var i = 0; i < names.length; i++) {
            var newResolution = newResolutions[i];
            var entry = names[i];
            var name = !ts.isString(entry) ? entry.fileName.toLowerCase() : entry;
            var mode = !ts.isString(entry) ? ts.getModeForFileReference(entry, oldSourceFile === null || oldSourceFile === void 0 ? void 0 : oldSourceFile.impliedNodeFormat) : oldSourceFile && ts.getModeForResolutionAtIndex(oldSourceFile, i);
            var oldResolution = oldResolutions && oldResolutions.get(name, mode);
            var changed = oldResolution
                ? !newResolution || !comparer(oldResolution, newResolution)
                : newResolution;
            if (changed) {
                return true;
            }
        }
        return false;
    }
    ts.hasChangesInResolutions = hasChangesInResolutions;
    function containsParseError(node) {
        aggregateChildData(node);
        return (node.flags & 524288) !== 0;
    }
    ts.containsParseError = containsParseError;
    function aggregateChildData(node) {
        if (!(node.flags & 1048576)) {
            var thisNodeOrAnySubNodesHasError = ((node.flags & 131072) !== 0) ||
                ts.forEachChild(node, containsParseError);
            if (thisNodeOrAnySubNodesHasError) {
                node.flags |= 524288;
            }
            node.flags |= 1048576;
        }
    }
    function getSourceFileOfNode(node) {
        while (node && node.kind !== 305) {
            node = node.parent;
        }
        return node;
    }
    ts.getSourceFileOfNode = getSourceFileOfNode;
    function getSourceFileOfModule(module) {
        return getSourceFileOfNode(module.valueDeclaration || getNonAugmentationDeclaration(module));
    }
    ts.getSourceFileOfModule = getSourceFileOfModule;
    function isPlainJsFile(file, checkJs) {
        return !!file && (file.scriptKind === 1 || file.scriptKind === 2) && !file.checkJsDirective && checkJs === undefined;
    }
    ts.isPlainJsFile = isPlainJsFile;
    function isStatementWithLocals(node) {
        switch (node.kind) {
            case 235:
            case 263:
            case 242:
            case 243:
            case 244:
                return true;
        }
        return false;
    }
    ts.isStatementWithLocals = isStatementWithLocals;
    function getStartPositionOfLine(line, sourceFile) {
        ts.Debug.assert(line >= 0);
        return ts.getLineStarts(sourceFile)[line];
    }
    ts.getStartPositionOfLine = getStartPositionOfLine;
    function nodePosToString(node) {
        var file = getSourceFileOfNode(node);
        var loc = ts.getLineAndCharacterOfPosition(file, node.pos);
        return "".concat(file.fileName, "(").concat(loc.line + 1, ",").concat(loc.character + 1, ")");
    }
    ts.nodePosToString = nodePosToString;
    function getEndLinePosition(line, sourceFile) {
        ts.Debug.assert(line >= 0);
        var lineStarts = ts.getLineStarts(sourceFile);
        var lineIndex = line;
        var sourceText = sourceFile.text;
        if (lineIndex + 1 === lineStarts.length) {
            return sourceText.length - 1;
        }
        else {
            var start = lineStarts[lineIndex];
            var pos = lineStarts[lineIndex + 1] - 1;
            ts.Debug.assert(ts.isLineBreak(sourceText.charCodeAt(pos)));
            while (start <= pos && ts.isLineBreak(sourceText.charCodeAt(pos))) {
                pos--;
            }
            return pos;
        }
    }
    ts.getEndLinePosition = getEndLinePosition;
    function isFileLevelUniqueName(sourceFile, name, hasGlobalName) {
        return !(hasGlobalName && hasGlobalName(name)) && !sourceFile.identifiers.has(name);
    }
    ts.isFileLevelUniqueName = isFileLevelUniqueName;
    function nodeIsMissing(node) {
        if (node === undefined) {
            return true;
        }
        return node.pos === node.end && node.pos >= 0 && node.kind !== 1;
    }
    ts.nodeIsMissing = nodeIsMissing;
    function nodeIsPresent(node) {
        return !nodeIsMissing(node);
    }
    ts.nodeIsPresent = nodeIsPresent;
    function insertStatementsAfterPrologue(to, from, isPrologueDirective) {
        if (from === undefined || from.length === 0)
            return to;
        var statementIndex = 0;
        for (; statementIndex < to.length; ++statementIndex) {
            if (!isPrologueDirective(to[statementIndex])) {
                break;
            }
        }
        to.splice.apply(to, __spreadArray([statementIndex, 0], from, false));
        return to;
    }
    function insertStatementAfterPrologue(to, statement, isPrologueDirective) {
        if (statement === undefined)
            return to;
        var statementIndex = 0;
        for (; statementIndex < to.length; ++statementIndex) {
            if (!isPrologueDirective(to[statementIndex])) {
                break;
            }
        }
        to.splice(statementIndex, 0, statement);
        return to;
    }
    function isAnyPrologueDirective(node) {
        return isPrologueDirective(node) || !!(getEmitFlags(node) & 1048576);
    }
    function insertStatementsAfterStandardPrologue(to, from) {
        return insertStatementsAfterPrologue(to, from, isPrologueDirective);
    }
    ts.insertStatementsAfterStandardPrologue = insertStatementsAfterStandardPrologue;
    function insertStatementsAfterCustomPrologue(to, from) {
        return insertStatementsAfterPrologue(to, from, isAnyPrologueDirective);
    }
    ts.insertStatementsAfterCustomPrologue = insertStatementsAfterCustomPrologue;
    function insertStatementAfterStandardPrologue(to, statement) {
        return insertStatementAfterPrologue(to, statement, isPrologueDirective);
    }
    ts.insertStatementAfterStandardPrologue = insertStatementAfterStandardPrologue;
    function insertStatementAfterCustomPrologue(to, statement) {
        return insertStatementAfterPrologue(to, statement, isAnyPrologueDirective);
    }
    ts.insertStatementAfterCustomPrologue = insertStatementAfterCustomPrologue;
    function isRecognizedTripleSlashComment(text, commentPos, commentEnd) {
        if (text.charCodeAt(commentPos + 1) === 47 &&
            commentPos + 2 < commentEnd &&
            text.charCodeAt(commentPos + 2) === 47) {
            var textSubStr = text.substring(commentPos, commentEnd);
            return ts.fullTripleSlashReferencePathRegEx.test(textSubStr) ||
                ts.fullTripleSlashAMDReferencePathRegEx.test(textSubStr) ||
                fullTripleSlashReferenceTypeReferenceDirectiveRegEx.test(textSubStr) ||
                defaultLibReferenceRegEx.test(textSubStr) ?
                true : false;
        }
        return false;
    }
    ts.isRecognizedTripleSlashComment = isRecognizedTripleSlashComment;
    function isPinnedComment(text, start) {
        return text.charCodeAt(start + 1) === 42 &&
            text.charCodeAt(start + 2) === 33;
    }
    ts.isPinnedComment = isPinnedComment;
    function createCommentDirectivesMap(sourceFile, commentDirectives) {
        var directivesByLine = new ts.Map(commentDirectives.map(function (commentDirective) { return ([
            "".concat(ts.getLineAndCharacterOfPosition(sourceFile, commentDirective.range.end).line),
            commentDirective,
        ]); }));
        var usedLines = new ts.Map();
        return { getUnusedExpectations: getUnusedExpectations, markUsed: markUsed };
        function getUnusedExpectations() {
            return ts.arrayFrom(directivesByLine.entries())
                .filter(function (_a) {
                var line = _a[0], directive = _a[1];
                return directive.type === 0 && !usedLines.get(line);
            })
                .map(function (_a) {
                var _ = _a[0], directive = _a[1];
                return directive;
            });
        }
        function markUsed(line) {
            if (!directivesByLine.has("".concat(line))) {
                return false;
            }
            usedLines.set("".concat(line), true);
            return true;
        }
    }
    ts.createCommentDirectivesMap = createCommentDirectivesMap;
    function getTokenPosOfNode(node, sourceFile, includeJsDoc) {
        if (nodeIsMissing(node)) {
            return node.pos;
        }
        if (ts.isJSDocNode(node) || node.kind === 11) {
            return ts.skipTrivia((sourceFile || getSourceFileOfNode(node)).text, node.pos, false, true);
        }
        if (includeJsDoc && ts.hasJSDocNodes(node)) {
            return getTokenPosOfNode(node.jsDoc[0], sourceFile);
        }
        if (node.kind === 348 && node._children.length > 0) {
            return getTokenPosOfNode(node._children[0], sourceFile, includeJsDoc);
        }
        return ts.skipTrivia((sourceFile || getSourceFileOfNode(node)).text, node.pos, false, false, isInJSDoc(node));
    }
    ts.getTokenPosOfNode = getTokenPosOfNode;
    function getNonDecoratorTokenPosOfNode(node, sourceFile) {
        if (nodeIsMissing(node) || !node.decorators) {
            return getTokenPosOfNode(node, sourceFile);
        }
        return ts.skipTrivia((sourceFile || getSourceFileOfNode(node)).text, node.decorators.end);
    }
    ts.getNonDecoratorTokenPosOfNode = getNonDecoratorTokenPosOfNode;
    function getSourceTextOfNodeFromSourceFile(sourceFile, node, includeTrivia) {
        if (includeTrivia === void 0) { includeTrivia = false; }
        return getTextOfNodeFromSourceText(sourceFile.text, node, includeTrivia);
    }
    ts.getSourceTextOfNodeFromSourceFile = getSourceTextOfNodeFromSourceFile;
    function isJSDocTypeExpressionOrChild(node) {
        return !!ts.findAncestor(node, ts.isJSDocTypeExpression);
    }
    function isExportNamespaceAsDefaultDeclaration(node) {
        return !!(ts.isExportDeclaration(node) && node.exportClause && ts.isNamespaceExport(node.exportClause) && node.exportClause.name.escapedText === "default");
    }
    ts.isExportNamespaceAsDefaultDeclaration = isExportNamespaceAsDefaultDeclaration;
    function getTextOfNodeFromSourceText(sourceText, node, includeTrivia) {
        if (includeTrivia === void 0) { includeTrivia = false; }
        if (nodeIsMissing(node)) {
            return "";
        }
        var text = sourceText.substring(includeTrivia ? node.pos : ts.skipTrivia(sourceText, node.pos), node.end);
        if (isJSDocTypeExpressionOrChild(node)) {
            text = text.split(/\r\n|\n|\r/).map(function (line) { return ts.trimStringStart(line.replace(/^\s*\*/, "")); }).join("\n");
        }
        return text;
    }
    ts.getTextOfNodeFromSourceText = getTextOfNodeFromSourceText;
    function getTextOfNode(node, includeTrivia) {
        if (includeTrivia === void 0) { includeTrivia = false; }
        return getSourceTextOfNodeFromSourceFile(getSourceFileOfNode(node), node, includeTrivia);
    }
    ts.getTextOfNode = getTextOfNode;
    function getPos(range) {
        return range.pos;
    }
    function indexOfNode(nodeArray, node) {
        return ts.binarySearch(nodeArray, node, getPos, ts.compareValues);
    }
    ts.indexOfNode = indexOfNode;
    function getEmitFlags(node) {
        var emitNode = node.emitNode;
        return emitNode && emitNode.flags || 0;
    }
    ts.getEmitFlags = getEmitFlags;
    ;
    function getScriptTargetFeatures() {
        return {
            es2015: {
                Array: ["find", "findIndex", "fill", "copyWithin", "entries", "keys", "values"],
                RegExp: ["flags", "sticky", "unicode"],
                Reflect: ["apply", "construct", "defineProperty", "deleteProperty", "get", " getOwnPropertyDescriptor", "getPrototypeOf", "has", "isExtensible", "ownKeys", "preventExtensions", "set", "setPrototypeOf"],
                ArrayConstructor: ["from", "of"],
                ObjectConstructor: ["assign", "getOwnPropertySymbols", "keys", "is", "setPrototypeOf"],
                NumberConstructor: ["isFinite", "isInteger", "isNaN", "isSafeInteger", "parseFloat", "parseInt"],
                Math: ["clz32", "imul", "sign", "log10", "log2", "log1p", "expm1", "cosh", "sinh", "tanh", "acosh", "asinh", "atanh", "hypot", "trunc", "fround", "cbrt"],
                Map: ["entries", "keys", "values"],
                Set: ["entries", "keys", "values"],
                Promise: ts.emptyArray,
                PromiseConstructor: ["all", "race", "reject", "resolve"],
                Symbol: ["for", "keyFor"],
                WeakMap: ["entries", "keys", "values"],
                WeakSet: ["entries", "keys", "values"],
                Iterator: ts.emptyArray,
                AsyncIterator: ts.emptyArray,
                String: ["codePointAt", "includes", "endsWith", "normalize", "repeat", "startsWith", "anchor", "big", "blink", "bold", "fixed", "fontcolor", "fontsize", "italics", "link", "small", "strike", "sub", "sup"],
                StringConstructor: ["fromCodePoint", "raw"]
            },
            es2016: {
                Array: ["includes"]
            },
            es2017: {
                Atomics: ts.emptyArray,
                SharedArrayBuffer: ts.emptyArray,
                String: ["padStart", "padEnd"],
                ObjectConstructor: ["values", "entries", "getOwnPropertyDescriptors"],
                DateTimeFormat: ["formatToParts"]
            },
            es2018: {
                Promise: ["finally"],
                RegExpMatchArray: ["groups"],
                RegExpExecArray: ["groups"],
                RegExp: ["dotAll"],
                Intl: ["PluralRules"],
                AsyncIterable: ts.emptyArray,
                AsyncIterableIterator: ts.emptyArray,
                AsyncGenerator: ts.emptyArray,
                AsyncGeneratorFunction: ts.emptyArray,
                NumberFormat: ["formatToParts"]
            },
            es2019: {
                Array: ["flat", "flatMap"],
                ObjectConstructor: ["fromEntries"],
                String: ["trimStart", "trimEnd", "trimLeft", "trimRight"],
                Symbol: ["description"]
            },
            es2020: {
                BigInt: ts.emptyArray,
                BigInt64Array: ts.emptyArray,
                BigUint64Array: ts.emptyArray,
                PromiseConstructor: ["allSettled"],
                SymbolConstructor: ["matchAll"],
                String: ["matchAll"],
                DataView: ["setBigInt64", "setBigUint64", "getBigInt64", "getBigUint64"],
                RelativeTimeFormat: ["format", "formatToParts", "resolvedOptions"]
            },
            es2021: {
                PromiseConstructor: ["any"],
                String: ["replaceAll"]
            },
            es2022: {
                Array: ["at"],
                String: ["at"],
                Int8Array: ["at"],
                Uint8Array: ["at"],
                Uint8ClampedArray: ["at"],
                Int16Array: ["at"],
                Uint16Array: ["at"],
                Int32Array: ["at"],
                Uint32Array: ["at"],
                Float32Array: ["at"],
                Float64Array: ["at"],
                BigInt64Array: ["at"],
                BigUint64Array: ["at"],
                ObjectConstructor: ["hasOwn"],
                Error: ["cause"]
            }
        };
    }
    ts.getScriptTargetFeatures = getScriptTargetFeatures;
    function getLiteralText(node, sourceFile, flags) {
        var _a;
        if (sourceFile && canUseOriginalText(node, flags)) {
            return getSourceTextOfNodeFromSourceFile(sourceFile, node);
        }
        switch (node.kind) {
            case 10: {
                var escapeText = flags & 2 ? escapeJsxAttributeString :
                    flags & 1 || (getEmitFlags(node) & 16777216) ? escapeString :
                        escapeNonAsciiString;
                if (node.singleQuote) {
                    return "'" + escapeText(node.text, 39) + "'";
                }
                else {
                    return '"' + escapeText(node.text, 34) + '"';
                }
            }
            case 14:
            case 15:
            case 16:
            case 17: {
                var escapeText = flags & 1 || (getEmitFlags(node) & 16777216) ? escapeString :
                    escapeNonAsciiString;
                var rawText = (_a = node.rawText) !== null && _a !== void 0 ? _a : escapeTemplateSubstitution(escapeText(node.text, 96));
                switch (node.kind) {
                    case 14:
                        return "`" + rawText + "`";
                    case 15:
                        return "`" + rawText + "${";
                    case 16:
                        return "}" + rawText + "${";
                    case 17:
                        return "}" + rawText + "`";
                }
                break;
            }
            case 8:
            case 9:
                return node.text;
            case 13:
                if (flags & 4 && node.isUnterminated) {
                    return node.text + (node.text.charCodeAt(node.text.length - 1) === 92 ? " /" : "/");
                }
                return node.text;
        }
        return ts.Debug.fail("Literal kind '".concat(node.kind, "' not accounted for."));
    }
    ts.getLiteralText = getLiteralText;
    function canUseOriginalText(node, flags) {
        if (nodeIsSynthesized(node) || !node.parent || (flags & 4 && node.isUnterminated)) {
            return false;
        }
        if (ts.isNumericLiteral(node) && node.numericLiteralFlags & 512) {
            return !!(flags & 8);
        }
        return !ts.isBigIntLiteral(node);
    }
    function getTextOfConstantValue(value) {
        return ts.isString(value) ? '"' + escapeNonAsciiString(value) + '"' : "" + value;
    }
    ts.getTextOfConstantValue = getTextOfConstantValue;
    function makeIdentifierFromModuleName(moduleName) {
        return ts.getBaseFileName(moduleName).replace(/^(\d)/, "_$1").replace(/\W/g, "_");
    }
    ts.makeIdentifierFromModuleName = makeIdentifierFromModuleName;
    function isBlockOrCatchScoped(declaration) {
        return (ts.getCombinedNodeFlags(declaration) & 3) !== 0 ||
            isCatchClauseVariableDeclarationOrBindingElement(declaration);
    }
    ts.isBlockOrCatchScoped = isBlockOrCatchScoped;
    function isCatchClauseVariableDeclarationOrBindingElement(declaration) {
        var node = getRootDeclaration(declaration);
        return node.kind === 254 && node.parent.kind === 292;
    }
    ts.isCatchClauseVariableDeclarationOrBindingElement = isCatchClauseVariableDeclarationOrBindingElement;
    function isAmbientModule(node) {
        return ts.isModuleDeclaration(node) && (node.name.kind === 10 || isGlobalScopeAugmentation(node));
    }
    ts.isAmbientModule = isAmbientModule;
    function isModuleWithStringLiteralName(node) {
        return ts.isModuleDeclaration(node) && node.name.kind === 10;
    }
    ts.isModuleWithStringLiteralName = isModuleWithStringLiteralName;
    function isNonGlobalAmbientModule(node) {
        return ts.isModuleDeclaration(node) && ts.isStringLiteral(node.name);
    }
    ts.isNonGlobalAmbientModule = isNonGlobalAmbientModule;
    function isEffectiveModuleDeclaration(node) {
        return ts.isModuleDeclaration(node) || ts.isIdentifier(node);
    }
    ts.isEffectiveModuleDeclaration = isEffectiveModuleDeclaration;
    function isShorthandAmbientModuleSymbol(moduleSymbol) {
        return isShorthandAmbientModule(moduleSymbol.valueDeclaration);
    }
    ts.isShorthandAmbientModuleSymbol = isShorthandAmbientModuleSymbol;
    function isShorthandAmbientModule(node) {
        return !!node && node.kind === 261 && (!node.body);
    }
    function isBlockScopedContainerTopLevel(node) {
        return node.kind === 305 ||
            node.kind === 261 ||
            ts.isFunctionLikeOrClassStaticBlockDeclaration(node);
    }
    ts.isBlockScopedContainerTopLevel = isBlockScopedContainerTopLevel;
    function isGlobalScopeAugmentation(module) {
        return !!(module.flags & 1024);
    }
    ts.isGlobalScopeAugmentation = isGlobalScopeAugmentation;
    function isExternalModuleAugmentation(node) {
        return isAmbientModule(node) && isModuleAugmentationExternal(node);
    }
    ts.isExternalModuleAugmentation = isExternalModuleAugmentation;
    function isModuleAugmentationExternal(node) {
        switch (node.parent.kind) {
            case 305:
                return ts.isExternalModule(node.parent);
            case 262:
                return isAmbientModule(node.parent.parent) && ts.isSourceFile(node.parent.parent.parent) && !ts.isExternalModule(node.parent.parent.parent);
        }
        return false;
    }
    ts.isModuleAugmentationExternal = isModuleAugmentationExternal;
    function getNonAugmentationDeclaration(symbol) {
        var _a;
        return (_a = symbol.declarations) === null || _a === void 0 ? void 0 : _a.find(function (d) { return !isExternalModuleAugmentation(d) && !(ts.isModuleDeclaration(d) && isGlobalScopeAugmentation(d)); });
    }
    ts.getNonAugmentationDeclaration = getNonAugmentationDeclaration;
    function isCommonJSContainingModuleKind(kind) {
        return kind === ts.ModuleKind.CommonJS || kind === ts.ModuleKind.Node16 || kind === ts.ModuleKind.NodeNext;
    }
    function isEffectiveExternalModule(node, compilerOptions) {
        return ts.isExternalModule(node) || compilerOptions.isolatedModules || (isCommonJSContainingModuleKind(getEmitModuleKind(compilerOptions)) && !!node.commonJsModuleIndicator);
    }
    ts.isEffectiveExternalModule = isEffectiveExternalModule;
    function isEffectiveStrictModeSourceFile(node, compilerOptions) {
        switch (node.scriptKind) {
            case 1:
            case 3:
            case 2:
            case 4:
                break;
            default:
                return false;
        }
        if (node.isDeclarationFile) {
            return false;
        }
        if (getStrictOptionValue(compilerOptions, "alwaysStrict")) {
            return true;
        }
        if (ts.startsWithUseStrict(node.statements)) {
            return true;
        }
        if (ts.isExternalModule(node) || compilerOptions.isolatedModules) {
            if (getEmitModuleKind(compilerOptions) >= ts.ModuleKind.ES2015) {
                return true;
            }
            return !compilerOptions.noImplicitUseStrict;
        }
        return false;
    }
    ts.isEffectiveStrictModeSourceFile = isEffectiveStrictModeSourceFile;
    function isBlockScope(node, parentNode) {
        switch (node.kind) {
            case 305:
            case 263:
            case 292:
            case 261:
            case 242:
            case 243:
            case 244:
            case 171:
            case 169:
            case 172:
            case 173:
            case 256:
            case 213:
            case 214:
            case 167:
            case 170:
                return true;
            case 235:
                return !ts.isFunctionLikeOrClassStaticBlockDeclaration(parentNode);
        }
        return false;
    }
    ts.isBlockScope = isBlockScope;
    function isDeclarationWithTypeParameters(node) {
        switch (node.kind) {
            case 338:
            case 345:
            case 323:
                return true;
            default:
                ts.assertType(node);
                return isDeclarationWithTypeParameterChildren(node);
        }
    }
    ts.isDeclarationWithTypeParameters = isDeclarationWithTypeParameters;
    function isDeclarationWithTypeParameterChildren(node) {
        switch (node.kind) {
            case 174:
            case 175:
            case 168:
            case 176:
            case 179:
            case 180:
            case 317:
            case 257:
            case 226:
            case 258:
            case 259:
            case 344:
            case 256:
            case 169:
            case 171:
            case 172:
            case 173:
            case 213:
            case 214:
                return true;
            default:
                ts.assertType(node);
                return false;
        }
    }
    ts.isDeclarationWithTypeParameterChildren = isDeclarationWithTypeParameterChildren;
    function isAnyImportSyntax(node) {
        switch (node.kind) {
            case 266:
            case 265:
                return true;
            default:
                return false;
        }
    }
    ts.isAnyImportSyntax = isAnyImportSyntax;
    function isAnyImportOrBareOrAccessedRequire(node) {
        return isAnyImportSyntax(node) || isVariableDeclarationInitializedToBareOrAccessedRequire(node);
    }
    ts.isAnyImportOrBareOrAccessedRequire = isAnyImportOrBareOrAccessedRequire;
    function isLateVisibilityPaintedStatement(node) {
        switch (node.kind) {
            case 266:
            case 265:
            case 237:
            case 257:
            case 256:
            case 261:
            case 259:
            case 258:
            case 260:
                return true;
            default:
                return false;
        }
    }
    ts.isLateVisibilityPaintedStatement = isLateVisibilityPaintedStatement;
    function hasPossibleExternalModuleReference(node) {
        return isAnyImportOrReExport(node) || ts.isModuleDeclaration(node) || ts.isImportTypeNode(node) || isImportCall(node);
    }
    ts.hasPossibleExternalModuleReference = hasPossibleExternalModuleReference;
    function isAnyImportOrReExport(node) {
        return isAnyImportSyntax(node) || ts.isExportDeclaration(node);
    }
    ts.isAnyImportOrReExport = isAnyImportOrReExport;
    function getEnclosingBlockScopeContainer(node) {
        return ts.findAncestor(node.parent, function (current) { return isBlockScope(current, current.parent); });
    }
    ts.getEnclosingBlockScopeContainer = getEnclosingBlockScopeContainer;
    function forEachEnclosingBlockScopeContainer(node, cb) {
        var container = getEnclosingBlockScopeContainer(node);
        while (container) {
            cb(container);
            container = getEnclosingBlockScopeContainer(container);
        }
    }
    ts.forEachEnclosingBlockScopeContainer = forEachEnclosingBlockScopeContainer;
    function declarationNameToString(name) {
        return !name || getFullWidth(name) === 0 ? "(Missing)" : getTextOfNode(name);
    }
    ts.declarationNameToString = declarationNameToString;
    function getNameFromIndexInfo(info) {
        return info.declaration ? declarationNameToString(info.declaration.parameters[0].name) : undefined;
    }
    ts.getNameFromIndexInfo = getNameFromIndexInfo;
    function isComputedNonLiteralName(name) {
        return name.kind === 162 && !isStringOrNumericLiteralLike(name.expression);
    }
    ts.isComputedNonLiteralName = isComputedNonLiteralName;
    function tryGetTextOfPropertyName(name) {
        switch (name.kind) {
            case 79:
            case 80:
                return name.escapedText;
            case 10:
            case 8:
            case 14:
                return ts.escapeLeadingUnderscores(name.text);
            case 162:
                if (isStringOrNumericLiteralLike(name.expression))
                    return ts.escapeLeadingUnderscores(name.expression.text);
                return undefined;
            default:
                return ts.Debug.assertNever(name);
        }
    }
    ts.tryGetTextOfPropertyName = tryGetTextOfPropertyName;
    function getTextOfPropertyName(name) {
        return ts.Debug.checkDefined(tryGetTextOfPropertyName(name));
    }
    ts.getTextOfPropertyName = getTextOfPropertyName;
    function entityNameToString(name) {
        switch (name.kind) {
            case 108:
                return "this";
            case 80:
            case 79:
                return getFullWidth(name) === 0 ? ts.idText(name) : getTextOfNode(name);
            case 161:
                return entityNameToString(name.left) + "." + entityNameToString(name.right);
            case 206:
                if (ts.isIdentifier(name.name) || ts.isPrivateIdentifier(name.name)) {
                    return entityNameToString(name.expression) + "." + entityNameToString(name.name);
                }
                else {
                    return ts.Debug.assertNever(name.name);
                }
            case 311:
                return entityNameToString(name.left) + entityNameToString(name.right);
            default:
                return ts.Debug.assertNever(name);
        }
    }
    ts.entityNameToString = entityNameToString;
    function createDiagnosticForNode(node, message, arg0, arg1, arg2, arg3) {
        var sourceFile = getSourceFileOfNode(node);
        return createDiagnosticForNodeInSourceFile(sourceFile, node, message, arg0, arg1, arg2, arg3);
    }
    ts.createDiagnosticForNode = createDiagnosticForNode;
    function createDiagnosticForNodeArray(sourceFile, nodes, message, arg0, arg1, arg2, arg3) {
        var start = ts.skipTrivia(sourceFile.text, nodes.pos);
        return createFileDiagnostic(sourceFile, start, nodes.end - start, message, arg0, arg1, arg2, arg3);
    }
    ts.createDiagnosticForNodeArray = createDiagnosticForNodeArray;
    function createDiagnosticForNodeInSourceFile(sourceFile, node, message, arg0, arg1, arg2, arg3) {
        var span = getErrorSpanForNode(sourceFile, node);
        return createFileDiagnostic(sourceFile, span.start, span.length, message, arg0, arg1, arg2, arg3);
    }
    ts.createDiagnosticForNodeInSourceFile = createDiagnosticForNodeInSourceFile;
    function createDiagnosticForNodeFromMessageChain(node, messageChain, relatedInformation) {
        var sourceFile = getSourceFileOfNode(node);
        var span = getErrorSpanForNode(sourceFile, node);
        return createFileDiagnosticFromMessageChain(sourceFile, span.start, span.length, messageChain, relatedInformation);
    }
    ts.createDiagnosticForNodeFromMessageChain = createDiagnosticForNodeFromMessageChain;
    function assertDiagnosticLocation(file, start, length) {
        ts.Debug.assertGreaterThanOrEqual(start, 0);
        ts.Debug.assertGreaterThanOrEqual(length, 0);
        if (file) {
            ts.Debug.assertLessThanOrEqual(start, file.text.length);
            ts.Debug.assertLessThanOrEqual(start + length, file.text.length);
        }
    }
    function createFileDiagnosticFromMessageChain(file, start, length, messageChain, relatedInformation) {
        assertDiagnosticLocation(file, start, length);
        return {
            file: file,
            start: start,
            length: length,
            code: messageChain.code,
            category: messageChain.category,
            messageText: messageChain.next ? messageChain : messageChain.messageText,
            relatedInformation: relatedInformation
        };
    }
    ts.createFileDiagnosticFromMessageChain = createFileDiagnosticFromMessageChain;
    function createDiagnosticForFileFromMessageChain(sourceFile, messageChain, relatedInformation) {
        return {
            file: sourceFile,
            start: 0,
            length: 0,
            code: messageChain.code,
            category: messageChain.category,
            messageText: messageChain.next ? messageChain : messageChain.messageText,
            relatedInformation: relatedInformation
        };
    }
    ts.createDiagnosticForFileFromMessageChain = createDiagnosticForFileFromMessageChain;
    function createDiagnosticMessageChainFromDiagnostic(diagnostic) {
        return typeof diagnostic.messageText === "string" ? {
            code: diagnostic.code,
            category: diagnostic.category,
            messageText: diagnostic.messageText,
            next: diagnostic.next,
        } : diagnostic.messageText;
    }
    ts.createDiagnosticMessageChainFromDiagnostic = createDiagnosticMessageChainFromDiagnostic;
    function createDiagnosticForRange(sourceFile, range, message) {
        return {
            file: sourceFile,
            start: range.pos,
            length: range.end - range.pos,
            code: message.code,
            category: message.category,
            messageText: message.message,
        };
    }
    ts.createDiagnosticForRange = createDiagnosticForRange;
    function getSpanOfTokenAtPosition(sourceFile, pos) {
        var scanner = ts.createScanner(sourceFile.languageVersion, true, sourceFile.languageVariant, sourceFile.text, undefined, pos);
        scanner.scan();
        var start = scanner.getTokenPos();
        return ts.createTextSpanFromBounds(start, scanner.getTextPos());
    }
    ts.getSpanOfTokenAtPosition = getSpanOfTokenAtPosition;
    function getErrorSpanForArrowFunction(sourceFile, node) {
        var pos = ts.skipTrivia(sourceFile.text, node.pos);
        if (node.body && node.body.kind === 235) {
            var startLine = ts.getLineAndCharacterOfPosition(sourceFile, node.body.pos).line;
            var endLine = ts.getLineAndCharacterOfPosition(sourceFile, node.body.end).line;
            if (startLine < endLine) {
                return ts.createTextSpan(pos, getEndLinePosition(startLine, sourceFile) - pos + 1);
            }
        }
        return ts.createTextSpanFromBounds(pos, node.end);
    }
    function getErrorSpanForNode(sourceFile, node) {
        var errorNode = node;
        switch (node.kind) {
            case 305:
                var pos_1 = ts.skipTrivia(sourceFile.text, 0, false);
                if (pos_1 === sourceFile.text.length) {
                    return ts.createTextSpan(0, 0);
                }
                return getSpanOfTokenAtPosition(sourceFile, pos_1);
            case 254:
            case 203:
            case 257:
            case 226:
            case 258:
            case 261:
            case 260:
            case 299:
            case 256:
            case 213:
            case 169:
            case 172:
            case 173:
            case 259:
            case 167:
            case 166:
            case 268:
                errorNode = node.name;
                break;
            case 214:
                return getErrorSpanForArrowFunction(sourceFile, node);
            case 289:
            case 290:
                var start = ts.skipTrivia(sourceFile.text, node.pos);
                var end = node.statements.length > 0 ? node.statements[0].pos : node.end;
                return ts.createTextSpanFromBounds(start, end);
        }
        if (errorNode === undefined) {
            return getSpanOfTokenAtPosition(sourceFile, node.pos);
        }
        ts.Debug.assert(!ts.isJSDoc(errorNode));
        var isMissing = nodeIsMissing(errorNode);
        var pos = isMissing || ts.isJsxText(node)
            ? errorNode.pos
            : ts.skipTrivia(sourceFile.text, errorNode.pos);
        if (isMissing) {
            ts.Debug.assert(pos === errorNode.pos, "This failure could trigger https://github.com/Microsoft/TypeScript/issues/20809");
            ts.Debug.assert(pos === errorNode.end, "This failure could trigger https://github.com/Microsoft/TypeScript/issues/20809");
        }
        else {
            ts.Debug.assert(pos >= errorNode.pos, "This failure could trigger https://github.com/Microsoft/TypeScript/issues/20809");
            ts.Debug.assert(pos <= errorNode.end, "This failure could trigger https://github.com/Microsoft/TypeScript/issues/20809");
        }
        return ts.createTextSpanFromBounds(pos, errorNode.end);
    }
    ts.getErrorSpanForNode = getErrorSpanForNode;
    function isExternalOrCommonJsModule(file) {
        return (file.externalModuleIndicator || file.commonJsModuleIndicator) !== undefined;
    }
    ts.isExternalOrCommonJsModule = isExternalOrCommonJsModule;
    function isJsonSourceFile(file) {
        return file.scriptKind === 6;
    }
    ts.isJsonSourceFile = isJsonSourceFile;
    function isEnumConst(node) {
        return !!(ts.getCombinedModifierFlags(node) & 2048);
    }
    ts.isEnumConst = isEnumConst;
    function isDeclarationReadonly(declaration) {
        return !!(ts.getCombinedModifierFlags(declaration) & 64 && !ts.isParameterPropertyDeclaration(declaration, declaration.parent));
    }
    ts.isDeclarationReadonly = isDeclarationReadonly;
    function isVarConst(node) {
        return !!(ts.getCombinedNodeFlags(node) & 2);
    }
    ts.isVarConst = isVarConst;
    function isLet(node) {
        return !!(ts.getCombinedNodeFlags(node) & 1);
    }
    ts.isLet = isLet;
    function isSuperCall(n) {
        return n.kind === 208 && n.expression.kind === 106;
    }
    ts.isSuperCall = isSuperCall;
    function isImportCall(n) {
        return n.kind === 208 && n.expression.kind === 100;
    }
    ts.isImportCall = isImportCall;
    function isImportMeta(n) {
        return ts.isMetaProperty(n)
            && n.keywordToken === 100
            && n.name.escapedText === "meta";
    }
    ts.isImportMeta = isImportMeta;
    function isLiteralImportTypeNode(n) {
        return ts.isImportTypeNode(n) && ts.isLiteralTypeNode(n.argument) && ts.isStringLiteral(n.argument.literal);
    }
    ts.isLiteralImportTypeNode = isLiteralImportTypeNode;
    function isPrologueDirective(node) {
        return node.kind === 238
            && node.expression.kind === 10;
    }
    ts.isPrologueDirective = isPrologueDirective;
    function isCustomPrologue(node) {
        return !!(getEmitFlags(node) & 1048576);
    }
    ts.isCustomPrologue = isCustomPrologue;
    function isHoistedFunction(node) {
        return isCustomPrologue(node)
            && ts.isFunctionDeclaration(node);
    }
    ts.isHoistedFunction = isHoistedFunction;
    function isHoistedVariable(node) {
        return ts.isIdentifier(node.name)
            && !node.initializer;
    }
    function isHoistedVariableStatement(node) {
        return isCustomPrologue(node)
            && ts.isVariableStatement(node)
            && ts.every(node.declarationList.declarations, isHoistedVariable);
    }
    ts.isHoistedVariableStatement = isHoistedVariableStatement;
    function getLeadingCommentRangesOfNode(node, sourceFileOfNode) {
        return node.kind !== 11 ? ts.getLeadingCommentRanges(sourceFileOfNode.text, node.pos) : undefined;
    }
    ts.getLeadingCommentRangesOfNode = getLeadingCommentRangesOfNode;
    function getJSDocCommentRanges(node, text) {
        var commentRanges = (node.kind === 164 ||
            node.kind === 163 ||
            node.kind === 213 ||
            node.kind === 214 ||
            node.kind === 212 ||
            node.kind === 254 ||
            node.kind === 275) ?
            ts.concatenate(ts.getTrailingCommentRanges(text, node.pos), ts.getLeadingCommentRanges(text, node.pos)) :
            ts.getLeadingCommentRanges(text, node.pos);
        return ts.filter(commentRanges, function (comment) {
            return text.charCodeAt(comment.pos + 1) === 42 &&
                text.charCodeAt(comment.pos + 2) === 42 &&
                text.charCodeAt(comment.pos + 3) !== 47;
        });
    }
    ts.getJSDocCommentRanges = getJSDocCommentRanges;
    ts.fullTripleSlashReferencePathRegEx = /^(\/\/\/\s*<reference\s+path\s*=\s*)(('[^']*')|("[^"]*")).*?\/>/;
    var fullTripleSlashReferenceTypeReferenceDirectiveRegEx = /^(\/\/\/\s*<reference\s+types\s*=\s*)(('[^']*')|("[^"]*")).*?\/>/;
    ts.fullTripleSlashAMDReferencePathRegEx = /^(\/\/\/\s*<amd-dependency\s+path\s*=\s*)(('[^']*')|("[^"]*")).*?\/>/;
    var defaultLibReferenceRegEx = /^(\/\/\/\s*<reference\s+no-default-lib\s*=\s*)(('[^']*')|("[^"]*"))\s*\/>/;
    function isPartOfTypeNode(node) {
        if (177 <= node.kind && node.kind <= 200) {
            return true;
        }
        switch (node.kind) {
            case 130:
            case 155:
            case 147:
            case 158:
            case 150:
            case 133:
            case 151:
            case 148:
            case 153:
            case 143:
                return true;
            case 114:
                return node.parent.kind !== 217;
            case 228:
                return ts.isHeritageClause(node.parent) && !isExpressionWithTypeArgumentsInClassExtendsClause(node);
            case 163:
                return node.parent.kind === 195 || node.parent.kind === 190;
            case 79:
                if (node.parent.kind === 161 && node.parent.right === node) {
                    node = node.parent;
                }
                else if (node.parent.kind === 206 && node.parent.name === node) {
                    node = node.parent;
                }
                ts.Debug.assert(node.kind === 79 || node.kind === 161 || node.kind === 206, "'node' was expected to be a qualified name, identifier or property access in 'isPartOfTypeNode'.");
            case 161:
            case 206:
            case 108: {
                var parent = node.parent;
                if (parent.kind === 181) {
                    return false;
                }
                if (parent.kind === 200) {
                    return !parent.isTypeOf;
                }
                if (177 <= parent.kind && parent.kind <= 200) {
                    return true;
                }
                switch (parent.kind) {
                    case 228:
                        return ts.isHeritageClause(parent.parent) && !isExpressionWithTypeArgumentsInClassExtendsClause(parent);
                    case 163:
                        return node === parent.constraint;
                    case 344:
                        return node === parent.constraint;
                    case 167:
                    case 166:
                    case 164:
                    case 254:
                        return node === parent.type;
                    case 256:
                    case 213:
                    case 214:
                    case 171:
                    case 169:
                    case 168:
                    case 172:
                    case 173:
                        return node === parent.type;
                    case 174:
                    case 175:
                    case 176:
                        return node === parent.type;
                    case 211:
                        return node === parent.type;
                    case 208:
                    case 209:
                        return ts.contains(parent.typeArguments, node);
                    case 210:
                        return false;
                }
            }
        }
        return false;
    }
    ts.isPartOfTypeNode = isPartOfTypeNode;
    function isChildOfNodeWithKind(node, kind) {
        while (node) {
            if (node.kind === kind) {
                return true;
            }
            node = node.parent;
        }
        return false;
    }
    ts.isChildOfNodeWithKind = isChildOfNodeWithKind;
    function forEachReturnStatement(body, visitor) {
        return traverse(body);
        function traverse(node) {
            switch (node.kind) {
                case 247:
                    return visitor(node);
                case 263:
                case 235:
                case 239:
                case 240:
                case 241:
                case 242:
                case 243:
                case 244:
                case 248:
                case 249:
                case 289:
                case 290:
                case 250:
                case 252:
                case 292:
                    return ts.forEachChild(node, traverse);
            }
        }
    }
    ts.forEachReturnStatement = forEachReturnStatement;
    function forEachYieldExpression(body, visitor) {
        return traverse(body);
        function traverse(node) {
            switch (node.kind) {
                case 224:
                    visitor(node);
                    var operand = node.expression;
                    if (operand) {
                        traverse(operand);
                    }
                    return;
                case 260:
                case 258:
                case 261:
                case 259:
                    return;
                default:
                    if (ts.isFunctionLike(node)) {
                        if (node.name && node.name.kind === 162) {
                            traverse(node.name.expression);
                            return;
                        }
                    }
                    else if (!isPartOfTypeNode(node)) {
                        ts.forEachChild(node, traverse);
                    }
            }
        }
    }
    ts.forEachYieldExpression = forEachYieldExpression;
    function getRestParameterElementType(node) {
        if (node && node.kind === 183) {
            return node.elementType;
        }
        else if (node && node.kind === 178) {
            return ts.singleOrUndefined(node.typeArguments);
        }
        else {
            return undefined;
        }
    }
    ts.getRestParameterElementType = getRestParameterElementType;
    function getMembersOfDeclaration(node) {
        switch (node.kind) {
            case 258:
            case 257:
            case 226:
            case 182:
                return node.members;
            case 205:
                return node.properties;
        }
    }
    ts.getMembersOfDeclaration = getMembersOfDeclaration;
    function isVariableLike(node) {
        if (node) {
            switch (node.kind) {
                case 203:
                case 299:
                case 164:
                case 296:
                case 167:
                case 166:
                case 297:
                case 254:
                    return true;
            }
        }
        return false;
    }
    ts.isVariableLike = isVariableLike;
    function isVariableLikeOrAccessor(node) {
        return isVariableLike(node) || ts.isAccessor(node);
    }
    ts.isVariableLikeOrAccessor = isVariableLikeOrAccessor;
    function isVariableDeclarationInVariableStatement(node) {
        return node.parent.kind === 255
            && node.parent.parent.kind === 237;
    }
    ts.isVariableDeclarationInVariableStatement = isVariableDeclarationInVariableStatement;
    function isCommonJsExportedExpression(node) {
        if (!isInJSFile(node))
            return false;
        return (ts.isObjectLiteralExpression(node.parent) && ts.isBinaryExpression(node.parent.parent) && getAssignmentDeclarationKind(node.parent.parent) === 2) ||
            isCommonJsExportPropertyAssignment(node.parent);
    }
    ts.isCommonJsExportedExpression = isCommonJsExportedExpression;
    function isCommonJsExportPropertyAssignment(node) {
        if (!isInJSFile(node))
            return false;
        return (ts.isBinaryExpression(node) && getAssignmentDeclarationKind(node) === 1);
    }
    ts.isCommonJsExportPropertyAssignment = isCommonJsExportPropertyAssignment;
    function isValidESSymbolDeclaration(node) {
        return (ts.isVariableDeclaration(node) ? isVarConst(node) && ts.isIdentifier(node.name) && isVariableDeclarationInVariableStatement(node) :
            ts.isPropertyDeclaration(node) ? hasEffectiveReadonlyModifier(node) && hasStaticModifier(node) :
                ts.isPropertySignature(node) && hasEffectiveReadonlyModifier(node)) || isCommonJsExportPropertyAssignment(node);
    }
    ts.isValidESSymbolDeclaration = isValidESSymbolDeclaration;
    function introducesArgumentsExoticObject(node) {
        switch (node.kind) {
            case 169:
            case 168:
            case 171:
            case 172:
            case 173:
            case 256:
            case 213:
                return true;
        }
        return false;
    }
    ts.introducesArgumentsExoticObject = introducesArgumentsExoticObject;
    function unwrapInnermostStatementOfLabel(node, beforeUnwrapLabelCallback) {
        while (true) {
            if (beforeUnwrapLabelCallback) {
                beforeUnwrapLabelCallback(node);
            }
            if (node.statement.kind !== 250) {
                return node.statement;
            }
            node = node.statement;
        }
    }
    ts.unwrapInnermostStatementOfLabel = unwrapInnermostStatementOfLabel;
    function isFunctionBlock(node) {
        return node && node.kind === 235 && ts.isFunctionLike(node.parent);
    }
    ts.isFunctionBlock = isFunctionBlock;
    function isObjectLiteralMethod(node) {
        return node && node.kind === 169 && node.parent.kind === 205;
    }
    ts.isObjectLiteralMethod = isObjectLiteralMethod;
    function isObjectLiteralOrClassExpressionMethodOrAccessor(node) {
        return (node.kind === 169 || node.kind === 172 || node.kind === 173) &&
            (node.parent.kind === 205 ||
                node.parent.kind === 226);
    }
    ts.isObjectLiteralOrClassExpressionMethodOrAccessor = isObjectLiteralOrClassExpressionMethodOrAccessor;
    function isIdentifierTypePredicate(predicate) {
        return predicate && predicate.kind === 1;
    }
    ts.isIdentifierTypePredicate = isIdentifierTypePredicate;
    function isThisTypePredicate(predicate) {
        return predicate && predicate.kind === 0;
    }
    ts.isThisTypePredicate = isThisTypePredicate;
    function getPropertyAssignment(objectLiteral, key, key2) {
        return objectLiteral.properties.filter(function (property) {
            if (property.kind === 296) {
                var propName = tryGetTextOfPropertyName(property.name);
                return key === propName || (!!key2 && key2 === propName);
            }
            return false;
        });
    }
    ts.getPropertyAssignment = getPropertyAssignment;
    function getPropertyArrayElementValue(objectLiteral, propKey, elementValue) {
        return ts.firstDefined(getPropertyAssignment(objectLiteral, propKey), function (property) {
            return ts.isArrayLiteralExpression(property.initializer) ?
                ts.find(property.initializer.elements, function (element) { return ts.isStringLiteral(element) && element.text === elementValue; }) :
                undefined;
        });
    }
    ts.getPropertyArrayElementValue = getPropertyArrayElementValue;
    function getTsConfigObjectLiteralExpression(tsConfigSourceFile) {
        if (tsConfigSourceFile && tsConfigSourceFile.statements.length) {
            var expression = tsConfigSourceFile.statements[0].expression;
            return ts.tryCast(expression, ts.isObjectLiteralExpression);
        }
    }
    ts.getTsConfigObjectLiteralExpression = getTsConfigObjectLiteralExpression;
    function getTsConfigPropArrayElementValue(tsConfigSourceFile, propKey, elementValue) {
        return ts.firstDefined(getTsConfigPropArray(tsConfigSourceFile, propKey), function (property) {
            return ts.isArrayLiteralExpression(property.initializer) ?
                ts.find(property.initializer.elements, function (element) { return ts.isStringLiteral(element) && element.text === elementValue; }) :
                undefined;
        });
    }
    ts.getTsConfigPropArrayElementValue = getTsConfigPropArrayElementValue;
    function getTsConfigPropArray(tsConfigSourceFile, propKey) {
        var jsonObjectLiteral = getTsConfigObjectLiteralExpression(tsConfigSourceFile);
        return jsonObjectLiteral ? getPropertyAssignment(jsonObjectLiteral, propKey) : ts.emptyArray;
    }
    ts.getTsConfigPropArray = getTsConfigPropArray;
    function getContainingFunction(node) {
        return ts.findAncestor(node.parent, ts.isFunctionLike);
    }
    ts.getContainingFunction = getContainingFunction;
    function getContainingFunctionDeclaration(node) {
        return ts.findAncestor(node.parent, ts.isFunctionLikeDeclaration);
    }
    ts.getContainingFunctionDeclaration = getContainingFunctionDeclaration;
    function getContainingClass(node) {
        return ts.findAncestor(node.parent, ts.isClassLike);
    }
    ts.getContainingClass = getContainingClass;
    function getContainingClassStaticBlock(node) {
        return ts.findAncestor(node.parent, function (n) {
            if (ts.isClassLike(n) || ts.isFunctionLike(n)) {
                return "quit";
            }
            return ts.isClassStaticBlockDeclaration(n);
        });
    }
    ts.getContainingClassStaticBlock = getContainingClassStaticBlock;
    function getContainingFunctionOrClassStaticBlock(node) {
        return ts.findAncestor(node.parent, ts.isFunctionLikeOrClassStaticBlockDeclaration);
    }
    ts.getContainingFunctionOrClassStaticBlock = getContainingFunctionOrClassStaticBlock;
    function getThisContainer(node, includeArrowFunctions) {
        ts.Debug.assert(node.kind !== 305);
        while (true) {
            node = node.parent;
            if (!node) {
                return ts.Debug.fail();
            }
            switch (node.kind) {
                case 162:
                    if (ts.isClassLike(node.parent.parent)) {
                        return node;
                    }
                    node = node.parent;
                    break;
                case 165:
                    if (node.parent.kind === 164 && ts.isClassElement(node.parent.parent)) {
                        node = node.parent.parent;
                    }
                    else if (ts.isClassElement(node.parent)) {
                        node = node.parent;
                    }
                    break;
                case 214:
                    if (!includeArrowFunctions) {
                        continue;
                    }
                case 256:
                case 213:
                case 261:
                case 170:
                case 167:
                case 166:
                case 169:
                case 168:
                case 171:
                case 172:
                case 173:
                case 174:
                case 175:
                case 176:
                case 260:
                case 305:
                    return node;
            }
        }
    }
    ts.getThisContainer = getThisContainer;
    function isThisContainerOrFunctionBlock(node) {
        switch (node.kind) {
            case 214:
            case 256:
            case 213:
            case 167:
                return true;
            case 235:
                switch (node.parent.kind) {
                    case 171:
                    case 169:
                    case 172:
                    case 173:
                        return true;
                    default:
                        return false;
                }
            default:
                return false;
        }
    }
    ts.isThisContainerOrFunctionBlock = isThisContainerOrFunctionBlock;
    function isInTopLevelContext(node) {
        if (ts.isIdentifier(node) && (ts.isClassDeclaration(node.parent) || ts.isFunctionDeclaration(node.parent)) && node.parent.name === node) {
            node = node.parent;
        }
        var container = getThisContainer(node, true);
        return ts.isSourceFile(container);
    }
    ts.isInTopLevelContext = isInTopLevelContext;
    function getNewTargetContainer(node) {
        var container = getThisContainer(node, false);
        if (container) {
            switch (container.kind) {
                case 171:
                case 256:
                case 213:
                    return container;
            }
        }
        return undefined;
    }
    ts.getNewTargetContainer = getNewTargetContainer;
    function getSuperContainer(node, stopOnFunctions) {
        while (true) {
            node = node.parent;
            if (!node) {
                return node;
            }
            switch (node.kind) {
                case 162:
                    node = node.parent;
                    break;
                case 256:
                case 213:
                case 214:
                    if (!stopOnFunctions) {
                        continue;
                    }
                case 167:
                case 166:
                case 169:
                case 168:
                case 171:
                case 172:
                case 173:
                case 170:
                    return node;
                case 165:
                    if (node.parent.kind === 164 && ts.isClassElement(node.parent.parent)) {
                        node = node.parent.parent;
                    }
                    else if (ts.isClassElement(node.parent)) {
                        node = node.parent;
                    }
                    break;
            }
        }
    }
    ts.getSuperContainer = getSuperContainer;
    function getImmediatelyInvokedFunctionExpression(func) {
        if (func.kind === 213 || func.kind === 214) {
            var prev = func;
            var parent = func.parent;
            while (parent.kind === 212) {
                prev = parent;
                parent = parent.parent;
            }
            if (parent.kind === 208 && parent.expression === prev) {
                return parent;
            }
        }
    }
    ts.getImmediatelyInvokedFunctionExpression = getImmediatelyInvokedFunctionExpression;
    function isSuperOrSuperProperty(node) {
        return node.kind === 106
            || isSuperProperty(node);
    }
    ts.isSuperOrSuperProperty = isSuperOrSuperProperty;
    function isSuperProperty(node) {
        var kind = node.kind;
        return (kind === 206 || kind === 207)
            && node.expression.kind === 106;
    }
    ts.isSuperProperty = isSuperProperty;
    function isThisProperty(node) {
        var kind = node.kind;
        return (kind === 206 || kind === 207)
            && node.expression.kind === 108;
    }
    ts.isThisProperty = isThisProperty;
    function isThisInitializedDeclaration(node) {
        var _a;
        return !!node && ts.isVariableDeclaration(node) && ((_a = node.initializer) === null || _a === void 0 ? void 0 : _a.kind) === 108;
    }
    ts.isThisInitializedDeclaration = isThisInitializedDeclaration;
    function isThisInitializedObjectBindingExpression(node) {
        return !!node
            && (ts.isShorthandPropertyAssignment(node) || ts.isPropertyAssignment(node))
            && ts.isBinaryExpression(node.parent.parent)
            && node.parent.parent.operatorToken.kind === 63
            && node.parent.parent.right.kind === 108;
    }
    ts.isThisInitializedObjectBindingExpression = isThisInitializedObjectBindingExpression;
    function getEntityNameFromTypeNode(node) {
        switch (node.kind) {
            case 178:
                return node.typeName;
            case 228:
                return isEntityNameExpression(node.expression)
                    ? node.expression
                    : undefined;
            case 79:
            case 161:
                return node;
        }
        return undefined;
    }
    ts.getEntityNameFromTypeNode = getEntityNameFromTypeNode;
    function getInvokedExpression(node) {
        switch (node.kind) {
            case 210:
                return node.tag;
            case 280:
            case 279:
                return node.tagName;
            default:
                return node.expression;
        }
    }
    ts.getInvokedExpression = getInvokedExpression;
    function nodeCanBeDecorated(node, parent, grandparent) {
        if (ts.isNamedDeclaration(node) && ts.isPrivateIdentifier(node.name)) {
            return false;
        }
        switch (node.kind) {
            case 257:
                return true;
            case 167:
                return parent.kind === 257;
            case 172:
            case 173:
            case 169:
                return node.body !== undefined
                    && parent.kind === 257;
            case 164:
                return parent.body !== undefined
                    && (parent.kind === 171
                        || parent.kind === 169
                        || parent.kind === 173)
                    && grandparent.kind === 257;
        }
        return false;
    }
    ts.nodeCanBeDecorated = nodeCanBeDecorated;
    function nodeIsDecorated(node, parent, grandparent) {
        return node.decorators !== undefined
            && nodeCanBeDecorated(node, parent, grandparent);
    }
    ts.nodeIsDecorated = nodeIsDecorated;
    function nodeOrChildIsDecorated(node, parent, grandparent) {
        return nodeIsDecorated(node, parent, grandparent) || childIsDecorated(node, parent);
    }
    ts.nodeOrChildIsDecorated = nodeOrChildIsDecorated;
    function childIsDecorated(node, parent) {
        switch (node.kind) {
            case 257:
                return ts.some(node.members, function (m) { return nodeOrChildIsDecorated(m, node, parent); });
            case 169:
            case 173:
            case 171:
                return ts.some(node.parameters, function (p) { return nodeIsDecorated(p, node, parent); });
            default:
                return false;
        }
    }
    ts.childIsDecorated = childIsDecorated;
    function classOrConstructorParameterIsDecorated(node) {
        if (nodeIsDecorated(node))
            return true;
        var constructor = getFirstConstructorWithBody(node);
        return !!constructor && childIsDecorated(constructor, node);
    }
    ts.classOrConstructorParameterIsDecorated = classOrConstructorParameterIsDecorated;
    function isJSXTagName(node) {
        var parent = node.parent;
        if (parent.kind === 280 ||
            parent.kind === 279 ||
            parent.kind === 281) {
            return parent.tagName === node;
        }
        return false;
    }
    ts.isJSXTagName = isJSXTagName;
    function isExpressionNode(node) {
        switch (node.kind) {
            case 106:
            case 104:
            case 110:
            case 95:
            case 13:
            case 204:
            case 205:
            case 206:
            case 207:
            case 208:
            case 209:
            case 210:
            case 229:
            case 211:
            case 230:
            case 212:
            case 213:
            case 226:
            case 214:
            case 217:
            case 215:
            case 216:
            case 219:
            case 220:
            case 221:
            case 222:
            case 225:
            case 223:
            case 227:
            case 278:
            case 279:
            case 282:
            case 224:
            case 218:
            case 231:
                return true;
            case 228:
                return !ts.isHeritageClause(node.parent);
            case 161:
                while (node.parent.kind === 161) {
                    node = node.parent;
                }
                return node.parent.kind === 181 || ts.isJSDocLinkLike(node.parent) || ts.isJSDocNameReference(node.parent) || ts.isJSDocMemberName(node.parent) || isJSXTagName(node);
            case 311:
                while (ts.isJSDocMemberName(node.parent)) {
                    node = node.parent;
                }
                return node.parent.kind === 181 || ts.isJSDocLinkLike(node.parent) || ts.isJSDocNameReference(node.parent) || ts.isJSDocMemberName(node.parent) || isJSXTagName(node);
            case 80:
                return ts.isBinaryExpression(node.parent) && node.parent.left === node && node.parent.operatorToken.kind === 101;
            case 79:
                if (node.parent.kind === 181 || ts.isJSDocLinkLike(node.parent) || ts.isJSDocNameReference(node.parent) || ts.isJSDocMemberName(node.parent) || isJSXTagName(node)) {
                    return true;
                }
            case 8:
            case 9:
            case 10:
            case 14:
            case 108:
                return isInExpressionContext(node);
            default:
                return false;
        }
    }
    ts.isExpressionNode = isExpressionNode;
    function isInExpressionContext(node) {
        var parent = node.parent;
        switch (parent.kind) {
            case 254:
            case 164:
            case 167:
            case 166:
            case 299:
            case 296:
            case 203:
                return parent.initializer === node;
            case 238:
            case 239:
            case 240:
            case 241:
            case 247:
            case 248:
            case 249:
            case 289:
            case 251:
                return parent.expression === node;
            case 242:
                var forStatement = parent;
                return (forStatement.initializer === node && forStatement.initializer.kind !== 255) ||
                    forStatement.condition === node ||
                    forStatement.incrementor === node;
            case 243:
            case 244:
                var forInStatement = parent;
                return (forInStatement.initializer === node && forInStatement.initializer.kind !== 255) ||
                    forInStatement.expression === node;
            case 211:
            case 229:
                return node === parent.expression;
            case 233:
                return node === parent.expression;
            case 162:
                return node === parent.expression;
            case 165:
            case 288:
            case 287:
            case 298:
                return true;
            case 228:
                return parent.expression === node && !isPartOfTypeNode(parent);
            case 297:
                return parent.objectAssignmentInitializer === node;
            default:
                return isExpressionNode(parent);
        }
    }
    ts.isInExpressionContext = isInExpressionContext;
    function isPartOfTypeQuery(node) {
        while (node.kind === 161 || node.kind === 79) {
            node = node.parent;
        }
        return node.kind === 181;
    }
    ts.isPartOfTypeQuery = isPartOfTypeQuery;
    function isNamespaceReexportDeclaration(node) {
        return ts.isNamespaceExport(node) && !!node.parent.moduleSpecifier;
    }
    ts.isNamespaceReexportDeclaration = isNamespaceReexportDeclaration;
    function isExternalModuleImportEqualsDeclaration(node) {
        return node.kind === 265 && node.moduleReference.kind === 277;
    }
    ts.isExternalModuleImportEqualsDeclaration = isExternalModuleImportEqualsDeclaration;
    function getExternalModuleImportEqualsDeclarationExpression(node) {
        ts.Debug.assert(isExternalModuleImportEqualsDeclaration(node));
        return node.moduleReference.expression;
    }
    ts.getExternalModuleImportEqualsDeclarationExpression = getExternalModuleImportEqualsDeclarationExpression;
    function getExternalModuleRequireArgument(node) {
        return isVariableDeclarationInitializedToBareOrAccessedRequire(node) && getLeftmostAccessExpression(node.initializer).arguments[0];
    }
    ts.getExternalModuleRequireArgument = getExternalModuleRequireArgument;
    function isInternalModuleImportEqualsDeclaration(node) {
        return node.kind === 265 && node.moduleReference.kind !== 277;
    }
    ts.isInternalModuleImportEqualsDeclaration = isInternalModuleImportEqualsDeclaration;
    function isSourceFileJS(file) {
        return isInJSFile(file);
    }
    ts.isSourceFileJS = isSourceFileJS;
    function isSourceFileNotJS(file) {
        return !isInJSFile(file);
    }
    ts.isSourceFileNotJS = isSourceFileNotJS;
    function isInJSFile(node) {
        return !!node && !!(node.flags & 262144);
    }
    ts.isInJSFile = isInJSFile;
    function isInJsonFile(node) {
        return !!node && !!(node.flags & 67108864);
    }
    ts.isInJsonFile = isInJsonFile;
    function isSourceFileNotJson(file) {
        return !isJsonSourceFile(file);
    }
    ts.isSourceFileNotJson = isSourceFileNotJson;
    function isInJSDoc(node) {
        return !!node && !!(node.flags & 8388608);
    }
    ts.isInJSDoc = isInJSDoc;
    function isJSDocIndexSignature(node) {
        return ts.isTypeReferenceNode(node) &&
            ts.isIdentifier(node.typeName) &&
            node.typeName.escapedText === "Object" &&
            node.typeArguments && node.typeArguments.length === 2 &&
            (node.typeArguments[0].kind === 150 || node.typeArguments[0].kind === 147);
    }
    ts.isJSDocIndexSignature = isJSDocIndexSignature;
    function isRequireCall(callExpression, requireStringLiteralLikeArgument) {
        if (callExpression.kind !== 208) {
            return false;
        }
        var _a = callExpression, expression = _a.expression, args = _a.arguments;
        if (expression.kind !== 79 || expression.escapedText !== "require") {
            return false;
        }
        if (args.length !== 1) {
            return false;
        }
        var arg = args[0];
        return !requireStringLiteralLikeArgument || ts.isStringLiteralLike(arg);
    }
    ts.isRequireCall = isRequireCall;
    function isVariableDeclarationInitializedToRequire(node) {
        return isVariableDeclarationInitializedWithRequireHelper(node, false);
    }
    ts.isVariableDeclarationInitializedToRequire = isVariableDeclarationInitializedToRequire;
    function isVariableDeclarationInitializedToBareOrAccessedRequire(node) {
        return isVariableDeclarationInitializedWithRequireHelper(node, true);
    }
    ts.isVariableDeclarationInitializedToBareOrAccessedRequire = isVariableDeclarationInitializedToBareOrAccessedRequire;
    function isVariableDeclarationInitializedWithRequireHelper(node, allowAccessedRequire) {
        return ts.isVariableDeclaration(node) &&
            !!node.initializer &&
            isRequireCall(allowAccessedRequire ? getLeftmostAccessExpression(node.initializer) : node.initializer, true);
    }
    function isRequireVariableStatement(node) {
        return ts.isVariableStatement(node)
            && node.declarationList.declarations.length > 0
            && ts.every(node.declarationList.declarations, function (decl) { return isVariableDeclarationInitializedToRequire(decl); });
    }
    ts.isRequireVariableStatement = isRequireVariableStatement;
    function isSingleOrDoubleQuote(charCode) {
        return charCode === 39 || charCode === 34;
    }
    ts.isSingleOrDoubleQuote = isSingleOrDoubleQuote;
    function isStringDoubleQuoted(str, sourceFile) {
        return getSourceTextOfNodeFromSourceFile(sourceFile, str).charCodeAt(0) === 34;
    }
    ts.isStringDoubleQuoted = isStringDoubleQuoted;
    function isAssignmentDeclaration(decl) {
        return ts.isBinaryExpression(decl) || isAccessExpression(decl) || ts.isIdentifier(decl) || ts.isCallExpression(decl);
    }
    ts.isAssignmentDeclaration = isAssignmentDeclaration;
    function getEffectiveInitializer(node) {
        if (isInJSFile(node) && node.initializer &&
            ts.isBinaryExpression(node.initializer) &&
            (node.initializer.operatorToken.kind === 56 || node.initializer.operatorToken.kind === 60) &&
            node.name && isEntityNameExpression(node.name) && isSameEntityName(node.name, node.initializer.left)) {
            return node.initializer.right;
        }
        return node.initializer;
    }
    ts.getEffectiveInitializer = getEffectiveInitializer;
    function getDeclaredExpandoInitializer(node) {
        var init = getEffectiveInitializer(node);
        return init && getExpandoInitializer(init, isPrototypeAccess(node.name));
    }
    ts.getDeclaredExpandoInitializer = getDeclaredExpandoInitializer;
    function hasExpandoValueProperty(node, isPrototypeAssignment) {
        return ts.forEach(node.properties, function (p) {
            return ts.isPropertyAssignment(p) &&
                ts.isIdentifier(p.name) &&
                p.name.escapedText === "value" &&
                p.initializer &&
                getExpandoInitializer(p.initializer, isPrototypeAssignment);
        });
    }
    function getAssignedExpandoInitializer(node) {
        if (node && node.parent && ts.isBinaryExpression(node.parent) && node.parent.operatorToken.kind === 63) {
            var isPrototypeAssignment = isPrototypeAccess(node.parent.left);
            return getExpandoInitializer(node.parent.right, isPrototypeAssignment) ||
                getDefaultedExpandoInitializer(node.parent.left, node.parent.right, isPrototypeAssignment);
        }
        if (node && ts.isCallExpression(node) && isBindableObjectDefinePropertyCall(node)) {
            var result = hasExpandoValueProperty(node.arguments[2], node.arguments[1].text === "prototype");
            if (result) {
                return result;
            }
        }
    }
    ts.getAssignedExpandoInitializer = getAssignedExpandoInitializer;
    function getExpandoInitializer(initializer, isPrototypeAssignment) {
        if (ts.isCallExpression(initializer)) {
            var e = skipParentheses(initializer.expression);
            return e.kind === 213 || e.kind === 214 ? initializer : undefined;
        }
        if (initializer.kind === 213 ||
            initializer.kind === 226 ||
            initializer.kind === 214) {
            return initializer;
        }
        if (ts.isObjectLiteralExpression(initializer) && (initializer.properties.length === 0 || isPrototypeAssignment)) {
            return initializer;
        }
    }
    ts.getExpandoInitializer = getExpandoInitializer;
    function getDefaultedExpandoInitializer(name, initializer, isPrototypeAssignment) {
        var e = ts.isBinaryExpression(initializer)
            && (initializer.operatorToken.kind === 56 || initializer.operatorToken.kind === 60)
            && getExpandoInitializer(initializer.right, isPrototypeAssignment);
        if (e && isSameEntityName(name, initializer.left)) {
            return e;
        }
    }
    function isDefaultedExpandoInitializer(node) {
        var name = ts.isVariableDeclaration(node.parent) ? node.parent.name :
            ts.isBinaryExpression(node.parent) && node.parent.operatorToken.kind === 63 ? node.parent.left :
                undefined;
        return name && getExpandoInitializer(node.right, isPrototypeAccess(name)) && isEntityNameExpression(name) && isSameEntityName(name, node.left);
    }
    ts.isDefaultedExpandoInitializer = isDefaultedExpandoInitializer;
    function getNameOfExpando(node) {
        if (ts.isBinaryExpression(node.parent)) {
            var parent = ((node.parent.operatorToken.kind === 56 || node.parent.operatorToken.kind === 60) && ts.isBinaryExpression(node.parent.parent)) ? node.parent.parent : node.parent;
            if (parent.operatorToken.kind === 63 && ts.isIdentifier(parent.left)) {
                return parent.left;
            }
        }
        else if (ts.isVariableDeclaration(node.parent)) {
            return node.parent.name;
        }
    }
    ts.getNameOfExpando = getNameOfExpando;
    function isSameEntityName(name, initializer) {
        if (isPropertyNameLiteral(name) && isPropertyNameLiteral(initializer)) {
            return getTextOfIdentifierOrLiteral(name) === getTextOfIdentifierOrLiteral(initializer);
        }
        if (ts.isMemberName(name) && isLiteralLikeAccess(initializer) &&
            (initializer.expression.kind === 108 ||
                ts.isIdentifier(initializer.expression) &&
                    (initializer.expression.escapedText === "window" ||
                        initializer.expression.escapedText === "self" ||
                        initializer.expression.escapedText === "global"))) {
            return isSameEntityName(name, getNameOrArgument(initializer));
        }
        if (isLiteralLikeAccess(name) && isLiteralLikeAccess(initializer)) {
            return getElementOrPropertyAccessName(name) === getElementOrPropertyAccessName(initializer)
                && isSameEntityName(name.expression, initializer.expression);
        }
        return false;
    }
    ts.isSameEntityName = isSameEntityName;
    function getRightMostAssignedExpression(node) {
        while (isAssignmentExpression(node, true)) {
            node = node.right;
        }
        return node;
    }
    ts.getRightMostAssignedExpression = getRightMostAssignedExpression;
    function isExportsIdentifier(node) {
        return ts.isIdentifier(node) && node.escapedText === "exports";
    }
    ts.isExportsIdentifier = isExportsIdentifier;
    function isModuleIdentifier(node) {
        return ts.isIdentifier(node) && node.escapedText === "module";
    }
    ts.isModuleIdentifier = isModuleIdentifier;
    function isModuleExportsAccessExpression(node) {
        return (ts.isPropertyAccessExpression(node) || isLiteralLikeElementAccess(node))
            && isModuleIdentifier(node.expression)
            && getElementOrPropertyAccessName(node) === "exports";
    }
    ts.isModuleExportsAccessExpression = isModuleExportsAccessExpression;
    function getAssignmentDeclarationKind(expr) {
        var special = getAssignmentDeclarationKindWorker(expr);
        return special === 5 || isInJSFile(expr) ? special : 0;
    }
    ts.getAssignmentDeclarationKind = getAssignmentDeclarationKind;
    function isBindableObjectDefinePropertyCall(expr) {
        return ts.length(expr.arguments) === 3 &&
            ts.isPropertyAccessExpression(expr.expression) &&
            ts.isIdentifier(expr.expression.expression) &&
            ts.idText(expr.expression.expression) === "Object" &&
            ts.idText(expr.expression.name) === "defineProperty" &&
            isStringOrNumericLiteralLike(expr.arguments[1]) &&
            isBindableStaticNameExpression(expr.arguments[0], true);
    }
    ts.isBindableObjectDefinePropertyCall = isBindableObjectDefinePropertyCall;
    function isLiteralLikeAccess(node) {
        return ts.isPropertyAccessExpression(node) || isLiteralLikeElementAccess(node);
    }
    ts.isLiteralLikeAccess = isLiteralLikeAccess;
    function isLiteralLikeElementAccess(node) {
        return ts.isElementAccessExpression(node) && isStringOrNumericLiteralLike(node.argumentExpression);
    }
    ts.isLiteralLikeElementAccess = isLiteralLikeElementAccess;
    function isBindableStaticAccessExpression(node, excludeThisKeyword) {
        return ts.isPropertyAccessExpression(node) && (!excludeThisKeyword && node.expression.kind === 108 || ts.isIdentifier(node.name) && isBindableStaticNameExpression(node.expression, true))
            || isBindableStaticElementAccessExpression(node, excludeThisKeyword);
    }
    ts.isBindableStaticAccessExpression = isBindableStaticAccessExpression;
    function isBindableStaticElementAccessExpression(node, excludeThisKeyword) {
        return isLiteralLikeElementAccess(node)
            && ((!excludeThisKeyword && node.expression.kind === 108) ||
                isEntityNameExpression(node.expression) ||
                isBindableStaticAccessExpression(node.expression, true));
    }
    ts.isBindableStaticElementAccessExpression = isBindableStaticElementAccessExpression;
    function isBindableStaticNameExpression(node, excludeThisKeyword) {
        return isEntityNameExpression(node) || isBindableStaticAccessExpression(node, excludeThisKeyword);
    }
    ts.isBindableStaticNameExpression = isBindableStaticNameExpression;
    function getNameOrArgument(expr) {
        if (ts.isPropertyAccessExpression(expr)) {
            return expr.name;
        }
        return expr.argumentExpression;
    }
    ts.getNameOrArgument = getNameOrArgument;
    function getAssignmentDeclarationKindWorker(expr) {
        if (ts.isCallExpression(expr)) {
            if (!isBindableObjectDefinePropertyCall(expr)) {
                return 0;
            }
            var entityName = expr.arguments[0];
            if (isExportsIdentifier(entityName) || isModuleExportsAccessExpression(entityName)) {
                return 8;
            }
            if (isBindableStaticAccessExpression(entityName) && getElementOrPropertyAccessName(entityName) === "prototype") {
                return 9;
            }
            return 7;
        }
        if (expr.operatorToken.kind !== 63 || !isAccessExpression(expr.left) || isVoidZero(getRightMostAssignedExpression(expr))) {
            return 0;
        }
        if (isBindableStaticNameExpression(expr.left.expression, true) && getElementOrPropertyAccessName(expr.left) === "prototype" && ts.isObjectLiteralExpression(getInitializerOfBinaryExpression(expr))) {
            return 6;
        }
        return getAssignmentDeclarationPropertyAccessKind(expr.left);
    }
    function isVoidZero(node) {
        return ts.isVoidExpression(node) && ts.isNumericLiteral(node.expression) && node.expression.text === "0";
    }
    function getElementOrPropertyAccessArgumentExpressionOrName(node) {
        if (ts.isPropertyAccessExpression(node)) {
            return node.name;
        }
        var arg = skipParentheses(node.argumentExpression);
        if (ts.isNumericLiteral(arg) || ts.isStringLiteralLike(arg)) {
            return arg;
        }
        return node;
    }
    ts.getElementOrPropertyAccessArgumentExpressionOrName = getElementOrPropertyAccessArgumentExpressionOrName;
    function getElementOrPropertyAccessName(node) {
        var name = getElementOrPropertyAccessArgumentExpressionOrName(node);
        if (name) {
            if (ts.isIdentifier(name)) {
                return name.escapedText;
            }
            if (ts.isStringLiteralLike(name) || ts.isNumericLiteral(name)) {
                return ts.escapeLeadingUnderscores(name.text);
            }
        }
        return undefined;
    }
    ts.getElementOrPropertyAccessName = getElementOrPropertyAccessName;
    function getAssignmentDeclarationPropertyAccessKind(lhs) {
        if (lhs.expression.kind === 108) {
            return 4;
        }
        else if (isModuleExportsAccessExpression(lhs)) {
            return 2;
        }
        else if (isBindableStaticNameExpression(lhs.expression, true)) {
            if (isPrototypeAccess(lhs.expression)) {
                return 3;
            }
            var nextToLast = lhs;
            while (!ts.isIdentifier(nextToLast.expression)) {
                nextToLast = nextToLast.expression;
            }
            var id = nextToLast.expression;
            if ((id.escapedText === "exports" ||
                id.escapedText === "module" && getElementOrPropertyAccessName(nextToLast) === "exports") &&
                isBindableStaticAccessExpression(lhs)) {
                return 1;
            }
            if (isBindableStaticNameExpression(lhs, true) || (ts.isElementAccessExpression(lhs) && isDynamicName(lhs))) {
                return 5;
            }
        }
        return 0;
    }
    ts.getAssignmentDeclarationPropertyAccessKind = getAssignmentDeclarationPropertyAccessKind;
    function getInitializerOfBinaryExpression(expr) {
        while (ts.isBinaryExpression(expr.right)) {
            expr = expr.right;
        }
        return expr.right;
    }
    ts.getInitializerOfBinaryExpression = getInitializerOfBinaryExpression;
    function isPrototypePropertyAssignment(node) {
        return ts.isBinaryExpression(node) && getAssignmentDeclarationKind(node) === 3;
    }
    ts.isPrototypePropertyAssignment = isPrototypePropertyAssignment;
    function isSpecialPropertyDeclaration(expr) {
        return isInJSFile(expr) &&
            expr.parent && expr.parent.kind === 238 &&
            (!ts.isElementAccessExpression(expr) || isLiteralLikeElementAccess(expr)) &&
            !!ts.getJSDocTypeTag(expr.parent);
    }
    ts.isSpecialPropertyDeclaration = isSpecialPropertyDeclaration;
    function setValueDeclaration(symbol, node) {
        var valueDeclaration = symbol.valueDeclaration;
        if (!valueDeclaration ||
            !(node.flags & 16777216 && !(valueDeclaration.flags & 16777216)) &&
                (isAssignmentDeclaration(valueDeclaration) && !isAssignmentDeclaration(node)) ||
            (valueDeclaration.kind !== node.kind && isEffectiveModuleDeclaration(valueDeclaration))) {
            symbol.valueDeclaration = node;
        }
    }
    ts.setValueDeclaration = setValueDeclaration;
    function isFunctionSymbol(symbol) {
        if (!symbol || !symbol.valueDeclaration) {
            return false;
        }
        var decl = symbol.valueDeclaration;
        return decl.kind === 256 || ts.isVariableDeclaration(decl) && decl.initializer && ts.isFunctionLike(decl.initializer);
    }
    ts.isFunctionSymbol = isFunctionSymbol;
    function tryGetModuleSpecifierFromDeclaration(node) {
        var _a, _b;
        switch (node.kind) {
            case 254:
                return (_a = ts.findAncestor(node.initializer, function (node) { return isRequireCall(node, true); })) === null || _a === void 0 ? void 0 : _a.arguments[0];
            case 266:
                return ts.tryCast(node.moduleSpecifier, ts.isStringLiteralLike);
            case 265:
                return ts.tryCast((_b = ts.tryCast(node.moduleReference, ts.isExternalModuleReference)) === null || _b === void 0 ? void 0 : _b.expression, ts.isStringLiteralLike);
            default:
                ts.Debug.assertNever(node);
        }
    }
    ts.tryGetModuleSpecifierFromDeclaration = tryGetModuleSpecifierFromDeclaration;
    function importFromModuleSpecifier(node) {
        return tryGetImportFromModuleSpecifier(node) || ts.Debug.failBadSyntaxKind(node.parent);
    }
    ts.importFromModuleSpecifier = importFromModuleSpecifier;
    function tryGetImportFromModuleSpecifier(node) {
        switch (node.parent.kind) {
            case 266:
            case 272:
                return node.parent;
            case 277:
                return node.parent.parent;
            case 208:
                return isImportCall(node.parent) || isRequireCall(node.parent, false) ? node.parent : undefined;
            case 196:
                ts.Debug.assert(ts.isStringLiteral(node));
                return ts.tryCast(node.parent.parent, ts.isImportTypeNode);
            default:
                return undefined;
        }
    }
    ts.tryGetImportFromModuleSpecifier = tryGetImportFromModuleSpecifier;
    function getExternalModuleName(node) {
        switch (node.kind) {
            case 266:
            case 272:
                return node.moduleSpecifier;
            case 265:
                return node.moduleReference.kind === 277 ? node.moduleReference.expression : undefined;
            case 200:
                return isLiteralImportTypeNode(node) ? node.argument.literal : undefined;
            case 208:
                return node.arguments[0];
            case 261:
                return node.name.kind === 10 ? node.name : undefined;
            default:
                return ts.Debug.assertNever(node);
        }
    }
    ts.getExternalModuleName = getExternalModuleName;
    function getNamespaceDeclarationNode(node) {
        switch (node.kind) {
            case 266:
                return node.importClause && ts.tryCast(node.importClause.namedBindings, ts.isNamespaceImport);
            case 265:
                return node;
            case 272:
                return node.exportClause && ts.tryCast(node.exportClause, ts.isNamespaceExport);
            default:
                return ts.Debug.assertNever(node);
        }
    }
    ts.getNamespaceDeclarationNode = getNamespaceDeclarationNode;
    function isDefaultImport(node) {
        return node.kind === 266 && !!node.importClause && !!node.importClause.name;
    }
    ts.isDefaultImport = isDefaultImport;
    function forEachImportClauseDeclaration(node, action) {
        if (node.name) {
            var result = action(node);
            if (result)
                return result;
        }
        if (node.namedBindings) {
            var result = ts.isNamespaceImport(node.namedBindings)
                ? action(node.namedBindings)
                : ts.forEach(node.namedBindings.elements, action);
            if (result)
                return result;
        }
    }
    ts.forEachImportClauseDeclaration = forEachImportClauseDeclaration;
    function hasQuestionToken(node) {
        if (node) {
            switch (node.kind) {
                case 164:
                case 169:
                case 168:
                case 297:
                case 296:
                case 167:
                case 166:
                    return node.questionToken !== undefined;
            }
        }
        return false;
    }
    ts.hasQuestionToken = hasQuestionToken;
    function isJSDocConstructSignature(node) {
        var param = ts.isJSDocFunctionType(node) ? ts.firstOrUndefined(node.parameters) : undefined;
        var name = ts.tryCast(param && param.name, ts.isIdentifier);
        return !!name && name.escapedText === "new";
    }
    ts.isJSDocConstructSignature = isJSDocConstructSignature;
    function isJSDocTypeAlias(node) {
        return node.kind === 345 || node.kind === 338 || node.kind === 339;
    }
    ts.isJSDocTypeAlias = isJSDocTypeAlias;
    function isTypeAlias(node) {
        return isJSDocTypeAlias(node) || ts.isTypeAliasDeclaration(node);
    }
    ts.isTypeAlias = isTypeAlias;
    function getSourceOfAssignment(node) {
        return ts.isExpressionStatement(node) &&
            ts.isBinaryExpression(node.expression) &&
            node.expression.operatorToken.kind === 63
            ? getRightMostAssignedExpression(node.expression)
            : undefined;
    }
    function getSourceOfDefaultedAssignment(node) {
        return ts.isExpressionStatement(node) &&
            ts.isBinaryExpression(node.expression) &&
            getAssignmentDeclarationKind(node.expression) !== 0 &&
            ts.isBinaryExpression(node.expression.right) &&
            (node.expression.right.operatorToken.kind === 56 || node.expression.right.operatorToken.kind === 60)
            ? node.expression.right.right
            : undefined;
    }
    function getSingleInitializerOfVariableStatementOrPropertyDeclaration(node) {
        switch (node.kind) {
            case 237:
                var v = getSingleVariableOfVariableStatement(node);
                return v && v.initializer;
            case 167:
                return node.initializer;
            case 296:
                return node.initializer;
        }
    }
    ts.getSingleInitializerOfVariableStatementOrPropertyDeclaration = getSingleInitializerOfVariableStatementOrPropertyDeclaration;
    function getSingleVariableOfVariableStatement(node) {
        return ts.isVariableStatement(node) ? ts.firstOrUndefined(node.declarationList.declarations) : undefined;
    }
    ts.getSingleVariableOfVariableStatement = getSingleVariableOfVariableStatement;
    function getNestedModuleDeclaration(node) {
        return ts.isModuleDeclaration(node) &&
            node.body &&
            node.body.kind === 261
            ? node.body
            : undefined;
    }
    function getJSDocCommentsAndTags(hostNode, noCache) {
        var result;
        if (isVariableLike(hostNode) && ts.hasInitializer(hostNode) && ts.hasJSDocNodes(hostNode.initializer)) {
            result = ts.addRange(result, filterOwnedJSDocTags(hostNode, ts.last(hostNode.initializer.jsDoc)));
        }
        var node = hostNode;
        while (node && node.parent) {
            if (ts.hasJSDocNodes(node)) {
                result = ts.addRange(result, filterOwnedJSDocTags(hostNode, ts.last(node.jsDoc)));
            }
            if (node.kind === 164) {
                result = ts.addRange(result, (noCache ? ts.getJSDocParameterTagsNoCache : ts.getJSDocParameterTags)(node));
                break;
            }
            if (node.kind === 163) {
                result = ts.addRange(result, (noCache ? ts.getJSDocTypeParameterTagsNoCache : ts.getJSDocTypeParameterTags)(node));
                break;
            }
            node = getNextJSDocCommentLocation(node);
        }
        return result || ts.emptyArray;
    }
    ts.getJSDocCommentsAndTags = getJSDocCommentsAndTags;
    function filterOwnedJSDocTags(hostNode, jsDoc) {
        if (ts.isJSDoc(jsDoc)) {
            var ownedTags = ts.filter(jsDoc.tags, function (tag) { return ownsJSDocTag(hostNode, tag); });
            return jsDoc.tags === ownedTags ? [jsDoc] : ownedTags;
        }
        return ownsJSDocTag(hostNode, jsDoc) ? [jsDoc] : undefined;
    }
    function ownsJSDocTag(hostNode, tag) {
        return !ts.isJSDocTypeTag(tag)
            || !tag.parent
            || !ts.isJSDoc(tag.parent)
            || !ts.isParenthesizedExpression(tag.parent.parent)
            || tag.parent.parent === hostNode;
    }
    function getNextJSDocCommentLocation(node) {
        var parent = node.parent;
        if (parent.kind === 296 ||
            parent.kind === 271 ||
            parent.kind === 167 ||
            parent.kind === 238 && node.kind === 206 ||
            parent.kind === 247 ||
            getNestedModuleDeclaration(parent) ||
            ts.isBinaryExpression(node) && node.operatorToken.kind === 63) {
            return parent;
        }
        else if (parent.parent &&
            (getSingleVariableOfVariableStatement(parent.parent) === node ||
                ts.isBinaryExpression(parent) && parent.operatorToken.kind === 63)) {
            return parent.parent;
        }
        else if (parent.parent && parent.parent.parent &&
            (getSingleVariableOfVariableStatement(parent.parent.parent) ||
                getSingleInitializerOfVariableStatementOrPropertyDeclaration(parent.parent.parent) === node ||
                getSourceOfDefaultedAssignment(parent.parent.parent))) {
            return parent.parent.parent;
        }
    }
    ts.getNextJSDocCommentLocation = getNextJSDocCommentLocation;
    function getParameterSymbolFromJSDoc(node) {
        if (node.symbol) {
            return node.symbol;
        }
        if (!ts.isIdentifier(node.name)) {
            return undefined;
        }
        var name = node.name.escapedText;
        var decl = getHostSignatureFromJSDoc(node);
        if (!decl) {
            return undefined;
        }
        var parameter = ts.find(decl.parameters, function (p) { return p.name.kind === 79 && p.name.escapedText === name; });
        return parameter && parameter.symbol;
    }
    ts.getParameterSymbolFromJSDoc = getParameterSymbolFromJSDoc;
    function getEffectiveContainerForJSDocTemplateTag(node) {
        if (ts.isJSDoc(node.parent) && node.parent.tags) {
            var typeAlias = ts.find(node.parent.tags, isJSDocTypeAlias);
            if (typeAlias) {
                return typeAlias;
            }
        }
        return getHostSignatureFromJSDoc(node);
    }
    ts.getEffectiveContainerForJSDocTemplateTag = getEffectiveContainerForJSDocTemplateTag;
    function getHostSignatureFromJSDoc(node) {
        var host = getEffectiveJSDocHost(node);
        if (host) {
            return ts.isPropertySignature(host) && host.type && ts.isFunctionLike(host.type) ? host.type :
                ts.isFunctionLike(host) ? host : undefined;
        }
        return undefined;
    }
    ts.getHostSignatureFromJSDoc = getHostSignatureFromJSDoc;
    function getEffectiveJSDocHost(node) {
        var host = getJSDocHost(node);
        if (host) {
            return getSourceOfDefaultedAssignment(host)
                || getSourceOfAssignment(host)
                || getSingleInitializerOfVariableStatementOrPropertyDeclaration(host)
                || getSingleVariableOfVariableStatement(host)
                || getNestedModuleDeclaration(host)
                || host;
        }
    }
    ts.getEffectiveJSDocHost = getEffectiveJSDocHost;
    function getJSDocHost(node) {
        var jsDoc = getJSDocRoot(node);
        if (!jsDoc) {
            return undefined;
        }
        var host = jsDoc.parent;
        if (host && host.jsDoc && jsDoc === ts.lastOrUndefined(host.jsDoc)) {
            return host;
        }
    }
    ts.getJSDocHost = getJSDocHost;
    function getJSDocRoot(node) {
        return ts.findAncestor(node.parent, ts.isJSDoc);
    }
    ts.getJSDocRoot = getJSDocRoot;
    function getTypeParameterFromJsDoc(node) {
        var name = node.name.escapedText;
        var typeParameters = node.parent.parent.parent.typeParameters;
        return typeParameters && ts.find(typeParameters, function (p) { return p.name.escapedText === name; });
    }
    ts.getTypeParameterFromJsDoc = getTypeParameterFromJsDoc;
    function hasRestParameter(s) {
        var last = ts.lastOrUndefined(s.parameters);
        return !!last && isRestParameter(last);
    }
    ts.hasRestParameter = hasRestParameter;
    function isRestParameter(node) {
        var type = ts.isJSDocParameterTag(node) ? (node.typeExpression && node.typeExpression.type) : node.type;
        return node.dotDotDotToken !== undefined || !!type && type.kind === 318;
    }
    ts.isRestParameter = isRestParameter;
    function hasTypeArguments(node) {
        return !!node.typeArguments;
    }
    ts.hasTypeArguments = hasTypeArguments;
    function getAssignmentTargetKind(node) {
        var parent = node.parent;
        while (true) {
            switch (parent.kind) {
                case 221:
                    var binaryOperator = parent.operatorToken.kind;
                    return isAssignmentOperator(binaryOperator) && parent.left === node ?
                        binaryOperator === 63 || isLogicalOrCoalescingAssignmentOperator(binaryOperator) ? 1 : 2 :
                        0;
                case 219:
                case 220:
                    var unaryOperator = parent.operator;
                    return unaryOperator === 45 || unaryOperator === 46 ? 2 : 0;
                case 243:
                case 244:
                    return parent.initializer === node ? 1 : 0;
                case 212:
                case 204:
                case 225:
                case 230:
                    node = parent;
                    break;
                case 298:
                    node = parent.parent;
                    break;
                case 297:
                    if (parent.name !== node) {
                        return 0;
                    }
                    node = parent.parent;
                    break;
                case 296:
                    if (parent.name === node) {
                        return 0;
                    }
                    node = parent.parent;
                    break;
                default:
                    return 0;
            }
            parent = node.parent;
        }
    }
    ts.getAssignmentTargetKind = getAssignmentTargetKind;
    function isAssignmentTarget(node) {
        return getAssignmentTargetKind(node) !== 0;
    }
    ts.isAssignmentTarget = isAssignmentTarget;
    function isNodeWithPossibleHoistedDeclaration(node) {
        switch (node.kind) {
            case 235:
            case 237:
            case 248:
            case 239:
            case 249:
            case 263:
            case 289:
            case 290:
            case 250:
            case 242:
            case 243:
            case 244:
            case 240:
            case 241:
            case 252:
            case 292:
                return true;
        }
        return false;
    }
    ts.isNodeWithPossibleHoistedDeclaration = isNodeWithPossibleHoistedDeclaration;
    function isValueSignatureDeclaration(node) {
        return ts.isFunctionExpression(node) || ts.isArrowFunction(node) || ts.isMethodOrAccessor(node) || ts.isFunctionDeclaration(node) || ts.isConstructorDeclaration(node);
    }
    ts.isValueSignatureDeclaration = isValueSignatureDeclaration;
    function walkUp(node, kind) {
        while (node && node.kind === kind) {
            node = node.parent;
        }
        return node;
    }
    function walkUpParenthesizedTypes(node) {
        return walkUp(node, 191);
    }
    ts.walkUpParenthesizedTypes = walkUpParenthesizedTypes;
    function walkUpParenthesizedExpressions(node) {
        return walkUp(node, 212);
    }
    ts.walkUpParenthesizedExpressions = walkUpParenthesizedExpressions;
    function walkUpParenthesizedTypesAndGetParentAndChild(node) {
        var child;
        while (node && node.kind === 191) {
            child = node;
            node = node.parent;
        }
        return [child, node];
    }
    ts.walkUpParenthesizedTypesAndGetParentAndChild = walkUpParenthesizedTypesAndGetParentAndChild;
    function skipParentheses(node, excludeJSDocTypeAssertions) {
        var flags = excludeJSDocTypeAssertions ?
            1 | 16 :
            1;
        return ts.skipOuterExpressions(node, flags);
    }
    ts.skipParentheses = skipParentheses;
    function isDeleteTarget(node) {
        if (node.kind !== 206 && node.kind !== 207) {
            return false;
        }
        node = walkUpParenthesizedExpressions(node.parent);
        return node && node.kind === 215;
    }
    ts.isDeleteTarget = isDeleteTarget;
    function isNodeDescendantOf(node, ancestor) {
        while (node) {
            if (node === ancestor)
                return true;
            node = node.parent;
        }
        return false;
    }
    ts.isNodeDescendantOf = isNodeDescendantOf;
    function isDeclarationName(name) {
        return !ts.isSourceFile(name) && !ts.isBindingPattern(name) && ts.isDeclaration(name.parent) && name.parent.name === name;
    }
    ts.isDeclarationName = isDeclarationName;
    function getDeclarationFromName(name) {
        var parent = name.parent;
        switch (name.kind) {
            case 10:
            case 14:
            case 8:
                if (ts.isComputedPropertyName(parent))
                    return parent.parent;
            case 79:
                if (ts.isDeclaration(parent)) {
                    return parent.name === name ? parent : undefined;
                }
                else if (ts.isQualifiedName(parent)) {
                    var tag = parent.parent;
                    return ts.isJSDocParameterTag(tag) && tag.name === parent ? tag : undefined;
                }
                else {
                    var binExp = parent.parent;
                    return ts.isBinaryExpression(binExp) &&
                        getAssignmentDeclarationKind(binExp) !== 0 &&
                        (binExp.left.symbol || binExp.symbol) &&
                        ts.getNameOfDeclaration(binExp) === name
                        ? binExp
                        : undefined;
                }
            case 80:
                return ts.isDeclaration(parent) && parent.name === name ? parent : undefined;
            default:
                return undefined;
        }
    }
    ts.getDeclarationFromName = getDeclarationFromName;
    function isLiteralComputedPropertyDeclarationName(node) {
        return isStringOrNumericLiteralLike(node) &&
            node.parent.kind === 162 &&
            ts.isDeclaration(node.parent.parent);
    }
    ts.isLiteralComputedPropertyDeclarationName = isLiteralComputedPropertyDeclarationName;
    function isIdentifierName(node) {
        var parent = node.parent;
        switch (parent.kind) {
            case 167:
            case 166:
            case 169:
            case 168:
            case 172:
            case 173:
            case 299:
            case 296:
            case 206:
                return parent.name === node;
            case 161:
                return parent.right === node;
            case 203:
            case 270:
                return parent.propertyName === node;
            case 275:
            case 285:
            case 279:
            case 280:
            case 281:
                return true;
        }
        return false;
    }
    ts.isIdentifierName = isIdentifierName;
    function isAliasSymbolDeclaration(node) {
        if (node.kind === 265 ||
            node.kind === 264 ||
            node.kind === 267 && !!node.name ||
            node.kind === 268 ||
            node.kind === 274 ||
            node.kind === 270 ||
            node.kind === 275 ||
            node.kind === 271 && exportAssignmentIsAlias(node)) {
            return true;
        }
        return isInJSFile(node) && (ts.isBinaryExpression(node) && getAssignmentDeclarationKind(node) === 2 && exportAssignmentIsAlias(node) ||
            ts.isPropertyAccessExpression(node)
                && ts.isBinaryExpression(node.parent)
                && node.parent.left === node
                && node.parent.operatorToken.kind === 63
                && isAliasableExpression(node.parent.right));
    }
    ts.isAliasSymbolDeclaration = isAliasSymbolDeclaration;
    function getAliasDeclarationFromName(node) {
        switch (node.parent.kind) {
            case 267:
            case 270:
            case 268:
            case 275:
            case 271:
            case 265:
            case 274:
                return node.parent;
            case 161:
                do {
                    node = node.parent;
                } while (node.parent.kind === 161);
                return getAliasDeclarationFromName(node);
        }
    }
    ts.getAliasDeclarationFromName = getAliasDeclarationFromName;
    function isAliasableExpression(e) {
        return isEntityNameExpression(e) || ts.isClassExpression(e);
    }
    ts.isAliasableExpression = isAliasableExpression;
    function exportAssignmentIsAlias(node) {
        var e = getExportAssignmentExpression(node);
        return isAliasableExpression(e);
    }
    ts.exportAssignmentIsAlias = exportAssignmentIsAlias;
    function getExportAssignmentExpression(node) {
        return ts.isExportAssignment(node) ? node.expression : node.right;
    }
    ts.getExportAssignmentExpression = getExportAssignmentExpression;
    function getPropertyAssignmentAliasLikeExpression(node) {
        return node.kind === 297 ? node.name : node.kind === 296 ? node.initializer :
            node.parent.right;
    }
    ts.getPropertyAssignmentAliasLikeExpression = getPropertyAssignmentAliasLikeExpression;
    function getEffectiveBaseTypeNode(node) {
        var baseType = getClassExtendsHeritageElement(node);
        if (baseType && isInJSFile(node)) {
            var tag = ts.getJSDocAugmentsTag(node);
            if (tag) {
                return tag.class;
            }
        }
        return baseType;
    }
    ts.getEffectiveBaseTypeNode = getEffectiveBaseTypeNode;
    function getClassExtendsHeritageElement(node) {
        var heritageClause = getHeritageClause(node.heritageClauses, 94);
        return heritageClause && heritageClause.types.length > 0 ? heritageClause.types[0] : undefined;
    }
    ts.getClassExtendsHeritageElement = getClassExtendsHeritageElement;
    function getEffectiveImplementsTypeNodes(node) {
        if (isInJSFile(node)) {
            return ts.getJSDocImplementsTags(node).map(function (n) { return n.class; });
        }
        else {
            var heritageClause = getHeritageClause(node.heritageClauses, 117);
            return heritageClause === null || heritageClause === void 0 ? void 0 : heritageClause.types;
        }
    }
    ts.getEffectiveImplementsTypeNodes = getEffectiveImplementsTypeNodes;
    function getAllSuperTypeNodes(node) {
        return ts.isInterfaceDeclaration(node) ? getInterfaceBaseTypeNodes(node) || ts.emptyArray :
            ts.isClassLike(node) ? ts.concatenate(ts.singleElementArray(getEffectiveBaseTypeNode(node)), getEffectiveImplementsTypeNodes(node)) || ts.emptyArray :
                ts.emptyArray;
    }
    ts.getAllSuperTypeNodes = getAllSuperTypeNodes;
    function getInterfaceBaseTypeNodes(node) {
        var heritageClause = getHeritageClause(node.heritageClauses, 94);
        return heritageClause ? heritageClause.types : undefined;
    }
    ts.getInterfaceBaseTypeNodes = getInterfaceBaseTypeNodes;
    function getHeritageClause(clauses, kind) {
        if (clauses) {
            for (var _i = 0, clauses_1 = clauses; _i < clauses_1.length; _i++) {
                var clause = clauses_1[_i];
                if (clause.token === kind) {
                    return clause;
                }
            }
        }
        return undefined;
    }
    ts.getHeritageClause = getHeritageClause;
    function getAncestor(node, kind) {
        while (node) {
            if (node.kind === kind) {
                return node;
            }
            node = node.parent;
        }
        return undefined;
    }
    ts.getAncestor = getAncestor;
    function isKeyword(token) {
        return 81 <= token && token <= 160;
    }
    ts.isKeyword = isKeyword;
    function isContextualKeyword(token) {
        return 126 <= token && token <= 160;
    }
    ts.isContextualKeyword = isContextualKeyword;
    function isNonContextualKeyword(token) {
        return isKeyword(token) && !isContextualKeyword(token);
    }
    ts.isNonContextualKeyword = isNonContextualKeyword;
    function isFutureReservedKeyword(token) {
        return 117 <= token && token <= 125;
    }
    ts.isFutureReservedKeyword = isFutureReservedKeyword;
    function isStringANonContextualKeyword(name) {
        var token = ts.stringToToken(name);
        return token !== undefined && isNonContextualKeyword(token);
    }
    ts.isStringANonContextualKeyword = isStringANonContextualKeyword;
    function isStringAKeyword(name) {
        var token = ts.stringToToken(name);
        return token !== undefined && isKeyword(token);
    }
    ts.isStringAKeyword = isStringAKeyword;
    function isIdentifierANonContextualKeyword(_a) {
        var originalKeywordKind = _a.originalKeywordKind;
        return !!originalKeywordKind && !isContextualKeyword(originalKeywordKind);
    }
    ts.isIdentifierANonContextualKeyword = isIdentifierANonContextualKeyword;
    function isTrivia(token) {
        return 2 <= token && token <= 7;
    }
    ts.isTrivia = isTrivia;
    function getFunctionFlags(node) {
        if (!node) {
            return 4;
        }
        var flags = 0;
        switch (node.kind) {
            case 256:
            case 213:
            case 169:
                if (node.asteriskToken) {
                    flags |= 1;
                }
            case 214:
                if (hasSyntacticModifier(node, 256)) {
                    flags |= 2;
                }
                break;
        }
        if (!node.body) {
            flags |= 4;
        }
        return flags;
    }
    ts.getFunctionFlags = getFunctionFlags;
    function isAsyncFunction(node) {
        switch (node.kind) {
            case 256:
            case 213:
            case 214:
            case 169:
                return node.body !== undefined
                    && node.asteriskToken === undefined
                    && hasSyntacticModifier(node, 256);
        }
        return false;
    }
    ts.isAsyncFunction = isAsyncFunction;
    function isStringOrNumericLiteralLike(node) {
        return ts.isStringLiteralLike(node) || ts.isNumericLiteral(node);
    }
    ts.isStringOrNumericLiteralLike = isStringOrNumericLiteralLike;
    function isSignedNumericLiteral(node) {
        return ts.isPrefixUnaryExpression(node) && (node.operator === 39 || node.operator === 40) && ts.isNumericLiteral(node.operand);
    }
    ts.isSignedNumericLiteral = isSignedNumericLiteral;
    function hasDynamicName(declaration) {
        var name = ts.getNameOfDeclaration(declaration);
        return !!name && isDynamicName(name);
    }
    ts.hasDynamicName = hasDynamicName;
    function isDynamicName(name) {
        if (!(name.kind === 162 || name.kind === 207)) {
            return false;
        }
        var expr = ts.isElementAccessExpression(name) ? skipParentheses(name.argumentExpression) : name.expression;
        return !isStringOrNumericLiteralLike(expr) &&
            !isSignedNumericLiteral(expr);
    }
    ts.isDynamicName = isDynamicName;
    function getPropertyNameForPropertyNameNode(name) {
        switch (name.kind) {
            case 79:
            case 80:
                return name.escapedText;
            case 10:
            case 8:
                return ts.escapeLeadingUnderscores(name.text);
            case 162:
                var nameExpression = name.expression;
                if (isStringOrNumericLiteralLike(nameExpression)) {
                    return ts.escapeLeadingUnderscores(nameExpression.text);
                }
                else if (isSignedNumericLiteral(nameExpression)) {
                    if (nameExpression.operator === 40) {
                        return ts.tokenToString(nameExpression.operator) + nameExpression.operand.text;
                    }
                    return nameExpression.operand.text;
                }
                return undefined;
            default:
                return ts.Debug.assertNever(name);
        }
    }
    ts.getPropertyNameForPropertyNameNode = getPropertyNameForPropertyNameNode;
    function isPropertyNameLiteral(node) {
        switch (node.kind) {
            case 79:
            case 10:
            case 14:
            case 8:
                return true;
            default:
                return false;
        }
    }
    ts.isPropertyNameLiteral = isPropertyNameLiteral;
    function getTextOfIdentifierOrLiteral(node) {
        return ts.isMemberName(node) ? ts.idText(node) : node.text;
    }
    ts.getTextOfIdentifierOrLiteral = getTextOfIdentifierOrLiteral;
    function getEscapedTextOfIdentifierOrLiteral(node) {
        return ts.isMemberName(node) ? node.escapedText : ts.escapeLeadingUnderscores(node.text);
    }
    ts.getEscapedTextOfIdentifierOrLiteral = getEscapedTextOfIdentifierOrLiteral;
    function getPropertyNameForUniqueESSymbol(symbol) {
        return "__@".concat(ts.getSymbolId(symbol), "@").concat(symbol.escapedName);
    }
    ts.getPropertyNameForUniqueESSymbol = getPropertyNameForUniqueESSymbol;
    function getSymbolNameForPrivateIdentifier(containingClassSymbol, description) {
        return "__#".concat(ts.getSymbolId(containingClassSymbol), "@").concat(description);
    }
    ts.getSymbolNameForPrivateIdentifier = getSymbolNameForPrivateIdentifier;
    function isKnownSymbol(symbol) {
        return ts.startsWith(symbol.escapedName, "__@");
    }
    ts.isKnownSymbol = isKnownSymbol;
    function isPrivateIdentifierSymbol(symbol) {
        return ts.startsWith(symbol.escapedName, "__#");
    }
    ts.isPrivateIdentifierSymbol = isPrivateIdentifierSymbol;
    function isESSymbolIdentifier(node) {
        return node.kind === 79 && node.escapedText === "Symbol";
    }
    ts.isESSymbolIdentifier = isESSymbolIdentifier;
    function isPushOrUnshiftIdentifier(node) {
        return node.escapedText === "push" || node.escapedText === "unshift";
    }
    ts.isPushOrUnshiftIdentifier = isPushOrUnshiftIdentifier;
    function isParameterDeclaration(node) {
        var root = getRootDeclaration(node);
        return root.kind === 164;
    }
    ts.isParameterDeclaration = isParameterDeclaration;
    function getRootDeclaration(node) {
        while (node.kind === 203) {
            node = node.parent.parent;
        }
        return node;
    }
    ts.getRootDeclaration = getRootDeclaration;
    function nodeStartsNewLexicalEnvironment(node) {
        var kind = node.kind;
        return kind === 171
            || kind === 213
            || kind === 256
            || kind === 214
            || kind === 169
            || kind === 172
            || kind === 173
            || kind === 261
            || kind === 305;
    }
    ts.nodeStartsNewLexicalEnvironment = nodeStartsNewLexicalEnvironment;
    function nodeIsSynthesized(range) {
        return positionIsSynthesized(range.pos)
            || positionIsSynthesized(range.end);
    }
    ts.nodeIsSynthesized = nodeIsSynthesized;
    function getOriginalSourceFile(sourceFile) {
        return ts.getParseTreeNode(sourceFile, ts.isSourceFile) || sourceFile;
    }
    ts.getOriginalSourceFile = getOriginalSourceFile;
    function getExpressionAssociativity(expression) {
        var operator = getOperator(expression);
        var hasArguments = expression.kind === 209 && expression.arguments !== undefined;
        return getOperatorAssociativity(expression.kind, operator, hasArguments);
    }
    ts.getExpressionAssociativity = getExpressionAssociativity;
    function getOperatorAssociativity(kind, operator, hasArguments) {
        switch (kind) {
            case 209:
                return hasArguments ? 0 : 1;
            case 219:
            case 216:
            case 217:
            case 215:
            case 218:
            case 222:
            case 224:
                return 1;
            case 221:
                switch (operator) {
                    case 42:
                    case 63:
                    case 64:
                    case 65:
                    case 67:
                    case 66:
                    case 68:
                    case 69:
                    case 70:
                    case 71:
                    case 72:
                    case 73:
                    case 78:
                    case 74:
                    case 75:
                    case 76:
                    case 77:
                        return 1;
                }
        }
        return 0;
    }
    ts.getOperatorAssociativity = getOperatorAssociativity;
    function getExpressionPrecedence(expression) {
        var operator = getOperator(expression);
        var hasArguments = expression.kind === 209 && expression.arguments !== undefined;
        return getOperatorPrecedence(expression.kind, operator, hasArguments);
    }
    ts.getExpressionPrecedence = getExpressionPrecedence;
    function getOperator(expression) {
        if (expression.kind === 221) {
            return expression.operatorToken.kind;
        }
        else if (expression.kind === 219 || expression.kind === 220) {
            return expression.operator;
        }
        else {
            return expression.kind;
        }
    }
    ts.getOperator = getOperator;
    function getOperatorPrecedence(nodeKind, operatorKind, hasArguments) {
        switch (nodeKind) {
            case 351:
                return 0;
            case 225:
                return 1;
            case 224:
                return 2;
            case 222:
                return 4;
            case 221:
                switch (operatorKind) {
                    case 27:
                        return 0;
                    case 63:
                    case 64:
                    case 65:
                    case 67:
                    case 66:
                    case 68:
                    case 69:
                    case 70:
                    case 71:
                    case 72:
                    case 73:
                    case 78:
                    case 74:
                    case 75:
                    case 76:
                    case 77:
                        return 3;
                    default:
                        return getBinaryOperatorPrecedence(operatorKind);
                }
            case 211:
            case 230:
            case 219:
            case 216:
            case 217:
            case 215:
            case 218:
                return 16;
            case 220:
                return 17;
            case 208:
                return 18;
            case 209:
                return hasArguments ? 19 : 18;
            case 210:
            case 206:
            case 207:
            case 231:
                return 19;
            case 229:
                return 11;
            case 108:
            case 106:
            case 79:
            case 80:
            case 104:
            case 110:
            case 95:
            case 8:
            case 9:
            case 10:
            case 204:
            case 205:
            case 213:
            case 214:
            case 226:
            case 13:
            case 14:
            case 223:
            case 212:
            case 227:
            case 278:
            case 279:
            case 282:
                return 20;
            default:
                return -1;
        }
    }
    ts.getOperatorPrecedence = getOperatorPrecedence;
    function getBinaryOperatorPrecedence(kind) {
        switch (kind) {
            case 60:
                return 4;
            case 56:
                return 5;
            case 55:
                return 6;
            case 51:
                return 7;
            case 52:
                return 8;
            case 50:
                return 9;
            case 34:
            case 35:
            case 36:
            case 37:
                return 10;
            case 29:
            case 31:
            case 32:
            case 33:
            case 102:
            case 101:
            case 127:
                return 11;
            case 47:
            case 48:
            case 49:
                return 12;
            case 39:
            case 40:
                return 13;
            case 41:
            case 43:
            case 44:
                return 14;
            case 42:
                return 15;
        }
        return -1;
    }
    ts.getBinaryOperatorPrecedence = getBinaryOperatorPrecedence;
    function getSemanticJsxChildren(children) {
        return ts.filter(children, function (i) {
            switch (i.kind) {
                case 288:
                    return !!i.expression;
                case 11:
                    return !i.containsOnlyTriviaWhiteSpaces;
                default:
                    return true;
            }
        });
    }
    ts.getSemanticJsxChildren = getSemanticJsxChildren;
    function createDiagnosticCollection() {
        var nonFileDiagnostics = [];
        var filesWithDiagnostics = [];
        var fileDiagnostics = new ts.Map();
        var hasReadNonFileDiagnostics = false;
        return {
            add: add,
            lookup: lookup,
            getGlobalDiagnostics: getGlobalDiagnostics,
            getDiagnostics: getDiagnostics,
        };
        function lookup(diagnostic) {
            var diagnostics;
            if (diagnostic.file) {
                diagnostics = fileDiagnostics.get(diagnostic.file.fileName);
            }
            else {
                diagnostics = nonFileDiagnostics;
            }
            if (!diagnostics) {
                return undefined;
            }
            var result = ts.binarySearch(diagnostics, diagnostic, ts.identity, compareDiagnosticsSkipRelatedInformation);
            if (result >= 0) {
                return diagnostics[result];
            }
            return undefined;
        }
        function add(diagnostic) {
            var diagnostics;
            if (diagnostic.file) {
                diagnostics = fileDiagnostics.get(diagnostic.file.fileName);
                if (!diagnostics) {
                    diagnostics = [];
                    fileDiagnostics.set(diagnostic.file.fileName, diagnostics);
                    ts.insertSorted(filesWithDiagnostics, diagnostic.file.fileName, ts.compareStringsCaseSensitive);
                }
            }
            else {
                if (hasReadNonFileDiagnostics) {
                    hasReadNonFileDiagnostics = false;
                    nonFileDiagnostics = nonFileDiagnostics.slice();
                }
                diagnostics = nonFileDiagnostics;
            }
            ts.insertSorted(diagnostics, diagnostic, compareDiagnostics);
        }
        function getGlobalDiagnostics() {
            hasReadNonFileDiagnostics = true;
            return nonFileDiagnostics;
        }
        function getDiagnostics(fileName) {
            if (fileName) {
                return fileDiagnostics.get(fileName) || [];
            }
            var fileDiags = ts.flatMapToMutable(filesWithDiagnostics, function (f) { return fileDiagnostics.get(f); });
            if (!nonFileDiagnostics.length) {
                return fileDiags;
            }
            fileDiags.unshift.apply(fileDiags, nonFileDiagnostics);
            return fileDiags;
        }
    }
    ts.createDiagnosticCollection = createDiagnosticCollection;
    var templateSubstitutionRegExp = /\$\{/g;
    function escapeTemplateSubstitution(str) {
        return str.replace(templateSubstitutionRegExp, "\\${");
    }
    function hasInvalidEscape(template) {
        return template && !!(ts.isNoSubstitutionTemplateLiteral(template)
            ? template.templateFlags
            : (template.head.templateFlags || ts.some(template.templateSpans, function (span) { return !!span.literal.templateFlags; })));
    }
    ts.hasInvalidEscape = hasInvalidEscape;
    var doubleQuoteEscapedCharsRegExp = /[\\\"\u0000-\u001f\t\v\f\b\r\n\u2028\u2029\u0085]/g;
    var singleQuoteEscapedCharsRegExp = /[\\\'\u0000-\u001f\t\v\f\b\r\n\u2028\u2029\u0085]/g;
    var backtickQuoteEscapedCharsRegExp = /\r\n|[\\\`\u0000-\u001f\t\v\f\b\r\u2028\u2029\u0085]/g;
    var escapedCharsMap = new ts.Map(ts.getEntries({
        "\t": "\\t",
        "\v": "\\v",
        "\f": "\\f",
        "\b": "\\b",
        "\r": "\\r",
        "\n": "\\n",
        "\\": "\\\\",
        "\"": "\\\"",
        "\'": "\\\'",
        "\`": "\\\`",
        "\u2028": "\\u2028",
        "\u2029": "\\u2029",
        "\u0085": "\\u0085",
        "\r\n": "\\r\\n",
    }));
    function encodeUtf16EscapeSequence(charCode) {
        var hexCharCode = charCode.toString(16).toUpperCase();
        var paddedHexCode = ("0000" + hexCharCode).slice(-4);
        return "\\u" + paddedHexCode;
    }
    function getReplacement(c, offset, input) {
        if (c.charCodeAt(0) === 0) {
            var lookAhead = input.charCodeAt(offset + c.length);
            if (lookAhead >= 48 && lookAhead <= 57) {
                return "\\x00";
            }
            return "\\0";
        }
        return escapedCharsMap.get(c) || encodeUtf16EscapeSequence(c.charCodeAt(0));
    }
    function escapeString(s, quoteChar) {
        var escapedCharsRegExp = quoteChar === 96 ? backtickQuoteEscapedCharsRegExp :
            quoteChar === 39 ? singleQuoteEscapedCharsRegExp :
                doubleQuoteEscapedCharsRegExp;
        return s.replace(escapedCharsRegExp, getReplacement);
    }
    ts.escapeString = escapeString;
    var nonAsciiCharacters = /[^\u0000-\u007F]/g;
    function escapeNonAsciiString(s, quoteChar) {
        s = escapeString(s, quoteChar);
        return nonAsciiCharacters.test(s) ?
            s.replace(nonAsciiCharacters, function (c) { return encodeUtf16EscapeSequence(c.charCodeAt(0)); }) :
            s;
    }
    ts.escapeNonAsciiString = escapeNonAsciiString;
    var jsxDoubleQuoteEscapedCharsRegExp = /[\"\u0000-\u001f\u2028\u2029\u0085]/g;
    var jsxSingleQuoteEscapedCharsRegExp = /[\'\u0000-\u001f\u2028\u2029\u0085]/g;
    var jsxEscapedCharsMap = new ts.Map(ts.getEntries({
        "\"": "&quot;",
        "\'": "&apos;"
    }));
    function encodeJsxCharacterEntity(charCode) {
        var hexCharCode = charCode.toString(16).toUpperCase();
        return "&#x" + hexCharCode + ";";
    }
    function getJsxAttributeStringReplacement(c) {
        if (c.charCodeAt(0) === 0) {
            return "&#0;";
        }
        return jsxEscapedCharsMap.get(c) || encodeJsxCharacterEntity(c.charCodeAt(0));
    }
    function escapeJsxAttributeString(s, quoteChar) {
        var escapedCharsRegExp = quoteChar === 39 ? jsxSingleQuoteEscapedCharsRegExp :
            jsxDoubleQuoteEscapedCharsRegExp;
        return s.replace(escapedCharsRegExp, getJsxAttributeStringReplacement);
    }
    ts.escapeJsxAttributeString = escapeJsxAttributeString;
    function stripQuotes(name) {
        var length = name.length;
        if (length >= 2 && name.charCodeAt(0) === name.charCodeAt(length - 1) && isQuoteOrBacktick(name.charCodeAt(0))) {
            return name.substring(1, length - 1);
        }
        return name;
    }
    ts.stripQuotes = stripQuotes;
    function isQuoteOrBacktick(charCode) {
        return charCode === 39 ||
            charCode === 34 ||
            charCode === 96;
    }
    function isIntrinsicJsxName(name) {
        var ch = name.charCodeAt(0);
        return (ch >= 97 && ch <= 122) || ts.stringContains(name, "-") || ts.stringContains(name, ":");
    }
    ts.isIntrinsicJsxName = isIntrinsicJsxName;
    var indentStrings = ["", "    "];
    function getIndentString(level) {
        var singleLevel = indentStrings[1];
        for (var current = indentStrings.length; current <= level; current++) {
            indentStrings.push(indentStrings[current - 1] + singleLevel);
        }
        return indentStrings[level];
    }
    ts.getIndentString = getIndentString;
    function getIndentSize() {
        return indentStrings[1].length;
    }
    ts.getIndentSize = getIndentSize;
    function isNightly() {
        return ts.stringContains(ts.version, "-dev") || ts.stringContains(ts.version, "-insiders");
    }
    ts.isNightly = isNightly;
    function createTextWriter(newLine) {
        var output;
        var indent;
        var lineStart;
        var lineCount;
        var linePos;
        var hasTrailingComment = false;
        function updateLineCountAndPosFor(s) {
            var lineStartsOfS = ts.computeLineStarts(s);
            if (lineStartsOfS.length > 1) {
                lineCount = lineCount + lineStartsOfS.length - 1;
                linePos = output.length - s.length + ts.last(lineStartsOfS);
                lineStart = (linePos - output.length) === 0;
            }
            else {
                lineStart = false;
            }
        }
        function writeText(s) {
            if (s && s.length) {
                if (lineStart) {
                    s = getIndentString(indent) + s;
                    lineStart = false;
                }
                output += s;
                updateLineCountAndPosFor(s);
            }
        }
        function write(s) {
            if (s)
                hasTrailingComment = false;
            writeText(s);
        }
        function writeComment(s) {
            if (s)
                hasTrailingComment = true;
            writeText(s);
        }
        function reset() {
            output = "";
            indent = 0;
            lineStart = true;
            lineCount = 0;
            linePos = 0;
            hasTrailingComment = false;
        }
        function rawWrite(s) {
            if (s !== undefined) {
                output += s;
                updateLineCountAndPosFor(s);
                hasTrailingComment = false;
            }
        }
        function writeLiteral(s) {
            if (s && s.length) {
                write(s);
            }
        }
        function writeLine(force) {
            if (!lineStart || force) {
                output += newLine;
                lineCount++;
                linePos = output.length;
                lineStart = true;
                hasTrailingComment = false;
            }
        }
        function getTextPosWithWriteLine() {
            return lineStart ? output.length : (output.length + newLine.length);
        }
        reset();
        return {
            write: write,
            rawWrite: rawWrite,
            writeLiteral: writeLiteral,
            writeLine: writeLine,
            increaseIndent: function () { indent++; },
            decreaseIndent: function () { indent--; },
            getIndent: function () { return indent; },
            getTextPos: function () { return output.length; },
            getLine: function () { return lineCount; },
            getColumn: function () { return lineStart ? indent * getIndentSize() : output.length - linePos; },
            getText: function () { return output; },
            isAtStartOfLine: function () { return lineStart; },
            hasTrailingComment: function () { return hasTrailingComment; },
            hasTrailingWhitespace: function () { return !!output.length && ts.isWhiteSpaceLike(output.charCodeAt(output.length - 1)); },
            clear: reset,
            reportInaccessibleThisError: ts.noop,
            reportPrivateInBaseOfClassExpression: ts.noop,
            reportInaccessibleUniqueSymbolError: ts.noop,
            trackSymbol: function () { return false; },
            writeKeyword: write,
            writeOperator: write,
            writeParameter: write,
            writeProperty: write,
            writePunctuation: write,
            writeSpace: write,
            writeStringLiteral: write,
            writeSymbol: function (s, _) { return write(s); },
            writeTrailingSemicolon: write,
            writeComment: writeComment,
            getTextPosWithWriteLine: getTextPosWithWriteLine
        };
    }
    ts.createTextWriter = createTextWriter;
    function getTrailingSemicolonDeferringWriter(writer) {
        var pendingTrailingSemicolon = false;
        function commitPendingTrailingSemicolon() {
            if (pendingTrailingSemicolon) {
                writer.writeTrailingSemicolon(";");
                pendingTrailingSemicolon = false;
            }
        }
        return __assign(__assign({}, writer), { writeTrailingSemicolon: function () {
                pendingTrailingSemicolon = true;
            }, writeLiteral: function (s) {
                commitPendingTrailingSemicolon();
                writer.writeLiteral(s);
            }, writeStringLiteral: function (s) {
                commitPendingTrailingSemicolon();
                writer.writeStringLiteral(s);
            }, writeSymbol: function (s, sym) {
                commitPendingTrailingSemicolon();
                writer.writeSymbol(s, sym);
            }, writePunctuation: function (s) {
                commitPendingTrailingSemicolon();
                writer.writePunctuation(s);
            }, writeKeyword: function (s) {
                commitPendingTrailingSemicolon();
                writer.writeKeyword(s);
            }, writeOperator: function (s) {
                commitPendingTrailingSemicolon();
                writer.writeOperator(s);
            }, writeParameter: function (s) {
                commitPendingTrailingSemicolon();
                writer.writeParameter(s);
            }, writeSpace: function (s) {
                commitPendingTrailingSemicolon();
                writer.writeSpace(s);
            }, writeProperty: function (s) {
                commitPendingTrailingSemicolon();
                writer.writeProperty(s);
            }, writeComment: function (s) {
                commitPendingTrailingSemicolon();
                writer.writeComment(s);
            }, writeLine: function () {
                commitPendingTrailingSemicolon();
                writer.writeLine();
            }, increaseIndent: function () {
                commitPendingTrailingSemicolon();
                writer.increaseIndent();
            }, decreaseIndent: function () {
                commitPendingTrailingSemicolon();
                writer.decreaseIndent();
            } });
    }
    ts.getTrailingSemicolonDeferringWriter = getTrailingSemicolonDeferringWriter;
    function hostUsesCaseSensitiveFileNames(host) {
        return host.useCaseSensitiveFileNames ? host.useCaseSensitiveFileNames() : false;
    }
    ts.hostUsesCaseSensitiveFileNames = hostUsesCaseSensitiveFileNames;
    function hostGetCanonicalFileName(host) {
        return ts.createGetCanonicalFileName(hostUsesCaseSensitiveFileNames(host));
    }
    ts.hostGetCanonicalFileName = hostGetCanonicalFileName;
    function getResolvedExternalModuleName(host, file, referenceFile) {
        return file.moduleName || getExternalModuleNameFromPath(host, file.fileName, referenceFile && referenceFile.fileName);
    }
    ts.getResolvedExternalModuleName = getResolvedExternalModuleName;
    function getCanonicalAbsolutePath(host, path) {
        return host.getCanonicalFileName(ts.getNormalizedAbsolutePath(path, host.getCurrentDirectory()));
    }
    function getExternalModuleNameFromDeclaration(host, resolver, declaration) {
        var file = resolver.getExternalModuleFileFromDeclaration(declaration);
        if (!file || file.isDeclarationFile) {
            return undefined;
        }
        var specifier = getExternalModuleName(declaration);
        if (specifier && ts.isStringLiteralLike(specifier) && !ts.pathIsRelative(specifier.text) &&
            getCanonicalAbsolutePath(host, file.path).indexOf(getCanonicalAbsolutePath(host, ts.ensureTrailingDirectorySeparator(host.getCommonSourceDirectory()))) === -1) {
            return undefined;
        }
        return getResolvedExternalModuleName(host, file);
    }
    ts.getExternalModuleNameFromDeclaration = getExternalModuleNameFromDeclaration;
    function getExternalModuleNameFromPath(host, fileName, referencePath) {
        var getCanonicalFileName = function (f) { return host.getCanonicalFileName(f); };
        var dir = ts.toPath(referencePath ? ts.getDirectoryPath(referencePath) : host.getCommonSourceDirectory(), host.getCurrentDirectory(), getCanonicalFileName);
        var filePath = ts.getNormalizedAbsolutePath(fileName, host.getCurrentDirectory());
        var relativePath = ts.getRelativePathToDirectoryOrUrl(dir, filePath, dir, getCanonicalFileName, false);
        var extensionless = removeFileExtension(relativePath);
        return referencePath ? ts.ensurePathIsNonModuleName(extensionless) : extensionless;
    }
    ts.getExternalModuleNameFromPath = getExternalModuleNameFromPath;
    function getOwnEmitOutputFilePath(fileName, host, extension) {
        var compilerOptions = host.getCompilerOptions();
        var emitOutputFilePathWithoutExtension;
        if (compilerOptions.outDir) {
            emitOutputFilePathWithoutExtension = removeFileExtension(getSourceFilePathInNewDir(fileName, host, compilerOptions.outDir));
        }
        else {
            emitOutputFilePathWithoutExtension = removeFileExtension(fileName);
        }
        return emitOutputFilePathWithoutExtension + extension;
    }
    ts.getOwnEmitOutputFilePath = getOwnEmitOutputFilePath;
    function getDeclarationEmitOutputFilePath(fileName, host) {
        return getDeclarationEmitOutputFilePathWorker(fileName, host.getCompilerOptions(), host.getCurrentDirectory(), host.getCommonSourceDirectory(), function (f) { return host.getCanonicalFileName(f); });
    }
    ts.getDeclarationEmitOutputFilePath = getDeclarationEmitOutputFilePath;
    function getDeclarationEmitOutputFilePathWorker(fileName, options, currentDirectory, commonSourceDirectory, getCanonicalFileName) {
        var outputDir = options.declarationDir || options.outDir;
        var path = outputDir
            ? getSourceFilePathInNewDirWorker(fileName, outputDir, currentDirectory, commonSourceDirectory, getCanonicalFileName)
            : fileName;
        var declarationExtension = getDeclarationEmitExtensionForPath(path);
        return removeFileExtension(path) + declarationExtension;
    }
    ts.getDeclarationEmitOutputFilePathWorker = getDeclarationEmitOutputFilePathWorker;
    function getDeclarationEmitExtensionForPath(path) {
        return ts.fileExtensionIsOneOf(path, [".mjs", ".mts"]) ? ".d.mts" :
            ts.fileExtensionIsOneOf(path, [".cjs", ".cts"]) ? ".d.cts" :
                ts.fileExtensionIsOneOf(path, [".json"]) ? ".json.d.ts" :
                    ".d.ts";
    }
    ts.getDeclarationEmitExtensionForPath = getDeclarationEmitExtensionForPath;
    function getPossibleOriginalInputExtensionForExtension(path) {
        return ts.fileExtensionIsOneOf(path, [".d.mts", ".mjs", ".mts"]) ? [".mts", ".mjs"] :
            ts.fileExtensionIsOneOf(path, [".d.cts", ".cjs", ".cts"]) ? [".cts", ".cjs"] :
                ts.fileExtensionIsOneOf(path, [".json.d.ts"]) ? [".json"] :
                    [".tsx", ".ts", ".jsx", ".js"];
    }
    ts.getPossibleOriginalInputExtensionForExtension = getPossibleOriginalInputExtensionForExtension;
    function outFile(options) {
        return options.outFile || options.out;
    }
    ts.outFile = outFile;
    function getPathsBasePath(options, host) {
        var _a, _b;
        if (!options.paths)
            return undefined;
        return (_a = options.baseUrl) !== null && _a !== void 0 ? _a : ts.Debug.checkDefined(options.pathsBasePath || ((_b = host.getCurrentDirectory) === null || _b === void 0 ? void 0 : _b.call(host)), "Encountered 'paths' without a 'baseUrl', config file, or host 'getCurrentDirectory'.");
    }
    ts.getPathsBasePath = getPathsBasePath;
    function getSourceFilesToEmit(host, targetSourceFile, forceDtsEmit) {
        var options = host.getCompilerOptions();
        if (outFile(options)) {
            var moduleKind = getEmitModuleKind(options);
            var moduleEmitEnabled_1 = options.emitDeclarationOnly || moduleKind === ts.ModuleKind.AMD || moduleKind === ts.ModuleKind.System;
            return ts.filter(host.getSourceFiles(), function (sourceFile) {
                return (moduleEmitEnabled_1 || !ts.isExternalModule(sourceFile)) &&
                    sourceFileMayBeEmitted(sourceFile, host, forceDtsEmit);
            });
        }
        else {
            var sourceFiles = targetSourceFile === undefined ? host.getSourceFiles() : [targetSourceFile];
            return ts.filter(sourceFiles, function (sourceFile) { return sourceFileMayBeEmitted(sourceFile, host, forceDtsEmit); });
        }
    }
    ts.getSourceFilesToEmit = getSourceFilesToEmit;
    function sourceFileMayBeEmitted(sourceFile, host, forceDtsEmit) {
        var options = host.getCompilerOptions();
        return !(options.noEmitForJsFiles && isSourceFileJS(sourceFile)) &&
            !sourceFile.isDeclarationFile &&
            !host.isSourceFileFromExternalLibrary(sourceFile) &&
            (forceDtsEmit || (!(isJsonSourceFile(sourceFile) && host.getResolvedProjectReferenceToRedirect(sourceFile.fileName)) &&
                !host.isSourceOfProjectReferenceRedirect(sourceFile.fileName)));
    }
    ts.sourceFileMayBeEmitted = sourceFileMayBeEmitted;
    function getSourceFilePathInNewDir(fileName, host, newDirPath) {
        return getSourceFilePathInNewDirWorker(fileName, newDirPath, host.getCurrentDirectory(), host.getCommonSourceDirectory(), function (f) { return host.getCanonicalFileName(f); });
    }
    ts.getSourceFilePathInNewDir = getSourceFilePathInNewDir;
    function getSourceFilePathInNewDirWorker(fileName, newDirPath, currentDirectory, commonSourceDirectory, getCanonicalFileName) {
        var sourceFilePath = ts.getNormalizedAbsolutePath(fileName, currentDirectory);
        var isSourceFileInCommonSourceDirectory = getCanonicalFileName(sourceFilePath).indexOf(getCanonicalFileName(commonSourceDirectory)) === 0;
        sourceFilePath = isSourceFileInCommonSourceDirectory ? sourceFilePath.substring(commonSourceDirectory.length) : sourceFilePath;
        return ts.combinePaths(newDirPath, sourceFilePath);
    }
    ts.getSourceFilePathInNewDirWorker = getSourceFilePathInNewDirWorker;
    function writeFile(host, diagnostics, fileName, text, writeByteOrderMark, sourceFiles, data) {
        host.writeFile(fileName, text, writeByteOrderMark, function (hostErrorMessage) {
            diagnostics.add(createCompilerDiagnostic(ts.Diagnostics.Could_not_write_file_0_Colon_1, fileName, hostErrorMessage));
        }, sourceFiles, data);
    }
    ts.writeFile = writeFile;
    function ensureDirectoriesExist(directoryPath, createDirectory, directoryExists) {
        if (directoryPath.length > ts.getRootLength(directoryPath) && !directoryExists(directoryPath)) {
            var parentDirectory = ts.getDirectoryPath(directoryPath);
            ensureDirectoriesExist(parentDirectory, createDirectory, directoryExists);
            createDirectory(directoryPath);
        }
    }
    function writeFileEnsuringDirectories(path, data, writeByteOrderMark, writeFile, createDirectory, directoryExists) {
        try {
            writeFile(path, data, writeByteOrderMark);
        }
        catch (_a) {
            ensureDirectoriesExist(ts.getDirectoryPath(ts.normalizePath(path)), createDirectory, directoryExists);
            writeFile(path, data, writeByteOrderMark);
        }
    }
    ts.writeFileEnsuringDirectories = writeFileEnsuringDirectories;
    function getLineOfLocalPosition(sourceFile, pos) {
        var lineStarts = ts.getLineStarts(sourceFile);
        return ts.computeLineOfPosition(lineStarts, pos);
    }
    ts.getLineOfLocalPosition = getLineOfLocalPosition;
    function getLineOfLocalPositionFromLineMap(lineMap, pos) {
        return ts.computeLineOfPosition(lineMap, pos);
    }
    ts.getLineOfLocalPositionFromLineMap = getLineOfLocalPositionFromLineMap;
    function getFirstConstructorWithBody(node) {
        return ts.find(node.members, function (member) { return ts.isConstructorDeclaration(member) && nodeIsPresent(member.body); });
    }
    ts.getFirstConstructorWithBody = getFirstConstructorWithBody;
    function getSetAccessorValueParameter(accessor) {
        if (accessor && accessor.parameters.length > 0) {
            var hasThis = accessor.parameters.length === 2 && parameterIsThisKeyword(accessor.parameters[0]);
            return accessor.parameters[hasThis ? 1 : 0];
        }
    }
    ts.getSetAccessorValueParameter = getSetAccessorValueParameter;
    function getSetAccessorTypeAnnotationNode(accessor) {
        var parameter = getSetAccessorValueParameter(accessor);
        return parameter && parameter.type;
    }
    ts.getSetAccessorTypeAnnotationNode = getSetAccessorTypeAnnotationNode;
    function getThisParameter(signature) {
        if (signature.parameters.length && !ts.isJSDocSignature(signature)) {
            var thisParameter = signature.parameters[0];
            if (parameterIsThisKeyword(thisParameter)) {
                return thisParameter;
            }
        }
    }
    ts.getThisParameter = getThisParameter;
    function parameterIsThisKeyword(parameter) {
        return isThisIdentifier(parameter.name);
    }
    ts.parameterIsThisKeyword = parameterIsThisKeyword;
    function isThisIdentifier(node) {
        return !!node && node.kind === 79 && identifierIsThisKeyword(node);
    }
    ts.isThisIdentifier = isThisIdentifier;
    function isThisInTypeQuery(node) {
        if (!isThisIdentifier(node)) {
            return false;
        }
        while (ts.isQualifiedName(node.parent) && node.parent.left === node) {
            node = node.parent;
        }
        return node.parent.kind === 181;
    }
    ts.isThisInTypeQuery = isThisInTypeQuery;
    function identifierIsThisKeyword(id) {
        return id.originalKeywordKind === 108;
    }
    ts.identifierIsThisKeyword = identifierIsThisKeyword;
    function getAllAccessorDeclarations(declarations, accessor) {
        var firstAccessor;
        var secondAccessor;
        var getAccessor;
        var setAccessor;
        if (hasDynamicName(accessor)) {
            firstAccessor = accessor;
            if (accessor.kind === 172) {
                getAccessor = accessor;
            }
            else if (accessor.kind === 173) {
                setAccessor = accessor;
            }
            else {
                ts.Debug.fail("Accessor has wrong kind");
            }
        }
        else {
            ts.forEach(declarations, function (member) {
                if (ts.isAccessor(member)
                    && isStatic(member) === isStatic(accessor)) {
                    var memberName = getPropertyNameForPropertyNameNode(member.name);
                    var accessorName = getPropertyNameForPropertyNameNode(accessor.name);
                    if (memberName === accessorName) {
                        if (!firstAccessor) {
                            firstAccessor = member;
                        }
                        else if (!secondAccessor) {
                            secondAccessor = member;
                        }
                        if (member.kind === 172 && !getAccessor) {
                            getAccessor = member;
                        }
                        if (member.kind === 173 && !setAccessor) {
                            setAccessor = member;
                        }
                    }
                }
            });
        }
        return {
            firstAccessor: firstAccessor,
            secondAccessor: secondAccessor,
            getAccessor: getAccessor,
            setAccessor: setAccessor
        };
    }
    ts.getAllAccessorDeclarations = getAllAccessorDeclarations;
    function getEffectiveTypeAnnotationNode(node) {
        if (!isInJSFile(node) && ts.isFunctionDeclaration(node))
            return undefined;
        var type = node.type;
        if (type || !isInJSFile(node))
            return type;
        return ts.isJSDocPropertyLikeTag(node) ? node.typeExpression && node.typeExpression.type : ts.getJSDocType(node);
    }
    ts.getEffectiveTypeAnnotationNode = getEffectiveTypeAnnotationNode;
    function getTypeAnnotationNode(node) {
        return node.type;
    }
    ts.getTypeAnnotationNode = getTypeAnnotationNode;
    function getEffectiveReturnTypeNode(node) {
        return ts.isJSDocSignature(node) ?
            node.type && node.type.typeExpression && node.type.typeExpression.type :
            node.type || (isInJSFile(node) ? ts.getJSDocReturnType(node) : undefined);
    }
    ts.getEffectiveReturnTypeNode = getEffectiveReturnTypeNode;
    function getJSDocTypeParameterDeclarations(node) {
        return ts.flatMap(ts.getJSDocTags(node), function (tag) { return isNonTypeAliasTemplate(tag) ? tag.typeParameters : undefined; });
    }
    ts.getJSDocTypeParameterDeclarations = getJSDocTypeParameterDeclarations;
    function isNonTypeAliasTemplate(tag) {
        return ts.isJSDocTemplateTag(tag) && !(tag.parent.kind === 320 && tag.parent.tags.some(isJSDocTypeAlias));
    }
    function getEffectiveSetAccessorTypeAnnotationNode(node) {
        var parameter = getSetAccessorValueParameter(node);
        return parameter && getEffectiveTypeAnnotationNode(parameter);
    }
    ts.getEffectiveSetAccessorTypeAnnotationNode = getEffectiveSetAccessorTypeAnnotationNode;
    function emitNewLineBeforeLeadingComments(lineMap, writer, node, leadingComments) {
        emitNewLineBeforeLeadingCommentsOfPosition(lineMap, writer, node.pos, leadingComments);
    }
    ts.emitNewLineBeforeLeadingComments = emitNewLineBeforeLeadingComments;
    function emitNewLineBeforeLeadingCommentsOfPosition(lineMap, writer, pos, leadingComments) {
        if (leadingComments && leadingComments.length && pos !== leadingComments[0].pos &&
            getLineOfLocalPositionFromLineMap(lineMap, pos) !== getLineOfLocalPositionFromLineMap(lineMap, leadingComments[0].pos)) {
            writer.writeLine();
        }
    }
    ts.emitNewLineBeforeLeadingCommentsOfPosition = emitNewLineBeforeLeadingCommentsOfPosition;
    function emitNewLineBeforeLeadingCommentOfPosition(lineMap, writer, pos, commentPos) {
        if (pos !== commentPos &&
            getLineOfLocalPositionFromLineMap(lineMap, pos) !== getLineOfLocalPositionFromLineMap(lineMap, commentPos)) {
            writer.writeLine();
        }
    }
    ts.emitNewLineBeforeLeadingCommentOfPosition = emitNewLineBeforeLeadingCommentOfPosition;
    function emitComments(text, lineMap, writer, comments, leadingSeparator, trailingSeparator, newLine, writeComment) {
        if (comments && comments.length > 0) {
            if (leadingSeparator) {
                writer.writeSpace(" ");
            }
            var emitInterveningSeparator = false;
            for (var _i = 0, comments_1 = comments; _i < comments_1.length; _i++) {
                var comment = comments_1[_i];
                if (emitInterveningSeparator) {
                    writer.writeSpace(" ");
                    emitInterveningSeparator = false;
                }
                writeComment(text, lineMap, writer, comment.pos, comment.end, newLine);
                if (comment.hasTrailingNewLine) {
                    writer.writeLine();
                }
                else {
                    emitInterveningSeparator = true;
                }
            }
            if (emitInterveningSeparator && trailingSeparator) {
                writer.writeSpace(" ");
            }
        }
    }
    ts.emitComments = emitComments;
    function emitDetachedComments(text, lineMap, writer, writeComment, node, newLine, removeComments) {
        var leadingComments;
        var currentDetachedCommentInfo;
        if (removeComments) {
            if (node.pos === 0) {
                leadingComments = ts.filter(ts.getLeadingCommentRanges(text, node.pos), isPinnedCommentLocal);
            }
        }
        else {
            leadingComments = ts.getLeadingCommentRanges(text, node.pos);
        }
        if (leadingComments) {
            var detachedComments = [];
            var lastComment = void 0;
            for (var _i = 0, leadingComments_1 = leadingComments; _i < leadingComments_1.length; _i++) {
                var comment = leadingComments_1[_i];
                if (lastComment) {
                    var lastCommentLine = getLineOfLocalPositionFromLineMap(lineMap, lastComment.end);
                    var commentLine = getLineOfLocalPositionFromLineMap(lineMap, comment.pos);
                    if (commentLine >= lastCommentLine + 2) {
                        break;
                    }
                }
                detachedComments.push(comment);
                lastComment = comment;
            }
            if (detachedComments.length) {
                var lastCommentLine = getLineOfLocalPositionFromLineMap(lineMap, ts.last(detachedComments).end);
                var nodeLine = getLineOfLocalPositionFromLineMap(lineMap, ts.skipTrivia(text, node.pos));
                if (nodeLine >= lastCommentLine + 2) {
                    emitNewLineBeforeLeadingComments(lineMap, writer, node, leadingComments);
                    emitComments(text, lineMap, writer, detachedComments, false, true, newLine, writeComment);
                    currentDetachedCommentInfo = { nodePos: node.pos, detachedCommentEndPos: ts.last(detachedComments).end };
                }
            }
        }
        return currentDetachedCommentInfo;
        function isPinnedCommentLocal(comment) {
            return isPinnedComment(text, comment.pos);
        }
    }
    ts.emitDetachedComments = emitDetachedComments;
    function writeCommentRange(text, lineMap, writer, commentPos, commentEnd, newLine) {
        if (text.charCodeAt(commentPos + 1) === 42) {
            var firstCommentLineAndCharacter = ts.computeLineAndCharacterOfPosition(lineMap, commentPos);
            var lineCount = lineMap.length;
            var firstCommentLineIndent = void 0;
            for (var pos = commentPos, currentLine = firstCommentLineAndCharacter.line; pos < commentEnd; currentLine++) {
                var nextLineStart = (currentLine + 1) === lineCount
                    ? text.length + 1
                    : lineMap[currentLine + 1];
                if (pos !== commentPos) {
                    if (firstCommentLineIndent === undefined) {
                        firstCommentLineIndent = calculateIndent(text, lineMap[firstCommentLineAndCharacter.line], commentPos);
                    }
                    var currentWriterIndentSpacing = writer.getIndent() * getIndentSize();
                    var spacesToEmit = currentWriterIndentSpacing - firstCommentLineIndent + calculateIndent(text, pos, nextLineStart);
                    if (spacesToEmit > 0) {
                        var numberOfSingleSpacesToEmit = spacesToEmit % getIndentSize();
                        var indentSizeSpaceString = getIndentString((spacesToEmit - numberOfSingleSpacesToEmit) / getIndentSize());
                        writer.rawWrite(indentSizeSpaceString);
                        while (numberOfSingleSpacesToEmit) {
                            writer.rawWrite(" ");
                            numberOfSingleSpacesToEmit--;
                        }
                    }
                    else {
                        writer.rawWrite("");
                    }
                }
                writeTrimmedCurrentLine(text, commentEnd, writer, newLine, pos, nextLineStart);
                pos = nextLineStart;
            }
        }
        else {
            writer.writeComment(text.substring(commentPos, commentEnd));
        }
    }
    ts.writeCommentRange = writeCommentRange;
    function writeTrimmedCurrentLine(text, commentEnd, writer, newLine, pos, nextLineStart) {
        var end = Math.min(commentEnd, nextLineStart - 1);
        var currentLineText = ts.trimString(text.substring(pos, end));
        if (currentLineText) {
            writer.writeComment(currentLineText);
            if (end !== commentEnd) {
                writer.writeLine();
            }
        }
        else {
            writer.rawWrite(newLine);
        }
    }
    function calculateIndent(text, pos, end) {
        var currentLineIndent = 0;
        for (; pos < end && ts.isWhiteSpaceSingleLine(text.charCodeAt(pos)); pos++) {
            if (text.charCodeAt(pos) === 9) {
                currentLineIndent += getIndentSize() - (currentLineIndent % getIndentSize());
            }
            else {
                currentLineIndent++;
            }
        }
        return currentLineIndent;
    }
    function hasEffectiveModifiers(node) {
        return getEffectiveModifierFlags(node) !== 0;
    }
    ts.hasEffectiveModifiers = hasEffectiveModifiers;
    function hasSyntacticModifiers(node) {
        return getSyntacticModifierFlags(node) !== 0;
    }
    ts.hasSyntacticModifiers = hasSyntacticModifiers;
    function hasEffectiveModifier(node, flags) {
        return !!getSelectedEffectiveModifierFlags(node, flags);
    }
    ts.hasEffectiveModifier = hasEffectiveModifier;
    function hasSyntacticModifier(node, flags) {
        return !!getSelectedSyntacticModifierFlags(node, flags);
    }
    ts.hasSyntacticModifier = hasSyntacticModifier;
    function isStatic(node) {
        return ts.isClassElement(node) && hasStaticModifier(node) || ts.isClassStaticBlockDeclaration(node);
    }
    ts.isStatic = isStatic;
    function hasStaticModifier(node) {
        return hasSyntacticModifier(node, 32);
    }
    ts.hasStaticModifier = hasStaticModifier;
    function hasOverrideModifier(node) {
        return hasEffectiveModifier(node, 16384);
    }
    ts.hasOverrideModifier = hasOverrideModifier;
    function hasAbstractModifier(node) {
        return hasSyntacticModifier(node, 128);
    }
    ts.hasAbstractModifier = hasAbstractModifier;
    function hasAmbientModifier(node) {
        return hasSyntacticModifier(node, 2);
    }
    ts.hasAmbientModifier = hasAmbientModifier;
    function hasEffectiveReadonlyModifier(node) {
        return hasEffectiveModifier(node, 64);
    }
    ts.hasEffectiveReadonlyModifier = hasEffectiveReadonlyModifier;
    function getSelectedEffectiveModifierFlags(node, flags) {
        return getEffectiveModifierFlags(node) & flags;
    }
    ts.getSelectedEffectiveModifierFlags = getSelectedEffectiveModifierFlags;
    function getSelectedSyntacticModifierFlags(node, flags) {
        return getSyntacticModifierFlags(node) & flags;
    }
    ts.getSelectedSyntacticModifierFlags = getSelectedSyntacticModifierFlags;
    function getModifierFlagsWorker(node, includeJSDoc, alwaysIncludeJSDoc) {
        if (node.kind >= 0 && node.kind <= 160) {
            return 0;
        }
        if (!(node.modifierFlagsCache & 536870912)) {
            node.modifierFlagsCache = getSyntacticModifierFlagsNoCache(node) | 536870912;
        }
        if (includeJSDoc && !(node.modifierFlagsCache & 4096) && (alwaysIncludeJSDoc || isInJSFile(node)) && node.parent) {
            node.modifierFlagsCache |= getJSDocModifierFlagsNoCache(node) | 4096;
        }
        return node.modifierFlagsCache & ~(536870912 | 4096);
    }
    function getEffectiveModifierFlags(node) {
        return getModifierFlagsWorker(node, true);
    }
    ts.getEffectiveModifierFlags = getEffectiveModifierFlags;
    function getEffectiveModifierFlagsAlwaysIncludeJSDoc(node) {
        return getModifierFlagsWorker(node, true, true);
    }
    ts.getEffectiveModifierFlagsAlwaysIncludeJSDoc = getEffectiveModifierFlagsAlwaysIncludeJSDoc;
    function getSyntacticModifierFlags(node) {
        return getModifierFlagsWorker(node, false);
    }
    ts.getSyntacticModifierFlags = getSyntacticModifierFlags;
    function getJSDocModifierFlagsNoCache(node) {
        var flags = 0;
        if (!!node.parent && !ts.isParameter(node)) {
            if (isInJSFile(node)) {
                if (ts.getJSDocPublicTagNoCache(node))
                    flags |= 4;
                if (ts.getJSDocPrivateTagNoCache(node))
                    flags |= 8;
                if (ts.getJSDocProtectedTagNoCache(node))
                    flags |= 16;
                if (ts.getJSDocReadonlyTagNoCache(node))
                    flags |= 64;
                if (ts.getJSDocOverrideTagNoCache(node))
                    flags |= 16384;
            }
            if (ts.getJSDocDeprecatedTagNoCache(node))
                flags |= 8192;
        }
        return flags;
    }
    function getEffectiveModifierFlagsNoCache(node) {
        return getSyntacticModifierFlagsNoCache(node) | getJSDocModifierFlagsNoCache(node);
    }
    ts.getEffectiveModifierFlagsNoCache = getEffectiveModifierFlagsNoCache;
    function getSyntacticModifierFlagsNoCache(node) {
        var flags = modifiersToFlags(node.modifiers);
        if (node.flags & 4 || (node.kind === 79 && node.isInJSDocNamespace)) {
            flags |= 1;
        }
        return flags;
    }
    ts.getSyntacticModifierFlagsNoCache = getSyntacticModifierFlagsNoCache;
    function modifiersToFlags(modifiers) {
        var flags = 0;
        if (modifiers) {
            for (var _i = 0, modifiers_1 = modifiers; _i < modifiers_1.length; _i++) {
                var modifier = modifiers_1[_i];
                flags |= modifierToFlag(modifier.kind);
            }
        }
        return flags;
    }
    ts.modifiersToFlags = modifiersToFlags;
    function modifierToFlag(token) {
        switch (token) {
            case 124: return 32;
            case 123: return 4;
            case 122: return 16;
            case 121: return 8;
            case 126: return 128;
            case 93: return 1;
            case 135: return 2;
            case 85: return 2048;
            case 88: return 512;
            case 131: return 256;
            case 145: return 64;
            case 159: return 16384;
            case 101: return 32768;
            case 144: return 65536;
        }
        return 0;
    }
    ts.modifierToFlag = modifierToFlag;
    function createModifiers(modifierFlags) {
        return modifierFlags ? ts.factory.createNodeArray(ts.factory.createModifiersFromModifierFlags(modifierFlags)) : undefined;
    }
    ts.createModifiers = createModifiers;
    function isLogicalOperator(token) {
        return token === 56
            || token === 55
            || token === 53;
    }
    ts.isLogicalOperator = isLogicalOperator;
    function isLogicalOrCoalescingAssignmentOperator(token) {
        return token === 75
            || token === 76
            || token === 77;
    }
    ts.isLogicalOrCoalescingAssignmentOperator = isLogicalOrCoalescingAssignmentOperator;
    function isLogicalOrCoalescingAssignmentExpression(expr) {
        return isLogicalOrCoalescingAssignmentOperator(expr.operatorToken.kind);
    }
    ts.isLogicalOrCoalescingAssignmentExpression = isLogicalOrCoalescingAssignmentExpression;
    function isAssignmentOperator(token) {
        return token >= 63 && token <= 78;
    }
    ts.isAssignmentOperator = isAssignmentOperator;
    function tryGetClassExtendingExpressionWithTypeArguments(node) {
        var cls = tryGetClassImplementingOrExtendingExpressionWithTypeArguments(node);
        return cls && !cls.isImplements ? cls.class : undefined;
    }
    ts.tryGetClassExtendingExpressionWithTypeArguments = tryGetClassExtendingExpressionWithTypeArguments;
    function tryGetClassImplementingOrExtendingExpressionWithTypeArguments(node) {
        return ts.isExpressionWithTypeArguments(node)
            && ts.isHeritageClause(node.parent)
            && ts.isClassLike(node.parent.parent)
            ? { class: node.parent.parent, isImplements: node.parent.token === 117 }
            : undefined;
    }
    ts.tryGetClassImplementingOrExtendingExpressionWithTypeArguments = tryGetClassImplementingOrExtendingExpressionWithTypeArguments;
    function isAssignmentExpression(node, excludeCompoundAssignment) {
        return ts.isBinaryExpression(node)
            && (excludeCompoundAssignment
                ? node.operatorToken.kind === 63
                : isAssignmentOperator(node.operatorToken.kind))
            && ts.isLeftHandSideExpression(node.left);
    }
    ts.isAssignmentExpression = isAssignmentExpression;
    function isLeftHandSideOfAssignment(node) {
        return isAssignmentExpression(node.parent) && node.parent.left === node;
    }
    ts.isLeftHandSideOfAssignment = isLeftHandSideOfAssignment;
    function isDestructuringAssignment(node) {
        if (isAssignmentExpression(node, true)) {
            var kind = node.left.kind;
            return kind === 205
                || kind === 204;
        }
        return false;
    }
    ts.isDestructuringAssignment = isDestructuringAssignment;
    function isExpressionWithTypeArgumentsInClassExtendsClause(node) {
        return tryGetClassExtendingExpressionWithTypeArguments(node) !== undefined;
    }
    ts.isExpressionWithTypeArgumentsInClassExtendsClause = isExpressionWithTypeArgumentsInClassExtendsClause;
    function isEntityNameExpression(node) {
        return node.kind === 79 || isPropertyAccessEntityNameExpression(node);
    }
    ts.isEntityNameExpression = isEntityNameExpression;
    function getFirstIdentifier(node) {
        switch (node.kind) {
            case 79:
                return node;
            case 161:
                do {
                    node = node.left;
                } while (node.kind !== 79);
                return node;
            case 206:
                do {
                    node = node.expression;
                } while (node.kind !== 79);
                return node;
        }
    }
    ts.getFirstIdentifier = getFirstIdentifier;
    function isDottedName(node) {
        return node.kind === 79
            || node.kind === 108
            || node.kind === 106
            || node.kind === 231
            || node.kind === 206 && isDottedName(node.expression)
            || node.kind === 212 && isDottedName(node.expression);
    }
    ts.isDottedName = isDottedName;
    function isPropertyAccessEntityNameExpression(node) {
        return ts.isPropertyAccessExpression(node) && ts.isIdentifier(node.name) && isEntityNameExpression(node.expression);
    }
    ts.isPropertyAccessEntityNameExpression = isPropertyAccessEntityNameExpression;
    function tryGetPropertyAccessOrIdentifierToString(expr) {
        if (ts.isPropertyAccessExpression(expr)) {
            var baseStr = tryGetPropertyAccessOrIdentifierToString(expr.expression);
            if (baseStr !== undefined) {
                return baseStr + "." + entityNameToString(expr.name);
            }
        }
        else if (ts.isElementAccessExpression(expr)) {
            var baseStr = tryGetPropertyAccessOrIdentifierToString(expr.expression);
            if (baseStr !== undefined && ts.isPropertyName(expr.argumentExpression)) {
                return baseStr + "." + getPropertyNameForPropertyNameNode(expr.argumentExpression);
            }
        }
        else if (ts.isIdentifier(expr)) {
            return ts.unescapeLeadingUnderscores(expr.escapedText);
        }
        return undefined;
    }
    ts.tryGetPropertyAccessOrIdentifierToString = tryGetPropertyAccessOrIdentifierToString;
    function isPrototypeAccess(node) {
        return isBindableStaticAccessExpression(node) && getElementOrPropertyAccessName(node) === "prototype";
    }
    ts.isPrototypeAccess = isPrototypeAccess;
    function isRightSideOfQualifiedNameOrPropertyAccess(node) {
        return (node.parent.kind === 161 && node.parent.right === node) ||
            (node.parent.kind === 206 && node.parent.name === node);
    }
    ts.isRightSideOfQualifiedNameOrPropertyAccess = isRightSideOfQualifiedNameOrPropertyAccess;
    function isRightSideOfAccessExpression(node) {
        return ts.isPropertyAccessExpression(node.parent) && node.parent.name === node
            || ts.isElementAccessExpression(node.parent) && node.parent.argumentExpression === node;
    }
    ts.isRightSideOfAccessExpression = isRightSideOfAccessExpression;
    function isRightSideOfQualifiedNameOrPropertyAccessOrJSDocMemberName(node) {
        return ts.isQualifiedName(node.parent) && node.parent.right === node
            || ts.isPropertyAccessExpression(node.parent) && node.parent.name === node
            || ts.isJSDocMemberName(node.parent) && node.parent.right === node;
    }
    ts.isRightSideOfQualifiedNameOrPropertyAccessOrJSDocMemberName = isRightSideOfQualifiedNameOrPropertyAccessOrJSDocMemberName;
    function isEmptyObjectLiteral(expression) {
        return expression.kind === 205 &&
            expression.properties.length === 0;
    }
    ts.isEmptyObjectLiteral = isEmptyObjectLiteral;
    function isEmptyArrayLiteral(expression) {
        return expression.kind === 204 &&
            expression.elements.length === 0;
    }
    ts.isEmptyArrayLiteral = isEmptyArrayLiteral;
    function getLocalSymbolForExportDefault(symbol) {
        if (!isExportDefaultSymbol(symbol) || !symbol.declarations)
            return undefined;
        for (var _i = 0, _a = symbol.declarations; _i < _a.length; _i++) {
            var decl = _a[_i];
            if (decl.localSymbol)
                return decl.localSymbol;
        }
        return undefined;
    }
    ts.getLocalSymbolForExportDefault = getLocalSymbolForExportDefault;
    function isExportDefaultSymbol(symbol) {
        return symbol && ts.length(symbol.declarations) > 0 && hasSyntacticModifier(symbol.declarations[0], 512);
    }
    function tryExtractTSExtension(fileName) {
        return ts.find(supportedTSExtensionsForExtractExtension, function (extension) { return ts.fileExtensionIs(fileName, extension); });
    }
    ts.tryExtractTSExtension = tryExtractTSExtension;
    function getExpandedCharCodes(input) {
        var output = [];
        var length = input.length;
        for (var i = 0; i < length; i++) {
            var charCode = input.charCodeAt(i);
            if (charCode < 0x80) {
                output.push(charCode);
            }
            else if (charCode < 0x800) {
                output.push((charCode >> 6) | 192);
                output.push((charCode & 63) | 128);
            }
            else if (charCode < 0x10000) {
                output.push((charCode >> 12) | 224);
                output.push(((charCode >> 6) & 63) | 128);
                output.push((charCode & 63) | 128);
            }
            else if (charCode < 0x20000) {
                output.push((charCode >> 18) | 240);
                output.push(((charCode >> 12) & 63) | 128);
                output.push(((charCode >> 6) & 63) | 128);
                output.push((charCode & 63) | 128);
            }
            else {
                ts.Debug.assert(false, "Unexpected code point");
            }
        }
        return output;
    }
    var base64Digits = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    function convertToBase64(input) {
        var result = "";
        var charCodes = getExpandedCharCodes(input);
        var i = 0;
        var length = charCodes.length;
        var byte1, byte2, byte3, byte4;
        while (i < length) {
            byte1 = charCodes[i] >> 2;
            byte2 = (charCodes[i] & 3) << 4 | charCodes[i + 1] >> 4;
            byte3 = (charCodes[i + 1] & 15) << 2 | charCodes[i + 2] >> 6;
            byte4 = charCodes[i + 2] & 63;
            if (i + 1 >= length) {
                byte3 = byte4 = 64;
            }
            else if (i + 2 >= length) {
                byte4 = 64;
            }
            result += base64Digits.charAt(byte1) + base64Digits.charAt(byte2) + base64Digits.charAt(byte3) + base64Digits.charAt(byte4);
            i += 3;
        }
        return result;
    }
    ts.convertToBase64 = convertToBase64;
    function getStringFromExpandedCharCodes(codes) {
        var output = "";
        var i = 0;
        var length = codes.length;
        while (i < length) {
            var charCode = codes[i];
            if (charCode < 0x80) {
                output += String.fromCharCode(charCode);
                i++;
            }
            else if ((charCode & 192) === 192) {
                var value = charCode & 63;
                i++;
                var nextCode = codes[i];
                while ((nextCode & 192) === 128) {
                    value = (value << 6) | (nextCode & 63);
                    i++;
                    nextCode = codes[i];
                }
                output += String.fromCharCode(value);
            }
            else {
                output += String.fromCharCode(charCode);
                i++;
            }
        }
        return output;
    }
    function base64encode(host, input) {
        if (host && host.base64encode) {
            return host.base64encode(input);
        }
        return convertToBase64(input);
    }
    ts.base64encode = base64encode;
    function base64decode(host, input) {
        if (host && host.base64decode) {
            return host.base64decode(input);
        }
        var length = input.length;
        var expandedCharCodes = [];
        var i = 0;
        while (i < length) {
            if (input.charCodeAt(i) === base64Digits.charCodeAt(64)) {
                break;
            }
            var ch1 = base64Digits.indexOf(input[i]);
            var ch2 = base64Digits.indexOf(input[i + 1]);
            var ch3 = base64Digits.indexOf(input[i + 2]);
            var ch4 = base64Digits.indexOf(input[i + 3]);
            var code1 = ((ch1 & 63) << 2) | ((ch2 >> 4) & 3);
            var code2 = ((ch2 & 15) << 4) | ((ch3 >> 2) & 15);
            var code3 = ((ch3 & 3) << 6) | (ch4 & 63);
            if (code2 === 0 && ch3 !== 0) {
                expandedCharCodes.push(code1);
            }
            else if (code3 === 0 && ch4 !== 0) {
                expandedCharCodes.push(code1, code2);
            }
            else {
                expandedCharCodes.push(code1, code2, code3);
            }
            i += 4;
        }
        return getStringFromExpandedCharCodes(expandedCharCodes);
    }
    ts.base64decode = base64decode;
    function readJson(path, host) {
        try {
            var jsonText = host.readFile(path);
            if (!jsonText)
                return {};
            var result = ts.parseConfigFileTextToJson(path, jsonText);
            if (result.error) {
                return {};
            }
            return result.config;
        }
        catch (e) {
            return {};
        }
    }
    ts.readJson = readJson;
    function directoryProbablyExists(directoryName, host) {
        return !host.directoryExists || host.directoryExists(directoryName);
    }
    ts.directoryProbablyExists = directoryProbablyExists;
    var carriageReturnLineFeed = "\r\n";
    var lineFeed = "\n";
    function getNewLineCharacter(options, getNewLine) {
        switch (options.newLine) {
            case 0:
                return carriageReturnLineFeed;
            case 1:
                return lineFeed;
        }
        return getNewLine ? getNewLine() : ts.sys ? ts.sys.newLine : carriageReturnLineFeed;
    }
    ts.getNewLineCharacter = getNewLineCharacter;
    function createRange(pos, end) {
        if (end === void 0) { end = pos; }
        ts.Debug.assert(end >= pos || end === -1);
        return { pos: pos, end: end };
    }
    ts.createRange = createRange;
    function moveRangeEnd(range, end) {
        return createRange(range.pos, end);
    }
    ts.moveRangeEnd = moveRangeEnd;
    function moveRangePos(range, pos) {
        return createRange(pos, range.end);
    }
    ts.moveRangePos = moveRangePos;
    function moveRangePastDecorators(node) {
        return node.decorators && node.decorators.length > 0
            ? moveRangePos(node, node.decorators.end)
            : node;
    }
    ts.moveRangePastDecorators = moveRangePastDecorators;
    function moveRangePastModifiers(node) {
        return node.modifiers && node.modifiers.length > 0
            ? moveRangePos(node, node.modifiers.end)
            : moveRangePastDecorators(node);
    }
    ts.moveRangePastModifiers = moveRangePastModifiers;
    function isCollapsedRange(range) {
        return range.pos === range.end;
    }
    ts.isCollapsedRange = isCollapsedRange;
    function createTokenRange(pos, token) {
        return createRange(pos, pos + ts.tokenToString(token).length);
    }
    ts.createTokenRange = createTokenRange;
    function rangeIsOnSingleLine(range, sourceFile) {
        return rangeStartIsOnSameLineAsRangeEnd(range, range, sourceFile);
    }
    ts.rangeIsOnSingleLine = rangeIsOnSingleLine;
    function rangeStartPositionsAreOnSameLine(range1, range2, sourceFile) {
        return positionsAreOnSameLine(getStartPositionOfRange(range1, sourceFile, false), getStartPositionOfRange(range2, sourceFile, false), sourceFile);
    }
    ts.rangeStartPositionsAreOnSameLine = rangeStartPositionsAreOnSameLine;
    function rangeEndPositionsAreOnSameLine(range1, range2, sourceFile) {
        return positionsAreOnSameLine(range1.end, range2.end, sourceFile);
    }
    ts.rangeEndPositionsAreOnSameLine = rangeEndPositionsAreOnSameLine;
    function rangeStartIsOnSameLineAsRangeEnd(range1, range2, sourceFile) {
        return positionsAreOnSameLine(getStartPositionOfRange(range1, sourceFile, false), range2.end, sourceFile);
    }
    ts.rangeStartIsOnSameLineAsRangeEnd = rangeStartIsOnSameLineAsRangeEnd;
    function rangeEndIsOnSameLineAsRangeStart(range1, range2, sourceFile) {
        return positionsAreOnSameLine(range1.end, getStartPositionOfRange(range2, sourceFile, false), sourceFile);
    }
    ts.rangeEndIsOnSameLineAsRangeStart = rangeEndIsOnSameLineAsRangeStart;
    function getLinesBetweenRangeEndAndRangeStart(range1, range2, sourceFile, includeSecondRangeComments) {
        var range2Start = getStartPositionOfRange(range2, sourceFile, includeSecondRangeComments);
        return ts.getLinesBetweenPositions(sourceFile, range1.end, range2Start);
    }
    ts.getLinesBetweenRangeEndAndRangeStart = getLinesBetweenRangeEndAndRangeStart;
    function getLinesBetweenRangeEndPositions(range1, range2, sourceFile) {
        return ts.getLinesBetweenPositions(sourceFile, range1.end, range2.end);
    }
    ts.getLinesBetweenRangeEndPositions = getLinesBetweenRangeEndPositions;
    function isNodeArrayMultiLine(list, sourceFile) {
        return !positionsAreOnSameLine(list.pos, list.end, sourceFile);
    }
    ts.isNodeArrayMultiLine = isNodeArrayMultiLine;
    function positionsAreOnSameLine(pos1, pos2, sourceFile) {
        return ts.getLinesBetweenPositions(sourceFile, pos1, pos2) === 0;
    }
    ts.positionsAreOnSameLine = positionsAreOnSameLine;
    function getStartPositionOfRange(range, sourceFile, includeComments) {
        return positionIsSynthesized(range.pos) ? -1 : ts.skipTrivia(sourceFile.text, range.pos, false, includeComments);
    }
    ts.getStartPositionOfRange = getStartPositionOfRange;
    function getLinesBetweenPositionAndPrecedingNonWhitespaceCharacter(pos, stopPos, sourceFile, includeComments) {
        var startPos = ts.skipTrivia(sourceFile.text, pos, false, includeComments);
        var prevPos = getPreviousNonWhitespacePosition(startPos, stopPos, sourceFile);
        return ts.getLinesBetweenPositions(sourceFile, prevPos !== null && prevPos !== void 0 ? prevPos : stopPos, startPos);
    }
    ts.getLinesBetweenPositionAndPrecedingNonWhitespaceCharacter = getLinesBetweenPositionAndPrecedingNonWhitespaceCharacter;
    function getLinesBetweenPositionAndNextNonWhitespaceCharacter(pos, stopPos, sourceFile, includeComments) {
        var nextPos = ts.skipTrivia(sourceFile.text, pos, false, includeComments);
        return ts.getLinesBetweenPositions(sourceFile, pos, Math.min(stopPos, nextPos));
    }
    ts.getLinesBetweenPositionAndNextNonWhitespaceCharacter = getLinesBetweenPositionAndNextNonWhitespaceCharacter;
    function getPreviousNonWhitespacePosition(pos, stopPos, sourceFile) {
        if (stopPos === void 0) { stopPos = 0; }
        while (pos-- > stopPos) {
            if (!ts.isWhiteSpaceLike(sourceFile.text.charCodeAt(pos))) {
                return pos;
            }
        }
    }
    function isDeclarationNameOfEnumOrNamespace(node) {
        var parseNode = ts.getParseTreeNode(node);
        if (parseNode) {
            switch (parseNode.parent.kind) {
                case 260:
                case 261:
                    return parseNode === parseNode.parent.name;
            }
        }
        return false;
    }
    ts.isDeclarationNameOfEnumOrNamespace = isDeclarationNameOfEnumOrNamespace;
    function getInitializedVariables(node) {
        return ts.filter(node.declarations, isInitializedVariable);
    }
    ts.getInitializedVariables = getInitializedVariables;
    function isInitializedVariable(node) {
        return node.initializer !== undefined;
    }
    function isWatchSet(options) {
        return options.watch && options.hasOwnProperty("watch");
    }
    ts.isWatchSet = isWatchSet;
    function closeFileWatcher(watcher) {
        watcher.close();
    }
    ts.closeFileWatcher = closeFileWatcher;
    function getCheckFlags(symbol) {
        return symbol.flags & 33554432 ? symbol.checkFlags : 0;
    }
    ts.getCheckFlags = getCheckFlags;
    function getDeclarationModifierFlagsFromSymbol(s, isWrite) {
        if (isWrite === void 0) { isWrite = false; }
        if (s.valueDeclaration) {
            var declaration = (isWrite && s.declarations && ts.find(s.declarations, function (d) { return d.kind === 173; })) || s.valueDeclaration;
            var flags = ts.getCombinedModifierFlags(declaration);
            return s.parent && s.parent.flags & 32 ? flags : flags & ~28;
        }
        if (getCheckFlags(s) & 6) {
            var checkFlags = s.checkFlags;
            var accessModifier = checkFlags & 1024 ? 8 :
                checkFlags & 256 ? 4 :
                    16;
            var staticModifier = checkFlags & 2048 ? 32 : 0;
            return accessModifier | staticModifier;
        }
        if (s.flags & 4194304) {
            return 4 | 32;
        }
        return 0;
    }
    ts.getDeclarationModifierFlagsFromSymbol = getDeclarationModifierFlagsFromSymbol;
    function skipAlias(symbol, checker) {
        return symbol.flags & 2097152 ? checker.getAliasedSymbol(symbol) : symbol;
    }
    ts.skipAlias = skipAlias;
    function getCombinedLocalAndExportSymbolFlags(symbol) {
        return symbol.exportSymbol ? symbol.exportSymbol.flags | symbol.flags : symbol.flags;
    }
    ts.getCombinedLocalAndExportSymbolFlags = getCombinedLocalAndExportSymbolFlags;
    function isWriteOnlyAccess(node) {
        return accessKind(node) === 1;
    }
    ts.isWriteOnlyAccess = isWriteOnlyAccess;
    function isWriteAccess(node) {
        return accessKind(node) !== 0;
    }
    ts.isWriteAccess = isWriteAccess;
    function accessKind(node) {
        var parent = node.parent;
        if (!parent)
            return 0;
        switch (parent.kind) {
            case 212:
                return accessKind(parent);
            case 220:
            case 219:
                var operator = parent.operator;
                return operator === 45 || operator === 46 ? writeOrReadWrite() : 0;
            case 221:
                var _a = parent, left = _a.left, operatorToken = _a.operatorToken;
                return left === node && isAssignmentOperator(operatorToken.kind) ?
                    operatorToken.kind === 63 ? 1 : writeOrReadWrite()
                    : 0;
            case 206:
                return parent.name !== node ? 0 : accessKind(parent);
            case 296: {
                var parentAccess = accessKind(parent.parent);
                return node === parent.name ? reverseAccessKind(parentAccess) : parentAccess;
            }
            case 297:
                return node === parent.objectAssignmentInitializer ? 0 : accessKind(parent.parent);
            case 204:
                return accessKind(parent);
            default:
                return 0;
        }
        function writeOrReadWrite() {
            return parent.parent && walkUpParenthesizedExpressions(parent.parent).kind === 238 ? 1 : 2;
        }
    }
    function reverseAccessKind(a) {
        switch (a) {
            case 0:
                return 1;
            case 1:
                return 0;
            case 2:
                return 2;
            default:
                return ts.Debug.assertNever(a);
        }
    }
    function compareDataObjects(dst, src) {
        if (!dst || !src || Object.keys(dst).length !== Object.keys(src).length) {
            return false;
        }
        for (var e in dst) {
            if (typeof dst[e] === "object") {
                if (!compareDataObjects(dst[e], src[e])) {
                    return false;
                }
            }
            else if (typeof dst[e] !== "function") {
                if (dst[e] !== src[e]) {
                    return false;
                }
            }
        }
        return true;
    }
    ts.compareDataObjects = compareDataObjects;
    function clearMap(map, onDeleteValue) {
        map.forEach(onDeleteValue);
        map.clear();
    }
    ts.clearMap = clearMap;
    function mutateMapSkippingNewValues(map, newMap, options) {
        var onDeleteValue = options.onDeleteValue, onExistingValue = options.onExistingValue;
        map.forEach(function (existingValue, key) {
            var valueInNewMap = newMap.get(key);
            if (valueInNewMap === undefined) {
                map.delete(key);
                onDeleteValue(existingValue, key);
            }
            else if (onExistingValue) {
                onExistingValue(existingValue, valueInNewMap, key);
            }
        });
    }
    ts.mutateMapSkippingNewValues = mutateMapSkippingNewValues;
    function mutateMap(map, newMap, options) {
        mutateMapSkippingNewValues(map, newMap, options);
        var createNewValue = options.createNewValue;
        newMap.forEach(function (valueInNewMap, key) {
            if (!map.has(key)) {
                map.set(key, createNewValue(key, valueInNewMap));
            }
        });
    }
    ts.mutateMap = mutateMap;
    function isAbstractConstructorSymbol(symbol) {
        if (symbol.flags & 32) {
            var declaration = getClassLikeDeclarationOfSymbol(symbol);
            return !!declaration && hasSyntacticModifier(declaration, 128);
        }
        return false;
    }
    ts.isAbstractConstructorSymbol = isAbstractConstructorSymbol;
    function getClassLikeDeclarationOfSymbol(symbol) {
        var _a;
        return (_a = symbol.declarations) === null || _a === void 0 ? void 0 : _a.find(ts.isClassLike);
    }
    ts.getClassLikeDeclarationOfSymbol = getClassLikeDeclarationOfSymbol;
    function getObjectFlags(type) {
        return type.flags & 3899393 ? type.objectFlags : 0;
    }
    ts.getObjectFlags = getObjectFlags;
    function typeHasCallOrConstructSignatures(type, checker) {
        return checker.getSignaturesOfType(type, 0).length !== 0 || checker.getSignaturesOfType(type, 1).length !== 0;
    }
    ts.typeHasCallOrConstructSignatures = typeHasCallOrConstructSignatures;
    function forSomeAncestorDirectory(directory, callback) {
        return !!ts.forEachAncestorDirectory(directory, function (d) { return callback(d) ? true : undefined; });
    }
    ts.forSomeAncestorDirectory = forSomeAncestorDirectory;
    function isUMDExportSymbol(symbol) {
        return !!symbol && !!symbol.declarations && !!symbol.declarations[0] && ts.isNamespaceExportDeclaration(symbol.declarations[0]);
    }
    ts.isUMDExportSymbol = isUMDExportSymbol;
    function showModuleSpecifier(_a) {
        var moduleSpecifier = _a.moduleSpecifier;
        return ts.isStringLiteral(moduleSpecifier) ? moduleSpecifier.text : getTextOfNode(moduleSpecifier);
    }
    ts.showModuleSpecifier = showModuleSpecifier;
    function getLastChild(node) {
        var lastChild;
        ts.forEachChild(node, function (child) {
            if (nodeIsPresent(child))
                lastChild = child;
        }, function (children) {
            for (var i = children.length - 1; i >= 0; i--) {
                if (nodeIsPresent(children[i])) {
                    lastChild = children[i];
                    break;
                }
            }
        });
        return lastChild;
    }
    ts.getLastChild = getLastChild;
    function addToSeen(seen, key, value) {
        if (value === void 0) { value = true; }
        if (seen.has(key)) {
            return false;
        }
        seen.set(key, value);
        return true;
    }
    ts.addToSeen = addToSeen;
    function isObjectTypeDeclaration(node) {
        return ts.isClassLike(node) || ts.isInterfaceDeclaration(node) || ts.isTypeLiteralNode(node);
    }
    ts.isObjectTypeDeclaration = isObjectTypeDeclaration;
    function isTypeNodeKind(kind) {
        return (kind >= 177 && kind <= 200)
            || kind === 130
            || kind === 155
            || kind === 147
            || kind === 158
            || kind === 148
            || kind === 133
            || kind === 150
            || kind === 151
            || kind === 114
            || kind === 153
            || kind === 143
            || kind === 228
            || kind === 312
            || kind === 313
            || kind === 314
            || kind === 315
            || kind === 316
            || kind === 317
            || kind === 318;
    }
    ts.isTypeNodeKind = isTypeNodeKind;
    function isAccessExpression(node) {
        return node.kind === 206 || node.kind === 207;
    }
    ts.isAccessExpression = isAccessExpression;
    function getNameOfAccessExpression(node) {
        if (node.kind === 206) {
            return node.name;
        }
        ts.Debug.assert(node.kind === 207);
        return node.argumentExpression;
    }
    ts.getNameOfAccessExpression = getNameOfAccessExpression;
    function isBundleFileTextLike(section) {
        switch (section.kind) {
            case "text":
            case "internal":
                return true;
            default:
                return false;
        }
    }
    ts.isBundleFileTextLike = isBundleFileTextLike;
    function isNamedImportsOrExports(node) {
        return node.kind === 269 || node.kind === 273;
    }
    ts.isNamedImportsOrExports = isNamedImportsOrExports;
    function getLeftmostAccessExpression(expr) {
        while (isAccessExpression(expr)) {
            expr = expr.expression;
        }
        return expr;
    }
    ts.getLeftmostAccessExpression = getLeftmostAccessExpression;
    function forEachNameInAccessChainWalkingLeft(name, action) {
        if (isAccessExpression(name.parent) && isRightSideOfAccessExpression(name)) {
            return walkAccessExpression(name.parent);
        }
        function walkAccessExpression(access) {
            if (access.kind === 206) {
                var res = action(access.name);
                if (res !== undefined) {
                    return res;
                }
            }
            else if (access.kind === 207) {
                if (ts.isIdentifier(access.argumentExpression) || ts.isStringLiteralLike(access.argumentExpression)) {
                    var res = action(access.argumentExpression);
                    if (res !== undefined) {
                        return res;
                    }
                }
                else {
                    return undefined;
                }
            }
            if (isAccessExpression(access.expression)) {
                return walkAccessExpression(access.expression);
            }
            if (ts.isIdentifier(access.expression)) {
                return action(access.expression);
            }
            return undefined;
        }
    }
    ts.forEachNameInAccessChainWalkingLeft = forEachNameInAccessChainWalkingLeft;
    function getLeftmostExpression(node, stopAtCallExpressions) {
        while (true) {
            switch (node.kind) {
                case 220:
                    node = node.operand;
                    continue;
                case 221:
                    node = node.left;
                    continue;
                case 222:
                    node = node.condition;
                    continue;
                case 210:
                    node = node.tag;
                    continue;
                case 208:
                    if (stopAtCallExpressions) {
                        return node;
                    }
                case 229:
                case 207:
                case 206:
                case 230:
                case 350:
                    node = node.expression;
                    continue;
            }
            return node;
        }
    }
    ts.getLeftmostExpression = getLeftmostExpression;
    function Symbol(flags, name) {
        this.flags = flags;
        this.escapedName = name;
        this.declarations = undefined;
        this.valueDeclaration = undefined;
        this.id = undefined;
        this.mergeId = undefined;
        this.parent = undefined;
    }
    function Type(checker, flags) {
        this.flags = flags;
        if (ts.Debug.isDebugging || ts.tracing) {
            this.checker = checker;
        }
    }
    function Signature(checker, flags) {
        this.flags = flags;
        if (ts.Debug.isDebugging) {
            this.checker = checker;
        }
    }
    function Node(kind, pos, end) {
        this.pos = pos;
        this.end = end;
        this.kind = kind;
        this.id = 0;
        this.flags = 0;
        this.modifierFlagsCache = 0;
        this.transformFlags = 0;
        this.parent = undefined;
        this.original = undefined;
    }
    function Token(kind, pos, end) {
        this.pos = pos;
        this.end = end;
        this.kind = kind;
        this.id = 0;
        this.flags = 0;
        this.transformFlags = 0;
        this.parent = undefined;
    }
    function Identifier(kind, pos, end) {
        this.pos = pos;
        this.end = end;
        this.kind = kind;
        this.id = 0;
        this.flags = 0;
        this.transformFlags = 0;
        this.parent = undefined;
        this.original = undefined;
        this.flowNode = undefined;
    }
    function SourceMapSource(fileName, text, skipTrivia) {
        this.fileName = fileName;
        this.text = text;
        this.skipTrivia = skipTrivia || (function (pos) { return pos; });
    }
    ts.objectAllocator = {
        getNodeConstructor: function () { return Node; },
        getTokenConstructor: function () { return Token; },
        getIdentifierConstructor: function () { return Identifier; },
        getPrivateIdentifierConstructor: function () { return Node; },
        getSourceFileConstructor: function () { return Node; },
        getSymbolConstructor: function () { return Symbol; },
        getTypeConstructor: function () { return Type; },
        getSignatureConstructor: function () { return Signature; },
        getSourceMapSourceConstructor: function () { return SourceMapSource; },
    };
    function setObjectAllocator(alloc) {
        Object.assign(ts.objectAllocator, alloc);
    }
    ts.setObjectAllocator = setObjectAllocator;
    function formatStringFromArgs(text, args, baseIndex) {
        if (baseIndex === void 0) { baseIndex = 0; }
        return text.replace(/{(\d+)}/g, function (_match, index) { return "" + ts.Debug.checkDefined(args[+index + baseIndex]); });
    }
    ts.formatStringFromArgs = formatStringFromArgs;
    var localizedDiagnosticMessages;
    function setLocalizedDiagnosticMessages(messages) {
        localizedDiagnosticMessages = messages;
    }
    ts.setLocalizedDiagnosticMessages = setLocalizedDiagnosticMessages;
    function maybeSetLocalizedDiagnosticMessages(getMessages) {
        if (!localizedDiagnosticMessages && getMessages) {
            localizedDiagnosticMessages = getMessages();
        }
    }
    ts.maybeSetLocalizedDiagnosticMessages = maybeSetLocalizedDiagnosticMessages;
    function getLocaleSpecificMessage(message) {
        return localizedDiagnosticMessages && localizedDiagnosticMessages[message.key] || message.message;
    }
    ts.getLocaleSpecificMessage = getLocaleSpecificMessage;
    function createDetachedDiagnostic(fileName, start, length, message) {
        assertDiagnosticLocation(undefined, start, length);
        var text = getLocaleSpecificMessage(message);
        if (arguments.length > 4) {
            text = formatStringFromArgs(text, arguments, 4);
        }
        return {
            file: undefined,
            start: start,
            length: length,
            messageText: text,
            category: message.category,
            code: message.code,
            reportsUnnecessary: message.reportsUnnecessary,
            fileName: fileName,
        };
    }
    ts.createDetachedDiagnostic = createDetachedDiagnostic;
    function isDiagnosticWithDetachedLocation(diagnostic) {
        return diagnostic.file === undefined
            && diagnostic.start !== undefined
            && diagnostic.length !== undefined
            && typeof diagnostic.fileName === "string";
    }
    function attachFileToDiagnostic(diagnostic, file) {
        var fileName = file.fileName || "";
        var length = file.text.length;
        ts.Debug.assertEqual(diagnostic.fileName, fileName);
        ts.Debug.assertLessThanOrEqual(diagnostic.start, length);
        ts.Debug.assertLessThanOrEqual(diagnostic.start + diagnostic.length, length);
        var diagnosticWithLocation = {
            file: file,
            start: diagnostic.start,
            length: diagnostic.length,
            messageText: diagnostic.messageText,
            category: diagnostic.category,
            code: diagnostic.code,
            reportsUnnecessary: diagnostic.reportsUnnecessary
        };
        if (diagnostic.relatedInformation) {
            diagnosticWithLocation.relatedInformation = [];
            for (var _i = 0, _a = diagnostic.relatedInformation; _i < _a.length; _i++) {
                var related = _a[_i];
                if (isDiagnosticWithDetachedLocation(related) && related.fileName === fileName) {
                    ts.Debug.assertLessThanOrEqual(related.start, length);
                    ts.Debug.assertLessThanOrEqual(related.start + related.length, length);
                    diagnosticWithLocation.relatedInformation.push(attachFileToDiagnostic(related, file));
                }
                else {
                    diagnosticWithLocation.relatedInformation.push(related);
                }
            }
        }
        return diagnosticWithLocation;
    }
    function attachFileToDiagnostics(diagnostics, file) {
        var diagnosticsWithLocation = [];
        for (var _i = 0, diagnostics_1 = diagnostics; _i < diagnostics_1.length; _i++) {
            var diagnostic = diagnostics_1[_i];
            diagnosticsWithLocation.push(attachFileToDiagnostic(diagnostic, file));
        }
        return diagnosticsWithLocation;
    }
    ts.attachFileToDiagnostics = attachFileToDiagnostics;
    function createFileDiagnostic(file, start, length, message) {
        assertDiagnosticLocation(file, start, length);
        var text = getLocaleSpecificMessage(message);
        if (arguments.length > 4) {
            text = formatStringFromArgs(text, arguments, 4);
        }
        return {
            file: file,
            start: start,
            length: length,
            messageText: text,
            category: message.category,
            code: message.code,
            reportsUnnecessary: message.reportsUnnecessary,
            reportsDeprecated: message.reportsDeprecated
        };
    }
    ts.createFileDiagnostic = createFileDiagnostic;
    function formatMessage(_dummy, message) {
        var text = getLocaleSpecificMessage(message);
        if (arguments.length > 2) {
            text = formatStringFromArgs(text, arguments, 2);
        }
        return text;
    }
    ts.formatMessage = formatMessage;
    function createCompilerDiagnostic(message) {
        var text = getLocaleSpecificMessage(message);
        if (arguments.length > 1) {
            text = formatStringFromArgs(text, arguments, 1);
        }
        return {
            file: undefined,
            start: undefined,
            length: undefined,
            messageText: text,
            category: message.category,
            code: message.code,
            reportsUnnecessary: message.reportsUnnecessary,
            reportsDeprecated: message.reportsDeprecated
        };
    }
    ts.createCompilerDiagnostic = createCompilerDiagnostic;
    function createCompilerDiagnosticFromMessageChain(chain, relatedInformation) {
        return {
            file: undefined,
            start: undefined,
            length: undefined,
            code: chain.code,
            category: chain.category,
            messageText: chain.next ? chain : chain.messageText,
            relatedInformation: relatedInformation
        };
    }
    ts.createCompilerDiagnosticFromMessageChain = createCompilerDiagnosticFromMessageChain;
    function chainDiagnosticMessages(details, message) {
        var text = getLocaleSpecificMessage(message);
        if (arguments.length > 2) {
            text = formatStringFromArgs(text, arguments, 2);
        }
        return {
            messageText: text,
            category: message.category,
            code: message.code,
            next: details === undefined || Array.isArray(details) ? details : [details]
        };
    }
    ts.chainDiagnosticMessages = chainDiagnosticMessages;
    function concatenateDiagnosticMessageChains(headChain, tailChain) {
        var lastChain = headChain;
        while (lastChain.next) {
            lastChain = lastChain.next[0];
        }
        lastChain.next = [tailChain];
    }
    ts.concatenateDiagnosticMessageChains = concatenateDiagnosticMessageChains;
    function getDiagnosticFilePath(diagnostic) {
        return diagnostic.file ? diagnostic.file.path : undefined;
    }
    function compareDiagnostics(d1, d2) {
        return compareDiagnosticsSkipRelatedInformation(d1, d2) ||
            compareRelatedInformation(d1, d2) ||
            0;
    }
    ts.compareDiagnostics = compareDiagnostics;
    function compareDiagnosticsSkipRelatedInformation(d1, d2) {
        return ts.compareStringsCaseSensitive(getDiagnosticFilePath(d1), getDiagnosticFilePath(d2)) ||
            ts.compareValues(d1.start, d2.start) ||
            ts.compareValues(d1.length, d2.length) ||
            ts.compareValues(d1.code, d2.code) ||
            compareMessageText(d1.messageText, d2.messageText) ||
            0;
    }
    ts.compareDiagnosticsSkipRelatedInformation = compareDiagnosticsSkipRelatedInformation;
    function compareRelatedInformation(d1, d2) {
        if (!d1.relatedInformation && !d2.relatedInformation) {
            return 0;
        }
        if (d1.relatedInformation && d2.relatedInformation) {
            return ts.compareValues(d1.relatedInformation.length, d2.relatedInformation.length) || ts.forEach(d1.relatedInformation, function (d1i, index) {
                var d2i = d2.relatedInformation[index];
                return compareDiagnostics(d1i, d2i);
            }) || 0;
        }
        return d1.relatedInformation ? -1 : 1;
    }
    function compareMessageText(t1, t2) {
        if (typeof t1 === "string" && typeof t2 === "string") {
            return ts.compareStringsCaseSensitive(t1, t2);
        }
        else if (typeof t1 === "string") {
            return -1;
        }
        else if (typeof t2 === "string") {
            return 1;
        }
        var res = ts.compareStringsCaseSensitive(t1.messageText, t2.messageText);
        if (res) {
            return res;
        }
        if (!t1.next && !t2.next) {
            return 0;
        }
        if (!t1.next) {
            return -1;
        }
        if (!t2.next) {
            return 1;
        }
        var len = Math.min(t1.next.length, t2.next.length);
        for (var i = 0; i < len; i++) {
            res = compareMessageText(t1.next[i], t2.next[i]);
            if (res) {
                return res;
            }
        }
        if (t1.next.length < t2.next.length) {
            return -1;
        }
        else if (t1.next.length > t2.next.length) {
            return 1;
        }
        return 0;
    }
    function getLanguageVariant(scriptKind) {
        return scriptKind === 4 || scriptKind === 2 || scriptKind === 1 || scriptKind === 6 ? 1 : 0;
    }
    ts.getLanguageVariant = getLanguageVariant;
    function walkTreeForJSXTags(node) {
        if (!(node.transformFlags & 2))
            return undefined;
        return ts.isJsxOpeningLikeElement(node) || ts.isJsxFragment(node) ? node : ts.forEachChild(node, walkTreeForJSXTags);
    }
    function isFileModuleFromUsingJSXTag(file) {
        return !file.isDeclarationFile ? walkTreeForJSXTags(file) : undefined;
    }
    function isFileForcedToBeModuleByFormat(file) {
        return (file.impliedNodeFormat === ts.ModuleKind.ESNext || (ts.fileExtensionIsOneOf(file.fileName, [".cjs", ".cts"]))) && !file.isDeclarationFile ? true : undefined;
    }
    function getSetExternalModuleIndicator(options) {
        switch (getEmitModuleDetectionKind(options)) {
            case ts.ModuleDetectionKind.Force:
                return function (file) {
                    file.externalModuleIndicator = ts.isFileProbablyExternalModule(file) || !file.isDeclarationFile || undefined;
                };
            case ts.ModuleDetectionKind.Legacy:
                return function (file) {
                    file.externalModuleIndicator = ts.isFileProbablyExternalModule(file);
                };
            case ts.ModuleDetectionKind.Auto:
                var checks = [ts.isFileProbablyExternalModule];
                if (options.jsx === 4 || options.jsx === 5) {
                    checks.push(isFileModuleFromUsingJSXTag);
                }
                var moduleKind = getEmitModuleKind(options);
                if (moduleKind === ts.ModuleKind.Node16 || moduleKind === ts.ModuleKind.NodeNext) {
                    checks.push(isFileForcedToBeModuleByFormat);
                }
                var combined_1 = ts.or.apply(void 0, checks);
                var callback = function (file) { return void (file.externalModuleIndicator = combined_1(file)); };
                return callback;
        }
    }
    ts.getSetExternalModuleIndicator = getSetExternalModuleIndicator;
    function getEmitScriptTarget(compilerOptions) {
        return compilerOptions.target ||
            (compilerOptions.module === ts.ModuleKind.Node16 && 9) ||
            (compilerOptions.module === ts.ModuleKind.NodeNext && 99) ||
            0;
    }
    ts.getEmitScriptTarget = getEmitScriptTarget;
    function getEmitModuleKind(compilerOptions) {
        return typeof compilerOptions.module === "number" ?
            compilerOptions.module :
            getEmitScriptTarget(compilerOptions) >= 2 ? ts.ModuleKind.ES2015 : ts.ModuleKind.CommonJS;
    }
    ts.getEmitModuleKind = getEmitModuleKind;
    function getEmitModuleResolutionKind(compilerOptions) {
        var moduleResolution = compilerOptions.moduleResolution;
        if (moduleResolution === undefined) {
            switch (getEmitModuleKind(compilerOptions)) {
                case ts.ModuleKind.CommonJS:
                    moduleResolution = ts.ModuleResolutionKind.NodeJs;
                    break;
                case ts.ModuleKind.Node16:
                    moduleResolution = ts.ModuleResolutionKind.Node16;
                    break;
                case ts.ModuleKind.NodeNext:
                    moduleResolution = ts.ModuleResolutionKind.NodeNext;
                    break;
                default:
                    moduleResolution = ts.ModuleResolutionKind.Classic;
                    break;
            }
        }
        return moduleResolution;
    }
    ts.getEmitModuleResolutionKind = getEmitModuleResolutionKind;
    function getEmitModuleDetectionKind(options) {
        return options.moduleDetection ||
            (getEmitModuleKind(options) === ts.ModuleKind.Node16 || getEmitModuleKind(options) === ts.ModuleKind.NodeNext ? ts.ModuleDetectionKind.Force : ts.ModuleDetectionKind.Auto);
    }
    ts.getEmitModuleDetectionKind = getEmitModuleDetectionKind;
    function hasJsonModuleEmitEnabled(options) {
        switch (getEmitModuleKind(options)) {
            case ts.ModuleKind.CommonJS:
            case ts.ModuleKind.AMD:
            case ts.ModuleKind.ES2015:
            case ts.ModuleKind.ES2020:
            case ts.ModuleKind.ES2022:
            case ts.ModuleKind.ESNext:
            case ts.ModuleKind.Node16:
            case ts.ModuleKind.NodeNext:
                return true;
            default:
                return false;
        }
    }
    ts.hasJsonModuleEmitEnabled = hasJsonModuleEmitEnabled;
    function unreachableCodeIsError(options) {
        return options.allowUnreachableCode === false;
    }
    ts.unreachableCodeIsError = unreachableCodeIsError;
    function unusedLabelIsError(options) {
        return options.allowUnusedLabels === false;
    }
    ts.unusedLabelIsError = unusedLabelIsError;
    function getAreDeclarationMapsEnabled(options) {
        return !!(getEmitDeclarations(options) && options.declarationMap);
    }
    ts.getAreDeclarationMapsEnabled = getAreDeclarationMapsEnabled;
    function getESModuleInterop(compilerOptions) {
        if (compilerOptions.esModuleInterop !== undefined) {
            return compilerOptions.esModuleInterop;
        }
        switch (getEmitModuleKind(compilerOptions)) {
            case ts.ModuleKind.Node16:
            case ts.ModuleKind.NodeNext:
                return true;
        }
        return undefined;
    }
    ts.getESModuleInterop = getESModuleInterop;
    function getAllowSyntheticDefaultImports(compilerOptions) {
        var moduleKind = getEmitModuleKind(compilerOptions);
        return compilerOptions.allowSyntheticDefaultImports !== undefined
            ? compilerOptions.allowSyntheticDefaultImports
            : getESModuleInterop(compilerOptions) ||
                moduleKind === ts.ModuleKind.System;
    }
    ts.getAllowSyntheticDefaultImports = getAllowSyntheticDefaultImports;
    function getEmitDeclarations(compilerOptions) {
        return !!(compilerOptions.declaration || compilerOptions.composite);
    }
    ts.getEmitDeclarations = getEmitDeclarations;
    function shouldPreserveConstEnums(compilerOptions) {
        return !!(compilerOptions.preserveConstEnums || compilerOptions.isolatedModules);
    }
    ts.shouldPreserveConstEnums = shouldPreserveConstEnums;
    function isIncrementalCompilation(options) {
        return !!(options.incremental || options.composite);
    }
    ts.isIncrementalCompilation = isIncrementalCompilation;
    function getStrictOptionValue(compilerOptions, flag) {
        return compilerOptions[flag] === undefined ? !!compilerOptions.strict : !!compilerOptions[flag];
    }
    ts.getStrictOptionValue = getStrictOptionValue;
    function getAllowJSCompilerOption(compilerOptions) {
        return compilerOptions.allowJs === undefined ? !!compilerOptions.checkJs : compilerOptions.allowJs;
    }
    ts.getAllowJSCompilerOption = getAllowJSCompilerOption;
    function getUseDefineForClassFields(compilerOptions) {
        return compilerOptions.useDefineForClassFields === undefined ? getEmitScriptTarget(compilerOptions) >= 9 : compilerOptions.useDefineForClassFields;
    }
    ts.getUseDefineForClassFields = getUseDefineForClassFields;
    function compilerOptionsAffectSemanticDiagnostics(newOptions, oldOptions) {
        return optionsHaveChanges(oldOptions, newOptions, ts.semanticDiagnosticsOptionDeclarations);
    }
    ts.compilerOptionsAffectSemanticDiagnostics = compilerOptionsAffectSemanticDiagnostics;
    function compilerOptionsAffectEmit(newOptions, oldOptions) {
        return optionsHaveChanges(oldOptions, newOptions, ts.affectsEmitOptionDeclarations);
    }
    ts.compilerOptionsAffectEmit = compilerOptionsAffectEmit;
    function getCompilerOptionValue(options, option) {
        return option.strictFlag ? getStrictOptionValue(options, option.name) : options[option.name];
    }
    ts.getCompilerOptionValue = getCompilerOptionValue;
    function getJSXTransformEnabled(options) {
        var jsx = options.jsx;
        return jsx === 2 || jsx === 4 || jsx === 5;
    }
    ts.getJSXTransformEnabled = getJSXTransformEnabled;
    function getJSXImplicitImportBase(compilerOptions, file) {
        var jsxImportSourcePragmas = file === null || file === void 0 ? void 0 : file.pragmas.get("jsximportsource");
        var jsxImportSourcePragma = ts.isArray(jsxImportSourcePragmas) ? jsxImportSourcePragmas[jsxImportSourcePragmas.length - 1] : jsxImportSourcePragmas;
        return compilerOptions.jsx === 4 ||
            compilerOptions.jsx === 5 ||
            compilerOptions.jsxImportSource ||
            jsxImportSourcePragma ?
            (jsxImportSourcePragma === null || jsxImportSourcePragma === void 0 ? void 0 : jsxImportSourcePragma.arguments.factory) || compilerOptions.jsxImportSource || "react" :
            undefined;
    }
    ts.getJSXImplicitImportBase = getJSXImplicitImportBase;
    function getJSXRuntimeImport(base, options) {
        return base ? "".concat(base, "/").concat(options.jsx === 5 ? "jsx-dev-runtime" : "jsx-runtime") : undefined;
    }
    ts.getJSXRuntimeImport = getJSXRuntimeImport;
    function hasZeroOrOneAsteriskCharacter(str) {
        var seenAsterisk = false;
        for (var i = 0; i < str.length; i++) {
            if (str.charCodeAt(i) === 42) {
                if (!seenAsterisk) {
                    seenAsterisk = true;
                }
                else {
                    return false;
                }
            }
        }
        return true;
    }
    ts.hasZeroOrOneAsteriskCharacter = hasZeroOrOneAsteriskCharacter;
    function createSymlinkCache(cwd, getCanonicalFileName) {
        var symlinkedDirectories;
        var symlinkedDirectoriesByRealpath;
        var symlinkedFiles;
        var hasProcessedResolutions = false;
        return {
            getSymlinkedFiles: function () { return symlinkedFiles; },
            getSymlinkedDirectories: function () { return symlinkedDirectories; },
            getSymlinkedDirectoriesByRealpath: function () { return symlinkedDirectoriesByRealpath; },
            setSymlinkedFile: function (path, real) { return (symlinkedFiles || (symlinkedFiles = new ts.Map())).set(path, real); },
            setSymlinkedDirectory: function (symlink, real) {
                var symlinkPath = ts.toPath(symlink, cwd, getCanonicalFileName);
                if (!containsIgnoredPath(symlinkPath)) {
                    symlinkPath = ts.ensureTrailingDirectorySeparator(symlinkPath);
                    if (real !== false && !(symlinkedDirectories === null || symlinkedDirectories === void 0 ? void 0 : symlinkedDirectories.has(symlinkPath))) {
                        (symlinkedDirectoriesByRealpath || (symlinkedDirectoriesByRealpath = ts.createMultiMap())).add(ts.ensureTrailingDirectorySeparator(real.realPath), symlink);
                    }
                    (symlinkedDirectories || (symlinkedDirectories = new ts.Map())).set(symlinkPath, real);
                }
            },
            setSymlinksFromResolutions: function (files, typeReferenceDirectives) {
                var _this = this;
                var _a;
                ts.Debug.assert(!hasProcessedResolutions);
                hasProcessedResolutions = true;
                for (var _i = 0, files_1 = files; _i < files_1.length; _i++) {
                    var file = files_1[_i];
                    (_a = file.resolvedModules) === null || _a === void 0 ? void 0 : _a.forEach(function (resolution) { return processResolution(_this, resolution); });
                }
                typeReferenceDirectives === null || typeReferenceDirectives === void 0 ? void 0 : typeReferenceDirectives.forEach(function (resolution) { return processResolution(_this, resolution); });
            },
            hasProcessedResolutions: function () { return hasProcessedResolutions; },
        };
        function processResolution(cache, resolution) {
            if (!resolution || !resolution.originalPath || !resolution.resolvedFileName)
                return;
            var resolvedFileName = resolution.resolvedFileName, originalPath = resolution.originalPath;
            cache.setSymlinkedFile(ts.toPath(originalPath, cwd, getCanonicalFileName), resolvedFileName);
            var _a = guessDirectorySymlink(resolvedFileName, originalPath, cwd, getCanonicalFileName) || ts.emptyArray, commonResolved = _a[0], commonOriginal = _a[1];
            if (commonResolved && commonOriginal) {
                cache.setSymlinkedDirectory(commonOriginal, { real: commonResolved, realPath: ts.toPath(commonResolved, cwd, getCanonicalFileName) });
            }
        }
    }
    ts.createSymlinkCache = createSymlinkCache;
    function guessDirectorySymlink(a, b, cwd, getCanonicalFileName) {
        var aParts = ts.getPathComponents(ts.getNormalizedAbsolutePath(a, cwd));
        var bParts = ts.getPathComponents(ts.getNormalizedAbsolutePath(b, cwd));
        var isDirectory = false;
        while (aParts.length >= 2 && bParts.length >= 2 &&
            !isNodeModulesOrScopedPackageDirectory(aParts[aParts.length - 2], getCanonicalFileName) &&
            !isNodeModulesOrScopedPackageDirectory(bParts[bParts.length - 2], getCanonicalFileName) &&
            getCanonicalFileName(aParts[aParts.length - 1]) === getCanonicalFileName(bParts[bParts.length - 1])) {
            aParts.pop();
            bParts.pop();
            isDirectory = true;
        }
        return isDirectory ? [ts.getPathFromPathComponents(aParts), ts.getPathFromPathComponents(bParts)] : undefined;
    }
    function isNodeModulesOrScopedPackageDirectory(s, getCanonicalFileName) {
        return s !== undefined && (getCanonicalFileName(s) === "node_modules" || ts.startsWith(s, "@"));
    }
    function stripLeadingDirectorySeparator(s) {
        return ts.isAnyDirectorySeparator(s.charCodeAt(0)) ? s.slice(1) : undefined;
    }
    function tryRemoveDirectoryPrefix(path, dirPath, getCanonicalFileName) {
        var withoutPrefix = ts.tryRemovePrefix(path, dirPath, getCanonicalFileName);
        return withoutPrefix === undefined ? undefined : stripLeadingDirectorySeparator(withoutPrefix);
    }
    ts.tryRemoveDirectoryPrefix = tryRemoveDirectoryPrefix;
    var reservedCharacterPattern = /[^\w\s\/]/g;
    function regExpEscape(text) {
        return text.replace(reservedCharacterPattern, escapeRegExpCharacter);
    }
    ts.regExpEscape = regExpEscape;
    function escapeRegExpCharacter(match) {
        return "\\" + match;
    }
    var wildcardCharCodes = [42, 63];
    ts.commonPackageFolders = ["node_modules", "bower_components", "jspm_packages"];
    var implicitExcludePathRegexPattern = "(?!(".concat(ts.commonPackageFolders.join("|"), ")(/|$))");
    var filesMatcher = {
        singleAsteriskRegexFragment: "([^./]|(\\.(?!min\\.js$))?)*",
        doubleAsteriskRegexFragment: "(/".concat(implicitExcludePathRegexPattern, "[^/.][^/]*)*?"),
        replaceWildcardCharacter: function (match) { return replaceWildcardCharacter(match, filesMatcher.singleAsteriskRegexFragment); }
    };
    var directoriesMatcher = {
        singleAsteriskRegexFragment: "[^/]*",
        doubleAsteriskRegexFragment: "(/".concat(implicitExcludePathRegexPattern, "[^/.][^/]*)*?"),
        replaceWildcardCharacter: function (match) { return replaceWildcardCharacter(match, directoriesMatcher.singleAsteriskRegexFragment); }
    };
    var excludeMatcher = {
        singleAsteriskRegexFragment: "[^/]*",
        doubleAsteriskRegexFragment: "(/.+?)?",
        replaceWildcardCharacter: function (match) { return replaceWildcardCharacter(match, excludeMatcher.singleAsteriskRegexFragment); }
    };
    var wildcardMatchers = {
        files: filesMatcher,
        directories: directoriesMatcher,
        exclude: excludeMatcher
    };
    function getRegularExpressionForWildcard(specs, basePath, usage) {
        var patterns = getRegularExpressionsForWildcards(specs, basePath, usage);
        if (!patterns || !patterns.length) {
            return undefined;
        }
        var pattern = patterns.map(function (pattern) { return "(".concat(pattern, ")"); }).join("|");
        var terminator = usage === "exclude" ? "($|/)" : "$";
        return "^(".concat(pattern, ")").concat(terminator);
    }
    ts.getRegularExpressionForWildcard = getRegularExpressionForWildcard;
    function getRegularExpressionsForWildcards(specs, basePath, usage) {
        if (specs === undefined || specs.length === 0) {
            return undefined;
        }
        return ts.flatMap(specs, function (spec) {
            return spec && getSubPatternFromSpec(spec, basePath, usage, wildcardMatchers[usage]);
        });
    }
    ts.getRegularExpressionsForWildcards = getRegularExpressionsForWildcards;
    function isImplicitGlob(lastPathComponent) {
        return !/[.*?]/.test(lastPathComponent);
    }
    ts.isImplicitGlob = isImplicitGlob;
    function getPatternFromSpec(spec, basePath, usage) {
        var pattern = spec && getSubPatternFromSpec(spec, basePath, usage, wildcardMatchers[usage]);
        return pattern && "^(".concat(pattern, ")").concat(usage === "exclude" ? "($|/)" : "$");
    }
    ts.getPatternFromSpec = getPatternFromSpec;
    function getSubPatternFromSpec(spec, basePath, usage, _a) {
        var singleAsteriskRegexFragment = _a.singleAsteriskRegexFragment, doubleAsteriskRegexFragment = _a.doubleAsteriskRegexFragment, replaceWildcardCharacter = _a.replaceWildcardCharacter;
        var subpattern = "";
        var hasWrittenComponent = false;
        var components = ts.getNormalizedPathComponents(spec, basePath);
        var lastComponent = ts.last(components);
        if (usage !== "exclude" && lastComponent === "**") {
            return undefined;
        }
        components[0] = ts.removeTrailingDirectorySeparator(components[0]);
        if (isImplicitGlob(lastComponent)) {
            components.push("**", "*");
        }
        var optionalCount = 0;
        for (var _i = 0, components_1 = components; _i < components_1.length; _i++) {
            var component = components_1[_i];
            if (component === "**") {
                subpattern += doubleAsteriskRegexFragment;
            }
            else {
                if (usage === "directories") {
                    subpattern += "(";
                    optionalCount++;
                }
                if (hasWrittenComponent) {
                    subpattern += ts.directorySeparator;
                }
                if (usage !== "exclude") {
                    var componentPattern = "";
                    if (component.charCodeAt(0) === 42) {
                        componentPattern += "([^./]" + singleAsteriskRegexFragment + ")?";
                        component = component.substr(1);
                    }
                    else if (component.charCodeAt(0) === 63) {
                        componentPattern += "[^./]";
                        component = component.substr(1);
                    }
                    componentPattern += component.replace(reservedCharacterPattern, replaceWildcardCharacter);
                    if (componentPattern !== component) {
                        subpattern += implicitExcludePathRegexPattern;
                    }
                    subpattern += componentPattern;
                }
                else {
                    subpattern += component.replace(reservedCharacterPattern, replaceWildcardCharacter);
                }
            }
            hasWrittenComponent = true;
        }
        while (optionalCount > 0) {
            subpattern += ")?";
            optionalCount--;
        }
        return subpattern;
    }
    function replaceWildcardCharacter(match, singleAsteriskRegexFragment) {
        return match === "*" ? singleAsteriskRegexFragment : match === "?" ? "[^/]" : "\\" + match;
    }
    function getFileMatcherPatterns(path, excludes, includes, useCaseSensitiveFileNames, currentDirectory) {
        path = ts.normalizePath(path);
        currentDirectory = ts.normalizePath(currentDirectory);
        var absolutePath = ts.combinePaths(currentDirectory, path);
        return {
            includeFilePatterns: ts.map(getRegularExpressionsForWildcards(includes, absolutePath, "files"), function (pattern) { return "^".concat(pattern, "$"); }),
            includeFilePattern: getRegularExpressionForWildcard(includes, absolutePath, "files"),
            includeDirectoryPattern: getRegularExpressionForWildcard(includes, absolutePath, "directories"),
            excludePattern: getRegularExpressionForWildcard(excludes, absolutePath, "exclude"),
            basePaths: getBasePaths(path, includes, useCaseSensitiveFileNames)
        };
    }
    ts.getFileMatcherPatterns = getFileMatcherPatterns;
    function getRegexFromPattern(pattern, useCaseSensitiveFileNames) {
        return new RegExp(pattern, useCaseSensitiveFileNames ? "" : "i");
    }
    ts.getRegexFromPattern = getRegexFromPattern;
    function matchFiles(path, extensions, excludes, includes, useCaseSensitiveFileNames, currentDirectory, depth, getFileSystemEntries, realpath) {
        path = ts.normalizePath(path);
        currentDirectory = ts.normalizePath(currentDirectory);
        var patterns = getFileMatcherPatterns(path, excludes, includes, useCaseSensitiveFileNames, currentDirectory);
        var includeFileRegexes = patterns.includeFilePatterns && patterns.includeFilePatterns.map(function (pattern) { return getRegexFromPattern(pattern, useCaseSensitiveFileNames); });
        var includeDirectoryRegex = patterns.includeDirectoryPattern && getRegexFromPattern(patterns.includeDirectoryPattern, useCaseSensitiveFileNames);
        var excludeRegex = patterns.excludePattern && getRegexFromPattern(patterns.excludePattern, useCaseSensitiveFileNames);
        var results = includeFileRegexes ? includeFileRegexes.map(function () { return []; }) : [[]];
        var visited = new ts.Map();
        var toCanonical = ts.createGetCanonicalFileName(useCaseSensitiveFileNames);
        for (var _i = 0, _a = patterns.basePaths; _i < _a.length; _i++) {
            var basePath = _a[_i];
            visitDirectory(basePath, ts.combinePaths(currentDirectory, basePath), depth);
        }
        return ts.flatten(results);
        function visitDirectory(path, absolutePath, depth) {
            var canonicalPath = toCanonical(realpath(absolutePath));
            if (visited.has(canonicalPath))
                return;
            visited.set(canonicalPath, true);
            var _a = getFileSystemEntries(path), files = _a.files, directories = _a.directories;
            var _loop_1 = function (current) {
                var name = ts.combinePaths(path, current);
                var absoluteName = ts.combinePaths(absolutePath, current);
                if (extensions && !ts.fileExtensionIsOneOf(name, extensions))
                    return "continue";
                if (excludeRegex && excludeRegex.test(absoluteName))
                    return "continue";
                if (!includeFileRegexes) {
                    results[0].push(name);
                }
                else {
                    var includeIndex = ts.findIndex(includeFileRegexes, function (re) { return re.test(absoluteName); });
                    if (includeIndex !== -1) {
                        results[includeIndex].push(name);
                    }
                }
            };
            for (var _i = 0, _b = ts.sort(files, ts.compareStringsCaseSensitive); _i < _b.length; _i++) {
                var current = _b[_i];
                _loop_1(current);
            }
            if (depth !== undefined) {
                depth--;
                if (depth === 0) {
                    return;
                }
            }
            for (var _c = 0, _d = ts.sort(directories, ts.compareStringsCaseSensitive); _c < _d.length; _c++) {
                var current = _d[_c];
                var name = ts.combinePaths(path, current);
                var absoluteName = ts.combinePaths(absolutePath, current);
                if ((!includeDirectoryRegex || includeDirectoryRegex.test(absoluteName)) &&
                    (!excludeRegex || !excludeRegex.test(absoluteName))) {
                    visitDirectory(name, absoluteName, depth);
                }
            }
        }
    }
    ts.matchFiles = matchFiles;
    function getBasePaths(path, includes, useCaseSensitiveFileNames) {
        var basePaths = [path];
        if (includes) {
            var includeBasePaths = [];
            for (var _i = 0, includes_1 = includes; _i < includes_1.length; _i++) {
                var include = includes_1[_i];
                var absolute = ts.isRootedDiskPath(include) ? include : ts.normalizePath(ts.combinePaths(path, include));
                includeBasePaths.push(getIncludeBasePath(absolute));
            }
            includeBasePaths.sort(ts.getStringComparer(!useCaseSensitiveFileNames));
            var _loop_2 = function (includeBasePath) {
                if (ts.every(basePaths, function (basePath) { return !ts.containsPath(basePath, includeBasePath, path, !useCaseSensitiveFileNames); })) {
                    basePaths.push(includeBasePath);
                }
            };
            for (var _a = 0, includeBasePaths_1 = includeBasePaths; _a < includeBasePaths_1.length; _a++) {
                var includeBasePath = includeBasePaths_1[_a];
                _loop_2(includeBasePath);
            }
        }
        return basePaths;
    }
    function getIncludeBasePath(absolute) {
        var wildcardOffset = ts.indexOfAnyCharCode(absolute, wildcardCharCodes);
        if (wildcardOffset < 0) {
            return !ts.hasExtension(absolute)
                ? absolute
                : ts.removeTrailingDirectorySeparator(ts.getDirectoryPath(absolute));
        }
        return absolute.substring(0, absolute.lastIndexOf(ts.directorySeparator, wildcardOffset));
    }
    function ensureScriptKind(fileName, scriptKind) {
        return scriptKind || getScriptKindFromFileName(fileName) || 3;
    }
    ts.ensureScriptKind = ensureScriptKind;
    function getScriptKindFromFileName(fileName) {
        var ext = fileName.substr(fileName.lastIndexOf("."));
        switch (ext.toLowerCase()) {
            case ".js":
            case ".cjs":
            case ".mjs":
                return 1;
            case ".jsx":
                return 2;
            case ".ts":
            case ".cts":
            case ".mts":
                return 3;
            case ".tsx":
                return 4;
            case ".json":
                return 6;
            default:
                return 0;
        }
    }
    ts.getScriptKindFromFileName = getScriptKindFromFileName;
    ts.supportedTSExtensions = [[".ts", ".tsx", ".d.ts"], [".cts", ".d.cts"], [".mts", ".d.mts"]];
    ts.supportedTSExtensionsFlat = ts.flatten(ts.supportedTSExtensions);
    var supportedTSExtensionsWithJson = __spreadArray(__spreadArray([], ts.supportedTSExtensions, true), [[".json"]], false);
    var supportedTSExtensionsForExtractExtension = [".d.ts", ".d.cts", ".d.mts", ".cts", ".mts", ".ts", ".tsx", ".cts", ".mts"];
    ts.supportedJSExtensions = [[".js", ".jsx"], [".mjs"], [".cjs"]];
    ts.supportedJSExtensionsFlat = ts.flatten(ts.supportedJSExtensions);
    var allSupportedExtensions = [[".ts", ".tsx", ".d.ts", ".js", ".jsx"], [".cts", ".d.cts", ".cjs"], [".mts", ".d.mts", ".mjs"]];
    var allSupportedExtensionsWithJson = __spreadArray(__spreadArray([], allSupportedExtensions, true), [[".json"]], false);
    ts.supportedDeclarationExtensions = [".d.ts", ".d.cts", ".d.mts"];
    function getSupportedExtensions(options, extraFileExtensions) {
        var needJsExtensions = options && getAllowJSCompilerOption(options);
        if (!extraFileExtensions || extraFileExtensions.length === 0) {
            return needJsExtensions ? allSupportedExtensions : ts.supportedTSExtensions;
        }
        var builtins = needJsExtensions ? allSupportedExtensions : ts.supportedTSExtensions;
        var flatBuiltins = ts.flatten(builtins);
        var extensions = __spreadArray(__spreadArray([], builtins, true), ts.mapDefined(extraFileExtensions, function (x) { return x.scriptKind === 7 || needJsExtensions && isJSLike(x.scriptKind) && flatBuiltins.indexOf(x.extension) === -1 ? [x.extension] : undefined; }), true);
        return extensions;
    }
    ts.getSupportedExtensions = getSupportedExtensions;
    function getSupportedExtensionsWithJsonIfResolveJsonModule(options, supportedExtensions) {
        if (!options || !options.resolveJsonModule)
            return supportedExtensions;
        if (supportedExtensions === allSupportedExtensions)
            return allSupportedExtensionsWithJson;
        if (supportedExtensions === ts.supportedTSExtensions)
            return supportedTSExtensionsWithJson;
        return __spreadArray(__spreadArray([], supportedExtensions, true), [[".json"]], false);
    }
    ts.getSupportedExtensionsWithJsonIfResolveJsonModule = getSupportedExtensionsWithJsonIfResolveJsonModule;
    function isJSLike(scriptKind) {
        return scriptKind === 1 || scriptKind === 2;
    }
    function hasJSFileExtension(fileName) {
        return ts.some(ts.supportedJSExtensionsFlat, function (extension) { return ts.fileExtensionIs(fileName, extension); });
    }
    ts.hasJSFileExtension = hasJSFileExtension;
    function hasTSFileExtension(fileName) {
        return ts.some(ts.supportedTSExtensionsFlat, function (extension) { return ts.fileExtensionIs(fileName, extension); });
    }
    ts.hasTSFileExtension = hasTSFileExtension;
    function isSupportedSourceFileName(fileName, compilerOptions, extraFileExtensions) {
        if (!fileName)
            return false;
        var supportedExtensions = getSupportedExtensions(compilerOptions, extraFileExtensions);
        for (var _i = 0, _a = ts.flatten(getSupportedExtensionsWithJsonIfResolveJsonModule(compilerOptions, supportedExtensions)); _i < _a.length; _i++) {
            var extension = _a[_i];
            if (ts.fileExtensionIs(fileName, extension)) {
                return true;
            }
        }
        return false;
    }
    ts.isSupportedSourceFileName = isSupportedSourceFileName;
    function numberOfDirectorySeparators(str) {
        var match = str.match(/\//g);
        return match ? match.length : 0;
    }
    function compareNumberOfDirectorySeparators(path1, path2) {
        return ts.compareValues(numberOfDirectorySeparators(path1), numberOfDirectorySeparators(path2));
    }
    ts.compareNumberOfDirectorySeparators = compareNumberOfDirectorySeparators;
    var extensionsToRemove = [".d.ts", ".d.mts", ".d.cts", ".mjs", ".mts", ".cjs", ".cts", ".ts", ".js", ".tsx", ".jsx", ".json"];
    function removeFileExtension(path) {
        for (var _i = 0, extensionsToRemove_1 = extensionsToRemove; _i < extensionsToRemove_1.length; _i++) {
            var ext = extensionsToRemove_1[_i];
            var extensionless = tryRemoveExtension(path, ext);
            if (extensionless !== undefined) {
                return extensionless;
            }
        }
        return path;
    }
    ts.removeFileExtension = removeFileExtension;
    function tryRemoveExtension(path, extension) {
        return ts.fileExtensionIs(path, extension) ? removeExtension(path, extension) : undefined;
    }
    ts.tryRemoveExtension = tryRemoveExtension;
    function removeExtension(path, extension) {
        return path.substring(0, path.length - extension.length);
    }
    ts.removeExtension = removeExtension;
    function changeExtension(path, newExtension) {
        return ts.changeAnyExtension(path, newExtension, extensionsToRemove, false);
    }
    ts.changeExtension = changeExtension;
    function tryParsePattern(pattern) {
        var indexOfStar = pattern.indexOf("*");
        if (indexOfStar === -1) {
            return pattern;
        }
        return pattern.indexOf("*", indexOfStar + 1) !== -1
            ? undefined
            : {
                prefix: pattern.substr(0, indexOfStar),
                suffix: pattern.substr(indexOfStar + 1)
            };
    }
    ts.tryParsePattern = tryParsePattern;
    function tryParsePatterns(paths) {
        return ts.mapDefined(ts.getOwnKeys(paths), function (path) { return tryParsePattern(path); });
    }
    ts.tryParsePatterns = tryParsePatterns;
    function positionIsSynthesized(pos) {
        return !(pos >= 0);
    }
    ts.positionIsSynthesized = positionIsSynthesized;
    function extensionIsTS(ext) {
        return ext === ".ts" || ext === ".tsx" || ext === ".d.ts" || ext === ".cts" || ext === ".mts" || ext === ".d.mts" || ext === ".d.cts";
    }
    ts.extensionIsTS = extensionIsTS;
    function resolutionExtensionIsTSOrJson(ext) {
        return extensionIsTS(ext) || ext === ".json";
    }
    ts.resolutionExtensionIsTSOrJson = resolutionExtensionIsTSOrJson;
    function extensionFromPath(path) {
        var ext = tryGetExtensionFromPath(path);
        return ext !== undefined ? ext : ts.Debug.fail("File ".concat(path, " has unknown extension."));
    }
    ts.extensionFromPath = extensionFromPath;
    function isAnySupportedFileExtension(path) {
        return tryGetExtensionFromPath(path) !== undefined;
    }
    ts.isAnySupportedFileExtension = isAnySupportedFileExtension;
    function tryGetExtensionFromPath(path) {
        return ts.find(extensionsToRemove, function (e) { return ts.fileExtensionIs(path, e); });
    }
    ts.tryGetExtensionFromPath = tryGetExtensionFromPath;
    function isCheckJsEnabledForFile(sourceFile, compilerOptions) {
        return sourceFile.checkJsDirective ? sourceFile.checkJsDirective.enabled : compilerOptions.checkJs;
    }
    ts.isCheckJsEnabledForFile = isCheckJsEnabledForFile;
    ts.emptyFileSystemEntries = {
        files: ts.emptyArray,
        directories: ts.emptyArray
    };
    function matchPatternOrExact(patternOrStrings, candidate) {
        var patterns = [];
        for (var _i = 0, patternOrStrings_1 = patternOrStrings; _i < patternOrStrings_1.length; _i++) {
            var patternOrString = patternOrStrings_1[_i];
            if (patternOrString === candidate) {
                return candidate;
            }
            if (!ts.isString(patternOrString)) {
                patterns.push(patternOrString);
            }
        }
        return ts.findBestPatternMatch(patterns, function (_) { return _; }, candidate);
    }
    ts.matchPatternOrExact = matchPatternOrExact;
    function sliceAfter(arr, value) {
        var index = arr.indexOf(value);
        ts.Debug.assert(index !== -1);
        return arr.slice(index);
    }
    ts.sliceAfter = sliceAfter;
    function addRelatedInfo(diagnostic) {
        var _a;
        var relatedInformation = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            relatedInformation[_i - 1] = arguments[_i];
        }
        if (!relatedInformation.length) {
            return diagnostic;
        }
        if (!diagnostic.relatedInformation) {
            diagnostic.relatedInformation = [];
        }
        ts.Debug.assert(diagnostic.relatedInformation !== ts.emptyArray, "Diagnostic had empty array singleton for related info, but is still being constructed!");
        (_a = diagnostic.relatedInformation).push.apply(_a, relatedInformation);
        return diagnostic;
    }
    ts.addRelatedInfo = addRelatedInfo;
    function minAndMax(arr, getValue) {
        ts.Debug.assert(arr.length !== 0);
        var min = getValue(arr[0]);
        var max = min;
        for (var i = 1; i < arr.length; i++) {
            var value = getValue(arr[i]);
            if (value < min) {
                min = value;
            }
            else if (value > max) {
                max = value;
            }
        }
        return { min: min, max: max };
    }
    ts.minAndMax = minAndMax;
    function rangeOfNode(node) {
        return { pos: getTokenPosOfNode(node), end: node.end };
    }
    ts.rangeOfNode = rangeOfNode;
    function rangeOfTypeParameters(sourceFile, typeParameters) {
        var pos = typeParameters.pos - 1;
        var end = ts.skipTrivia(sourceFile.text, typeParameters.end) + 1;
        return { pos: pos, end: end };
    }
    ts.rangeOfTypeParameters = rangeOfTypeParameters;
    function skipTypeChecking(sourceFile, options, host) {
        return (options.skipLibCheck && sourceFile.isDeclarationFile ||
            options.skipDefaultLibCheck && sourceFile.hasNoDefaultLib) ||
            host.isSourceOfProjectReferenceRedirect(sourceFile.fileName);
    }
    ts.skipTypeChecking = skipTypeChecking;
    function isJsonEqual(a, b) {
        return a === b || typeof a === "object" && a !== null && typeof b === "object" && b !== null && ts.equalOwnProperties(a, b, isJsonEqual);
    }
    ts.isJsonEqual = isJsonEqual;
    function parsePseudoBigInt(stringValue) {
        var log2Base;
        switch (stringValue.charCodeAt(1)) {
            case 98:
            case 66:
                log2Base = 1;
                break;
            case 111:
            case 79:
                log2Base = 3;
                break;
            case 120:
            case 88:
                log2Base = 4;
                break;
            default:
                var nIndex = stringValue.length - 1;
                var nonZeroStart = 0;
                while (stringValue.charCodeAt(nonZeroStart) === 48) {
                    nonZeroStart++;
                }
                return stringValue.slice(nonZeroStart, nIndex) || "0";
        }
        var startIndex = 2, endIndex = stringValue.length - 1;
        var bitsNeeded = (endIndex - startIndex) * log2Base;
        var segments = new Uint16Array((bitsNeeded >>> 4) + (bitsNeeded & 15 ? 1 : 0));
        for (var i = endIndex - 1, bitOffset = 0; i >= startIndex; i--, bitOffset += log2Base) {
            var segment = bitOffset >>> 4;
            var digitChar = stringValue.charCodeAt(i);
            var digit = digitChar <= 57
                ? digitChar - 48
                : 10 + digitChar -
                    (digitChar <= 70 ? 65 : 97);
            var shiftedDigit = digit << (bitOffset & 15);
            segments[segment] |= shiftedDigit;
            var residual = shiftedDigit >>> 16;
            if (residual)
                segments[segment + 1] |= residual;
        }
        var base10Value = "";
        var firstNonzeroSegment = segments.length - 1;
        var segmentsRemaining = true;
        while (segmentsRemaining) {
            var mod10 = 0;
            segmentsRemaining = false;
            for (var segment = firstNonzeroSegment; segment >= 0; segment--) {
                var newSegment = mod10 << 16 | segments[segment];
                var segmentValue = (newSegment / 10) | 0;
                segments[segment] = segmentValue;
                mod10 = newSegment - segmentValue * 10;
                if (segmentValue && !segmentsRemaining) {
                    firstNonzeroSegment = segment;
                    segmentsRemaining = true;
                }
            }
            base10Value = mod10 + base10Value;
        }
        return base10Value;
    }
    ts.parsePseudoBigInt = parsePseudoBigInt;
    function pseudoBigIntToString(_a) {
        var negative = _a.negative, base10Value = _a.base10Value;
        return (negative && base10Value !== "0" ? "-" : "") + base10Value;
    }
    ts.pseudoBigIntToString = pseudoBigIntToString;
    function isValidTypeOnlyAliasUseSite(useSite) {
        return !!(useSite.flags & 16777216)
            || isPartOfTypeQuery(useSite)
            || isIdentifierInNonEmittingHeritageClause(useSite)
            || isPartOfPossiblyValidTypeOrAbstractComputedPropertyName(useSite)
            || !(isExpressionNode(useSite) || isShorthandPropertyNameUseSite(useSite));
    }
    ts.isValidTypeOnlyAliasUseSite = isValidTypeOnlyAliasUseSite;
    function isShorthandPropertyNameUseSite(useSite) {
        return ts.isIdentifier(useSite) && ts.isShorthandPropertyAssignment(useSite.parent) && useSite.parent.name === useSite;
    }
    function isPartOfPossiblyValidTypeOrAbstractComputedPropertyName(node) {
        while (node.kind === 79 || node.kind === 206) {
            node = node.parent;
        }
        if (node.kind !== 162) {
            return false;
        }
        if (hasSyntacticModifier(node.parent, 128)) {
            return true;
        }
        var containerKind = node.parent.parent.kind;
        return containerKind === 258 || containerKind === 182;
    }
    function isIdentifierInNonEmittingHeritageClause(node) {
        if (node.kind !== 79)
            return false;
        var heritageClause = ts.findAncestor(node.parent, function (parent) {
            switch (parent.kind) {
                case 291:
                    return true;
                case 206:
                case 228:
                    return false;
                default:
                    return "quit";
            }
        });
        return (heritageClause === null || heritageClause === void 0 ? void 0 : heritageClause.token) === 117 || (heritageClause === null || heritageClause === void 0 ? void 0 : heritageClause.parent.kind) === 258;
    }
    function isIdentifierTypeReference(node) {
        return ts.isTypeReferenceNode(node) && ts.isIdentifier(node.typeName);
    }
    ts.isIdentifierTypeReference = isIdentifierTypeReference;
    function arrayIsHomogeneous(array, comparer) {
        if (comparer === void 0) { comparer = ts.equateValues; }
        if (array.length < 2)
            return true;
        var first = array[0];
        for (var i = 1, length_1 = array.length; i < length_1; i++) {
            var target = array[i];
            if (!comparer(first, target))
                return false;
        }
        return true;
    }
    ts.arrayIsHomogeneous = arrayIsHomogeneous;
    function setTextRangePos(range, pos) {
        range.pos = pos;
        return range;
    }
    ts.setTextRangePos = setTextRangePos;
    function setTextRangeEnd(range, end) {
        range.end = end;
        return range;
    }
    ts.setTextRangeEnd = setTextRangeEnd;
    function setTextRangePosEnd(range, pos, end) {
        return setTextRangeEnd(setTextRangePos(range, pos), end);
    }
    ts.setTextRangePosEnd = setTextRangePosEnd;
    function setTextRangePosWidth(range, pos, width) {
        return setTextRangePosEnd(range, pos, pos + width);
    }
    ts.setTextRangePosWidth = setTextRangePosWidth;
    function setNodeFlags(node, newFlags) {
        if (node) {
            node.flags = newFlags;
        }
        return node;
    }
    ts.setNodeFlags = setNodeFlags;
    function setParent(child, parent) {
        if (child && parent) {
            child.parent = parent;
        }
        return child;
    }
    ts.setParent = setParent;
    function setEachParent(children, parent) {
        if (children) {
            for (var _i = 0, children_1 = children; _i < children_1.length; _i++) {
                var child = children_1[_i];
                setParent(child, parent);
            }
        }
        return children;
    }
    ts.setEachParent = setEachParent;
    function setParentRecursive(rootNode, incremental) {
        if (!rootNode)
            return rootNode;
        ts.forEachChildRecursively(rootNode, ts.isJSDocNode(rootNode) ? bindParentToChildIgnoringJSDoc : bindParentToChild);
        return rootNode;
        function bindParentToChildIgnoringJSDoc(child, parent) {
            if (incremental && child.parent === parent) {
                return "skip";
            }
            setParent(child, parent);
        }
        function bindJSDoc(child) {
            if (ts.hasJSDocNodes(child)) {
                for (var _i = 0, _a = child.jsDoc; _i < _a.length; _i++) {
                    var doc = _a[_i];
                    bindParentToChildIgnoringJSDoc(doc, child);
                    ts.forEachChildRecursively(doc, bindParentToChildIgnoringJSDoc);
                }
            }
        }
        function bindParentToChild(child, parent) {
            return bindParentToChildIgnoringJSDoc(child, parent) || bindJSDoc(child);
        }
    }
    ts.setParentRecursive = setParentRecursive;
    function isPackedElement(node) {
        return !ts.isOmittedExpression(node);
    }
    function isPackedArrayLiteral(node) {
        return ts.isArrayLiteralExpression(node) && ts.every(node.elements, isPackedElement);
    }
    ts.isPackedArrayLiteral = isPackedArrayLiteral;
    function expressionResultIsUnused(node) {
        ts.Debug.assertIsDefined(node.parent);
        while (true) {
            var parent = node.parent;
            if (ts.isParenthesizedExpression(parent)) {
                node = parent;
                continue;
            }
            if (ts.isExpressionStatement(parent) ||
                ts.isVoidExpression(parent) ||
                ts.isForStatement(parent) && (parent.initializer === node || parent.incrementor === node)) {
                return true;
            }
            if (ts.isCommaListExpression(parent)) {
                if (node !== ts.last(parent.elements))
                    return true;
                node = parent;
                continue;
            }
            if (ts.isBinaryExpression(parent) && parent.operatorToken.kind === 27) {
                if (node === parent.left)
                    return true;
                node = parent;
                continue;
            }
            return false;
        }
    }
    ts.expressionResultIsUnused = expressionResultIsUnused;
    function containsIgnoredPath(path) {
        return ts.some(ts.ignoredPaths, function (p) { return ts.stringContains(path, p); });
    }
    ts.containsIgnoredPath = containsIgnoredPath;
    function getContainingNodeArray(node) {
        if (!node.parent)
            return undefined;
        switch (node.kind) {
            case 163:
                var parent_1 = node.parent;
                return parent_1.kind === 190 ? undefined : parent_1.typeParameters;
            case 164:
                return node.parent.parameters;
            case 199:
                return node.parent.templateSpans;
            case 233:
                return node.parent.templateSpans;
            case 165:
                return node.parent.decorators;
            case 291:
                return node.parent.heritageClauses;
        }
        var parent = node.parent;
        if (ts.isJSDocTag(node)) {
            return ts.isJSDocTypeLiteral(node.parent) ? undefined : node.parent.tags;
        }
        switch (parent.kind) {
            case 182:
            case 258:
                return ts.isTypeElement(node) ? parent.members : undefined;
            case 187:
            case 188:
                return parent.types;
            case 184:
            case 204:
            case 351:
            case 269:
            case 273:
                return parent.elements;
            case 205:
            case 286:
                return parent.properties;
            case 208:
            case 209:
                return ts.isTypeNode(node) ? parent.typeArguments :
                    parent.expression === node ? undefined :
                        parent.arguments;
            case 278:
            case 282:
                return ts.isJsxChild(node) ? parent.children : undefined;
            case 280:
            case 279:
                return ts.isTypeNode(node) ? parent.typeArguments : undefined;
            case 235:
            case 289:
            case 290:
            case 262:
                return parent.statements;
            case 263:
                return parent.clauses;
            case 257:
            case 226:
                return ts.isClassElement(node) ? parent.members : undefined;
            case 260:
                return ts.isEnumMember(node) ? parent.members : undefined;
            case 305:
                return parent.statements;
        }
    }
    ts.getContainingNodeArray = getContainingNodeArray;
    function hasContextSensitiveParameters(node) {
        if (!node.typeParameters) {
            if (ts.some(node.parameters, function (p) { return !getEffectiveTypeAnnotationNode(p); })) {
                return true;
            }
            if (node.kind !== 214) {
                var parameter = ts.firstOrUndefined(node.parameters);
                if (!(parameter && parameterIsThisKeyword(parameter))) {
                    return true;
                }
            }
        }
        return false;
    }
    ts.hasContextSensitiveParameters = hasContextSensitiveParameters;
    function isInfinityOrNaNString(name) {
        return name === "Infinity" || name === "-Infinity" || name === "NaN";
    }
    ts.isInfinityOrNaNString = isInfinityOrNaNString;
    function isCatchClauseVariableDeclaration(node) {
        return node.kind === 254 && node.parent.kind === 292;
    }
    ts.isCatchClauseVariableDeclaration = isCatchClauseVariableDeclaration;
    function isParameterOrCatchClauseVariable(symbol) {
        var declaration = symbol.valueDeclaration && getRootDeclaration(symbol.valueDeclaration);
        return !!declaration && (ts.isParameter(declaration) || isCatchClauseVariableDeclaration(declaration));
    }
    ts.isParameterOrCatchClauseVariable = isParameterOrCatchClauseVariable;
    function isFunctionExpressionOrArrowFunction(node) {
        return node.kind === 213 || node.kind === 214;
    }
    ts.isFunctionExpressionOrArrowFunction = isFunctionExpressionOrArrowFunction;
    function escapeSnippetText(text) {
        return text.replace(/\$/gm, function () { return "\\$"; });
    }
    ts.escapeSnippetText = escapeSnippetText;
    function isNumericLiteralName(name) {
        return (+name).toString() === name;
    }
    ts.isNumericLiteralName = isNumericLiteralName;
    function createPropertyNameNodeForIdentifierOrLiteral(name, target, singleQuote, stringNamed) {
        return ts.isIdentifierText(name, target) ? ts.factory.createIdentifier(name) :
            !stringNamed && isNumericLiteralName(name) && +name >= 0 ? ts.factory.createNumericLiteral(+name) :
                ts.factory.createStringLiteral(name, !!singleQuote);
    }
    ts.createPropertyNameNodeForIdentifierOrLiteral = createPropertyNameNodeForIdentifierOrLiteral;
    function isThisTypeParameter(type) {
        return !!(type.flags & 262144 && type.isThisType);
    }
    ts.isThisTypeParameter = isThisTypeParameter;
    function getNodeModulePathParts(fullPath) {
        var topLevelNodeModulesIndex = 0;
        var topLevelPackageNameIndex = 0;
        var packageRootIndex = 0;
        var fileNameIndex = 0;
        var partStart = 0;
        var partEnd = 0;
        var state = 0;
        while (partEnd >= 0) {
            partStart = partEnd;
            partEnd = fullPath.indexOf("/", partStart + 1);
            switch (state) {
                case 0:
                    if (fullPath.indexOf(ts.nodeModulesPathPart, partStart) === partStart) {
                        topLevelNodeModulesIndex = partStart;
                        topLevelPackageNameIndex = partEnd;
                        state = 1;
                    }
                    break;
                case 1:
                case 2:
                    if (state === 1 && fullPath.charAt(partStart + 1) === "@") {
                        state = 2;
                    }
                    else {
                        packageRootIndex = partEnd;
                        state = 3;
                    }
                    break;
                case 3:
                    if (fullPath.indexOf(ts.nodeModulesPathPart, partStart) === partStart) {
                        state = 1;
                    }
                    else {
                        state = 3;
                    }
                    break;
            }
        }
        fileNameIndex = partStart;
        return state > 1 ? { topLevelNodeModulesIndex: topLevelNodeModulesIndex, topLevelPackageNameIndex: topLevelPackageNameIndex, packageRootIndex: packageRootIndex, fileNameIndex: fileNameIndex } : undefined;
    }
    ts.getNodeModulePathParts = getNodeModulePathParts;
    function getParameterTypeNode(parameter) {
        var _a;
        return parameter.kind === 340 ? (_a = parameter.typeExpression) === null || _a === void 0 ? void 0 : _a.type : parameter.type;
    }
    ts.getParameterTypeNode = getParameterTypeNode;
})(ts || (ts = {}));
var ts;
(function (ts) {
    function createBaseNodeFactory() {
        var NodeConstructor;
        var TokenConstructor;
        var IdentifierConstructor;
        var PrivateIdentifierConstructor;
        var SourceFileConstructor;
        return {
            createBaseSourceFileNode: createBaseSourceFileNode,
            createBaseIdentifierNode: createBaseIdentifierNode,
            createBasePrivateIdentifierNode: createBasePrivateIdentifierNode,
            createBaseTokenNode: createBaseTokenNode,
            createBaseNode: createBaseNode
        };
        function createBaseSourceFileNode(kind) {
            return new (SourceFileConstructor || (SourceFileConstructor = ts.objectAllocator.getSourceFileConstructor()))(kind, -1, -1);
        }
        function createBaseIdentifierNode(kind) {
            return new (IdentifierConstructor || (IdentifierConstructor = ts.objectAllocator.getIdentifierConstructor()))(kind, -1, -1);
        }
        function createBasePrivateIdentifierNode(kind) {
            return new (PrivateIdentifierConstructor || (PrivateIdentifierConstructor = ts.objectAllocator.getPrivateIdentifierConstructor()))(kind, -1, -1);
        }
        function createBaseTokenNode(kind) {
            return new (TokenConstructor || (TokenConstructor = ts.objectAllocator.getTokenConstructor()))(kind, -1, -1);
        }
        function createBaseNode(kind) {
            return new (NodeConstructor || (NodeConstructor = ts.objectAllocator.getNodeConstructor()))(kind, -1, -1);
        }
    }
    ts.createBaseNodeFactory = createBaseNodeFactory;
})(ts || (ts = {}));
var ts;
(function (ts) {
    function createParenthesizerRules(factory) {
        var binaryLeftOperandParenthesizerCache;
        var binaryRightOperandParenthesizerCache;
        return {
            getParenthesizeLeftSideOfBinaryForOperator: getParenthesizeLeftSideOfBinaryForOperator,
            getParenthesizeRightSideOfBinaryForOperator: getParenthesizeRightSideOfBinaryForOperator,
            parenthesizeLeftSideOfBinary: parenthesizeLeftSideOfBinary,
            parenthesizeRightSideOfBinary: parenthesizeRightSideOfBinary,
            parenthesizeExpressionOfComputedPropertyName: parenthesizeExpressionOfComputedPropertyName,
            parenthesizeConditionOfConditionalExpression: parenthesizeConditionOfConditionalExpression,
            parenthesizeBranchOfConditionalExpression: parenthesizeBranchOfConditionalExpression,
            parenthesizeExpressionOfExportDefault: parenthesizeExpressionOfExportDefault,
            parenthesizeExpressionOfNew: parenthesizeExpressionOfNew,
            parenthesizeLeftSideOfAccess: parenthesizeLeftSideOfAccess,
            parenthesizeOperandOfPostfixUnary: parenthesizeOperandOfPostfixUnary,
            parenthesizeOperandOfPrefixUnary: parenthesizeOperandOfPrefixUnary,
            parenthesizeExpressionsOfCommaDelimitedList: parenthesizeExpressionsOfCommaDelimitedList,
            parenthesizeExpressionForDisallowedComma: parenthesizeExpressionForDisallowedComma,
            parenthesizeExpressionOfExpressionStatement: parenthesizeExpressionOfExpressionStatement,
            parenthesizeConciseBodyOfArrowFunction: parenthesizeConciseBodyOfArrowFunction,
            parenthesizeCheckTypeOfConditionalType: parenthesizeCheckTypeOfConditionalType,
            parenthesizeExtendsTypeOfConditionalType: parenthesizeExtendsTypeOfConditionalType,
            parenthesizeConstituentTypesOfUnionType: parenthesizeConstituentTypesOfUnionType,
            parenthesizeConstituentTypeOfUnionType: parenthesizeConstituentTypeOfUnionType,
            parenthesizeConstituentTypesOfIntersectionType: parenthesizeConstituentTypesOfIntersectionType,
            parenthesizeConstituentTypeOfIntersectionType: parenthesizeConstituentTypeOfIntersectionType,
            parenthesizeOperandOfTypeOperator: parenthesizeOperandOfTypeOperator,
            parenthesizeOperandOfReadonlyTypeOperator: parenthesizeOperandOfReadonlyTypeOperator,
            parenthesizeNonArrayTypeOfPostfixType: parenthesizeNonArrayTypeOfPostfixType,
            parenthesizeElementTypesOfTupleType: parenthesizeElementTypesOfTupleType,
            parenthesizeElementTypeOfTupleType: parenthesizeElementTypeOfTupleType,
            parenthesizeTypeOfOptionalType: parenthesizeTypeOfOptionalType,
            parenthesizeTypeArguments: parenthesizeTypeArguments,
            parenthesizeLeadingTypeArgument: parenthesizeLeadingTypeArgument,
        };
        function getParenthesizeLeftSideOfBinaryForOperator(operatorKind) {
            binaryLeftOperandParenthesizerCache || (binaryLeftOperandParenthesizerCache = new ts.Map());
            var parenthesizerRule = binaryLeftOperandParenthesizerCache.get(operatorKind);
            if (!parenthesizerRule) {
                parenthesizerRule = function (node) { return parenthesizeLeftSideOfBinary(operatorKind, node); };
                binaryLeftOperandParenthesizerCache.set(operatorKind, parenthesizerRule);
            }
            return parenthesizerRule;
        }
        function getParenthesizeRightSideOfBinaryForOperator(operatorKind) {
            binaryRightOperandParenthesizerCache || (binaryRightOperandParenthesizerCache = new ts.Map());
            var parenthesizerRule = binaryRightOperandParenthesizerCache.get(operatorKind);
            if (!parenthesizerRule) {
                parenthesizerRule = function (node) { return parenthesizeRightSideOfBinary(operatorKind, undefined, node); };
                binaryRightOperandParenthesizerCache.set(operatorKind, parenthesizerRule);
            }
            return parenthesizerRule;
        }
        function binaryOperandNeedsParentheses(binaryOperator, operand, isLeftSideOfBinary, leftOperand) {
            var binaryOperatorPrecedence = ts.getOperatorPrecedence(221, binaryOperator);
            var binaryOperatorAssociativity = ts.getOperatorAssociativity(221, binaryOperator);
            var emittedOperand = ts.skipPartiallyEmittedExpressions(operand);
            if (!isLeftSideOfBinary && operand.kind === 214 && binaryOperatorPrecedence > 3) {
                return true;
            }
            var operandPrecedence = ts.getExpressionPrecedence(emittedOperand);
            switch (ts.compareValues(operandPrecedence, binaryOperatorPrecedence)) {
                case -1:
                    if (!isLeftSideOfBinary
                        && binaryOperatorAssociativity === 1
                        && operand.kind === 224) {
                        return false;
                    }
                    return true;
                case 1:
                    return false;
                case 0:
                    if (isLeftSideOfBinary) {
                        return binaryOperatorAssociativity === 1;
                    }
                    else {
                        if (ts.isBinaryExpression(emittedOperand)
                            && emittedOperand.operatorToken.kind === binaryOperator) {
                            if (operatorHasAssociativeProperty(binaryOperator)) {
                                return false;
                            }
                            if (binaryOperator === 39) {
                                var leftKind = leftOperand ? getLiteralKindOfBinaryPlusOperand(leftOperand) : 0;
                                if (ts.isLiteralKind(leftKind) && leftKind === getLiteralKindOfBinaryPlusOperand(emittedOperand)) {
                                    return false;
                                }
                            }
                        }
                        var operandAssociativity = ts.getExpressionAssociativity(emittedOperand);
                        return operandAssociativity === 0;
                    }
            }
        }
        function operatorHasAssociativeProperty(binaryOperator) {
            return binaryOperator === 41
                || binaryOperator === 51
                || binaryOperator === 50
                || binaryOperator === 52;
        }
        function getLiteralKindOfBinaryPlusOperand(node) {
            node = ts.skipPartiallyEmittedExpressions(node);
            if (ts.isLiteralKind(node.kind)) {
                return node.kind;
            }
            if (node.kind === 221 && node.operatorToken.kind === 39) {
                if (node.cachedLiteralKind !== undefined) {
                    return node.cachedLiteralKind;
                }
                var leftKind = getLiteralKindOfBinaryPlusOperand(node.left);
                var literalKind = ts.isLiteralKind(leftKind)
                    && leftKind === getLiteralKindOfBinaryPlusOperand(node.right)
                    ? leftKind
                    : 0;
                node.cachedLiteralKind = literalKind;
                return literalKind;
            }
            return 0;
        }
        function parenthesizeBinaryOperand(binaryOperator, operand, isLeftSideOfBinary, leftOperand) {
            var skipped = ts.skipPartiallyEmittedExpressions(operand);
            if (skipped.kind === 212) {
                return operand;
            }
            return binaryOperandNeedsParentheses(binaryOperator, operand, isLeftSideOfBinary, leftOperand)
                ? factory.createParenthesizedExpression(operand)
                : operand;
        }
        function parenthesizeLeftSideOfBinary(binaryOperator, leftSide) {
            return parenthesizeBinaryOperand(binaryOperator, leftSide, true);
        }
        function parenthesizeRightSideOfBinary(binaryOperator, leftSide, rightSide) {
            return parenthesizeBinaryOperand(binaryOperator, rightSide, false, leftSide);
        }
        function parenthesizeExpressionOfComputedPropertyName(expression) {
            return ts.isCommaSequence(expression) ? factory.createParenthesizedExpression(expression) : expression;
        }
        function parenthesizeConditionOfConditionalExpression(condition) {
            var conditionalPrecedence = ts.getOperatorPrecedence(222, 57);
            var emittedCondition = ts.skipPartiallyEmittedExpressions(condition);
            var conditionPrecedence = ts.getExpressionPrecedence(emittedCondition);
            if (ts.compareValues(conditionPrecedence, conditionalPrecedence) !== 1) {
                return factory.createParenthesizedExpression(condition);
            }
            return condition;
        }
        function parenthesizeBranchOfConditionalExpression(branch) {
            var emittedExpression = ts.skipPartiallyEmittedExpressions(branch);
            return ts.isCommaSequence(emittedExpression)
                ? factory.createParenthesizedExpression(branch)
                : branch;
        }
        function parenthesizeExpressionOfExportDefault(expression) {
            var check = ts.skipPartiallyEmittedExpressions(expression);
            var needsParens = ts.isCommaSequence(check);
            if (!needsParens) {
                switch (ts.getLeftmostExpression(check, false).kind) {
                    case 226:
                    case 213:
                        needsParens = true;
                }
            }
            return needsParens ? factory.createParenthesizedExpression(expression) : expression;
        }
        function parenthesizeExpressionOfNew(expression) {
            var leftmostExpr = ts.getLeftmostExpression(expression, true);
            switch (leftmostExpr.kind) {
                case 208:
                    return factory.createParenthesizedExpression(expression);
                case 209:
                    return !leftmostExpr.arguments
                        ? factory.createParenthesizedExpression(expression)
                        : expression;
            }
            return parenthesizeLeftSideOfAccess(expression);
        }
        function parenthesizeLeftSideOfAccess(expression) {
            var emittedExpression = ts.skipPartiallyEmittedExpressions(expression);
            if (ts.isLeftHandSideExpression(emittedExpression)
                && (emittedExpression.kind !== 209 || emittedExpression.arguments)) {
                return expression;
            }
            return ts.setTextRange(factory.createParenthesizedExpression(expression), expression);
        }
        function parenthesizeOperandOfPostfixUnary(operand) {
            return ts.isLeftHandSideExpression(operand) ? operand : ts.setTextRange(factory.createParenthesizedExpression(operand), operand);
        }
        function parenthesizeOperandOfPrefixUnary(operand) {
            return ts.isUnaryExpression(operand) ? operand : ts.setTextRange(factory.createParenthesizedExpression(operand), operand);
        }
        function parenthesizeExpressionsOfCommaDelimitedList(elements) {
            var result = ts.sameMap(elements, parenthesizeExpressionForDisallowedComma);
            return ts.setTextRange(factory.createNodeArray(result, elements.hasTrailingComma), elements);
        }
        function parenthesizeExpressionForDisallowedComma(expression) {
            var emittedExpression = ts.skipPartiallyEmittedExpressions(expression);
            var expressionPrecedence = ts.getExpressionPrecedence(emittedExpression);
            var commaPrecedence = ts.getOperatorPrecedence(221, 27);
            return expressionPrecedence > commaPrecedence ? expression : ts.setTextRange(factory.createParenthesizedExpression(expression), expression);
        }
        function parenthesizeExpressionOfExpressionStatement(expression) {
            var emittedExpression = ts.skipPartiallyEmittedExpressions(expression);
            if (ts.isCallExpression(emittedExpression)) {
                var callee = emittedExpression.expression;
                var kind = ts.skipPartiallyEmittedExpressions(callee).kind;
                if (kind === 213 || kind === 214) {
                    var updated = factory.updateCallExpression(emittedExpression, ts.setTextRange(factory.createParenthesizedExpression(callee), callee), emittedExpression.typeArguments, emittedExpression.arguments);
                    return factory.restoreOuterExpressions(expression, updated, 8);
                }
            }
            var leftmostExpressionKind = ts.getLeftmostExpression(emittedExpression, false).kind;
            if (leftmostExpressionKind === 205 || leftmostExpressionKind === 213) {
                return ts.setTextRange(factory.createParenthesizedExpression(expression), expression);
            }
            return expression;
        }
        function parenthesizeConciseBodyOfArrowFunction(body) {
            if (!ts.isBlock(body) && (ts.isCommaSequence(body) || ts.getLeftmostExpression(body, false).kind === 205)) {
                return ts.setTextRange(factory.createParenthesizedExpression(body), body);
            }
            return body;
        }
        function parenthesizeCheckTypeOfConditionalType(checkType) {
            switch (checkType.kind) {
                case 179:
                case 180:
                case 189:
                    return factory.createParenthesizedType(checkType);
            }
            return checkType;
        }
        function parenthesizeExtendsTypeOfConditionalType(extendsType) {
            switch (extendsType.kind) {
                case 189:
                    return factory.createParenthesizedType(extendsType);
            }
            return extendsType;
        }
        function parenthesizeConstituentTypeOfUnionType(type) {
            switch (type.kind) {
                case 187:
                case 188:
                    return factory.createParenthesizedType(type);
            }
            return parenthesizeCheckTypeOfConditionalType(type);
        }
        function parenthesizeConstituentTypesOfUnionType(members) {
            return factory.createNodeArray(ts.sameMap(members, parenthesizeConstituentTypeOfUnionType));
        }
        function parenthesizeConstituentTypeOfIntersectionType(type) {
            switch (type.kind) {
                case 187:
                case 188:
                    return factory.createParenthesizedType(type);
            }
            return parenthesizeConstituentTypeOfUnionType(type);
        }
        function parenthesizeConstituentTypesOfIntersectionType(members) {
            return factory.createNodeArray(ts.sameMap(members, parenthesizeConstituentTypeOfIntersectionType));
        }
        function parenthesizeOperandOfTypeOperator(type) {
            switch (type.kind) {
                case 188:
                    return factory.createParenthesizedType(type);
            }
            return parenthesizeConstituentTypeOfIntersectionType(type);
        }
        function parenthesizeOperandOfReadonlyTypeOperator(type) {
            switch (type.kind) {
                case 193:
                    return factory.createParenthesizedType(type);
            }
            return parenthesizeOperandOfTypeOperator(type);
        }
        function parenthesizeNonArrayTypeOfPostfixType(type) {
            switch (type.kind) {
                case 190:
                case 193:
                case 181:
                    return factory.createParenthesizedType(type);
            }
            return parenthesizeOperandOfTypeOperator(type);
        }
        function parenthesizeElementTypesOfTupleType(types) {
            return factory.createNodeArray(ts.sameMap(types, parenthesizeElementTypeOfTupleType));
        }
        function parenthesizeElementTypeOfTupleType(type) {
            if (hasJSDocPostfixQuestion(type))
                return factory.createParenthesizedType(type);
            return type;
        }
        function hasJSDocPostfixQuestion(type) {
            if (ts.isJSDocNullableType(type))
                return type.postfix;
            if (ts.isNamedTupleMember(type))
                return hasJSDocPostfixQuestion(type.type);
            if (ts.isFunctionTypeNode(type) || ts.isConstructorTypeNode(type) || ts.isTypeOperatorNode(type))
                return hasJSDocPostfixQuestion(type.type);
            if (ts.isConditionalTypeNode(type))
                return hasJSDocPostfixQuestion(type.falseType);
            if (ts.isUnionTypeNode(type))
                return hasJSDocPostfixQuestion(ts.last(type.types));
            if (ts.isIntersectionTypeNode(type))
                return hasJSDocPostfixQuestion(ts.last(type.types));
            if (ts.isInferTypeNode(type))
                return !!type.typeParameter.constraint && hasJSDocPostfixQuestion(type.typeParameter.constraint);
            return false;
        }
        function parenthesizeTypeOfOptionalType(type) {
            if (hasJSDocPostfixQuestion(type))
                return factory.createParenthesizedType(type);
            return parenthesizeNonArrayTypeOfPostfixType(type);
        }
        function parenthesizeLeadingTypeArgument(node) {
            return ts.isFunctionOrConstructorTypeNode(node) && node.typeParameters ? factory.createParenthesizedType(node) : node;
        }
        function parenthesizeOrdinalTypeArgument(node, i) {
            return i === 0 ? parenthesizeLeadingTypeArgument(node) : node;
        }
        function parenthesizeTypeArguments(typeArguments) {
            if (ts.some(typeArguments)) {
                return factory.createNodeArray(ts.sameMap(typeArguments, parenthesizeOrdinalTypeArgument));
            }
        }
    }
    ts.createParenthesizerRules = createParenthesizerRules;
    ts.nullParenthesizerRules = {
        getParenthesizeLeftSideOfBinaryForOperator: function (_) { return ts.identity; },
        getParenthesizeRightSideOfBinaryForOperator: function (_) { return ts.identity; },
        parenthesizeLeftSideOfBinary: function (_binaryOperator, leftSide) { return leftSide; },
        parenthesizeRightSideOfBinary: function (_binaryOperator, _leftSide, rightSide) { return rightSide; },
        parenthesizeExpressionOfComputedPropertyName: ts.identity,
        parenthesizeConditionOfConditionalExpression: ts.identity,
        parenthesizeBranchOfConditionalExpression: ts.identity,
        parenthesizeExpressionOfExportDefault: ts.identity,
        parenthesizeExpressionOfNew: function (expression) { return ts.cast(expression, ts.isLeftHandSideExpression); },
        parenthesizeLeftSideOfAccess: function (expression) { return ts.cast(expression, ts.isLeftHandSideExpression); },
        parenthesizeOperandOfPostfixUnary: function (operand) { return ts.cast(operand, ts.isLeftHandSideExpression); },
        parenthesizeOperandOfPrefixUnary: function (operand) { return ts.cast(operand, ts.isUnaryExpression); },
        parenthesizeExpressionsOfCommaDelimitedList: function (nodes) { return ts.cast(nodes, ts.isNodeArray); },
        parenthesizeExpressionForDisallowedComma: ts.identity,
        parenthesizeExpressionOfExpressionStatement: ts.identity,
        parenthesizeConciseBodyOfArrowFunction: ts.identity,
        parenthesizeCheckTypeOfConditionalType: ts.identity,
        parenthesizeExtendsTypeOfConditionalType: ts.identity,
        parenthesizeConstituentTypesOfUnionType: function (nodes) { return ts.cast(nodes, ts.isNodeArray); },
        parenthesizeConstituentTypeOfUnionType: ts.identity,
        parenthesizeConstituentTypesOfIntersectionType: function (nodes) { return ts.cast(nodes, ts.isNodeArray); },
        parenthesizeConstituentTypeOfIntersectionType: ts.identity,
        parenthesizeOperandOfTypeOperator: ts.identity,
        parenthesizeOperandOfReadonlyTypeOperator: ts.identity,
        parenthesizeNonArrayTypeOfPostfixType: ts.identity,
        parenthesizeElementTypesOfTupleType: function (nodes) { return ts.cast(nodes, ts.isNodeArray); },
        parenthesizeElementTypeOfTupleType: ts.identity,
        parenthesizeTypeOfOptionalType: ts.identity,
        parenthesizeTypeArguments: function (nodes) { return nodes && ts.cast(nodes, ts.isNodeArray); },
        parenthesizeLeadingTypeArgument: ts.identity,
    };
})(ts || (ts = {}));
var ts;
(function (ts) {
    function createNodeConverters(factory) {
        return {
            convertToFunctionBlock: convertToFunctionBlock,
            convertToFunctionExpression: convertToFunctionExpression,
            convertToArrayAssignmentElement: convertToArrayAssignmentElement,
            convertToObjectAssignmentElement: convertToObjectAssignmentElement,
            convertToAssignmentPattern: convertToAssignmentPattern,
            convertToObjectAssignmentPattern: convertToObjectAssignmentPattern,
            convertToArrayAssignmentPattern: convertToArrayAssignmentPattern,
            convertToAssignmentElementTarget: convertToAssignmentElementTarget,
        };
        function convertToFunctionBlock(node, multiLine) {
            if (ts.isBlock(node))
                return node;
            var returnStatement = factory.createReturnStatement(node);
            ts.setTextRange(returnStatement, node);
            var body = factory.createBlock([returnStatement], multiLine);
            ts.setTextRange(body, node);
            return body;
        }
        function convertToFunctionExpression(node) {
            if (!node.body)
                return ts.Debug.fail("Cannot convert a FunctionDeclaration without a body");
            var updated = factory.createFunctionExpression(node.modifiers, node.asteriskToken, node.name, node.typeParameters, node.parameters, node.type, node.body);
            ts.setOriginalNode(updated, node);
            ts.setTextRange(updated, node);
            if (ts.getStartsOnNewLine(node)) {
                ts.setStartsOnNewLine(updated, true);
            }
            return updated;
        }
        function convertToArrayAssignmentElement(element) {
            if (ts.isBindingElement(element)) {
                if (element.dotDotDotToken) {
                    ts.Debug.assertNode(element.name, ts.isIdentifier);
                    return ts.setOriginalNode(ts.setTextRange(factory.createSpreadElement(element.name), element), element);
                }
                var expression = convertToAssignmentElementTarget(element.name);
                return element.initializer
                    ? ts.setOriginalNode(ts.setTextRange(factory.createAssignment(expression, element.initializer), element), element)
                    : expression;
            }
            return ts.cast(element, ts.isExpression);
        }
        function convertToObjectAssignmentElement(element) {
            if (ts.isBindingElement(element)) {
                if (element.dotDotDotToken) {
                    ts.Debug.assertNode(element.name, ts.isIdentifier);
                    return ts.setOriginalNode(ts.setTextRange(factory.createSpreadAssignment(element.name), element), element);
                }
                if (element.propertyName) {
                    var expression = convertToAssignmentElementTarget(element.name);
                    return ts.setOriginalNode(ts.setTextRange(factory.createPropertyAssignment(element.propertyName, element.initializer ? factory.createAssignment(expression, element.initializer) : expression), element), element);
                }
                ts.Debug.assertNode(element.name, ts.isIdentifier);
                return ts.setOriginalNode(ts.setTextRange(factory.createShorthandPropertyAssignment(element.name, element.initializer), element), element);
            }
            return ts.cast(element, ts.isObjectLiteralElementLike);
        }
        function convertToAssignmentPattern(node) {
            switch (node.kind) {
                case 202:
                case 204:
                    return convertToArrayAssignmentPattern(node);
                case 201:
                case 205:
                    return convertToObjectAssignmentPattern(node);
            }
        }
        function convertToObjectAssignmentPattern(node) {
            if (ts.isObjectBindingPattern(node)) {
                return ts.setOriginalNode(ts.setTextRange(factory.createObjectLiteralExpression(ts.map(node.elements, convertToObjectAssignmentElement)), node), node);
            }
            return ts.cast(node, ts.isObjectLiteralExpression);
        }
        function convertToArrayAssignmentPattern(node) {
            if (ts.isArrayBindingPattern(node)) {
                return ts.setOriginalNode(ts.setTextRange(factory.createArrayLiteralExpression(ts.map(node.elements, convertToArrayAssignmentElement)), node), node);
            }
            return ts.cast(node, ts.isArrayLiteralExpression);
        }
        function convertToAssignmentElementTarget(node) {
            if (ts.isBindingPattern(node)) {
                return convertToAssignmentPattern(node);
            }
            return ts.cast(node, ts.isExpression);
        }
    }
    ts.createNodeConverters = createNodeConverters;
    ts.nullNodeConverters = {
        convertToFunctionBlock: ts.notImplemented,
        convertToFunctionExpression: ts.notImplemented,
        convertToArrayAssignmentElement: ts.notImplemented,
        convertToObjectAssignmentElement: ts.notImplemented,
        convertToAssignmentPattern: ts.notImplemented,
        convertToObjectAssignmentPattern: ts.notImplemented,
        convertToArrayAssignmentPattern: ts.notImplemented,
        convertToAssignmentElementTarget: ts.notImplemented,
    };
})(ts || (ts = {}));
var ts;
(function (ts) {
    var nextAutoGenerateId = 0;
    function createNodeFactory(flags, baseFactory) {
        var update = flags & 8 ? updateWithoutOriginal : updateWithOriginal;
        var parenthesizerRules = ts.memoize(function () { return flags & 1 ? ts.nullParenthesizerRules : ts.createParenthesizerRules(factory); });
        var converters = ts.memoize(function () { return flags & 2 ? ts.nullNodeConverters : ts.createNodeConverters(factory); });
        var getBinaryCreateFunction = ts.memoizeOne(function (operator) { return function (left, right) { return createBinaryExpression(left, operator, right); }; });
        var getPrefixUnaryCreateFunction = ts.memoizeOne(function (operator) { return function (operand) { return createPrefixUnaryExpression(operator, operand); }; });
        var getPostfixUnaryCreateFunction = ts.memoizeOne(function (operator) { return function (operand) { return createPostfixUnaryExpression(operand, operator); }; });
        var getJSDocPrimaryTypeCreateFunction = ts.memoizeOne(function (kind) { return function () { return createJSDocPrimaryTypeWorker(kind); }; });
        var getJSDocUnaryTypeCreateFunction = ts.memoizeOne(function (kind) { return function (type) { return createJSDocUnaryTypeWorker(kind, type); }; });
        var getJSDocUnaryTypeUpdateFunction = ts.memoizeOne(function (kind) { return function (node, type) { return updateJSDocUnaryTypeWorker(kind, node, type); }; });
        var getJSDocPrePostfixUnaryTypeCreateFunction = ts.memoizeOne(function (kind) { return function (type, postfix) { return createJSDocPrePostfixUnaryTypeWorker(kind, type, postfix); }; });
        var getJSDocPrePostfixUnaryTypeUpdateFunction = ts.memoizeOne(function (kind) { return function (node, type) { return updateJSDocPrePostfixUnaryTypeWorker(kind, node, type); }; });
        var getJSDocSimpleTagCreateFunction = ts.memoizeOne(function (kind) { return function (tagName, comment) { return createJSDocSimpleTagWorker(kind, tagName, comment); }; });
        var getJSDocSimpleTagUpdateFunction = ts.memoizeOne(function (kind) { return function (node, tagName, comment) { return updateJSDocSimpleTagWorker(kind, node, tagName, comment); }; });
        var getJSDocTypeLikeTagCreateFunction = ts.memoizeOne(function (kind) { return function (tagName, typeExpression, comment) { return createJSDocTypeLikeTagWorker(kind, tagName, typeExpression, comment); }; });
        var getJSDocTypeLikeTagUpdateFunction = ts.memoizeOne(function (kind) { return function (node, tagName, typeExpression, comment) { return updateJSDocTypeLikeTagWorker(kind, node, tagName, typeExpression, comment); }; });
        var factory = {
            get parenthesizer() { return parenthesizerRules(); },
            get converters() { return converters(); },
            baseFactory: baseFactory,
            flags: flags,
            createNodeArray: createNodeArray,
            createNumericLiteral: createNumericLiteral,
            createBigIntLiteral: createBigIntLiteral,
            createStringLiteral: createStringLiteral,
            createStringLiteralFromNode: createStringLiteralFromNode,
            createRegularExpressionLiteral: createRegularExpressionLiteral,
            createLiteralLikeNode: createLiteralLikeNode,
            createIdentifier: createIdentifier,
            updateIdentifier: updateIdentifier,
            createTempVariable: createTempVariable,
            createLoopVariable: createLoopVariable,
            createUniqueName: createUniqueName,
            getGeneratedNameForNode: getGeneratedNameForNode,
            createPrivateIdentifier: createPrivateIdentifier,
            createToken: createToken,
            createSuper: createSuper,
            createThis: createThis,
            createNull: createNull,
            createTrue: createTrue,
            createFalse: createFalse,
            createModifier: createModifier,
            createModifiersFromModifierFlags: createModifiersFromModifierFlags,
            createQualifiedName: createQualifiedName,
            updateQualifiedName: updateQualifiedName,
            createComputedPropertyName: createComputedPropertyName,
            updateComputedPropertyName: updateComputedPropertyName,
            createTypeParameterDeclaration: createTypeParameterDeclaration,
            updateTypeParameterDeclaration: updateTypeParameterDeclaration,
            createParameterDeclaration: createParameterDeclaration,
            updateParameterDeclaration: updateParameterDeclaration,
            createDecorator: createDecorator,
            updateDecorator: updateDecorator,
            createPropertySignature: createPropertySignature,
            updatePropertySignature: updatePropertySignature,
            createPropertyDeclaration: createPropertyDeclaration,
            updatePropertyDeclaration: updatePropertyDeclaration,
            createMethodSignature: createMethodSignature,
            updateMethodSignature: updateMethodSignature,
            createMethodDeclaration: createMethodDeclaration,
            updateMethodDeclaration: updateMethodDeclaration,
            createConstructorDeclaration: createConstructorDeclaration,
            updateConstructorDeclaration: updateConstructorDeclaration,
            createGetAccessorDeclaration: createGetAccessorDeclaration,
            updateGetAccessorDeclaration: updateGetAccessorDeclaration,
            createSetAccessorDeclaration: createSetAccessorDeclaration,
            updateSetAccessorDeclaration: updateSetAccessorDeclaration,
            createCallSignature: createCallSignature,
            updateCallSignature: updateCallSignature,
            createConstructSignature: createConstructSignature,
            updateConstructSignature: updateConstructSignature,
            createIndexSignature: createIndexSignature,
            updateIndexSignature: updateIndexSignature,
            createClassStaticBlockDeclaration: createClassStaticBlockDeclaration,
            updateClassStaticBlockDeclaration: updateClassStaticBlockDeclaration,
            createTemplateLiteralTypeSpan: createTemplateLiteralTypeSpan,
            updateTemplateLiteralTypeSpan: updateTemplateLiteralTypeSpan,
            createKeywordTypeNode: createKeywordTypeNode,
            createTypePredicateNode: createTypePredicateNode,
            updateTypePredicateNode: updateTypePredicateNode,
            createTypeReferenceNode: createTypeReferenceNode,
            updateTypeReferenceNode: updateTypeReferenceNode,
            createFunctionTypeNode: createFunctionTypeNode,
            updateFunctionTypeNode: updateFunctionTypeNode,
            createConstructorTypeNode: createConstructorTypeNode,
            updateConstructorTypeNode: updateConstructorTypeNode,
            createTypeQueryNode: createTypeQueryNode,
            updateTypeQueryNode: updateTypeQueryNode,
            createTypeLiteralNode: createTypeLiteralNode,
            updateTypeLiteralNode: updateTypeLiteralNode,
            createArrayTypeNode: createArrayTypeNode,
            updateArrayTypeNode: updateArrayTypeNode,
            createTupleTypeNode: createTupleTypeNode,
            updateTupleTypeNode: updateTupleTypeNode,
            createNamedTupleMember: createNamedTupleMember,
            updateNamedTupleMember: updateNamedTupleMember,
            createOptionalTypeNode: createOptionalTypeNode,
            updateOptionalTypeNode: updateOptionalTypeNode,
            createRestTypeNode: createRestTypeNode,
            updateRestTypeNode: updateRestTypeNode,
            createUnionTypeNode: createUnionTypeNode,
            updateUnionTypeNode: updateUnionTypeNode,
            createIntersectionTypeNode: createIntersectionTypeNode,
            updateIntersectionTypeNode: updateIntersectionTypeNode,
            createConditionalTypeNode: createConditionalTypeNode,
            updateConditionalTypeNode: updateConditionalTypeNode,
            createInferTypeNode: createInferTypeNode,
            updateInferTypeNode: updateInferTypeNode,
            createImportTypeNode: createImportTypeNode,
            updateImportTypeNode: updateImportTypeNode,
            createParenthesizedType: createParenthesizedType,
            updateParenthesizedType: updateParenthesizedType,
            createThisTypeNode: createThisTypeNode,
            createTypeOperatorNode: createTypeOperatorNode,
            updateTypeOperatorNode: updateTypeOperatorNode,
            createIndexedAccessTypeNode: createIndexedAccessTypeNode,
            updateIndexedAccessTypeNode: updateIndexedAccessTypeNode,
            createMappedTypeNode: createMappedTypeNode,
            updateMappedTypeNode: updateMappedTypeNode,
            createLiteralTypeNode: createLiteralTypeNode,
            updateLiteralTypeNode: updateLiteralTypeNode,
            createTemplateLiteralType: createTemplateLiteralType,
            updateTemplateLiteralType: updateTemplateLiteralType,
            createObjectBindingPattern: createObjectBindingPattern,
            updateObjectBindingPattern: updateObjectBindingPattern,
            createArrayBindingPattern: createArrayBindingPattern,
            updateArrayBindingPattern: updateArrayBindingPattern,
            createBindingElement: createBindingElement,
            updateBindingElement: updateBindingElement,
            createArrayLiteralExpression: createArrayLiteralExpression,
            updateArrayLiteralExpression: updateArrayLiteralExpression,
            createObjectLiteralExpression: createObjectLiteralExpression,
            updateObjectLiteralExpression: updateObjectLiteralExpression,
            createPropertyAccessExpression: flags & 4 ?
                function (expression, name) { return ts.setEmitFlags(createPropertyAccessExpression(expression, name), 131072); } :
                createPropertyAccessExpression,
            updatePropertyAccessExpression: updatePropertyAccessExpression,
            createPropertyAccessChain: flags & 4 ?
                function (expression, questionDotToken, name) { return ts.setEmitFlags(createPropertyAccessChain(expression, questionDotToken, name), 131072); } :
                createPropertyAccessChain,
            updatePropertyAccessChain: updatePropertyAccessChain,
            createElementAccessExpression: createElementAccessExpression,
            updateElementAccessExpression: updateElementAccessExpression,
            createElementAccessChain: createElementAccessChain,
            updateElementAccessChain: updateElementAccessChain,
            createCallExpression: createCallExpression,
            updateCallExpression: updateCallExpression,
            createCallChain: createCallChain,
            updateCallChain: updateCallChain,
            createNewExpression: createNewExpression,
            updateNewExpression: updateNewExpression,
            createTaggedTemplateExpression: createTaggedTemplateExpression,
            updateTaggedTemplateExpression: updateTaggedTemplateExpression,
            createTypeAssertion: createTypeAssertion,
            updateTypeAssertion: updateTypeAssertion,
            createParenthesizedExpression: createParenthesizedExpression,
            updateParenthesizedExpression: updateParenthesizedExpression,
            createFunctionExpression: createFunctionExpression,
            updateFunctionExpression: updateFunctionExpression,
            createArrowFunction: createArrowFunction,
            updateArrowFunction: updateArrowFunction,
            createDeleteExpression: createDeleteExpression,
            updateDeleteExpression: updateDeleteExpression,
            createTypeOfExpression: createTypeOfExpression,
            updateTypeOfExpression: updateTypeOfExpression,
            createVoidExpression: createVoidExpression,
            updateVoidExpression: updateVoidExpression,
            createAwaitExpression: createAwaitExpression,
            updateAwaitExpression: updateAwaitExpression,
            createPrefixUnaryExpression: createPrefixUnaryExpression,
            updatePrefixUnaryExpression: updatePrefixUnaryExpression,
            createPostfixUnaryExpression: createPostfixUnaryExpression,
            updatePostfixUnaryExpression: updatePostfixUnaryExpression,
            createBinaryExpression: createBinaryExpression,
            updateBinaryExpression: updateBinaryExpression,
            createConditionalExpression: createConditionalExpression,
            updateConditionalExpression: updateConditionalExpression,
            createTemplateExpression: createTemplateExpression,
            updateTemplateExpression: updateTemplateExpression,
            createTemplateHead: createTemplateHead,
            createTemplateMiddle: createTemplateMiddle,
            createTemplateTail: createTemplateTail,
            createNoSubstitutionTemplateLiteral: createNoSubstitutionTemplateLiteral,
            createTemplateLiteralLikeNode: createTemplateLiteralLikeNode,
            createYieldExpression: createYieldExpression,
            updateYieldExpression: updateYieldExpression,
            createSpreadElement: createSpreadElement,
            updateSpreadElement: updateSpreadElement,
            createClassExpression: createClassExpression,
            updateClassExpression: updateClassExpression,
            createOmittedExpression: createOmittedExpression,
            createExpressionWithTypeArguments: createExpressionWithTypeArguments,
            updateExpressionWithTypeArguments: updateExpressionWithTypeArguments,
            createAsExpression: createAsExpression,
            updateAsExpression: updateAsExpression,
            createNonNullExpression: createNonNullExpression,
            updateNonNullExpression: updateNonNullExpression,
            createNonNullChain: createNonNullChain,
            updateNonNullChain: updateNonNullChain,
            createMetaProperty: createMetaProperty,
            updateMetaProperty: updateMetaProperty,
            createTemplateSpan: createTemplateSpan,
            updateTemplateSpan: updateTemplateSpan,
            createSemicolonClassElement: createSemicolonClassElement,
            createBlock: createBlock,
            updateBlock: updateBlock,
            createVariableStatement: createVariableStatement,
            updateVariableStatement: updateVariableStatement,
            createEmptyStatement: createEmptyStatement,
            createExpressionStatement: createExpressionStatement,
            updateExpressionStatement: updateExpressionStatement,
            createIfStatement: createIfStatement,
            updateIfStatement: updateIfStatement,
            createDoStatement: createDoStatement,
            updateDoStatement: updateDoStatement,
            createWhileStatement: createWhileStatement,
            updateWhileStatement: updateWhileStatement,
            createForStatement: createForStatement,
            updateForStatement: updateForStatement,
            createForInStatement: createForInStatement,
            updateForInStatement: updateForInStatement,
            createForOfStatement: createForOfStatement,
            updateForOfStatement: updateForOfStatement,
            createContinueStatement: createContinueStatement,
            updateContinueStatement: updateContinueStatement,
            createBreakStatement: createBreakStatement,
            updateBreakStatement: updateBreakStatement,
            createReturnStatement: createReturnStatement,
            updateReturnStatement: updateReturnStatement,
            createWithStatement: createWithStatement,
            updateWithStatement: updateWithStatement,
            createSwitchStatement: createSwitchStatement,
            updateSwitchStatement: updateSwitchStatement,
            createLabeledStatement: createLabeledStatement,
            updateLabeledStatement: updateLabeledStatement,
            createThrowStatement: createThrowStatement,
            updateThrowStatement: updateThrowStatement,
            createTryStatement: createTryStatement,
            updateTryStatement: updateTryStatement,
            createDebuggerStatement: createDebuggerStatement,
            createVariableDeclaration: createVariableDeclaration,
            updateVariableDeclaration: updateVariableDeclaration,
            createVariableDeclarationList: createVariableDeclarationList,
            updateVariableDeclarationList: updateVariableDeclarationList,
            createFunctionDeclaration: createFunctionDeclaration,
            updateFunctionDeclaration: updateFunctionDeclaration,
            createClassDeclaration: createClassDeclaration,
            updateClassDeclaration: updateClassDeclaration,
            createInterfaceDeclaration: createInterfaceDeclaration,
            updateInterfaceDeclaration: updateInterfaceDeclaration,
            createTypeAliasDeclaration: createTypeAliasDeclaration,
            updateTypeAliasDeclaration: updateTypeAliasDeclaration,
            createEnumDeclaration: createEnumDeclaration,
            updateEnumDeclaration: updateEnumDeclaration,
            createModuleDeclaration: createModuleDeclaration,
            updateModuleDeclaration: updateModuleDeclaration,
            createModuleBlock: createModuleBlock,
            updateModuleBlock: updateModuleBlock,
            createCaseBlock: createCaseBlock,
            updateCaseBlock: updateCaseBlock,
            createNamespaceExportDeclaration: createNamespaceExportDeclaration,
            updateNamespaceExportDeclaration: updateNamespaceExportDeclaration,
            createImportEqualsDeclaration: createImportEqualsDeclaration,
            updateImportEqualsDeclaration: updateImportEqualsDeclaration,
            createImportDeclaration: createImportDeclaration,
            updateImportDeclaration: updateImportDeclaration,
            createImportClause: createImportClause,
            updateImportClause: updateImportClause,
            createAssertClause: createAssertClause,
            updateAssertClause: updateAssertClause,
            createAssertEntry: createAssertEntry,
            updateAssertEntry: updateAssertEntry,
            createImportTypeAssertionContainer: createImportTypeAssertionContainer,
            updateImportTypeAssertionContainer: updateImportTypeAssertionContainer,
            createNamespaceImport: createNamespaceImport,
            updateNamespaceImport: updateNamespaceImport,
            createNamespaceExport: createNamespaceExport,
            updateNamespaceExport: updateNamespaceExport,
            createNamedImports: createNamedImports,
            updateNamedImports: updateNamedImports,
            createImportSpecifier: createImportSpecifier,
            updateImportSpecifier: updateImportSpecifier,
            createExportAssignment: createExportAssignment,
            updateExportAssignment: updateExportAssignment,
            createExportDeclaration: createExportDeclaration,
            updateExportDeclaration: updateExportDeclaration,
            createNamedExports: createNamedExports,
            updateNamedExports: updateNamedExports,
            createExportSpecifier: createExportSpecifier,
            updateExportSpecifier: updateExportSpecifier,
            createMissingDeclaration: createMissingDeclaration,
            createExternalModuleReference: createExternalModuleReference,
            updateExternalModuleReference: updateExternalModuleReference,
            get createJSDocAllType() { return getJSDocPrimaryTypeCreateFunction(312); },
            get createJSDocUnknownType() { return getJSDocPrimaryTypeCreateFunction(313); },
            get createJSDocNonNullableType() { return getJSDocPrePostfixUnaryTypeCreateFunction(315); },
            get updateJSDocNonNullableType() { return getJSDocPrePostfixUnaryTypeUpdateFunction(315); },
            get createJSDocNullableType() { return getJSDocPrePostfixUnaryTypeCreateFunction(314); },
            get updateJSDocNullableType() { return getJSDocPrePostfixUnaryTypeUpdateFunction(314); },
            get createJSDocOptionalType() { return getJSDocUnaryTypeCreateFunction(316); },
            get updateJSDocOptionalType() { return getJSDocUnaryTypeUpdateFunction(316); },
            get createJSDocVariadicType() { return getJSDocUnaryTypeCreateFunction(318); },
            get updateJSDocVariadicType() { return getJSDocUnaryTypeUpdateFunction(318); },
            get createJSDocNamepathType() { return getJSDocUnaryTypeCreateFunction(319); },
            get updateJSDocNamepathType() { return getJSDocUnaryTypeUpdateFunction(319); },
            createJSDocFunctionType: createJSDocFunctionType,
            updateJSDocFunctionType: updateJSDocFunctionType,
            createJSDocTypeLiteral: createJSDocTypeLiteral,
            updateJSDocTypeLiteral: updateJSDocTypeLiteral,
            createJSDocTypeExpression: createJSDocTypeExpression,
            updateJSDocTypeExpression: updateJSDocTypeExpression,
            createJSDocSignature: createJSDocSignature,
            updateJSDocSignature: updateJSDocSignature,
            createJSDocTemplateTag: createJSDocTemplateTag,
            updateJSDocTemplateTag: updateJSDocTemplateTag,
            createJSDocTypedefTag: createJSDocTypedefTag,
            updateJSDocTypedefTag: updateJSDocTypedefTag,
            createJSDocParameterTag: createJSDocParameterTag,
            updateJSDocParameterTag: updateJSDocParameterTag,
            createJSDocPropertyTag: createJSDocPropertyTag,
            updateJSDocPropertyTag: updateJSDocPropertyTag,
            createJSDocCallbackTag: createJSDocCallbackTag,
            updateJSDocCallbackTag: updateJSDocCallbackTag,
            createJSDocAugmentsTag: createJSDocAugmentsTag,
            updateJSDocAugmentsTag: updateJSDocAugmentsTag,
            createJSDocImplementsTag: createJSDocImplementsTag,
            updateJSDocImplementsTag: updateJSDocImplementsTag,
            createJSDocSeeTag: createJSDocSeeTag,
            updateJSDocSeeTag: updateJSDocSeeTag,
            createJSDocNameReference: createJSDocNameReference,
            updateJSDocNameReference: updateJSDocNameReference,
            createJSDocMemberName: createJSDocMemberName,
            updateJSDocMemberName: updateJSDocMemberName,
            createJSDocLink: createJSDocLink,
            updateJSDocLink: updateJSDocLink,
            createJSDocLinkCode: createJSDocLinkCode,
            updateJSDocLinkCode: updateJSDocLinkCode,
            createJSDocLinkPlain: createJSDocLinkPlain,
            updateJSDocLinkPlain: updateJSDocLinkPlain,
            get createJSDocTypeTag() { return getJSDocTypeLikeTagCreateFunction(343); },
            get updateJSDocTypeTag() { return getJSDocTypeLikeTagUpdateFunction(343); },
            get createJSDocReturnTag() { return getJSDocTypeLikeTagCreateFunction(341); },
            get updateJSDocReturnTag() { return getJSDocTypeLikeTagUpdateFunction(341); },
            get createJSDocThisTag() { return getJSDocTypeLikeTagCreateFunction(342); },
            get updateJSDocThisTag() { return getJSDocTypeLikeTagUpdateFunction(342); },
            get createJSDocEnumTag() { return getJSDocTypeLikeTagCreateFunction(339); },
            get updateJSDocEnumTag() { return getJSDocTypeLikeTagUpdateFunction(339); },
            get createJSDocAuthorTag() { return getJSDocSimpleTagCreateFunction(330); },
            get updateJSDocAuthorTag() { return getJSDocSimpleTagUpdateFunction(330); },
            get createJSDocClassTag() { return getJSDocSimpleTagCreateFunction(332); },
            get updateJSDocClassTag() { return getJSDocSimpleTagUpdateFunction(332); },
            get createJSDocPublicTag() { return getJSDocSimpleTagCreateFunction(333); },
            get updateJSDocPublicTag() { return getJSDocSimpleTagUpdateFunction(333); },
            get createJSDocPrivateTag() { return getJSDocSimpleTagCreateFunction(334); },
            get updateJSDocPrivateTag() { return getJSDocSimpleTagUpdateFunction(334); },
            get createJSDocProtectedTag() { return getJSDocSimpleTagCreateFunction(335); },
            get updateJSDocProtectedTag() { return getJSDocSimpleTagUpdateFunction(335); },
            get createJSDocReadonlyTag() { return getJSDocSimpleTagCreateFunction(336); },
            get updateJSDocReadonlyTag() { return getJSDocSimpleTagUpdateFunction(336); },
            get createJSDocOverrideTag() { return getJSDocSimpleTagCreateFunction(337); },
            get updateJSDocOverrideTag() { return getJSDocSimpleTagUpdateFunction(337); },
            get createJSDocDeprecatedTag() { return getJSDocSimpleTagCreateFunction(331); },
            get updateJSDocDeprecatedTag() { return getJSDocSimpleTagUpdateFunction(331); },
            createJSDocUnknownTag: createJSDocUnknownTag,
            updateJSDocUnknownTag: updateJSDocUnknownTag,
            createJSDocText: createJSDocText,
            updateJSDocText: updateJSDocText,
            createJSDocComment: createJSDocComment,
            updateJSDocComment: updateJSDocComment,
            createJsxElement: createJsxElement,
            updateJsxElement: updateJsxElement,
            createJsxSelfClosingElement: createJsxSelfClosingElement,
            updateJsxSelfClosingElement: updateJsxSelfClosingElement,
            createJsxOpeningElement: createJsxOpeningElement,
            updateJsxOpeningElement: updateJsxOpeningElement,
            createJsxClosingElement: createJsxClosingElement,
            updateJsxClosingElement: updateJsxClosingElement,
            createJsxFragment: createJsxFragment,
            createJsxText: createJsxText,
            updateJsxText: updateJsxText,
            createJsxOpeningFragment: createJsxOpeningFragment,
            createJsxJsxClosingFragment: createJsxJsxClosingFragment,
            updateJsxFragment: updateJsxFragment,
            createJsxAttribute: createJsxAttribute,
            updateJsxAttribute: updateJsxAttribute,
            createJsxAttributes: createJsxAttributes,
            updateJsxAttributes: updateJsxAttributes,
            createJsxSpreadAttribute: createJsxSpreadAttribute,
            updateJsxSpreadAttribute: updateJsxSpreadAttribute,
            createJsxExpression: createJsxExpression,
            updateJsxExpression: updateJsxExpression,
            createCaseClause: createCaseClause,
            updateCaseClause: updateCaseClause,
            createDefaultClause: createDefaultClause,
            updateDefaultClause: updateDefaultClause,
            createHeritageClause: createHeritageClause,
            updateHeritageClause: updateHeritageClause,
            createCatchClause: createCatchClause,
            updateCatchClause: updateCatchClause,
            createPropertyAssignment: createPropertyAssignment,
            updatePropertyAssignment: updatePropertyAssignment,
            createShorthandPropertyAssignment: createShorthandPropertyAssignment,
            updateShorthandPropertyAssignment: updateShorthandPropertyAssignment,
            createSpreadAssignment: createSpreadAssignment,
            updateSpreadAssignment: updateSpreadAssignment,
            createEnumMember: createEnumMember,
            updateEnumMember: updateEnumMember,
            createSourceFile: createSourceFile,
            updateSourceFile: updateSourceFile,
            createBundle: createBundle,
            updateBundle: updateBundle,
            createUnparsedSource: createUnparsedSource,
            createUnparsedPrologue: createUnparsedPrologue,
            createUnparsedPrepend: createUnparsedPrepend,
            createUnparsedTextLike: createUnparsedTextLike,
            createUnparsedSyntheticReference: createUnparsedSyntheticReference,
            createInputFiles: createInputFiles,
            createSyntheticExpression: createSyntheticExpression,
            createSyntaxList: createSyntaxList,
            createNotEmittedStatement: createNotEmittedStatement,
            createPartiallyEmittedExpression: createPartiallyEmittedExpression,
            updatePartiallyEmittedExpression: updatePartiallyEmittedExpression,
            createCommaListExpression: createCommaListExpression,
            updateCommaListExpression: updateCommaListExpression,
            createEndOfDeclarationMarker: createEndOfDeclarationMarker,
            createMergeDeclarationMarker: createMergeDeclarationMarker,
            createSyntheticReferenceExpression: createSyntheticReferenceExpression,
            updateSyntheticReferenceExpression: updateSyntheticReferenceExpression,
            cloneNode: cloneNode,
            get createComma() { return getBinaryCreateFunction(27); },
            get createAssignment() { return getBinaryCreateFunction(63); },
            get createLogicalOr() { return getBinaryCreateFunction(56); },
            get createLogicalAnd() { return getBinaryCreateFunction(55); },
            get createBitwiseOr() { return getBinaryCreateFunction(51); },
            get createBitwiseXor() { return getBinaryCreateFunction(52); },
            get createBitwiseAnd() { return getBinaryCreateFunction(50); },
            get createStrictEquality() { return getBinaryCreateFunction(36); },
            get createStrictInequality() { return getBinaryCreateFunction(37); },
            get createEquality() { return getBinaryCreateFunction(34); },
            get createInequality() { return getBinaryCreateFunction(35); },
            get createLessThan() { return getBinaryCreateFunction(29); },
            get createLessThanEquals() { return getBinaryCreateFunction(32); },
            get createGreaterThan() { return getBinaryCreateFunction(31); },
            get createGreaterThanEquals() { return getBinaryCreateFunction(33); },
            get createLeftShift() { return getBinaryCreateFunction(47); },
            get createRightShift() { return getBinaryCreateFunction(48); },
            get createUnsignedRightShift() { return getBinaryCreateFunction(49); },
            get createAdd() { return getBinaryCreateFunction(39); },
            get createSubtract() { return getBinaryCreateFunction(40); },
            get createMultiply() { return getBinaryCreateFunction(41); },
            get createDivide() { return getBinaryCreateFunction(43); },
            get createModulo() { return getBinaryCreateFunction(44); },
            get createExponent() { return getBinaryCreateFunction(42); },
            get createPrefixPlus() { return getPrefixUnaryCreateFunction(39); },
            get createPrefixMinus() { return getPrefixUnaryCreateFunction(40); },
            get createPrefixIncrement() { return getPrefixUnaryCreateFunction(45); },
            get createPrefixDecrement() { return getPrefixUnaryCreateFunction(46); },
            get createBitwiseNot() { return getPrefixUnaryCreateFunction(54); },
            get createLogicalNot() { return getPrefixUnaryCreateFunction(53); },
            get createPostfixIncrement() { return getPostfixUnaryCreateFunction(45); },
            get createPostfixDecrement() { return getPostfixUnaryCreateFunction(46); },
            createImmediatelyInvokedFunctionExpression: createImmediatelyInvokedFunctionExpression,
            createImmediatelyInvokedArrowFunction: createImmediatelyInvokedArrowFunction,
            createVoidZero: createVoidZero,
            createExportDefault: createExportDefault,
            createExternalModuleExport: createExternalModuleExport,
            createTypeCheck: createTypeCheck,
            createMethodCall: createMethodCall,
            createGlobalMethodCall: createGlobalMethodCall,
            createFunctionBindCall: createFunctionBindCall,
            createFunctionCallCall: createFunctionCallCall,
            createFunctionApplyCall: createFunctionApplyCall,
            createArraySliceCall: createArraySliceCall,
            createArrayConcatCall: createArrayConcatCall,
            createObjectDefinePropertyCall: createObjectDefinePropertyCall,
            createReflectGetCall: createReflectGetCall,
            createReflectSetCall: createReflectSetCall,
            createPropertyDescriptor: createPropertyDescriptor,
            createCallBinding: createCallBinding,
            createAssignmentTargetWrapper: createAssignmentTargetWrapper,
            inlineExpressions: inlineExpressions,
            getInternalName: getInternalName,
            getLocalName: getLocalName,
            getExportName: getExportName,
            getDeclarationName: getDeclarationName,
            getNamespaceMemberName: getNamespaceMemberName,
            getExternalModuleOrNamespaceExportName: getExternalModuleOrNamespaceExportName,
            restoreOuterExpressions: restoreOuterExpressions,
            restoreEnclosingLabel: restoreEnclosingLabel,
            createUseStrictPrologue: createUseStrictPrologue,
            copyPrologue: copyPrologue,
            copyStandardPrologue: copyStandardPrologue,
            copyCustomPrologue: copyCustomPrologue,
            ensureUseStrict: ensureUseStrict,
            liftToBlock: liftToBlock,
            mergeLexicalEnvironment: mergeLexicalEnvironment,
            updateModifiers: updateModifiers,
        };
        return factory;
        function createNodeArray(elements, hasTrailingComma) {
            if (elements === undefined || elements === ts.emptyArray) {
                elements = [];
            }
            else if (ts.isNodeArray(elements)) {
                if (hasTrailingComma === undefined || elements.hasTrailingComma === hasTrailingComma) {
                    if (elements.transformFlags === undefined) {
                        aggregateChildrenFlags(elements);
                    }
                    ts.Debug.attachNodeArrayDebugInfo(elements);
                    return elements;
                }
                var array_8 = elements.slice();
                array_8.pos = elements.pos;
                array_8.end = elements.end;
                array_8.hasTrailingComma = hasTrailingComma;
                array_8.transformFlags = elements.transformFlags;
                ts.Debug.attachNodeArrayDebugInfo(array_8);
                return array_8;
            }
            var length = elements.length;
            var array = (length >= 1 && length <= 4 ? elements.slice() : elements);
            ts.setTextRangePosEnd(array, -1, -1);
            array.hasTrailingComma = !!hasTrailingComma;
            aggregateChildrenFlags(array);
            ts.Debug.attachNodeArrayDebugInfo(array);
            return array;
        }
        function createBaseNode(kind) {
            return baseFactory.createBaseNode(kind);
        }
        function createBaseDeclaration(kind, decorators, modifiers) {
            var node = createBaseNode(kind);
            node.decorators = asNodeArray(decorators);
            node.modifiers = asNodeArray(modifiers);
            node.transformFlags |=
                propagateChildrenFlags(node.decorators) |
                    propagateChildrenFlags(node.modifiers);
            node.symbol = undefined;
            node.localSymbol = undefined;
            node.locals = undefined;
            node.nextContainer = undefined;
            return node;
        }
        function createBaseNamedDeclaration(kind, decorators, modifiers, name) {
            var node = createBaseDeclaration(kind, decorators, modifiers);
            name = asName(name);
            node.name = name;
            if (name) {
                switch (node.kind) {
                    case 169:
                    case 172:
                    case 173:
                    case 167:
                    case 296:
                        if (ts.isIdentifier(name)) {
                            node.transformFlags |= propagateIdentifierNameFlags(name);
                            break;
                        }
                    default:
                        node.transformFlags |= propagateChildFlags(name);
                        break;
                }
            }
            return node;
        }
        function createBaseGenericNamedDeclaration(kind, decorators, modifiers, name, typeParameters) {
            var node = createBaseNamedDeclaration(kind, decorators, modifiers, name);
            node.typeParameters = asNodeArray(typeParameters);
            node.transformFlags |= propagateChildrenFlags(node.typeParameters);
            if (typeParameters)
                node.transformFlags |= 1;
            return node;
        }
        function createBaseSignatureDeclaration(kind, decorators, modifiers, name, typeParameters, parameters, type) {
            var node = createBaseGenericNamedDeclaration(kind, decorators, modifiers, name, typeParameters);
            node.parameters = createNodeArray(parameters);
            node.type = type;
            node.transformFlags |=
                propagateChildrenFlags(node.parameters) |
                    propagateChildFlags(node.type);
            if (type)
                node.transformFlags |= 1;
            return node;
        }
        function updateBaseSignatureDeclaration(updated, original) {
            if (original.typeArguments)
                updated.typeArguments = original.typeArguments;
            return update(updated, original);
        }
        function createBaseFunctionLikeDeclaration(kind, decorators, modifiers, name, typeParameters, parameters, type, body) {
            var node = createBaseSignatureDeclaration(kind, decorators, modifiers, name, typeParameters, parameters, type);
            node.body = body;
            node.transformFlags |= propagateChildFlags(node.body) & ~16777216;
            if (!body)
                node.transformFlags |= 1;
            return node;
        }
        function updateBaseFunctionLikeDeclaration(updated, original) {
            if (original.exclamationToken)
                updated.exclamationToken = original.exclamationToken;
            if (original.typeArguments)
                updated.typeArguments = original.typeArguments;
            return updateBaseSignatureDeclaration(updated, original);
        }
        function createBaseInterfaceOrClassLikeDeclaration(kind, decorators, modifiers, name, typeParameters, heritageClauses) {
            var node = createBaseGenericNamedDeclaration(kind, decorators, modifiers, name, typeParameters);
            node.heritageClauses = asNodeArray(heritageClauses);
            node.transformFlags |= propagateChildrenFlags(node.heritageClauses);
            return node;
        }
        function createBaseClassLikeDeclaration(kind, decorators, modifiers, name, typeParameters, heritageClauses, members) {
            var node = createBaseInterfaceOrClassLikeDeclaration(kind, decorators, modifiers, name, typeParameters, heritageClauses);
            node.members = createNodeArray(members);
            node.transformFlags |= propagateChildrenFlags(node.members);
            return node;
        }
        function createBaseBindingLikeDeclaration(kind, decorators, modifiers, name, initializer) {
            var node = createBaseNamedDeclaration(kind, decorators, modifiers, name);
            node.initializer = initializer;
            node.transformFlags |= propagateChildFlags(node.initializer);
            return node;
        }
        function createBaseVariableLikeDeclaration(kind, decorators, modifiers, name, type, initializer) {
            var node = createBaseBindingLikeDeclaration(kind, decorators, modifiers, name, initializer);
            node.type = type;
            node.transformFlags |= propagateChildFlags(type);
            if (type)
                node.transformFlags |= 1;
            return node;
        }
        function createBaseLiteral(kind, text) {
            var node = createBaseToken(kind);
            node.text = text;
            return node;
        }
        function createNumericLiteral(value, numericLiteralFlags) {
            if (numericLiteralFlags === void 0) { numericLiteralFlags = 0; }
            var node = createBaseLiteral(8, typeof value === "number" ? value + "" : value);
            node.numericLiteralFlags = numericLiteralFlags;
            if (numericLiteralFlags & 384)
                node.transformFlags |= 1024;
            return node;
        }
        function createBigIntLiteral(value) {
            var node = createBaseLiteral(9, typeof value === "string" ? value : ts.pseudoBigIntToString(value) + "n");
            node.transformFlags |= 4;
            return node;
        }
        function createBaseStringLiteral(text, isSingleQuote) {
            var node = createBaseLiteral(10, text);
            node.singleQuote = isSingleQuote;
            return node;
        }
        function createStringLiteral(text, isSingleQuote, hasExtendedUnicodeEscape) {
            var node = createBaseStringLiteral(text, isSingleQuote);
            node.hasExtendedUnicodeEscape = hasExtendedUnicodeEscape;
            if (hasExtendedUnicodeEscape)
                node.transformFlags |= 1024;
            return node;
        }
        function createStringLiteralFromNode(sourceNode) {
            var node = createBaseStringLiteral(ts.getTextOfIdentifierOrLiteral(sourceNode), undefined);
            node.textSourceNode = sourceNode;
            return node;
        }
        function createRegularExpressionLiteral(text) {
            var node = createBaseLiteral(13, text);
            return node;
        }
        function createLiteralLikeNode(kind, text) {
            switch (kind) {
                case 8: return createNumericLiteral(text, 0);
                case 9: return createBigIntLiteral(text);
                case 10: return createStringLiteral(text, undefined);
                case 11: return createJsxText(text, false);
                case 12: return createJsxText(text, true);
                case 13: return createRegularExpressionLiteral(text);
                case 14: return createTemplateLiteralLikeNode(kind, text, undefined, 0);
            }
        }
        function createBaseIdentifier(text, originalKeywordKind) {
            if (originalKeywordKind === undefined && text) {
                originalKeywordKind = ts.stringToToken(text);
            }
            if (originalKeywordKind === 79) {
                originalKeywordKind = undefined;
            }
            var node = baseFactory.createBaseIdentifierNode(79);
            node.originalKeywordKind = originalKeywordKind;
            node.escapedText = ts.escapeLeadingUnderscores(text);
            return node;
        }
        function createBaseGeneratedIdentifier(text, autoGenerateFlags) {
            var node = createBaseIdentifier(text, undefined);
            node.autoGenerateFlags = autoGenerateFlags;
            node.autoGenerateId = nextAutoGenerateId;
            nextAutoGenerateId++;
            return node;
        }
        function createIdentifier(text, typeArguments, originalKeywordKind) {
            var node = createBaseIdentifier(text, originalKeywordKind);
            if (typeArguments) {
                node.typeArguments = createNodeArray(typeArguments);
            }
            if (node.originalKeywordKind === 132) {
                node.transformFlags |= 16777216;
            }
            return node;
        }
        function updateIdentifier(node, typeArguments) {
            return node.typeArguments !== typeArguments
                ? update(createIdentifier(ts.idText(node), typeArguments), node)
                : node;
        }
        function createTempVariable(recordTempVariable, reservedInNestedScopes) {
            var flags = 1;
            if (reservedInNestedScopes)
                flags |= 8;
            var name = createBaseGeneratedIdentifier("", flags);
            if (recordTempVariable) {
                recordTempVariable(name);
            }
            return name;
        }
        function createLoopVariable(reservedInNestedScopes) {
            var flags = 2;
            if (reservedInNestedScopes)
                flags |= 8;
            return createBaseGeneratedIdentifier("", flags);
        }
        function createUniqueName(text, flags) {
            if (flags === void 0) { flags = 0; }
            ts.Debug.assert(!(flags & 7), "Argument out of range: flags");
            ts.Debug.assert((flags & (16 | 32)) !== 32, "GeneratedIdentifierFlags.FileLevel cannot be set without also setting GeneratedIdentifierFlags.Optimistic");
            return createBaseGeneratedIdentifier(text, 3 | flags);
        }
        function getGeneratedNameForNode(node, flags) {
            if (flags === void 0) { flags = 0; }
            ts.Debug.assert(!(flags & 7), "Argument out of range: flags");
            var name = createBaseGeneratedIdentifier(node && ts.isIdentifier(node) ? ts.idText(node) : "", 4 | flags);
            name.original = node;
            return name;
        }
        function createPrivateIdentifier(text) {
            if (!ts.startsWith(text, "#"))
                ts.Debug.fail("First character of private identifier must be #: " + text);
            var node = baseFactory.createBasePrivateIdentifierNode(80);
            node.escapedText = ts.escapeLeadingUnderscores(text);
            node.transformFlags |= 8388608;
            return node;
        }
        function createBaseToken(kind) {
            return baseFactory.createBaseTokenNode(kind);
        }
        function createToken(token) {
            ts.Debug.assert(token >= 0 && token <= 160, "Invalid token");
            ts.Debug.assert(token <= 14 || token >= 17, "Invalid token. Use 'createTemplateLiteralLikeNode' to create template literals.");
            ts.Debug.assert(token <= 8 || token >= 14, "Invalid token. Use 'createLiteralLikeNode' to create literals.");
            ts.Debug.assert(token !== 79, "Invalid token. Use 'createIdentifier' to create identifiers");
            var node = createBaseToken(token);
            var transformFlags = 0;
            switch (token) {
                case 131:
                    transformFlags =
                        256 |
                            128;
                    break;
                case 123:
                case 121:
                case 122:
                case 145:
                case 126:
                case 135:
                case 85:
                case 130:
                case 147:
                case 158:
                case 143:
                case 148:
                case 101:
                case 144:
                case 159:
                case 150:
                case 133:
                case 151:
                case 114:
                case 155:
                case 153:
                    transformFlags = 1;
                    break;
                case 106:
                    transformFlags = 1024 | 33554432;
                    break;
                case 124:
                    transformFlags = 1024;
                    break;
                case 108:
                    transformFlags = 8192;
                    break;
            }
            if (transformFlags) {
                node.transformFlags |= transformFlags;
            }
            return node;
        }
        function createSuper() {
            return createToken(106);
        }
        function createThis() {
            return createToken(108);
        }
        function createNull() {
            return createToken(104);
        }
        function createTrue() {
            return createToken(110);
        }
        function createFalse() {
            return createToken(95);
        }
        function createModifier(kind) {
            return createToken(kind);
        }
        function createModifiersFromModifierFlags(flags) {
            var result = [];
            if (flags & 1)
                result.push(createModifier(93));
            if (flags & 2)
                result.push(createModifier(135));
            if (flags & 512)
                result.push(createModifier(88));
            if (flags & 2048)
                result.push(createModifier(85));
            if (flags & 4)
                result.push(createModifier(123));
            if (flags & 8)
                result.push(createModifier(121));
            if (flags & 16)
                result.push(createModifier(122));
            if (flags & 128)
                result.push(createModifier(126));
            if (flags & 32)
                result.push(createModifier(124));
            if (flags & 16384)
                result.push(createModifier(159));
            if (flags & 64)
                result.push(createModifier(145));
            if (flags & 256)
                result.push(createModifier(131));
            if (flags & 32768)
                result.push(createModifier(101));
            if (flags & 65536)
                result.push(createModifier(144));
            return result.length ? result : undefined;
        }
        function createQualifiedName(left, right) {
            var node = createBaseNode(161);
            node.left = left;
            node.right = asName(right);
            node.transformFlags |=
                propagateChildFlags(node.left) |
                    propagateIdentifierNameFlags(node.right);
            return node;
        }
        function updateQualifiedName(node, left, right) {
            return node.left !== left
                || node.right !== right
                ? update(createQualifiedName(left, right), node)
                : node;
        }
        function createComputedPropertyName(expression) {
            var node = createBaseNode(162);
            node.expression = parenthesizerRules().parenthesizeExpressionOfComputedPropertyName(expression);
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    1024 |
                    65536;
            return node;
        }
        function updateComputedPropertyName(node, expression) {
            return node.expression !== expression
                ? update(createComputedPropertyName(expression), node)
                : node;
        }
        function createTypeParameterDeclaration(modifiersOrName, nameOrConstraint, constraintOrDefault, defaultType) {
            var name;
            var modifiers;
            var constraint;
            if (modifiersOrName === undefined || ts.isArray(modifiersOrName)) {
                modifiers = modifiersOrName;
                name = nameOrConstraint;
                constraint = constraintOrDefault;
            }
            else {
                modifiers = undefined;
                name = modifiersOrName;
                constraint = nameOrConstraint;
            }
            var node = createBaseNamedDeclaration(163, undefined, modifiers, name);
            node.constraint = constraint;
            node.default = defaultType;
            node.transformFlags = 1;
            return node;
        }
        function updateTypeParameterDeclaration(node, modifiersOrName, nameOrConstraint, constraintOrDefault, defaultType) {
            var name;
            var modifiers;
            var constraint;
            if (modifiersOrName === undefined || ts.isArray(modifiersOrName)) {
                modifiers = modifiersOrName;
                name = nameOrConstraint;
                constraint = constraintOrDefault;
            }
            else {
                modifiers = undefined;
                name = modifiersOrName;
                constraint = nameOrConstraint;
            }
            return node.modifiers !== modifiers
                || node.name !== name
                || node.constraint !== constraint
                || node.default !== defaultType
                ? update(createTypeParameterDeclaration(modifiers, name, constraint, defaultType), node)
                : node;
        }
        function createParameterDeclaration(decorators, modifiers, dotDotDotToken, name, questionToken, type, initializer) {
            var node = createBaseVariableLikeDeclaration(164, decorators, modifiers, name, type, initializer && parenthesizerRules().parenthesizeExpressionForDisallowedComma(initializer));
            node.dotDotDotToken = dotDotDotToken;
            node.questionToken = questionToken;
            if (ts.isThisIdentifier(node.name)) {
                node.transformFlags = 1;
            }
            else {
                node.transformFlags |=
                    propagateChildFlags(node.dotDotDotToken) |
                        propagateChildFlags(node.questionToken);
                if (questionToken)
                    node.transformFlags |= 1;
                if (ts.modifiersToFlags(node.modifiers) & 16476)
                    node.transformFlags |= 4096;
                if (initializer || dotDotDotToken)
                    node.transformFlags |= 1024;
            }
            return node;
        }
        function updateParameterDeclaration(node, decorators, modifiers, dotDotDotToken, name, questionToken, type, initializer) {
            return node.decorators !== decorators
                || node.modifiers !== modifiers
                || node.dotDotDotToken !== dotDotDotToken
                || node.name !== name
                || node.questionToken !== questionToken
                || node.type !== type
                || node.initializer !== initializer
                ? update(createParameterDeclaration(decorators, modifiers, dotDotDotToken, name, questionToken, type, initializer), node)
                : node;
        }
        function createDecorator(expression) {
            var node = createBaseNode(165);
            node.expression = parenthesizerRules().parenthesizeLeftSideOfAccess(expression);
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    1 |
                    4096;
            return node;
        }
        function updateDecorator(node, expression) {
            return node.expression !== expression
                ? update(createDecorator(expression), node)
                : node;
        }
        function createPropertySignature(modifiers, name, questionToken, type) {
            var node = createBaseNamedDeclaration(166, undefined, modifiers, name);
            node.type = type;
            node.questionToken = questionToken;
            node.transformFlags = 1;
            return node;
        }
        function updatePropertySignature(node, modifiers, name, questionToken, type) {
            return node.modifiers !== modifiers
                || node.name !== name
                || node.questionToken !== questionToken
                || node.type !== type
                ? update(createPropertySignature(modifiers, name, questionToken, type), node)
                : node;
        }
        function createPropertyDeclaration(decorators, modifiers, name, questionOrExclamationToken, type, initializer) {
            var node = createBaseVariableLikeDeclaration(167, decorators, modifiers, name, type, initializer);
            node.questionToken = questionOrExclamationToken && ts.isQuestionToken(questionOrExclamationToken) ? questionOrExclamationToken : undefined;
            node.exclamationToken = questionOrExclamationToken && ts.isExclamationToken(questionOrExclamationToken) ? questionOrExclamationToken : undefined;
            node.transformFlags |=
                propagateChildFlags(node.questionToken) |
                    propagateChildFlags(node.exclamationToken) |
                    8388608;
            if (ts.isComputedPropertyName(node.name) || (ts.hasStaticModifier(node) && node.initializer)) {
                node.transformFlags |= 4096;
            }
            if (questionOrExclamationToken || ts.modifiersToFlags(node.modifiers) & 2) {
                node.transformFlags |= 1;
            }
            return node;
        }
        function updatePropertyDeclaration(node, decorators, modifiers, name, questionOrExclamationToken, type, initializer) {
            return node.decorators !== decorators
                || node.modifiers !== modifiers
                || node.name !== name
                || node.questionToken !== (questionOrExclamationToken !== undefined && ts.isQuestionToken(questionOrExclamationToken) ? questionOrExclamationToken : undefined)
                || node.exclamationToken !== (questionOrExclamationToken !== undefined && ts.isExclamationToken(questionOrExclamationToken) ? questionOrExclamationToken : undefined)
                || node.type !== type
                || node.initializer !== initializer
                ? update(createPropertyDeclaration(decorators, modifiers, name, questionOrExclamationToken, type, initializer), node)
                : node;
        }
        function createMethodSignature(modifiers, name, questionToken, typeParameters, parameters, type) {
            var node = createBaseSignatureDeclaration(168, undefined, modifiers, name, typeParameters, parameters, type);
            node.questionToken = questionToken;
            node.transformFlags = 1;
            return node;
        }
        function updateMethodSignature(node, modifiers, name, questionToken, typeParameters, parameters, type) {
            return node.modifiers !== modifiers
                || node.name !== name
                || node.questionToken !== questionToken
                || node.typeParameters !== typeParameters
                || node.parameters !== parameters
                || node.type !== type
                ? updateBaseSignatureDeclaration(createMethodSignature(modifiers, name, questionToken, typeParameters, parameters, type), node)
                : node;
        }
        function createMethodDeclaration(decorators, modifiers, asteriskToken, name, questionToken, typeParameters, parameters, type, body) {
            var node = createBaseFunctionLikeDeclaration(169, decorators, modifiers, name, typeParameters, parameters, type, body);
            node.asteriskToken = asteriskToken;
            node.questionToken = questionToken;
            node.transformFlags |=
                propagateChildFlags(node.asteriskToken) |
                    propagateChildFlags(node.questionToken) |
                    1024;
            if (questionToken) {
                node.transformFlags |= 1;
            }
            if (ts.modifiersToFlags(node.modifiers) & 256) {
                if (asteriskToken) {
                    node.transformFlags |= 128;
                }
                else {
                    node.transformFlags |= 256;
                }
            }
            else if (asteriskToken) {
                node.transformFlags |= 2048;
            }
            return node;
        }
        function updateMethodDeclaration(node, decorators, modifiers, asteriskToken, name, questionToken, typeParameters, parameters, type, body) {
            return node.decorators !== decorators
                || node.modifiers !== modifiers
                || node.asteriskToken !== asteriskToken
                || node.name !== name
                || node.questionToken !== questionToken
                || node.typeParameters !== typeParameters
                || node.parameters !== parameters
                || node.type !== type
                || node.body !== body
                ? updateBaseFunctionLikeDeclaration(createMethodDeclaration(decorators, modifiers, asteriskToken, name, questionToken, typeParameters, parameters, type, body), node)
                : node;
        }
        function createClassStaticBlockDeclaration(decorators, modifiers, body) {
            var node = createBaseGenericNamedDeclaration(170, decorators, modifiers, undefined, undefined);
            node.body = body;
            node.transformFlags = propagateChildFlags(body) | 8388608;
            return node;
        }
        function updateClassStaticBlockDeclaration(node, decorators, modifiers, body) {
            return node.decorators !== decorators
                || node.modifier !== modifiers
                || node.body !== body
                ? update(createClassStaticBlockDeclaration(decorators, modifiers, body), node)
                : node;
        }
        function createConstructorDeclaration(decorators, modifiers, parameters, body) {
            var node = createBaseFunctionLikeDeclaration(171, decorators, modifiers, undefined, undefined, parameters, undefined, body);
            node.transformFlags |= 1024;
            return node;
        }
        function updateConstructorDeclaration(node, decorators, modifiers, parameters, body) {
            return node.decorators !== decorators
                || node.modifiers !== modifiers
                || node.parameters !== parameters
                || node.body !== body
                ? updateBaseFunctionLikeDeclaration(createConstructorDeclaration(decorators, modifiers, parameters, body), node)
                : node;
        }
        function createGetAccessorDeclaration(decorators, modifiers, name, parameters, type, body) {
            return createBaseFunctionLikeDeclaration(172, decorators, modifiers, name, undefined, parameters, type, body);
        }
        function updateGetAccessorDeclaration(node, decorators, modifiers, name, parameters, type, body) {
            return node.decorators !== decorators
                || node.modifiers !== modifiers
                || node.name !== name
                || node.parameters !== parameters
                || node.type !== type
                || node.body !== body
                ? updateBaseFunctionLikeDeclaration(createGetAccessorDeclaration(decorators, modifiers, name, parameters, type, body), node)
                : node;
        }
        function createSetAccessorDeclaration(decorators, modifiers, name, parameters, body) {
            return createBaseFunctionLikeDeclaration(173, decorators, modifiers, name, undefined, parameters, undefined, body);
        }
        function updateSetAccessorDeclaration(node, decorators, modifiers, name, parameters, body) {
            return node.decorators !== decorators
                || node.modifiers !== modifiers
                || node.name !== name
                || node.parameters !== parameters
                || node.body !== body
                ? updateBaseFunctionLikeDeclaration(createSetAccessorDeclaration(decorators, modifiers, name, parameters, body), node)
                : node;
        }
        function createCallSignature(typeParameters, parameters, type) {
            var node = createBaseSignatureDeclaration(174, undefined, undefined, undefined, typeParameters, parameters, type);
            node.transformFlags = 1;
            return node;
        }
        function updateCallSignature(node, typeParameters, parameters, type) {
            return node.typeParameters !== typeParameters
                || node.parameters !== parameters
                || node.type !== type
                ? updateBaseSignatureDeclaration(createCallSignature(typeParameters, parameters, type), node)
                : node;
        }
        function createConstructSignature(typeParameters, parameters, type) {
            var node = createBaseSignatureDeclaration(175, undefined, undefined, undefined, typeParameters, parameters, type);
            node.transformFlags = 1;
            return node;
        }
        function updateConstructSignature(node, typeParameters, parameters, type) {
            return node.typeParameters !== typeParameters
                || node.parameters !== parameters
                || node.type !== type
                ? updateBaseSignatureDeclaration(createConstructSignature(typeParameters, parameters, type), node)
                : node;
        }
        function createIndexSignature(decorators, modifiers, parameters, type) {
            var node = createBaseSignatureDeclaration(176, decorators, modifiers, undefined, undefined, parameters, type);
            node.transformFlags = 1;
            return node;
        }
        function updateIndexSignature(node, decorators, modifiers, parameters, type) {
            return node.parameters !== parameters
                || node.type !== type
                || node.decorators !== decorators
                || node.modifiers !== modifiers
                ? updateBaseSignatureDeclaration(createIndexSignature(decorators, modifiers, parameters, type), node)
                : node;
        }
        function createTemplateLiteralTypeSpan(type, literal) {
            var node = createBaseNode(199);
            node.type = type;
            node.literal = literal;
            node.transformFlags = 1;
            return node;
        }
        function updateTemplateLiteralTypeSpan(node, type, literal) {
            return node.type !== type
                || node.literal !== literal
                ? update(createTemplateLiteralTypeSpan(type, literal), node)
                : node;
        }
        function createKeywordTypeNode(kind) {
            return createToken(kind);
        }
        function createTypePredicateNode(assertsModifier, parameterName, type) {
            var node = createBaseNode(177);
            node.assertsModifier = assertsModifier;
            node.parameterName = asName(parameterName);
            node.type = type;
            node.transformFlags = 1;
            return node;
        }
        function updateTypePredicateNode(node, assertsModifier, parameterName, type) {
            return node.assertsModifier !== assertsModifier
                || node.parameterName !== parameterName
                || node.type !== type
                ? update(createTypePredicateNode(assertsModifier, parameterName, type), node)
                : node;
        }
        function createTypeReferenceNode(typeName, typeArguments) {
            var node = createBaseNode(178);
            node.typeName = asName(typeName);
            node.typeArguments = typeArguments && parenthesizerRules().parenthesizeTypeArguments(createNodeArray(typeArguments));
            node.transformFlags = 1;
            return node;
        }
        function updateTypeReferenceNode(node, typeName, typeArguments) {
            return node.typeName !== typeName
                || node.typeArguments !== typeArguments
                ? update(createTypeReferenceNode(typeName, typeArguments), node)
                : node;
        }
        function createFunctionTypeNode(typeParameters, parameters, type) {
            var node = createBaseSignatureDeclaration(179, undefined, undefined, undefined, typeParameters, parameters, type);
            node.transformFlags = 1;
            return node;
        }
        function updateFunctionTypeNode(node, typeParameters, parameters, type) {
            return node.typeParameters !== typeParameters
                || node.parameters !== parameters
                || node.type !== type
                ? updateBaseSignatureDeclaration(createFunctionTypeNode(typeParameters, parameters, type), node)
                : node;
        }
        function createConstructorTypeNode() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return args.length === 4 ? createConstructorTypeNode1.apply(void 0, args) :
                args.length === 3 ? createConstructorTypeNode2.apply(void 0, args) :
                    ts.Debug.fail("Incorrect number of arguments specified.");
        }
        function createConstructorTypeNode1(modifiers, typeParameters, parameters, type) {
            var node = createBaseSignatureDeclaration(180, undefined, modifiers, undefined, typeParameters, parameters, type);
            node.transformFlags = 1;
            return node;
        }
        function createConstructorTypeNode2(typeParameters, parameters, type) {
            return createConstructorTypeNode1(undefined, typeParameters, parameters, type);
        }
        function updateConstructorTypeNode() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return args.length === 5 ? updateConstructorTypeNode1.apply(void 0, args) :
                args.length === 4 ? updateConstructorTypeNode2.apply(void 0, args) :
                    ts.Debug.fail("Incorrect number of arguments specified.");
        }
        function updateConstructorTypeNode1(node, modifiers, typeParameters, parameters, type) {
            return node.modifiers !== modifiers
                || node.typeParameters !== typeParameters
                || node.parameters !== parameters
                || node.type !== type
                ? updateBaseSignatureDeclaration(createConstructorTypeNode(modifiers, typeParameters, parameters, type), node)
                : node;
        }
        function updateConstructorTypeNode2(node, typeParameters, parameters, type) {
            return updateConstructorTypeNode1(node, node.modifiers, typeParameters, parameters, type);
        }
        function createTypeQueryNode(exprName, typeArguments) {
            var node = createBaseNode(181);
            node.exprName = exprName;
            node.typeArguments = typeArguments && parenthesizerRules().parenthesizeTypeArguments(typeArguments);
            node.transformFlags = 1;
            return node;
        }
        function updateTypeQueryNode(node, exprName, typeArguments) {
            return node.exprName !== exprName
                || node.typeArguments !== typeArguments
                ? update(createTypeQueryNode(exprName, typeArguments), node)
                : node;
        }
        function createTypeLiteralNode(members) {
            var node = createBaseNode(182);
            node.members = createNodeArray(members);
            node.transformFlags = 1;
            return node;
        }
        function updateTypeLiteralNode(node, members) {
            return node.members !== members
                ? update(createTypeLiteralNode(members), node)
                : node;
        }
        function createArrayTypeNode(elementType) {
            var node = createBaseNode(183);
            node.elementType = parenthesizerRules().parenthesizeNonArrayTypeOfPostfixType(elementType);
            node.transformFlags = 1;
            return node;
        }
        function updateArrayTypeNode(node, elementType) {
            return node.elementType !== elementType
                ? update(createArrayTypeNode(elementType), node)
                : node;
        }
        function createTupleTypeNode(elements) {
            var node = createBaseNode(184);
            node.elements = createNodeArray(parenthesizerRules().parenthesizeElementTypesOfTupleType(elements));
            node.transformFlags = 1;
            return node;
        }
        function updateTupleTypeNode(node, elements) {
            return node.elements !== elements
                ? update(createTupleTypeNode(elements), node)
                : node;
        }
        function createNamedTupleMember(dotDotDotToken, name, questionToken, type) {
            var node = createBaseNode(197);
            node.dotDotDotToken = dotDotDotToken;
            node.name = name;
            node.questionToken = questionToken;
            node.type = type;
            node.transformFlags = 1;
            return node;
        }
        function updateNamedTupleMember(node, dotDotDotToken, name, questionToken, type) {
            return node.dotDotDotToken !== dotDotDotToken
                || node.name !== name
                || node.questionToken !== questionToken
                || node.type !== type
                ? update(createNamedTupleMember(dotDotDotToken, name, questionToken, type), node)
                : node;
        }
        function createOptionalTypeNode(type) {
            var node = createBaseNode(185);
            node.type = parenthesizerRules().parenthesizeTypeOfOptionalType(type);
            node.transformFlags = 1;
            return node;
        }
        function updateOptionalTypeNode(node, type) {
            return node.type !== type
                ? update(createOptionalTypeNode(type), node)
                : node;
        }
        function createRestTypeNode(type) {
            var node = createBaseNode(186);
            node.type = type;
            node.transformFlags = 1;
            return node;
        }
        function updateRestTypeNode(node, type) {
            return node.type !== type
                ? update(createRestTypeNode(type), node)
                : node;
        }
        function createUnionOrIntersectionTypeNode(kind, types, parenthesize) {
            var node = createBaseNode(kind);
            node.types = factory.createNodeArray(parenthesize(types));
            node.transformFlags = 1;
            return node;
        }
        function updateUnionOrIntersectionTypeNode(node, types, parenthesize) {
            return node.types !== types
                ? update(createUnionOrIntersectionTypeNode(node.kind, types, parenthesize), node)
                : node;
        }
        function createUnionTypeNode(types) {
            return createUnionOrIntersectionTypeNode(187, types, parenthesizerRules().parenthesizeConstituentTypesOfUnionType);
        }
        function updateUnionTypeNode(node, types) {
            return updateUnionOrIntersectionTypeNode(node, types, parenthesizerRules().parenthesizeConstituentTypesOfUnionType);
        }
        function createIntersectionTypeNode(types) {
            return createUnionOrIntersectionTypeNode(188, types, parenthesizerRules().parenthesizeConstituentTypesOfIntersectionType);
        }
        function updateIntersectionTypeNode(node, types) {
            return updateUnionOrIntersectionTypeNode(node, types, parenthesizerRules().parenthesizeConstituentTypesOfIntersectionType);
        }
        function createConditionalTypeNode(checkType, extendsType, trueType, falseType) {
            var node = createBaseNode(189);
            node.checkType = parenthesizerRules().parenthesizeCheckTypeOfConditionalType(checkType);
            node.extendsType = parenthesizerRules().parenthesizeExtendsTypeOfConditionalType(extendsType);
            node.trueType = trueType;
            node.falseType = falseType;
            node.transformFlags = 1;
            return node;
        }
        function updateConditionalTypeNode(node, checkType, extendsType, trueType, falseType) {
            return node.checkType !== checkType
                || node.extendsType !== extendsType
                || node.trueType !== trueType
                || node.falseType !== falseType
                ? update(createConditionalTypeNode(checkType, extendsType, trueType, falseType), node)
                : node;
        }
        function createInferTypeNode(typeParameter) {
            var node = createBaseNode(190);
            node.typeParameter = typeParameter;
            node.transformFlags = 1;
            return node;
        }
        function updateInferTypeNode(node, typeParameter) {
            return node.typeParameter !== typeParameter
                ? update(createInferTypeNode(typeParameter), node)
                : node;
        }
        function createTemplateLiteralType(head, templateSpans) {
            var node = createBaseNode(198);
            node.head = head;
            node.templateSpans = createNodeArray(templateSpans);
            node.transformFlags = 1;
            return node;
        }
        function updateTemplateLiteralType(node, head, templateSpans) {
            return node.head !== head
                || node.templateSpans !== templateSpans
                ? update(createTemplateLiteralType(head, templateSpans), node)
                : node;
        }
        function createImportTypeNode(argument, qualifierOrAssertions, typeArgumentsOrQualifier, isTypeOfOrTypeArguments, isTypeOf) {
            var assertion = qualifierOrAssertions && qualifierOrAssertions.kind === 295 ? qualifierOrAssertions : undefined;
            var qualifier = qualifierOrAssertions && ts.isEntityName(qualifierOrAssertions) ? qualifierOrAssertions
                : typeArgumentsOrQualifier && !ts.isArray(typeArgumentsOrQualifier) ? typeArgumentsOrQualifier : undefined;
            var typeArguments = ts.isArray(typeArgumentsOrQualifier) ? typeArgumentsOrQualifier : ts.isArray(isTypeOfOrTypeArguments) ? isTypeOfOrTypeArguments : undefined;
            isTypeOf = typeof isTypeOfOrTypeArguments === "boolean" ? isTypeOfOrTypeArguments : typeof isTypeOf === "boolean" ? isTypeOf : false;
            var node = createBaseNode(200);
            node.argument = argument;
            node.assertions = assertion;
            node.qualifier = qualifier;
            node.typeArguments = typeArguments && parenthesizerRules().parenthesizeTypeArguments(typeArguments);
            node.isTypeOf = isTypeOf;
            node.transformFlags = 1;
            return node;
        }
        function updateImportTypeNode(node, argument, qualifierOrAssertions, typeArgumentsOrQualifier, isTypeOfOrTypeArguments, isTypeOf) {
            var assertion = qualifierOrAssertions && qualifierOrAssertions.kind === 295 ? qualifierOrAssertions : undefined;
            var qualifier = qualifierOrAssertions && ts.isEntityName(qualifierOrAssertions) ? qualifierOrAssertions
                : typeArgumentsOrQualifier && !ts.isArray(typeArgumentsOrQualifier) ? typeArgumentsOrQualifier : undefined;
            var typeArguments = ts.isArray(typeArgumentsOrQualifier) ? typeArgumentsOrQualifier : ts.isArray(isTypeOfOrTypeArguments) ? isTypeOfOrTypeArguments : undefined;
            isTypeOf = typeof isTypeOfOrTypeArguments === "boolean" ? isTypeOfOrTypeArguments : typeof isTypeOf === "boolean" ? isTypeOf : node.isTypeOf;
            return node.argument !== argument
                || node.assertions !== assertion
                || node.qualifier !== qualifier
                || node.typeArguments !== typeArguments
                || node.isTypeOf !== isTypeOf
                ? update(createImportTypeNode(argument, assertion, qualifier, typeArguments, isTypeOf), node)
                : node;
        }
        function createParenthesizedType(type) {
            var node = createBaseNode(191);
            node.type = type;
            node.transformFlags = 1;
            return node;
        }
        function updateParenthesizedType(node, type) {
            return node.type !== type
                ? update(createParenthesizedType(type), node)
                : node;
        }
        function createThisTypeNode() {
            var node = createBaseNode(192);
            node.transformFlags = 1;
            return node;
        }
        function createTypeOperatorNode(operator, type) {
            var node = createBaseNode(193);
            node.operator = operator;
            node.type = operator === 145 ?
                parenthesizerRules().parenthesizeOperandOfReadonlyTypeOperator(type) :
                parenthesizerRules().parenthesizeOperandOfTypeOperator(type);
            node.transformFlags = 1;
            return node;
        }
        function updateTypeOperatorNode(node, type) {
            return node.type !== type
                ? update(createTypeOperatorNode(node.operator, type), node)
                : node;
        }
        function createIndexedAccessTypeNode(objectType, indexType) {
            var node = createBaseNode(194);
            node.objectType = parenthesizerRules().parenthesizeNonArrayTypeOfPostfixType(objectType);
            node.indexType = indexType;
            node.transformFlags = 1;
            return node;
        }
        function updateIndexedAccessTypeNode(node, objectType, indexType) {
            return node.objectType !== objectType
                || node.indexType !== indexType
                ? update(createIndexedAccessTypeNode(objectType, indexType), node)
                : node;
        }
        function createMappedTypeNode(readonlyToken, typeParameter, nameType, questionToken, type, members) {
            var node = createBaseNode(195);
            node.readonlyToken = readonlyToken;
            node.typeParameter = typeParameter;
            node.nameType = nameType;
            node.questionToken = questionToken;
            node.type = type;
            node.members = members && createNodeArray(members);
            node.transformFlags = 1;
            return node;
        }
        function updateMappedTypeNode(node, readonlyToken, typeParameter, nameType, questionToken, type, members) {
            return node.readonlyToken !== readonlyToken
                || node.typeParameter !== typeParameter
                || node.nameType !== nameType
                || node.questionToken !== questionToken
                || node.type !== type
                || node.members !== members
                ? update(createMappedTypeNode(readonlyToken, typeParameter, nameType, questionToken, type, members), node)
                : node;
        }
        function createLiteralTypeNode(literal) {
            var node = createBaseNode(196);
            node.literal = literal;
            node.transformFlags = 1;
            return node;
        }
        function updateLiteralTypeNode(node, literal) {
            return node.literal !== literal
                ? update(createLiteralTypeNode(literal), node)
                : node;
        }
        function createObjectBindingPattern(elements) {
            var node = createBaseNode(201);
            node.elements = createNodeArray(elements);
            node.transformFlags |=
                propagateChildrenFlags(node.elements) |
                    1024 |
                    262144;
            if (node.transformFlags & 16384) {
                node.transformFlags |=
                    128 |
                        32768;
            }
            return node;
        }
        function updateObjectBindingPattern(node, elements) {
            return node.elements !== elements
                ? update(createObjectBindingPattern(elements), node)
                : node;
        }
        function createArrayBindingPattern(elements) {
            var node = createBaseNode(202);
            node.elements = createNodeArray(elements);
            node.transformFlags |=
                propagateChildrenFlags(node.elements) |
                    1024 |
                    262144;
            return node;
        }
        function updateArrayBindingPattern(node, elements) {
            return node.elements !== elements
                ? update(createArrayBindingPattern(elements), node)
                : node;
        }
        function createBindingElement(dotDotDotToken, propertyName, name, initializer) {
            var node = createBaseBindingLikeDeclaration(203, undefined, undefined, name, initializer && parenthesizerRules().parenthesizeExpressionForDisallowedComma(initializer));
            node.propertyName = asName(propertyName);
            node.dotDotDotToken = dotDotDotToken;
            node.transformFlags |=
                propagateChildFlags(node.dotDotDotToken) |
                    1024;
            if (node.propertyName) {
                node.transformFlags |= ts.isIdentifier(node.propertyName) ?
                    propagateIdentifierNameFlags(node.propertyName) :
                    propagateChildFlags(node.propertyName);
            }
            if (dotDotDotToken)
                node.transformFlags |= 16384;
            return node;
        }
        function updateBindingElement(node, dotDotDotToken, propertyName, name, initializer) {
            return node.propertyName !== propertyName
                || node.dotDotDotToken !== dotDotDotToken
                || node.name !== name
                || node.initializer !== initializer
                ? update(createBindingElement(dotDotDotToken, propertyName, name, initializer), node)
                : node;
        }
        function createBaseExpression(kind) {
            var node = createBaseNode(kind);
            return node;
        }
        function createArrayLiteralExpression(elements, multiLine) {
            var node = createBaseExpression(204);
            var lastElement = elements && ts.lastOrUndefined(elements);
            var elementsArray = createNodeArray(elements, lastElement && ts.isOmittedExpression(lastElement) ? true : undefined);
            node.elements = parenthesizerRules().parenthesizeExpressionsOfCommaDelimitedList(elementsArray);
            node.multiLine = multiLine;
            node.transformFlags |= propagateChildrenFlags(node.elements);
            return node;
        }
        function updateArrayLiteralExpression(node, elements) {
            return node.elements !== elements
                ? update(createArrayLiteralExpression(elements, node.multiLine), node)
                : node;
        }
        function createObjectLiteralExpression(properties, multiLine) {
            var node = createBaseExpression(205);
            node.properties = createNodeArray(properties);
            node.multiLine = multiLine;
            node.transformFlags |= propagateChildrenFlags(node.properties);
            return node;
        }
        function updateObjectLiteralExpression(node, properties) {
            return node.properties !== properties
                ? update(createObjectLiteralExpression(properties, node.multiLine), node)
                : node;
        }
        function createPropertyAccessExpression(expression, name) {
            var node = createBaseExpression(206);
            node.expression = parenthesizerRules().parenthesizeLeftSideOfAccess(expression);
            node.name = asName(name);
            node.transformFlags =
                propagateChildFlags(node.expression) |
                    (ts.isIdentifier(node.name) ?
                        propagateIdentifierNameFlags(node.name) :
                        propagateChildFlags(node.name));
            if (ts.isSuperKeyword(expression)) {
                node.transformFlags |=
                    256 |
                        128;
            }
            return node;
        }
        function updatePropertyAccessExpression(node, expression, name) {
            if (ts.isPropertyAccessChain(node)) {
                return updatePropertyAccessChain(node, expression, node.questionDotToken, ts.cast(name, ts.isIdentifier));
            }
            return node.expression !== expression
                || node.name !== name
                ? update(createPropertyAccessExpression(expression, name), node)
                : node;
        }
        function createPropertyAccessChain(expression, questionDotToken, name) {
            var node = createBaseExpression(206);
            node.flags |= 32;
            node.expression = parenthesizerRules().parenthesizeLeftSideOfAccess(expression);
            node.questionDotToken = questionDotToken;
            node.name = asName(name);
            node.transformFlags |=
                32 |
                    propagateChildFlags(node.expression) |
                    propagateChildFlags(node.questionDotToken) |
                    (ts.isIdentifier(node.name) ?
                        propagateIdentifierNameFlags(node.name) :
                        propagateChildFlags(node.name));
            return node;
        }
        function updatePropertyAccessChain(node, expression, questionDotToken, name) {
            ts.Debug.assert(!!(node.flags & 32), "Cannot update a PropertyAccessExpression using updatePropertyAccessChain. Use updatePropertyAccess instead.");
            return node.expression !== expression
                || node.questionDotToken !== questionDotToken
                || node.name !== name
                ? update(createPropertyAccessChain(expression, questionDotToken, name), node)
                : node;
        }
        function createElementAccessExpression(expression, index) {
            var node = createBaseExpression(207);
            node.expression = parenthesizerRules().parenthesizeLeftSideOfAccess(expression);
            node.argumentExpression = asExpression(index);
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    propagateChildFlags(node.argumentExpression);
            if (ts.isSuperKeyword(expression)) {
                node.transformFlags |=
                    256 |
                        128;
            }
            return node;
        }
        function updateElementAccessExpression(node, expression, argumentExpression) {
            if (ts.isElementAccessChain(node)) {
                return updateElementAccessChain(node, expression, node.questionDotToken, argumentExpression);
            }
            return node.expression !== expression
                || node.argumentExpression !== argumentExpression
                ? update(createElementAccessExpression(expression, argumentExpression), node)
                : node;
        }
        function createElementAccessChain(expression, questionDotToken, index) {
            var node = createBaseExpression(207);
            node.flags |= 32;
            node.expression = parenthesizerRules().parenthesizeLeftSideOfAccess(expression);
            node.questionDotToken = questionDotToken;
            node.argumentExpression = asExpression(index);
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    propagateChildFlags(node.questionDotToken) |
                    propagateChildFlags(node.argumentExpression) |
                    32;
            return node;
        }
        function updateElementAccessChain(node, expression, questionDotToken, argumentExpression) {
            ts.Debug.assert(!!(node.flags & 32), "Cannot update a ElementAccessExpression using updateElementAccessChain. Use updateElementAccess instead.");
            return node.expression !== expression
                || node.questionDotToken !== questionDotToken
                || node.argumentExpression !== argumentExpression
                ? update(createElementAccessChain(expression, questionDotToken, argumentExpression), node)
                : node;
        }
        function createCallExpression(expression, typeArguments, argumentsArray) {
            var node = createBaseExpression(208);
            node.expression = parenthesizerRules().parenthesizeLeftSideOfAccess(expression);
            node.typeArguments = asNodeArray(typeArguments);
            node.arguments = parenthesizerRules().parenthesizeExpressionsOfCommaDelimitedList(createNodeArray(argumentsArray));
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    propagateChildrenFlags(node.typeArguments) |
                    propagateChildrenFlags(node.arguments);
            if (node.typeArguments) {
                node.transformFlags |= 1;
            }
            if (ts.isImportKeyword(node.expression)) {
                node.transformFlags |= 4194304;
            }
            else if (ts.isSuperProperty(node.expression)) {
                node.transformFlags |= 8192;
            }
            return node;
        }
        function updateCallExpression(node, expression, typeArguments, argumentsArray) {
            if (ts.isCallChain(node)) {
                return updateCallChain(node, expression, node.questionDotToken, typeArguments, argumentsArray);
            }
            return node.expression !== expression
                || node.typeArguments !== typeArguments
                || node.arguments !== argumentsArray
                ? update(createCallExpression(expression, typeArguments, argumentsArray), node)
                : node;
        }
        function createCallChain(expression, questionDotToken, typeArguments, argumentsArray) {
            var node = createBaseExpression(208);
            node.flags |= 32;
            node.expression = parenthesizerRules().parenthesizeLeftSideOfAccess(expression);
            node.questionDotToken = questionDotToken;
            node.typeArguments = asNodeArray(typeArguments);
            node.arguments = parenthesizerRules().parenthesizeExpressionsOfCommaDelimitedList(createNodeArray(argumentsArray));
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    propagateChildFlags(node.questionDotToken) |
                    propagateChildrenFlags(node.typeArguments) |
                    propagateChildrenFlags(node.arguments) |
                    32;
            if (node.typeArguments) {
                node.transformFlags |= 1;
            }
            if (ts.isSuperProperty(node.expression)) {
                node.transformFlags |= 8192;
            }
            return node;
        }
        function updateCallChain(node, expression, questionDotToken, typeArguments, argumentsArray) {
            ts.Debug.assert(!!(node.flags & 32), "Cannot update a CallExpression using updateCallChain. Use updateCall instead.");
            return node.expression !== expression
                || node.questionDotToken !== questionDotToken
                || node.typeArguments !== typeArguments
                || node.arguments !== argumentsArray
                ? update(createCallChain(expression, questionDotToken, typeArguments, argumentsArray), node)
                : node;
        }
        function createNewExpression(expression, typeArguments, argumentsArray) {
            var node = createBaseExpression(209);
            node.expression = parenthesizerRules().parenthesizeExpressionOfNew(expression);
            node.typeArguments = asNodeArray(typeArguments);
            node.arguments = argumentsArray ? parenthesizerRules().parenthesizeExpressionsOfCommaDelimitedList(argumentsArray) : undefined;
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    propagateChildrenFlags(node.typeArguments) |
                    propagateChildrenFlags(node.arguments) |
                    32;
            if (node.typeArguments) {
                node.transformFlags |= 1;
            }
            return node;
        }
        function updateNewExpression(node, expression, typeArguments, argumentsArray) {
            return node.expression !== expression
                || node.typeArguments !== typeArguments
                || node.arguments !== argumentsArray
                ? update(createNewExpression(expression, typeArguments, argumentsArray), node)
                : node;
        }
        function createTaggedTemplateExpression(tag, typeArguments, template) {
            var node = createBaseExpression(210);
            node.tag = parenthesizerRules().parenthesizeLeftSideOfAccess(tag);
            node.typeArguments = asNodeArray(typeArguments);
            node.template = template;
            node.transformFlags |=
                propagateChildFlags(node.tag) |
                    propagateChildrenFlags(node.typeArguments) |
                    propagateChildFlags(node.template) |
                    1024;
            if (node.typeArguments) {
                node.transformFlags |= 1;
            }
            if (ts.hasInvalidEscape(node.template)) {
                node.transformFlags |= 128;
            }
            return node;
        }
        function updateTaggedTemplateExpression(node, tag, typeArguments, template) {
            return node.tag !== tag
                || node.typeArguments !== typeArguments
                || node.template !== template
                ? update(createTaggedTemplateExpression(tag, typeArguments, template), node)
                : node;
        }
        function createTypeAssertion(type, expression) {
            var node = createBaseExpression(211);
            node.expression = parenthesizerRules().parenthesizeOperandOfPrefixUnary(expression);
            node.type = type;
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    propagateChildFlags(node.type) |
                    1;
            return node;
        }
        function updateTypeAssertion(node, type, expression) {
            return node.type !== type
                || node.expression !== expression
                ? update(createTypeAssertion(type, expression), node)
                : node;
        }
        function createParenthesizedExpression(expression) {
            var node = createBaseExpression(212);
            node.expression = expression;
            node.transformFlags = propagateChildFlags(node.expression);
            return node;
        }
        function updateParenthesizedExpression(node, expression) {
            return node.expression !== expression
                ? update(createParenthesizedExpression(expression), node)
                : node;
        }
        function createFunctionExpression(modifiers, asteriskToken, name, typeParameters, parameters, type, body) {
            var node = createBaseFunctionLikeDeclaration(213, undefined, modifiers, name, typeParameters, parameters, type, body);
            node.asteriskToken = asteriskToken;
            node.transformFlags |= propagateChildFlags(node.asteriskToken);
            if (node.typeParameters) {
                node.transformFlags |= 1;
            }
            if (ts.modifiersToFlags(node.modifiers) & 256) {
                if (node.asteriskToken) {
                    node.transformFlags |= 128;
                }
                else {
                    node.transformFlags |= 256;
                }
            }
            else if (node.asteriskToken) {
                node.transformFlags |= 2048;
            }
            return node;
        }
        function updateFunctionExpression(node, modifiers, asteriskToken, name, typeParameters, parameters, type, body) {
            return node.name !== name
                || node.modifiers !== modifiers
                || node.asteriskToken !== asteriskToken
                || node.typeParameters !== typeParameters
                || node.parameters !== parameters
                || node.type !== type
                || node.body !== body
                ? updateBaseFunctionLikeDeclaration(createFunctionExpression(modifiers, asteriskToken, name, typeParameters, parameters, type, body), node)
                : node;
        }
        function createArrowFunction(modifiers, typeParameters, parameters, type, equalsGreaterThanToken, body) {
            var node = createBaseFunctionLikeDeclaration(214, undefined, modifiers, undefined, typeParameters, parameters, type, parenthesizerRules().parenthesizeConciseBodyOfArrowFunction(body));
            node.equalsGreaterThanToken = equalsGreaterThanToken !== null && equalsGreaterThanToken !== void 0 ? equalsGreaterThanToken : createToken(38);
            node.transformFlags |=
                propagateChildFlags(node.equalsGreaterThanToken) |
                    1024;
            if (ts.modifiersToFlags(node.modifiers) & 256) {
                node.transformFlags |= 256 | 8192;
            }
            return node;
        }
        function updateArrowFunction(node, modifiers, typeParameters, parameters, type, equalsGreaterThanToken, body) {
            return node.modifiers !== modifiers
                || node.typeParameters !== typeParameters
                || node.parameters !== parameters
                || node.type !== type
                || node.equalsGreaterThanToken !== equalsGreaterThanToken
                || node.body !== body
                ? updateBaseFunctionLikeDeclaration(createArrowFunction(modifiers, typeParameters, parameters, type, equalsGreaterThanToken, body), node)
                : node;
        }
        function createDeleteExpression(expression) {
            var node = createBaseExpression(215);
            node.expression = parenthesizerRules().parenthesizeOperandOfPrefixUnary(expression);
            node.transformFlags |= propagateChildFlags(node.expression);
            return node;
        }
        function updateDeleteExpression(node, expression) {
            return node.expression !== expression
                ? update(createDeleteExpression(expression), node)
                : node;
        }
        function createTypeOfExpression(expression) {
            var node = createBaseExpression(216);
            node.expression = parenthesizerRules().parenthesizeOperandOfPrefixUnary(expression);
            node.transformFlags |= propagateChildFlags(node.expression);
            return node;
        }
        function updateTypeOfExpression(node, expression) {
            return node.expression !== expression
                ? update(createTypeOfExpression(expression), node)
                : node;
        }
        function createVoidExpression(expression) {
            var node = createBaseExpression(217);
            node.expression = parenthesizerRules().parenthesizeOperandOfPrefixUnary(expression);
            node.transformFlags |= propagateChildFlags(node.expression);
            return node;
        }
        function updateVoidExpression(node, expression) {
            return node.expression !== expression
                ? update(createVoidExpression(expression), node)
                : node;
        }
        function createAwaitExpression(expression) {
            var node = createBaseExpression(218);
            node.expression = parenthesizerRules().parenthesizeOperandOfPrefixUnary(expression);
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    256 |
                    128 |
                    1048576;
            return node;
        }
        function updateAwaitExpression(node, expression) {
            return node.expression !== expression
                ? update(createAwaitExpression(expression), node)
                : node;
        }
        function createPrefixUnaryExpression(operator, operand) {
            var node = createBaseExpression(219);
            node.operator = operator;
            node.operand = parenthesizerRules().parenthesizeOperandOfPrefixUnary(operand);
            node.transformFlags |= propagateChildFlags(node.operand);
            if ((operator === 45 || operator === 46) &&
                ts.isIdentifier(node.operand) &&
                !ts.isGeneratedIdentifier(node.operand) &&
                !ts.isLocalName(node.operand)) {
                node.transformFlags |= 67108864;
            }
            return node;
        }
        function updatePrefixUnaryExpression(node, operand) {
            return node.operand !== operand
                ? update(createPrefixUnaryExpression(node.operator, operand), node)
                : node;
        }
        function createPostfixUnaryExpression(operand, operator) {
            var node = createBaseExpression(220);
            node.operator = operator;
            node.operand = parenthesizerRules().parenthesizeOperandOfPostfixUnary(operand);
            node.transformFlags |= propagateChildFlags(node.operand);
            if (ts.isIdentifier(node.operand) &&
                !ts.isGeneratedIdentifier(node.operand) &&
                !ts.isLocalName(node.operand)) {
                node.transformFlags |= 67108864;
            }
            return node;
        }
        function updatePostfixUnaryExpression(node, operand) {
            return node.operand !== operand
                ? update(createPostfixUnaryExpression(operand, node.operator), node)
                : node;
        }
        function createBinaryExpression(left, operator, right) {
            var node = createBaseExpression(221);
            var operatorToken = asToken(operator);
            var operatorKind = operatorToken.kind;
            node.left = parenthesizerRules().parenthesizeLeftSideOfBinary(operatorKind, left);
            node.operatorToken = operatorToken;
            node.right = parenthesizerRules().parenthesizeRightSideOfBinary(operatorKind, node.left, right);
            node.transformFlags |=
                propagateChildFlags(node.left) |
                    propagateChildFlags(node.operatorToken) |
                    propagateChildFlags(node.right);
            if (operatorKind === 60) {
                node.transformFlags |= 32;
            }
            else if (operatorKind === 63) {
                if (ts.isObjectLiteralExpression(node.left)) {
                    node.transformFlags |=
                        1024 |
                            128 |
                            4096 |
                            propagateAssignmentPatternFlags(node.left);
                }
                else if (ts.isArrayLiteralExpression(node.left)) {
                    node.transformFlags |=
                        1024 |
                            4096 |
                            propagateAssignmentPatternFlags(node.left);
                }
            }
            else if (operatorKind === 42 || operatorKind === 67) {
                node.transformFlags |= 512;
            }
            else if (ts.isLogicalOrCoalescingAssignmentOperator(operatorKind)) {
                node.transformFlags |= 16;
            }
            return node;
        }
        function propagateAssignmentPatternFlags(node) {
            if (node.transformFlags & 32768)
                return 32768;
            if (node.transformFlags & 128) {
                for (var _i = 0, _a = ts.getElementsOfBindingOrAssignmentPattern(node); _i < _a.length; _i++) {
                    var element = _a[_i];
                    var target = ts.getTargetOfBindingOrAssignmentElement(element);
                    if (target && ts.isAssignmentPattern(target)) {
                        if (target.transformFlags & 32768) {
                            return 32768;
                        }
                        if (target.transformFlags & 128) {
                            var flags_1 = propagateAssignmentPatternFlags(target);
                            if (flags_1)
                                return flags_1;
                        }
                    }
                }
            }
            return 0;
        }
        function updateBinaryExpression(node, left, operator, right) {
            return node.left !== left
                || node.operatorToken !== operator
                || node.right !== right
                ? update(createBinaryExpression(left, operator, right), node)
                : node;
        }
        function createConditionalExpression(condition, questionToken, whenTrue, colonToken, whenFalse) {
            var node = createBaseExpression(222);
            node.condition = parenthesizerRules().parenthesizeConditionOfConditionalExpression(condition);
            node.questionToken = questionToken !== null && questionToken !== void 0 ? questionToken : createToken(57);
            node.whenTrue = parenthesizerRules().parenthesizeBranchOfConditionalExpression(whenTrue);
            node.colonToken = colonToken !== null && colonToken !== void 0 ? colonToken : createToken(58);
            node.whenFalse = parenthesizerRules().parenthesizeBranchOfConditionalExpression(whenFalse);
            node.transformFlags |=
                propagateChildFlags(node.condition) |
                    propagateChildFlags(node.questionToken) |
                    propagateChildFlags(node.whenTrue) |
                    propagateChildFlags(node.colonToken) |
                    propagateChildFlags(node.whenFalse);
            return node;
        }
        function updateConditionalExpression(node, condition, questionToken, whenTrue, colonToken, whenFalse) {
            return node.condition !== condition
                || node.questionToken !== questionToken
                || node.whenTrue !== whenTrue
                || node.colonToken !== colonToken
                || node.whenFalse !== whenFalse
                ? update(createConditionalExpression(condition, questionToken, whenTrue, colonToken, whenFalse), node)
                : node;
        }
        function createTemplateExpression(head, templateSpans) {
            var node = createBaseExpression(223);
            node.head = head;
            node.templateSpans = createNodeArray(templateSpans);
            node.transformFlags |=
                propagateChildFlags(node.head) |
                    propagateChildrenFlags(node.templateSpans) |
                    1024;
            return node;
        }
        function updateTemplateExpression(node, head, templateSpans) {
            return node.head !== head
                || node.templateSpans !== templateSpans
                ? update(createTemplateExpression(head, templateSpans), node)
                : node;
        }
        function createTemplateLiteralLikeNodeChecked(kind, text, rawText, templateFlags) {
            if (templateFlags === void 0) { templateFlags = 0; }
            ts.Debug.assert(!(templateFlags & ~2048), "Unsupported template flags.");
            var cooked = undefined;
            if (rawText !== undefined && rawText !== text) {
                cooked = getCookedText(kind, rawText);
                if (typeof cooked === "object") {
                    return ts.Debug.fail("Invalid raw text");
                }
            }
            if (text === undefined) {
                if (cooked === undefined) {
                    return ts.Debug.fail("Arguments 'text' and 'rawText' may not both be undefined.");
                }
                text = cooked;
            }
            else if (cooked !== undefined) {
                ts.Debug.assert(text === cooked, "Expected argument 'text' to be the normalized (i.e. 'cooked') version of argument 'rawText'.");
            }
            return createTemplateLiteralLikeNode(kind, text, rawText, templateFlags);
        }
        function createTemplateLiteralLikeNode(kind, text, rawText, templateFlags) {
            var node = createBaseToken(kind);
            node.text = text;
            node.rawText = rawText;
            node.templateFlags = templateFlags & 2048;
            node.transformFlags |= 1024;
            if (node.templateFlags) {
                node.transformFlags |= 128;
            }
            return node;
        }
        function createTemplateHead(text, rawText, templateFlags) {
            return createTemplateLiteralLikeNodeChecked(15, text, rawText, templateFlags);
        }
        function createTemplateMiddle(text, rawText, templateFlags) {
            return createTemplateLiteralLikeNodeChecked(16, text, rawText, templateFlags);
        }
        function createTemplateTail(text, rawText, templateFlags) {
            return createTemplateLiteralLikeNodeChecked(17, text, rawText, templateFlags);
        }
        function createNoSubstitutionTemplateLiteral(text, rawText, templateFlags) {
            return createTemplateLiteralLikeNodeChecked(14, text, rawText, templateFlags);
        }
        function createYieldExpression(asteriskToken, expression) {
            ts.Debug.assert(!asteriskToken || !!expression, "A `YieldExpression` with an asteriskToken must have an expression.");
            var node = createBaseExpression(224);
            node.expression = expression && parenthesizerRules().parenthesizeExpressionForDisallowedComma(expression);
            node.asteriskToken = asteriskToken;
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    propagateChildFlags(node.asteriskToken) |
                    1024 |
                    128 |
                    524288;
            return node;
        }
        function updateYieldExpression(node, asteriskToken, expression) {
            return node.expression !== expression
                || node.asteriskToken !== asteriskToken
                ? update(createYieldExpression(asteriskToken, expression), node)
                : node;
        }
        function createSpreadElement(expression) {
            var node = createBaseExpression(225);
            node.expression = parenthesizerRules().parenthesizeExpressionForDisallowedComma(expression);
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    1024 |
                    16384;
            return node;
        }
        function updateSpreadElement(node, expression) {
            return node.expression !== expression
                ? update(createSpreadElement(expression), node)
                : node;
        }
        function createClassExpression(decorators, modifiers, name, typeParameters, heritageClauses, members) {
            var node = createBaseClassLikeDeclaration(226, decorators, modifiers, name, typeParameters, heritageClauses, members);
            node.transformFlags |= 1024;
            return node;
        }
        function updateClassExpression(node, decorators, modifiers, name, typeParameters, heritageClauses, members) {
            return node.decorators !== decorators
                || node.modifiers !== modifiers
                || node.name !== name
                || node.typeParameters !== typeParameters
                || node.heritageClauses !== heritageClauses
                || node.members !== members
                ? update(createClassExpression(decorators, modifiers, name, typeParameters, heritageClauses, members), node)
                : node;
        }
        function createOmittedExpression() {
            return createBaseExpression(227);
        }
        function createExpressionWithTypeArguments(expression, typeArguments) {
            var node = createBaseNode(228);
            node.expression = parenthesizerRules().parenthesizeLeftSideOfAccess(expression);
            node.typeArguments = typeArguments && parenthesizerRules().parenthesizeTypeArguments(typeArguments);
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    propagateChildrenFlags(node.typeArguments) |
                    1024;
            return node;
        }
        function updateExpressionWithTypeArguments(node, expression, typeArguments) {
            return node.expression !== expression
                || node.typeArguments !== typeArguments
                ? update(createExpressionWithTypeArguments(expression, typeArguments), node)
                : node;
        }
        function createAsExpression(expression, type) {
            var node = createBaseExpression(229);
            node.expression = expression;
            node.type = type;
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    propagateChildFlags(node.type) |
                    1;
            return node;
        }
        function updateAsExpression(node, expression, type) {
            return node.expression !== expression
                || node.type !== type
                ? update(createAsExpression(expression, type), node)
                : node;
        }
        function createNonNullExpression(expression) {
            var node = createBaseExpression(230);
            node.expression = parenthesizerRules().parenthesizeLeftSideOfAccess(expression);
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    1;
            return node;
        }
        function updateNonNullExpression(node, expression) {
            if (ts.isNonNullChain(node)) {
                return updateNonNullChain(node, expression);
            }
            return node.expression !== expression
                ? update(createNonNullExpression(expression), node)
                : node;
        }
        function createNonNullChain(expression) {
            var node = createBaseExpression(230);
            node.flags |= 32;
            node.expression = parenthesizerRules().parenthesizeLeftSideOfAccess(expression);
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    1;
            return node;
        }
        function updateNonNullChain(node, expression) {
            ts.Debug.assert(!!(node.flags & 32), "Cannot update a NonNullExpression using updateNonNullChain. Use updateNonNullExpression instead.");
            return node.expression !== expression
                ? update(createNonNullChain(expression), node)
                : node;
        }
        function createMetaProperty(keywordToken, name) {
            var node = createBaseExpression(231);
            node.keywordToken = keywordToken;
            node.name = name;
            node.transformFlags |= propagateChildFlags(node.name);
            switch (keywordToken) {
                case 103:
                    node.transformFlags |= 1024;
                    break;
                case 100:
                    node.transformFlags |= 4;
                    break;
                default:
                    return ts.Debug.assertNever(keywordToken);
            }
            return node;
        }
        function updateMetaProperty(node, name) {
            return node.name !== name
                ? update(createMetaProperty(node.keywordToken, name), node)
                : node;
        }
        function createTemplateSpan(expression, literal) {
            var node = createBaseNode(233);
            node.expression = expression;
            node.literal = literal;
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    propagateChildFlags(node.literal) |
                    1024;
            return node;
        }
        function updateTemplateSpan(node, expression, literal) {
            return node.expression !== expression
                || node.literal !== literal
                ? update(createTemplateSpan(expression, literal), node)
                : node;
        }
        function createSemicolonClassElement() {
            var node = createBaseNode(234);
            node.transformFlags |= 1024;
            return node;
        }
        function createBlock(statements, multiLine) {
            var node = createBaseNode(235);
            node.statements = createNodeArray(statements);
            node.multiLine = multiLine;
            node.transformFlags |= propagateChildrenFlags(node.statements);
            return node;
        }
        function updateBlock(node, statements) {
            return node.statements !== statements
                ? update(createBlock(statements, node.multiLine), node)
                : node;
        }
        function createVariableStatement(modifiers, declarationList) {
            var node = createBaseDeclaration(237, undefined, modifiers);
            node.declarationList = ts.isArray(declarationList) ? createVariableDeclarationList(declarationList) : declarationList;
            node.transformFlags |=
                propagateChildFlags(node.declarationList);
            if (ts.modifiersToFlags(node.modifiers) & 2) {
                node.transformFlags = 1;
            }
            return node;
        }
        function updateVariableStatement(node, modifiers, declarationList) {
            return node.modifiers !== modifiers
                || node.declarationList !== declarationList
                ? update(createVariableStatement(modifiers, declarationList), node)
                : node;
        }
        function createEmptyStatement() {
            return createBaseNode(236);
        }
        function createExpressionStatement(expression) {
            var node = createBaseNode(238);
            node.expression = parenthesizerRules().parenthesizeExpressionOfExpressionStatement(expression);
            node.transformFlags |= propagateChildFlags(node.expression);
            return node;
        }
        function updateExpressionStatement(node, expression) {
            return node.expression !== expression
                ? update(createExpressionStatement(expression), node)
                : node;
        }
        function createIfStatement(expression, thenStatement, elseStatement) {
            var node = createBaseNode(239);
            node.expression = expression;
            node.thenStatement = asEmbeddedStatement(thenStatement);
            node.elseStatement = asEmbeddedStatement(elseStatement);
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    propagateChildFlags(node.thenStatement) |
                    propagateChildFlags(node.elseStatement);
            return node;
        }
        function updateIfStatement(node, expression, thenStatement, elseStatement) {
            return node.expression !== expression
                || node.thenStatement !== thenStatement
                || node.elseStatement !== elseStatement
                ? update(createIfStatement(expression, thenStatement, elseStatement), node)
                : node;
        }
        function createDoStatement(statement, expression) {
            var node = createBaseNode(240);
            node.statement = asEmbeddedStatement(statement);
            node.expression = expression;
            node.transformFlags |=
                propagateChildFlags(node.statement) |
                    propagateChildFlags(node.expression);
            return node;
        }
        function updateDoStatement(node, statement, expression) {
            return node.statement !== statement
                || node.expression !== expression
                ? update(createDoStatement(statement, expression), node)
                : node;
        }
        function createWhileStatement(expression, statement) {
            var node = createBaseNode(241);
            node.expression = expression;
            node.statement = asEmbeddedStatement(statement);
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    propagateChildFlags(node.statement);
            return node;
        }
        function updateWhileStatement(node, expression, statement) {
            return node.expression !== expression
                || node.statement !== statement
                ? update(createWhileStatement(expression, statement), node)
                : node;
        }
        function createForStatement(initializer, condition, incrementor, statement) {
            var node = createBaseNode(242);
            node.initializer = initializer;
            node.condition = condition;
            node.incrementor = incrementor;
            node.statement = asEmbeddedStatement(statement);
            node.transformFlags |=
                propagateChildFlags(node.initializer) |
                    propagateChildFlags(node.condition) |
                    propagateChildFlags(node.incrementor) |
                    propagateChildFlags(node.statement);
            return node;
        }
        function updateForStatement(node, initializer, condition, incrementor, statement) {
            return node.initializer !== initializer
                || node.condition !== condition
                || node.incrementor !== incrementor
                || node.statement !== statement
                ? update(createForStatement(initializer, condition, incrementor, statement), node)
                : node;
        }
        function createForInStatement(initializer, expression, statement) {
            var node = createBaseNode(243);
            node.initializer = initializer;
            node.expression = expression;
            node.statement = asEmbeddedStatement(statement);
            node.transformFlags |=
                propagateChildFlags(node.initializer) |
                    propagateChildFlags(node.expression) |
                    propagateChildFlags(node.statement);
            return node;
        }
        function updateForInStatement(node, initializer, expression, statement) {
            return node.initializer !== initializer
                || node.expression !== expression
                || node.statement !== statement
                ? update(createForInStatement(initializer, expression, statement), node)
                : node;
        }
        function createForOfStatement(awaitModifier, initializer, expression, statement) {
            var node = createBaseNode(244);
            node.awaitModifier = awaitModifier;
            node.initializer = initializer;
            node.expression = parenthesizerRules().parenthesizeExpressionForDisallowedComma(expression);
            node.statement = asEmbeddedStatement(statement);
            node.transformFlags |=
                propagateChildFlags(node.awaitModifier) |
                    propagateChildFlags(node.initializer) |
                    propagateChildFlags(node.expression) |
                    propagateChildFlags(node.statement) |
                    1024;
            if (awaitModifier)
                node.transformFlags |= 128;
            return node;
        }
        function updateForOfStatement(node, awaitModifier, initializer, expression, statement) {
            return node.awaitModifier !== awaitModifier
                || node.initializer !== initializer
                || node.expression !== expression
                || node.statement !== statement
                ? update(createForOfStatement(awaitModifier, initializer, expression, statement), node)
                : node;
        }
        function createContinueStatement(label) {
            var node = createBaseNode(245);
            node.label = asName(label);
            node.transformFlags |=
                propagateChildFlags(node.label) |
                    2097152;
            return node;
        }
        function updateContinueStatement(node, label) {
            return node.label !== label
                ? update(createContinueStatement(label), node)
                : node;
        }
        function createBreakStatement(label) {
            var node = createBaseNode(246);
            node.label = asName(label);
            node.transformFlags |=
                propagateChildFlags(node.label) |
                    2097152;
            return node;
        }
        function updateBreakStatement(node, label) {
            return node.label !== label
                ? update(createBreakStatement(label), node)
                : node;
        }
        function createReturnStatement(expression) {
            var node = createBaseNode(247);
            node.expression = expression;
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    128 |
                    2097152;
            return node;
        }
        function updateReturnStatement(node, expression) {
            return node.expression !== expression
                ? update(createReturnStatement(expression), node)
                : node;
        }
        function createWithStatement(expression, statement) {
            var node = createBaseNode(248);
            node.expression = expression;
            node.statement = asEmbeddedStatement(statement);
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    propagateChildFlags(node.statement);
            return node;
        }
        function updateWithStatement(node, expression, statement) {
            return node.expression !== expression
                || node.statement !== statement
                ? update(createWithStatement(expression, statement), node)
                : node;
        }
        function createSwitchStatement(expression, caseBlock) {
            var node = createBaseNode(249);
            node.expression = parenthesizerRules().parenthesizeExpressionForDisallowedComma(expression);
            node.caseBlock = caseBlock;
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    propagateChildFlags(node.caseBlock);
            return node;
        }
        function updateSwitchStatement(node, expression, caseBlock) {
            return node.expression !== expression
                || node.caseBlock !== caseBlock
                ? update(createSwitchStatement(expression, caseBlock), node)
                : node;
        }
        function createLabeledStatement(label, statement) {
            var node = createBaseNode(250);
            node.label = asName(label);
            node.statement = asEmbeddedStatement(statement);
            node.transformFlags |=
                propagateChildFlags(node.label) |
                    propagateChildFlags(node.statement);
            return node;
        }
        function updateLabeledStatement(node, label, statement) {
            return node.label !== label
                || node.statement !== statement
                ? update(createLabeledStatement(label, statement), node)
                : node;
        }
        function createThrowStatement(expression) {
            var node = createBaseNode(251);
            node.expression = expression;
            node.transformFlags |= propagateChildFlags(node.expression);
            return node;
        }
        function updateThrowStatement(node, expression) {
            return node.expression !== expression
                ? update(createThrowStatement(expression), node)
                : node;
        }
        function createTryStatement(tryBlock, catchClause, finallyBlock) {
            var node = createBaseNode(252);
            node.tryBlock = tryBlock;
            node.catchClause = catchClause;
            node.finallyBlock = finallyBlock;
            node.transformFlags |=
                propagateChildFlags(node.tryBlock) |
                    propagateChildFlags(node.catchClause) |
                    propagateChildFlags(node.finallyBlock);
            return node;
        }
        function updateTryStatement(node, tryBlock, catchClause, finallyBlock) {
            return node.tryBlock !== tryBlock
                || node.catchClause !== catchClause
                || node.finallyBlock !== finallyBlock
                ? update(createTryStatement(tryBlock, catchClause, finallyBlock), node)
                : node;
        }
        function createDebuggerStatement() {
            return createBaseNode(253);
        }
        function createVariableDeclaration(name, exclamationToken, type, initializer) {
            var node = createBaseVariableLikeDeclaration(254, undefined, undefined, name, type, initializer && parenthesizerRules().parenthesizeExpressionForDisallowedComma(initializer));
            node.exclamationToken = exclamationToken;
            node.transformFlags |= propagateChildFlags(node.exclamationToken);
            if (exclamationToken) {
                node.transformFlags |= 1;
            }
            return node;
        }
        function updateVariableDeclaration(node, name, exclamationToken, type, initializer) {
            return node.name !== name
                || node.type !== type
                || node.exclamationToken !== exclamationToken
                || node.initializer !== initializer
                ? update(createVariableDeclaration(name, exclamationToken, type, initializer), node)
                : node;
        }
        function createVariableDeclarationList(declarations, flags) {
            if (flags === void 0) { flags = 0; }
            var node = createBaseNode(255);
            node.flags |= flags & 3;
            node.declarations = createNodeArray(declarations);
            node.transformFlags |=
                propagateChildrenFlags(node.declarations) |
                    2097152;
            if (flags & 3) {
                node.transformFlags |=
                    1024 |
                        131072;
            }
            return node;
        }
        function updateVariableDeclarationList(node, declarations) {
            return node.declarations !== declarations
                ? update(createVariableDeclarationList(declarations, node.flags), node)
                : node;
        }
        function createFunctionDeclaration(decorators, modifiers, asteriskToken, name, typeParameters, parameters, type, body) {
            var node = createBaseFunctionLikeDeclaration(256, decorators, modifiers, name, typeParameters, parameters, type, body);
            node.asteriskToken = asteriskToken;
            if (!node.body || ts.modifiersToFlags(node.modifiers) & 2) {
                node.transformFlags = 1;
            }
            else {
                node.transformFlags |=
                    propagateChildFlags(node.asteriskToken) |
                        2097152;
                if (ts.modifiersToFlags(node.modifiers) & 256) {
                    if (node.asteriskToken) {
                        node.transformFlags |= 128;
                    }
                    else {
                        node.transformFlags |= 256;
                    }
                }
                else if (node.asteriskToken) {
                    node.transformFlags |= 2048;
                }
            }
            return node;
        }
        function updateFunctionDeclaration(node, decorators, modifiers, asteriskToken, name, typeParameters, parameters, type, body) {
            return node.decorators !== decorators
                || node.modifiers !== modifiers
                || node.asteriskToken !== asteriskToken
                || node.name !== name
                || node.typeParameters !== typeParameters
                || node.parameters !== parameters
                || node.type !== type
                || node.body !== body
                ? updateBaseFunctionLikeDeclaration(createFunctionDeclaration(decorators, modifiers, asteriskToken, name, typeParameters, parameters, type, body), node)
                : node;
        }
        function createClassDeclaration(decorators, modifiers, name, typeParameters, heritageClauses, members) {
            var node = createBaseClassLikeDeclaration(257, decorators, modifiers, name, typeParameters, heritageClauses, members);
            if (ts.modifiersToFlags(node.modifiers) & 2) {
                node.transformFlags = 1;
            }
            else {
                node.transformFlags |= 1024;
                if (node.transformFlags & 4096) {
                    node.transformFlags |= 1;
                }
            }
            return node;
        }
        function updateClassDeclaration(node, decorators, modifiers, name, typeParameters, heritageClauses, members) {
            return node.decorators !== decorators
                || node.modifiers !== modifiers
                || node.name !== name
                || node.typeParameters !== typeParameters
                || node.heritageClauses !== heritageClauses
                || node.members !== members
                ? update(createClassDeclaration(decorators, modifiers, name, typeParameters, heritageClauses, members), node)
                : node;
        }
        function createInterfaceDeclaration(decorators, modifiers, name, typeParameters, heritageClauses, members) {
            var node = createBaseInterfaceOrClassLikeDeclaration(258, decorators, modifiers, name, typeParameters, heritageClauses);
            node.members = createNodeArray(members);
            node.transformFlags = 1;
            return node;
        }
        function updateInterfaceDeclaration(node, decorators, modifiers, name, typeParameters, heritageClauses, members) {
            return node.decorators !== decorators
                || node.modifiers !== modifiers
                || node.name !== name
                || node.typeParameters !== typeParameters
                || node.heritageClauses !== heritageClauses
                || node.members !== members
                ? update(createInterfaceDeclaration(decorators, modifiers, name, typeParameters, heritageClauses, members), node)
                : node;
        }
        function createTypeAliasDeclaration(decorators, modifiers, name, typeParameters, type) {
            var node = createBaseGenericNamedDeclaration(259, decorators, modifiers, name, typeParameters);
            node.type = type;
            node.transformFlags = 1;
            return node;
        }
        function updateTypeAliasDeclaration(node, decorators, modifiers, name, typeParameters, type) {
            return node.decorators !== decorators
                || node.modifiers !== modifiers
                || node.name !== name
                || node.typeParameters !== typeParameters
                || node.type !== type
                ? update(createTypeAliasDeclaration(decorators, modifiers, name, typeParameters, type), node)
                : node;
        }
        function createEnumDeclaration(decorators, modifiers, name, members) {
            var node = createBaseNamedDeclaration(260, decorators, modifiers, name);
            node.members = createNodeArray(members);
            node.transformFlags |=
                propagateChildrenFlags(node.members) |
                    1;
            node.transformFlags &= ~16777216;
            return node;
        }
        function updateEnumDeclaration(node, decorators, modifiers, name, members) {
            return node.decorators !== decorators
                || node.modifiers !== modifiers
                || node.name !== name
                || node.members !== members
                ? update(createEnumDeclaration(decorators, modifiers, name, members), node)
                : node;
        }
        function createModuleDeclaration(decorators, modifiers, name, body, flags) {
            if (flags === void 0) { flags = 0; }
            var node = createBaseDeclaration(261, decorators, modifiers);
            node.flags |= flags & (16 | 4 | 1024);
            node.name = name;
            node.body = body;
            if (ts.modifiersToFlags(node.modifiers) & 2) {
                node.transformFlags = 1;
            }
            else {
                node.transformFlags |=
                    propagateChildFlags(node.name) |
                        propagateChildFlags(node.body) |
                        1;
            }
            node.transformFlags &= ~16777216;
            return node;
        }
        function updateModuleDeclaration(node, decorators, modifiers, name, body) {
            return node.decorators !== decorators
                || node.modifiers !== modifiers
                || node.name !== name
                || node.body !== body
                ? update(createModuleDeclaration(decorators, modifiers, name, body, node.flags), node)
                : node;
        }
        function createModuleBlock(statements) {
            var node = createBaseNode(262);
            node.statements = createNodeArray(statements);
            node.transformFlags |= propagateChildrenFlags(node.statements);
            return node;
        }
        function updateModuleBlock(node, statements) {
            return node.statements !== statements
                ? update(createModuleBlock(statements), node)
                : node;
        }
        function createCaseBlock(clauses) {
            var node = createBaseNode(263);
            node.clauses = createNodeArray(clauses);
            node.transformFlags |= propagateChildrenFlags(node.clauses);
            return node;
        }
        function updateCaseBlock(node, clauses) {
            return node.clauses !== clauses
                ? update(createCaseBlock(clauses), node)
                : node;
        }
        function createNamespaceExportDeclaration(name) {
            var node = createBaseNamedDeclaration(264, undefined, undefined, name);
            node.transformFlags = 1;
            return node;
        }
        function updateNamespaceExportDeclaration(node, name) {
            return node.name !== name
                ? update(createNamespaceExportDeclaration(name), node)
                : node;
        }
        function createImportEqualsDeclaration(decorators, modifiers, isTypeOnly, name, moduleReference) {
            var node = createBaseNamedDeclaration(265, decorators, modifiers, name);
            node.isTypeOnly = isTypeOnly;
            node.moduleReference = moduleReference;
            node.transformFlags |= propagateChildFlags(node.moduleReference);
            if (!ts.isExternalModuleReference(node.moduleReference))
                node.transformFlags |= 1;
            node.transformFlags &= ~16777216;
            return node;
        }
        function updateImportEqualsDeclaration(node, decorators, modifiers, isTypeOnly, name, moduleReference) {
            return node.decorators !== decorators
                || node.modifiers !== modifiers
                || node.isTypeOnly !== isTypeOnly
                || node.name !== name
                || node.moduleReference !== moduleReference
                ? update(createImportEqualsDeclaration(decorators, modifiers, isTypeOnly, name, moduleReference), node)
                : node;
        }
        function createImportDeclaration(decorators, modifiers, importClause, moduleSpecifier, assertClause) {
            var node = createBaseDeclaration(266, decorators, modifiers);
            node.importClause = importClause;
            node.moduleSpecifier = moduleSpecifier;
            node.assertClause = assertClause;
            node.transformFlags |=
                propagateChildFlags(node.importClause) |
                    propagateChildFlags(node.moduleSpecifier);
            node.transformFlags &= ~16777216;
            return node;
        }
        function updateImportDeclaration(node, decorators, modifiers, importClause, moduleSpecifier, assertClause) {
            return node.decorators !== decorators
                || node.modifiers !== modifiers
                || node.importClause !== importClause
                || node.moduleSpecifier !== moduleSpecifier
                || node.assertClause !== assertClause
                ? update(createImportDeclaration(decorators, modifiers, importClause, moduleSpecifier, assertClause), node)
                : node;
        }
        function createImportClause(isTypeOnly, name, namedBindings) {
            var node = createBaseNode(267);
            node.isTypeOnly = isTypeOnly;
            node.name = name;
            node.namedBindings = namedBindings;
            node.transformFlags |=
                propagateChildFlags(node.name) |
                    propagateChildFlags(node.namedBindings);
            if (isTypeOnly) {
                node.transformFlags |= 1;
            }
            node.transformFlags &= ~16777216;
            return node;
        }
        function updateImportClause(node, isTypeOnly, name, namedBindings) {
            return node.isTypeOnly !== isTypeOnly
                || node.name !== name
                || node.namedBindings !== namedBindings
                ? update(createImportClause(isTypeOnly, name, namedBindings), node)
                : node;
        }
        function createAssertClause(elements, multiLine) {
            var node = createBaseNode(293);
            node.elements = createNodeArray(elements);
            node.multiLine = multiLine;
            node.transformFlags |= 4;
            return node;
        }
        function updateAssertClause(node, elements, multiLine) {
            return node.elements !== elements
                || node.multiLine !== multiLine
                ? update(createAssertClause(elements, multiLine), node)
                : node;
        }
        function createAssertEntry(name, value) {
            var node = createBaseNode(294);
            node.name = name;
            node.value = value;
            node.transformFlags |= 4;
            return node;
        }
        function updateAssertEntry(node, name, value) {
            return node.name !== name
                || node.value !== value
                ? update(createAssertEntry(name, value), node)
                : node;
        }
        function createImportTypeAssertionContainer(clause, multiLine) {
            var node = createBaseNode(295);
            node.assertClause = clause;
            node.multiLine = multiLine;
            return node;
        }
        function updateImportTypeAssertionContainer(node, clause, multiLine) {
            return node.assertClause !== clause
                || node.multiLine !== multiLine
                ? update(createImportTypeAssertionContainer(clause, multiLine), node)
                : node;
        }
        function createNamespaceImport(name) {
            var node = createBaseNode(268);
            node.name = name;
            node.transformFlags |= propagateChildFlags(node.name);
            node.transformFlags &= ~16777216;
            return node;
        }
        function updateNamespaceImport(node, name) {
            return node.name !== name
                ? update(createNamespaceImport(name), node)
                : node;
        }
        function createNamespaceExport(name) {
            var node = createBaseNode(274);
            node.name = name;
            node.transformFlags |=
                propagateChildFlags(node.name) |
                    4;
            node.transformFlags &= ~16777216;
            return node;
        }
        function updateNamespaceExport(node, name) {
            return node.name !== name
                ? update(createNamespaceExport(name), node)
                : node;
        }
        function createNamedImports(elements) {
            var node = createBaseNode(269);
            node.elements = createNodeArray(elements);
            node.transformFlags |= propagateChildrenFlags(node.elements);
            node.transformFlags &= ~16777216;
            return node;
        }
        function updateNamedImports(node, elements) {
            return node.elements !== elements
                ? update(createNamedImports(elements), node)
                : node;
        }
        function createImportSpecifier(isTypeOnly, propertyName, name) {
            var node = createBaseNode(270);
            node.isTypeOnly = isTypeOnly;
            node.propertyName = propertyName;
            node.name = name;
            node.transformFlags |=
                propagateChildFlags(node.propertyName) |
                    propagateChildFlags(node.name);
            node.transformFlags &= ~16777216;
            return node;
        }
        function updateImportSpecifier(node, isTypeOnly, propertyName, name) {
            return node.isTypeOnly !== isTypeOnly
                || node.propertyName !== propertyName
                || node.name !== name
                ? update(createImportSpecifier(isTypeOnly, propertyName, name), node)
                : node;
        }
        function createExportAssignment(decorators, modifiers, isExportEquals, expression) {
            var node = createBaseDeclaration(271, decorators, modifiers);
            node.isExportEquals = isExportEquals;
            node.expression = isExportEquals
                ? parenthesizerRules().parenthesizeRightSideOfBinary(63, undefined, expression)
                : parenthesizerRules().parenthesizeExpressionOfExportDefault(expression);
            node.transformFlags |= propagateChildFlags(node.expression);
            node.transformFlags &= ~16777216;
            return node;
        }
        function updateExportAssignment(node, decorators, modifiers, expression) {
            return node.decorators !== decorators
                || node.modifiers !== modifiers
                || node.expression !== expression
                ? update(createExportAssignment(decorators, modifiers, node.isExportEquals, expression), node)
                : node;
        }
        function createExportDeclaration(decorators, modifiers, isTypeOnly, exportClause, moduleSpecifier, assertClause) {
            var node = createBaseDeclaration(272, decorators, modifiers);
            node.isTypeOnly = isTypeOnly;
            node.exportClause = exportClause;
            node.moduleSpecifier = moduleSpecifier;
            node.assertClause = assertClause;
            node.transformFlags |=
                propagateChildFlags(node.exportClause) |
                    propagateChildFlags(node.moduleSpecifier);
            node.transformFlags &= ~16777216;
            return node;
        }
        function updateExportDeclaration(node, decorators, modifiers, isTypeOnly, exportClause, moduleSpecifier, assertClause) {
            return node.decorators !== decorators
                || node.modifiers !== modifiers
                || node.isTypeOnly !== isTypeOnly
                || node.exportClause !== exportClause
                || node.moduleSpecifier !== moduleSpecifier
                || node.assertClause !== assertClause
                ? update(createExportDeclaration(decorators, modifiers, isTypeOnly, exportClause, moduleSpecifier, assertClause), node)
                : node;
        }
        function createNamedExports(elements) {
            var node = createBaseNode(273);
            node.elements = createNodeArray(elements);
            node.transformFlags |= propagateChildrenFlags(node.elements);
            node.transformFlags &= ~16777216;
            return node;
        }
        function updateNamedExports(node, elements) {
            return node.elements !== elements
                ? update(createNamedExports(elements), node)
                : node;
        }
        function createExportSpecifier(isTypeOnly, propertyName, name) {
            var node = createBaseNode(275);
            node.isTypeOnly = isTypeOnly;
            node.propertyName = asName(propertyName);
            node.name = asName(name);
            node.transformFlags |=
                propagateChildFlags(node.propertyName) |
                    propagateChildFlags(node.name);
            node.transformFlags &= ~16777216;
            return node;
        }
        function updateExportSpecifier(node, isTypeOnly, propertyName, name) {
            return node.isTypeOnly !== isTypeOnly
                || node.propertyName !== propertyName
                || node.name !== name
                ? update(createExportSpecifier(isTypeOnly, propertyName, name), node)
                : node;
        }
        function createMissingDeclaration() {
            var node = createBaseDeclaration(276, undefined, undefined);
            return node;
        }
        function createExternalModuleReference(expression) {
            var node = createBaseNode(277);
            node.expression = expression;
            node.transformFlags |= propagateChildFlags(node.expression);
            node.transformFlags &= ~16777216;
            return node;
        }
        function updateExternalModuleReference(node, expression) {
            return node.expression !== expression
                ? update(createExternalModuleReference(expression), node)
                : node;
        }
        function createJSDocPrimaryTypeWorker(kind) {
            return createBaseNode(kind);
        }
        function createJSDocPrePostfixUnaryTypeWorker(kind, type, postfix) {
            if (postfix === void 0) { postfix = false; }
            var node = createJSDocUnaryTypeWorker(kind, postfix ? type && parenthesizerRules().parenthesizeNonArrayTypeOfPostfixType(type) : type);
            node.postfix = postfix;
            return node;
        }
        function createJSDocUnaryTypeWorker(kind, type) {
            var node = createBaseNode(kind);
            node.type = type;
            return node;
        }
        function updateJSDocPrePostfixUnaryTypeWorker(kind, node, type) {
            return node.type !== type
                ? update(createJSDocPrePostfixUnaryTypeWorker(kind, type, node.postfix), node)
                : node;
        }
        function updateJSDocUnaryTypeWorker(kind, node, type) {
            return node.type !== type
                ? update(createJSDocUnaryTypeWorker(kind, type), node)
                : node;
        }
        function createJSDocFunctionType(parameters, type) {
            var node = createBaseSignatureDeclaration(317, undefined, undefined, undefined, undefined, parameters, type);
            return node;
        }
        function updateJSDocFunctionType(node, parameters, type) {
            return node.parameters !== parameters
                || node.type !== type
                ? update(createJSDocFunctionType(parameters, type), node)
                : node;
        }
        function createJSDocTypeLiteral(propertyTags, isArrayType) {
            if (isArrayType === void 0) { isArrayType = false; }
            var node = createBaseNode(322);
            node.jsDocPropertyTags = asNodeArray(propertyTags);
            node.isArrayType = isArrayType;
            return node;
        }
        function updateJSDocTypeLiteral(node, propertyTags, isArrayType) {
            return node.jsDocPropertyTags !== propertyTags
                || node.isArrayType !== isArrayType
                ? update(createJSDocTypeLiteral(propertyTags, isArrayType), node)
                : node;
        }
        function createJSDocTypeExpression(type) {
            var node = createBaseNode(309);
            node.type = type;
            return node;
        }
        function updateJSDocTypeExpression(node, type) {
            return node.type !== type
                ? update(createJSDocTypeExpression(type), node)
                : node;
        }
        function createJSDocSignature(typeParameters, parameters, type) {
            var node = createBaseNode(323);
            node.typeParameters = asNodeArray(typeParameters);
            node.parameters = createNodeArray(parameters);
            node.type = type;
            return node;
        }
        function updateJSDocSignature(node, typeParameters, parameters, type) {
            return node.typeParameters !== typeParameters
                || node.parameters !== parameters
                || node.type !== type
                ? update(createJSDocSignature(typeParameters, parameters, type), node)
                : node;
        }
        function getDefaultTagName(node) {
            var defaultTagName = getDefaultTagNameForKind(node.kind);
            return node.tagName.escapedText === ts.escapeLeadingUnderscores(defaultTagName)
                ? node.tagName
                : createIdentifier(defaultTagName);
        }
        function createBaseJSDocTag(kind, tagName, comment) {
            var node = createBaseNode(kind);
            node.tagName = tagName;
            node.comment = comment;
            return node;
        }
        function createJSDocTemplateTag(tagName, constraint, typeParameters, comment) {
            var node = createBaseJSDocTag(344, tagName !== null && tagName !== void 0 ? tagName : createIdentifier("template"), comment);
            node.constraint = constraint;
            node.typeParameters = createNodeArray(typeParameters);
            return node;
        }
        function updateJSDocTemplateTag(node, tagName, constraint, typeParameters, comment) {
            if (tagName === void 0) { tagName = getDefaultTagName(node); }
            return node.tagName !== tagName
                || node.constraint !== constraint
                || node.typeParameters !== typeParameters
                || node.comment !== comment
                ? update(createJSDocTemplateTag(tagName, constraint, typeParameters, comment), node)
                : node;
        }
        function createJSDocTypedefTag(tagName, typeExpression, fullName, comment) {
            var node = createBaseJSDocTag(345, tagName !== null && tagName !== void 0 ? tagName : createIdentifier("typedef"), comment);
            node.typeExpression = typeExpression;
            node.fullName = fullName;
            node.name = ts.getJSDocTypeAliasName(fullName);
            return node;
        }
        function updateJSDocTypedefTag(node, tagName, typeExpression, fullName, comment) {
            if (tagName === void 0) { tagName = getDefaultTagName(node); }
            return node.tagName !== tagName
                || node.typeExpression !== typeExpression
                || node.fullName !== fullName
                || node.comment !== comment
                ? update(createJSDocTypedefTag(tagName, typeExpression, fullName, comment), node)
                : node;
        }
        function createJSDocParameterTag(tagName, name, isBracketed, typeExpression, isNameFirst, comment) {
            var node = createBaseJSDocTag(340, tagName !== null && tagName !== void 0 ? tagName : createIdentifier("param"), comment);
            node.typeExpression = typeExpression;
            node.name = name;
            node.isNameFirst = !!isNameFirst;
            node.isBracketed = isBracketed;
            return node;
        }
        function updateJSDocParameterTag(node, tagName, name, isBracketed, typeExpression, isNameFirst, comment) {
            if (tagName === void 0) { tagName = getDefaultTagName(node); }
            return node.tagName !== tagName
                || node.name !== name
                || node.isBracketed !== isBracketed
                || node.typeExpression !== typeExpression
                || node.isNameFirst !== isNameFirst
                || node.comment !== comment
                ? update(createJSDocParameterTag(tagName, name, isBracketed, typeExpression, isNameFirst, comment), node)
                : node;
        }
        function createJSDocPropertyTag(tagName, name, isBracketed, typeExpression, isNameFirst, comment) {
            var node = createBaseJSDocTag(347, tagName !== null && tagName !== void 0 ? tagName : createIdentifier("prop"), comment);
            node.typeExpression = typeExpression;
            node.name = name;
            node.isNameFirst = !!isNameFirst;
            node.isBracketed = isBracketed;
            return node;
        }
        function updateJSDocPropertyTag(node, tagName, name, isBracketed, typeExpression, isNameFirst, comment) {
            if (tagName === void 0) { tagName = getDefaultTagName(node); }
            return node.tagName !== tagName
                || node.name !== name
                || node.isBracketed !== isBracketed
                || node.typeExpression !== typeExpression
                || node.isNameFirst !== isNameFirst
                || node.comment !== comment
                ? update(createJSDocPropertyTag(tagName, name, isBracketed, typeExpression, isNameFirst, comment), node)
                : node;
        }
        function createJSDocCallbackTag(tagName, typeExpression, fullName, comment) {
            var node = createBaseJSDocTag(338, tagName !== null && tagName !== void 0 ? tagName : createIdentifier("callback"), comment);
            node.typeExpression = typeExpression;
            node.fullName = fullName;
            node.name = ts.getJSDocTypeAliasName(fullName);
            return node;
        }
        function updateJSDocCallbackTag(node, tagName, typeExpression, fullName, comment) {
            if (tagName === void 0) { tagName = getDefaultTagName(node); }
            return node.tagName !== tagName
                || node.typeExpression !== typeExpression
                || node.fullName !== fullName
                || node.comment !== comment
                ? update(createJSDocCallbackTag(tagName, typeExpression, fullName, comment), node)
                : node;
        }
        function createJSDocAugmentsTag(tagName, className, comment) {
            var node = createBaseJSDocTag(328, tagName !== null && tagName !== void 0 ? tagName : createIdentifier("augments"), comment);
            node.class = className;
            return node;
        }
        function updateJSDocAugmentsTag(node, tagName, className, comment) {
            if (tagName === void 0) { tagName = getDefaultTagName(node); }
            return node.tagName !== tagName
                || node.class !== className
                || node.comment !== comment
                ? update(createJSDocAugmentsTag(tagName, className, comment), node)
                : node;
        }
        function createJSDocImplementsTag(tagName, className, comment) {
            var node = createBaseJSDocTag(329, tagName !== null && tagName !== void 0 ? tagName : createIdentifier("implements"), comment);
            node.class = className;
            return node;
        }
        function createJSDocSeeTag(tagName, name, comment) {
            var node = createBaseJSDocTag(346, tagName !== null && tagName !== void 0 ? tagName : createIdentifier("see"), comment);
            node.name = name;
            return node;
        }
        function updateJSDocSeeTag(node, tagName, name, comment) {
            return node.tagName !== tagName
                || node.name !== name
                || node.comment !== comment
                ? update(createJSDocSeeTag(tagName, name, comment), node)
                : node;
        }
        function createJSDocNameReference(name) {
            var node = createBaseNode(310);
            node.name = name;
            return node;
        }
        function updateJSDocNameReference(node, name) {
            return node.name !== name
                ? update(createJSDocNameReference(name), node)
                : node;
        }
        function createJSDocMemberName(left, right) {
            var node = createBaseNode(311);
            node.left = left;
            node.right = right;
            node.transformFlags |=
                propagateChildFlags(node.left) |
                    propagateChildFlags(node.right);
            return node;
        }
        function updateJSDocMemberName(node, left, right) {
            return node.left !== left
                || node.right !== right
                ? update(createJSDocMemberName(left, right), node)
                : node;
        }
        function createJSDocLink(name, text) {
            var node = createBaseNode(324);
            node.name = name;
            node.text = text;
            return node;
        }
        function updateJSDocLink(node, name, text) {
            return node.name !== name
                ? update(createJSDocLink(name, text), node)
                : node;
        }
        function createJSDocLinkCode(name, text) {
            var node = createBaseNode(325);
            node.name = name;
            node.text = text;
            return node;
        }
        function updateJSDocLinkCode(node, name, text) {
            return node.name !== name
                ? update(createJSDocLinkCode(name, text), node)
                : node;
        }
        function createJSDocLinkPlain(name, text) {
            var node = createBaseNode(326);
            node.name = name;
            node.text = text;
            return node;
        }
        function updateJSDocLinkPlain(node, name, text) {
            return node.name !== name
                ? update(createJSDocLinkPlain(name, text), node)
                : node;
        }
        function updateJSDocImplementsTag(node, tagName, className, comment) {
            if (tagName === void 0) { tagName = getDefaultTagName(node); }
            return node.tagName !== tagName
                || node.class !== className
                || node.comment !== comment
                ? update(createJSDocImplementsTag(tagName, className, comment), node)
                : node;
        }
        function createJSDocSimpleTagWorker(kind, tagName, comment) {
            var node = createBaseJSDocTag(kind, tagName !== null && tagName !== void 0 ? tagName : createIdentifier(getDefaultTagNameForKind(kind)), comment);
            return node;
        }
        function updateJSDocSimpleTagWorker(kind, node, tagName, comment) {
            if (tagName === void 0) { tagName = getDefaultTagName(node); }
            return node.tagName !== tagName
                || node.comment !== comment
                ? update(createJSDocSimpleTagWorker(kind, tagName, comment), node) :
                node;
        }
        function createJSDocTypeLikeTagWorker(kind, tagName, typeExpression, comment) {
            var node = createBaseJSDocTag(kind, tagName !== null && tagName !== void 0 ? tagName : createIdentifier(getDefaultTagNameForKind(kind)), comment);
            node.typeExpression = typeExpression;
            return node;
        }
        function updateJSDocTypeLikeTagWorker(kind, node, tagName, typeExpression, comment) {
            if (tagName === void 0) { tagName = getDefaultTagName(node); }
            return node.tagName !== tagName
                || node.typeExpression !== typeExpression
                || node.comment !== comment
                ? update(createJSDocTypeLikeTagWorker(kind, tagName, typeExpression, comment), node)
                : node;
        }
        function createJSDocUnknownTag(tagName, comment) {
            var node = createBaseJSDocTag(327, tagName, comment);
            return node;
        }
        function updateJSDocUnknownTag(node, tagName, comment) {
            return node.tagName !== tagName
                || node.comment !== comment
                ? update(createJSDocUnknownTag(tagName, comment), node)
                : node;
        }
        function createJSDocText(text) {
            var node = createBaseNode(321);
            node.text = text;
            return node;
        }
        function updateJSDocText(node, text) {
            return node.text !== text
                ? update(createJSDocText(text), node)
                : node;
        }
        function createJSDocComment(comment, tags) {
            var node = createBaseNode(320);
            node.comment = comment;
            node.tags = asNodeArray(tags);
            return node;
        }
        function updateJSDocComment(node, comment, tags) {
            return node.comment !== comment
                || node.tags !== tags
                ? update(createJSDocComment(comment, tags), node)
                : node;
        }
        function createJsxElement(openingElement, children, closingElement) {
            var node = createBaseNode(278);
            node.openingElement = openingElement;
            node.children = createNodeArray(children);
            node.closingElement = closingElement;
            node.transformFlags |=
                propagateChildFlags(node.openingElement) |
                    propagateChildrenFlags(node.children) |
                    propagateChildFlags(node.closingElement) |
                    2;
            return node;
        }
        function updateJsxElement(node, openingElement, children, closingElement) {
            return node.openingElement !== openingElement
                || node.children !== children
                || node.closingElement !== closingElement
                ? update(createJsxElement(openingElement, children, closingElement), node)
                : node;
        }
        function createJsxSelfClosingElement(tagName, typeArguments, attributes) {
            var node = createBaseNode(279);
            node.tagName = tagName;
            node.typeArguments = asNodeArray(typeArguments);
            node.attributes = attributes;
            node.transformFlags |=
                propagateChildFlags(node.tagName) |
                    propagateChildrenFlags(node.typeArguments) |
                    propagateChildFlags(node.attributes) |
                    2;
            if (node.typeArguments) {
                node.transformFlags |= 1;
            }
            return node;
        }
        function updateJsxSelfClosingElement(node, tagName, typeArguments, attributes) {
            return node.tagName !== tagName
                || node.typeArguments !== typeArguments
                || node.attributes !== attributes
                ? update(createJsxSelfClosingElement(tagName, typeArguments, attributes), node)
                : node;
        }
        function createJsxOpeningElement(tagName, typeArguments, attributes) {
            var node = createBaseNode(280);
            node.tagName = tagName;
            node.typeArguments = asNodeArray(typeArguments);
            node.attributes = attributes;
            node.transformFlags |=
                propagateChildFlags(node.tagName) |
                    propagateChildrenFlags(node.typeArguments) |
                    propagateChildFlags(node.attributes) |
                    2;
            if (typeArguments) {
                node.transformFlags |= 1;
            }
            return node;
        }
        function updateJsxOpeningElement(node, tagName, typeArguments, attributes) {
            return node.tagName !== tagName
                || node.typeArguments !== typeArguments
                || node.attributes !== attributes
                ? update(createJsxOpeningElement(tagName, typeArguments, attributes), node)
                : node;
        }
        function createJsxClosingElement(tagName) {
            var node = createBaseNode(281);
            node.tagName = tagName;
            node.transformFlags |=
                propagateChildFlags(node.tagName) |
                    2;
            return node;
        }
        function updateJsxClosingElement(node, tagName) {
            return node.tagName !== tagName
                ? update(createJsxClosingElement(tagName), node)
                : node;
        }
        function createJsxFragment(openingFragment, children, closingFragment) {
            var node = createBaseNode(282);
            node.openingFragment = openingFragment;
            node.children = createNodeArray(children);
            node.closingFragment = closingFragment;
            node.transformFlags |=
                propagateChildFlags(node.openingFragment) |
                    propagateChildrenFlags(node.children) |
                    propagateChildFlags(node.closingFragment) |
                    2;
            return node;
        }
        function updateJsxFragment(node, openingFragment, children, closingFragment) {
            return node.openingFragment !== openingFragment
                || node.children !== children
                || node.closingFragment !== closingFragment
                ? update(createJsxFragment(openingFragment, children, closingFragment), node)
                : node;
        }
        function createJsxText(text, containsOnlyTriviaWhiteSpaces) {
            var node = createBaseNode(11);
            node.text = text;
            node.containsOnlyTriviaWhiteSpaces = !!containsOnlyTriviaWhiteSpaces;
            node.transformFlags |= 2;
            return node;
        }
        function updateJsxText(node, text, containsOnlyTriviaWhiteSpaces) {
            return node.text !== text
                || node.containsOnlyTriviaWhiteSpaces !== containsOnlyTriviaWhiteSpaces
                ? update(createJsxText(text, containsOnlyTriviaWhiteSpaces), node)
                : node;
        }
        function createJsxOpeningFragment() {
            var node = createBaseNode(283);
            node.transformFlags |= 2;
            return node;
        }
        function createJsxJsxClosingFragment() {
            var node = createBaseNode(284);
            node.transformFlags |= 2;
            return node;
        }
        function createJsxAttribute(name, initializer) {
            var node = createBaseNode(285);
            node.name = name;
            node.initializer = initializer;
            node.transformFlags |=
                propagateChildFlags(node.name) |
                    propagateChildFlags(node.initializer) |
                    2;
            return node;
        }
        function updateJsxAttribute(node, name, initializer) {
            return node.name !== name
                || node.initializer !== initializer
                ? update(createJsxAttribute(name, initializer), node)
                : node;
        }
        function createJsxAttributes(properties) {
            var node = createBaseNode(286);
            node.properties = createNodeArray(properties);
            node.transformFlags |=
                propagateChildrenFlags(node.properties) |
                    2;
            return node;
        }
        function updateJsxAttributes(node, properties) {
            return node.properties !== properties
                ? update(createJsxAttributes(properties), node)
                : node;
        }
        function createJsxSpreadAttribute(expression) {
            var node = createBaseNode(287);
            node.expression = expression;
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    2;
            return node;
        }
        function updateJsxSpreadAttribute(node, expression) {
            return node.expression !== expression
                ? update(createJsxSpreadAttribute(expression), node)
                : node;
        }
        function createJsxExpression(dotDotDotToken, expression) {
            var node = createBaseNode(288);
            node.dotDotDotToken = dotDotDotToken;
            node.expression = expression;
            node.transformFlags |=
                propagateChildFlags(node.dotDotDotToken) |
                    propagateChildFlags(node.expression) |
                    2;
            return node;
        }
        function updateJsxExpression(node, expression) {
            return node.expression !== expression
                ? update(createJsxExpression(node.dotDotDotToken, expression), node)
                : node;
        }
        function createCaseClause(expression, statements) {
            var node = createBaseNode(289);
            node.expression = parenthesizerRules().parenthesizeExpressionForDisallowedComma(expression);
            node.statements = createNodeArray(statements);
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    propagateChildrenFlags(node.statements);
            return node;
        }
        function updateCaseClause(node, expression, statements) {
            return node.expression !== expression
                || node.statements !== statements
                ? update(createCaseClause(expression, statements), node)
                : node;
        }
        function createDefaultClause(statements) {
            var node = createBaseNode(290);
            node.statements = createNodeArray(statements);
            node.transformFlags = propagateChildrenFlags(node.statements);
            return node;
        }
        function updateDefaultClause(node, statements) {
            return node.statements !== statements
                ? update(createDefaultClause(statements), node)
                : node;
        }
        function createHeritageClause(token, types) {
            var node = createBaseNode(291);
            node.token = token;
            node.types = createNodeArray(types);
            node.transformFlags |= propagateChildrenFlags(node.types);
            switch (token) {
                case 94:
                    node.transformFlags |= 1024;
                    break;
                case 117:
                    node.transformFlags |= 1;
                    break;
                default:
                    return ts.Debug.assertNever(token);
            }
            return node;
        }
        function updateHeritageClause(node, types) {
            return node.types !== types
                ? update(createHeritageClause(node.token, types), node)
                : node;
        }
        function createCatchClause(variableDeclaration, block) {
            var node = createBaseNode(292);
            if (typeof variableDeclaration === "string" || variableDeclaration && !ts.isVariableDeclaration(variableDeclaration)) {
                variableDeclaration = createVariableDeclaration(variableDeclaration, undefined, undefined, undefined);
            }
            node.variableDeclaration = variableDeclaration;
            node.block = block;
            node.transformFlags |=
                propagateChildFlags(node.variableDeclaration) |
                    propagateChildFlags(node.block);
            if (!variableDeclaration)
                node.transformFlags |= 64;
            return node;
        }
        function updateCatchClause(node, variableDeclaration, block) {
            return node.variableDeclaration !== variableDeclaration
                || node.block !== block
                ? update(createCatchClause(variableDeclaration, block), node)
                : node;
        }
        function createPropertyAssignment(name, initializer) {
            var node = createBaseNamedDeclaration(296, undefined, undefined, name);
            node.initializer = parenthesizerRules().parenthesizeExpressionForDisallowedComma(initializer);
            node.transformFlags |=
                propagateChildFlags(node.name) |
                    propagateChildFlags(node.initializer);
            return node;
        }
        function finishUpdatePropertyAssignment(updated, original) {
            if (original.decorators)
                updated.decorators = original.decorators;
            if (original.modifiers)
                updated.modifiers = original.modifiers;
            if (original.questionToken)
                updated.questionToken = original.questionToken;
            if (original.exclamationToken)
                updated.exclamationToken = original.exclamationToken;
            return update(updated, original);
        }
        function updatePropertyAssignment(node, name, initializer) {
            return node.name !== name
                || node.initializer !== initializer
                ? finishUpdatePropertyAssignment(createPropertyAssignment(name, initializer), node)
                : node;
        }
        function createShorthandPropertyAssignment(name, objectAssignmentInitializer) {
            var node = createBaseNamedDeclaration(297, undefined, undefined, name);
            node.objectAssignmentInitializer = objectAssignmentInitializer && parenthesizerRules().parenthesizeExpressionForDisallowedComma(objectAssignmentInitializer);
            node.transformFlags |=
                propagateChildFlags(node.objectAssignmentInitializer) |
                    1024;
            return node;
        }
        function finishUpdateShorthandPropertyAssignment(updated, original) {
            if (original.decorators)
                updated.decorators = original.decorators;
            if (original.modifiers)
                updated.modifiers = original.modifiers;
            if (original.equalsToken)
                updated.equalsToken = original.equalsToken;
            if (original.questionToken)
                updated.questionToken = original.questionToken;
            if (original.exclamationToken)
                updated.exclamationToken = original.exclamationToken;
            return update(updated, original);
        }
        function updateShorthandPropertyAssignment(node, name, objectAssignmentInitializer) {
            return node.name !== name
                || node.objectAssignmentInitializer !== objectAssignmentInitializer
                ? finishUpdateShorthandPropertyAssignment(createShorthandPropertyAssignment(name, objectAssignmentInitializer), node)
                : node;
        }
        function createSpreadAssignment(expression) {
            var node = createBaseNode(298);
            node.expression = parenthesizerRules().parenthesizeExpressionForDisallowedComma(expression);
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    128 |
                    32768;
            return node;
        }
        function updateSpreadAssignment(node, expression) {
            return node.expression !== expression
                ? update(createSpreadAssignment(expression), node)
                : node;
        }
        function createEnumMember(name, initializer) {
            var node = createBaseNode(299);
            node.name = asName(name);
            node.initializer = initializer && parenthesizerRules().parenthesizeExpressionForDisallowedComma(initializer);
            node.transformFlags |=
                propagateChildFlags(node.name) |
                    propagateChildFlags(node.initializer) |
                    1;
            return node;
        }
        function updateEnumMember(node, name, initializer) {
            return node.name !== name
                || node.initializer !== initializer
                ? update(createEnumMember(name, initializer), node)
                : node;
        }
        function createSourceFile(statements, endOfFileToken, flags) {
            var node = baseFactory.createBaseSourceFileNode(305);
            node.statements = createNodeArray(statements);
            node.endOfFileToken = endOfFileToken;
            node.flags |= flags;
            node.fileName = "";
            node.text = "";
            node.languageVersion = 0;
            node.languageVariant = 0;
            node.scriptKind = 0;
            node.isDeclarationFile = false;
            node.hasNoDefaultLib = false;
            node.transformFlags |=
                propagateChildrenFlags(node.statements) |
                    propagateChildFlags(node.endOfFileToken);
            return node;
        }
        function cloneSourceFileWithChanges(source, statements, isDeclarationFile, referencedFiles, typeReferences, hasNoDefaultLib, libReferences) {
            var node = (source.redirectInfo ? Object.create(source.redirectInfo.redirectTarget) : baseFactory.createBaseSourceFileNode(305));
            for (var p in source) {
                if (p === "emitNode" || ts.hasProperty(node, p) || !ts.hasProperty(source, p))
                    continue;
                node[p] = source[p];
            }
            node.flags |= source.flags;
            node.statements = createNodeArray(statements);
            node.endOfFileToken = source.endOfFileToken;
            node.isDeclarationFile = isDeclarationFile;
            node.referencedFiles = referencedFiles;
            node.typeReferenceDirectives = typeReferences;
            node.hasNoDefaultLib = hasNoDefaultLib;
            node.libReferenceDirectives = libReferences;
            node.transformFlags =
                propagateChildrenFlags(node.statements) |
                    propagateChildFlags(node.endOfFileToken);
            node.impliedNodeFormat = source.impliedNodeFormat;
            return node;
        }
        function updateSourceFile(node, statements, isDeclarationFile, referencedFiles, typeReferenceDirectives, hasNoDefaultLib, libReferenceDirectives) {
            if (isDeclarationFile === void 0) { isDeclarationFile = node.isDeclarationFile; }
            if (referencedFiles === void 0) { referencedFiles = node.referencedFiles; }
            if (typeReferenceDirectives === void 0) { typeReferenceDirectives = node.typeReferenceDirectives; }
            if (hasNoDefaultLib === void 0) { hasNoDefaultLib = node.hasNoDefaultLib; }
            if (libReferenceDirectives === void 0) { libReferenceDirectives = node.libReferenceDirectives; }
            return node.statements !== statements
                || node.isDeclarationFile !== isDeclarationFile
                || node.referencedFiles !== referencedFiles
                || node.typeReferenceDirectives !== typeReferenceDirectives
                || node.hasNoDefaultLib !== hasNoDefaultLib
                || node.libReferenceDirectives !== libReferenceDirectives
                ? update(cloneSourceFileWithChanges(node, statements, isDeclarationFile, referencedFiles, typeReferenceDirectives, hasNoDefaultLib, libReferenceDirectives), node)
                : node;
        }
        function createBundle(sourceFiles, prepends) {
            if (prepends === void 0) { prepends = ts.emptyArray; }
            var node = createBaseNode(306);
            node.prepends = prepends;
            node.sourceFiles = sourceFiles;
            return node;
        }
        function updateBundle(node, sourceFiles, prepends) {
            if (prepends === void 0) { prepends = ts.emptyArray; }
            return node.sourceFiles !== sourceFiles
                || node.prepends !== prepends
                ? update(createBundle(sourceFiles, prepends), node)
                : node;
        }
        function createUnparsedSource(prologues, syntheticReferences, texts) {
            var node = createBaseNode(307);
            node.prologues = prologues;
            node.syntheticReferences = syntheticReferences;
            node.texts = texts;
            node.fileName = "";
            node.text = "";
            node.referencedFiles = ts.emptyArray;
            node.libReferenceDirectives = ts.emptyArray;
            node.getLineAndCharacterOfPosition = function (pos) { return ts.getLineAndCharacterOfPosition(node, pos); };
            return node;
        }
        function createBaseUnparsedNode(kind, data) {
            var node = createBaseNode(kind);
            node.data = data;
            return node;
        }
        function createUnparsedPrologue(data) {
            return createBaseUnparsedNode(300, data);
        }
        function createUnparsedPrepend(data, texts) {
            var node = createBaseUnparsedNode(301, data);
            node.texts = texts;
            return node;
        }
        function createUnparsedTextLike(data, internal) {
            return createBaseUnparsedNode(internal ? 303 : 302, data);
        }
        function createUnparsedSyntheticReference(section) {
            var node = createBaseNode(304);
            node.data = section.data;
            node.section = section;
            return node;
        }
        function createInputFiles() {
            var node = createBaseNode(308);
            node.javascriptText = "";
            node.declarationText = "";
            return node;
        }
        function createSyntheticExpression(type, isSpread, tupleNameSource) {
            if (isSpread === void 0) { isSpread = false; }
            var node = createBaseNode(232);
            node.type = type;
            node.isSpread = isSpread;
            node.tupleNameSource = tupleNameSource;
            return node;
        }
        function createSyntaxList(children) {
            var node = createBaseNode(348);
            node._children = children;
            return node;
        }
        function createNotEmittedStatement(original) {
            var node = createBaseNode(349);
            node.original = original;
            ts.setTextRange(node, original);
            return node;
        }
        function createPartiallyEmittedExpression(expression, original) {
            var node = createBaseNode(350);
            node.expression = expression;
            node.original = original;
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    1;
            ts.setTextRange(node, original);
            return node;
        }
        function updatePartiallyEmittedExpression(node, expression) {
            return node.expression !== expression
                ? update(createPartiallyEmittedExpression(expression, node.original), node)
                : node;
        }
        function flattenCommaElements(node) {
            if (ts.nodeIsSynthesized(node) && !ts.isParseTreeNode(node) && !node.original && !node.emitNode && !node.id) {
                if (ts.isCommaListExpression(node)) {
                    return node.elements;
                }
                if (ts.isBinaryExpression(node) && ts.isCommaToken(node.operatorToken)) {
                    return [node.left, node.right];
                }
            }
            return node;
        }
        function createCommaListExpression(elements) {
            var node = createBaseNode(351);
            node.elements = createNodeArray(ts.sameFlatMap(elements, flattenCommaElements));
            node.transformFlags |= propagateChildrenFlags(node.elements);
            return node;
        }
        function updateCommaListExpression(node, elements) {
            return node.elements !== elements
                ? update(createCommaListExpression(elements), node)
                : node;
        }
        function createEndOfDeclarationMarker(original) {
            var node = createBaseNode(353);
            node.emitNode = {};
            node.original = original;
            return node;
        }
        function createMergeDeclarationMarker(original) {
            var node = createBaseNode(352);
            node.emitNode = {};
            node.original = original;
            return node;
        }
        function createSyntheticReferenceExpression(expression, thisArg) {
            var node = createBaseNode(354);
            node.expression = expression;
            node.thisArg = thisArg;
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    propagateChildFlags(node.thisArg);
            return node;
        }
        function updateSyntheticReferenceExpression(node, expression, thisArg) {
            return node.expression !== expression
                || node.thisArg !== thisArg
                ? update(createSyntheticReferenceExpression(expression, thisArg), node)
                : node;
        }
        function cloneNode(node) {
            if (node === undefined) {
                return node;
            }
            var clone = ts.isSourceFile(node) ? baseFactory.createBaseSourceFileNode(305) :
                ts.isIdentifier(node) ? baseFactory.createBaseIdentifierNode(79) :
                    ts.isPrivateIdentifier(node) ? baseFactory.createBasePrivateIdentifierNode(80) :
                        !ts.isNodeKind(node.kind) ? baseFactory.createBaseTokenNode(node.kind) :
                            baseFactory.createBaseNode(node.kind);
            clone.flags |= (node.flags & ~8);
            clone.transformFlags = node.transformFlags;
            setOriginalNode(clone, node);
            for (var key in node) {
                if (clone.hasOwnProperty(key) || !node.hasOwnProperty(key)) {
                    continue;
                }
                clone[key] = node[key];
            }
            return clone;
        }
        function createImmediatelyInvokedFunctionExpression(statements, param, paramValue) {
            return createCallExpression(createFunctionExpression(undefined, undefined, undefined, undefined, param ? [param] : [], undefined, createBlock(statements, true)), undefined, paramValue ? [paramValue] : []);
        }
        function createImmediatelyInvokedArrowFunction(statements, param, paramValue) {
            return createCallExpression(createArrowFunction(undefined, undefined, param ? [param] : [], undefined, undefined, createBlock(statements, true)), undefined, paramValue ? [paramValue] : []);
        }
        function createVoidZero() {
            return createVoidExpression(createNumericLiteral("0"));
        }
        function createExportDefault(expression) {
            return createExportAssignment(undefined, undefined, false, expression);
        }
        function createExternalModuleExport(exportName) {
            return createExportDeclaration(undefined, undefined, false, createNamedExports([
                createExportSpecifier(false, undefined, exportName)
            ]));
        }
        function createTypeCheck(value, tag) {
            return tag === "undefined"
                ? factory.createStrictEquality(value, createVoidZero())
                : factory.createStrictEquality(createTypeOfExpression(value), createStringLiteral(tag));
        }
        function createMethodCall(object, methodName, argumentsList) {
            if (ts.isCallChain(object)) {
                return createCallChain(createPropertyAccessChain(object, undefined, methodName), undefined, undefined, argumentsList);
            }
            return createCallExpression(createPropertyAccessExpression(object, methodName), undefined, argumentsList);
        }
        function createFunctionBindCall(target, thisArg, argumentsList) {
            return createMethodCall(target, "bind", __spreadArray([thisArg], argumentsList, true));
        }
        function createFunctionCallCall(target, thisArg, argumentsList) {
            return createMethodCall(target, "call", __spreadArray([thisArg], argumentsList, true));
        }
        function createFunctionApplyCall(target, thisArg, argumentsExpression) {
            return createMethodCall(target, "apply", [thisArg, argumentsExpression]);
        }
        function createGlobalMethodCall(globalObjectName, methodName, argumentsList) {
            return createMethodCall(createIdentifier(globalObjectName), methodName, argumentsList);
        }
        function createArraySliceCall(array, start) {
            return createMethodCall(array, "slice", start === undefined ? [] : [asExpression(start)]);
        }
        function createArrayConcatCall(array, argumentsList) {
            return createMethodCall(array, "concat", argumentsList);
        }
        function createObjectDefinePropertyCall(target, propertyName, attributes) {
            return createGlobalMethodCall("Object", "defineProperty", [target, asExpression(propertyName), attributes]);
        }
        function createReflectGetCall(target, propertyKey, receiver) {
            return createGlobalMethodCall("Reflect", "get", receiver ? [target, propertyKey, receiver] : [target, propertyKey]);
        }
        function createReflectSetCall(target, propertyKey, value, receiver) {
            return createGlobalMethodCall("Reflect", "set", receiver ? [target, propertyKey, value, receiver] : [target, propertyKey, value]);
        }
        function tryAddPropertyAssignment(properties, propertyName, expression) {
            if (expression) {
                properties.push(createPropertyAssignment(propertyName, expression));
                return true;
            }
            return false;
        }
        function createPropertyDescriptor(attributes, singleLine) {
            var properties = [];
            tryAddPropertyAssignment(properties, "enumerable", asExpression(attributes.enumerable));
            tryAddPropertyAssignment(properties, "configurable", asExpression(attributes.configurable));
            var isData = tryAddPropertyAssignment(properties, "writable", asExpression(attributes.writable));
            isData = tryAddPropertyAssignment(properties, "value", attributes.value) || isData;
            var isAccessor = tryAddPropertyAssignment(properties, "get", attributes.get);
            isAccessor = tryAddPropertyAssignment(properties, "set", attributes.set) || isAccessor;
            ts.Debug.assert(!(isData && isAccessor), "A PropertyDescriptor may not be both an accessor descriptor and a data descriptor.");
            return createObjectLiteralExpression(properties, !singleLine);
        }
        function updateOuterExpression(outerExpression, expression) {
            switch (outerExpression.kind) {
                case 212: return updateParenthesizedExpression(outerExpression, expression);
                case 211: return updateTypeAssertion(outerExpression, outerExpression.type, expression);
                case 229: return updateAsExpression(outerExpression, expression, outerExpression.type);
                case 230: return updateNonNullExpression(outerExpression, expression);
                case 350: return updatePartiallyEmittedExpression(outerExpression, expression);
            }
        }
        function isIgnorableParen(node) {
            return ts.isParenthesizedExpression(node)
                && ts.nodeIsSynthesized(node)
                && ts.nodeIsSynthesized(ts.getSourceMapRange(node))
                && ts.nodeIsSynthesized(ts.getCommentRange(node))
                && !ts.some(ts.getSyntheticLeadingComments(node))
                && !ts.some(ts.getSyntheticTrailingComments(node));
        }
        function restoreOuterExpressions(outerExpression, innerExpression, kinds) {
            if (kinds === void 0) { kinds = 15; }
            if (outerExpression && ts.isOuterExpression(outerExpression, kinds) && !isIgnorableParen(outerExpression)) {
                return updateOuterExpression(outerExpression, restoreOuterExpressions(outerExpression.expression, innerExpression));
            }
            return innerExpression;
        }
        function restoreEnclosingLabel(node, outermostLabeledStatement, afterRestoreLabelCallback) {
            if (!outermostLabeledStatement) {
                return node;
            }
            var updated = updateLabeledStatement(outermostLabeledStatement, outermostLabeledStatement.label, ts.isLabeledStatement(outermostLabeledStatement.statement)
                ? restoreEnclosingLabel(node, outermostLabeledStatement.statement)
                : node);
            if (afterRestoreLabelCallback) {
                afterRestoreLabelCallback(outermostLabeledStatement);
            }
            return updated;
        }
        function shouldBeCapturedInTempVariable(node, cacheIdentifiers) {
            var target = ts.skipParentheses(node);
            switch (target.kind) {
                case 79:
                    return cacheIdentifiers;
                case 108:
                case 8:
                case 9:
                case 10:
                    return false;
                case 204:
                    var elements = target.elements;
                    if (elements.length === 0) {
                        return false;
                    }
                    return true;
                case 205:
                    return target.properties.length > 0;
                default:
                    return true;
            }
        }
        function createCallBinding(expression, recordTempVariable, languageVersion, cacheIdentifiers) {
            if (cacheIdentifiers === void 0) { cacheIdentifiers = false; }
            var callee = ts.skipOuterExpressions(expression, 15);
            var thisArg;
            var target;
            if (ts.isSuperProperty(callee)) {
                thisArg = createThis();
                target = callee;
            }
            else if (ts.isSuperKeyword(callee)) {
                thisArg = createThis();
                target = languageVersion !== undefined && languageVersion < 2
                    ? ts.setTextRange(createIdentifier("_super"), callee)
                    : callee;
            }
            else if (ts.getEmitFlags(callee) & 4096) {
                thisArg = createVoidZero();
                target = parenthesizerRules().parenthesizeLeftSideOfAccess(callee);
            }
            else if (ts.isPropertyAccessExpression(callee)) {
                if (shouldBeCapturedInTempVariable(callee.expression, cacheIdentifiers)) {
                    thisArg = createTempVariable(recordTempVariable);
                    target = createPropertyAccessExpression(ts.setTextRange(factory.createAssignment(thisArg, callee.expression), callee.expression), callee.name);
                    ts.setTextRange(target, callee);
                }
                else {
                    thisArg = callee.expression;
                    target = callee;
                }
            }
            else if (ts.isElementAccessExpression(callee)) {
                if (shouldBeCapturedInTempVariable(callee.expression, cacheIdentifiers)) {
                    thisArg = createTempVariable(recordTempVariable);
                    target = createElementAccessExpression(ts.setTextRange(factory.createAssignment(thisArg, callee.expression), callee.expression), callee.argumentExpression);
                    ts.setTextRange(target, callee);
                }
                else {
                    thisArg = callee.expression;
                    target = callee;
                }
            }
            else {
                thisArg = createVoidZero();
                target = parenthesizerRules().parenthesizeLeftSideOfAccess(expression);
            }
            return { target: target, thisArg: thisArg };
        }
        function createAssignmentTargetWrapper(paramName, expression) {
            return createPropertyAccessExpression(createParenthesizedExpression(createObjectLiteralExpression([
                createSetAccessorDeclaration(undefined, undefined, "value", [createParameterDeclaration(undefined, undefined, undefined, paramName, undefined, undefined, undefined)], createBlock([
                    createExpressionStatement(expression)
                ]))
            ])), "value");
        }
        function inlineExpressions(expressions) {
            return expressions.length > 10
                ? createCommaListExpression(expressions)
                : ts.reduceLeft(expressions, factory.createComma);
        }
        function getName(node, allowComments, allowSourceMaps, emitFlags) {
            if (emitFlags === void 0) { emitFlags = 0; }
            var nodeName = ts.getNameOfDeclaration(node);
            if (nodeName && ts.isIdentifier(nodeName) && !ts.isGeneratedIdentifier(nodeName)) {
                var name = ts.setParent(ts.setTextRange(cloneNode(nodeName), nodeName), nodeName.parent);
                emitFlags |= ts.getEmitFlags(nodeName);
                if (!allowSourceMaps)
                    emitFlags |= 48;
                if (!allowComments)
                    emitFlags |= 1536;
                if (emitFlags)
                    ts.setEmitFlags(name, emitFlags);
                return name;
            }
            return getGeneratedNameForNode(node);
        }
        function getInternalName(node, allowComments, allowSourceMaps) {
            return getName(node, allowComments, allowSourceMaps, 16384 | 32768);
        }
        function getLocalName(node, allowComments, allowSourceMaps) {
            return getName(node, allowComments, allowSourceMaps, 16384);
        }
        function getExportName(node, allowComments, allowSourceMaps) {
            return getName(node, allowComments, allowSourceMaps, 8192);
        }
        function getDeclarationName(node, allowComments, allowSourceMaps) {
            return getName(node, allowComments, allowSourceMaps);
        }
        function getNamespaceMemberName(ns, name, allowComments, allowSourceMaps) {
            var qualifiedName = createPropertyAccessExpression(ns, ts.nodeIsSynthesized(name) ? name : cloneNode(name));
            ts.setTextRange(qualifiedName, name);
            var emitFlags = 0;
            if (!allowSourceMaps)
                emitFlags |= 48;
            if (!allowComments)
                emitFlags |= 1536;
            if (emitFlags)
                ts.setEmitFlags(qualifiedName, emitFlags);
            return qualifiedName;
        }
        function getExternalModuleOrNamespaceExportName(ns, node, allowComments, allowSourceMaps) {
            if (ns && ts.hasSyntacticModifier(node, 1)) {
                return getNamespaceMemberName(ns, getName(node), allowComments, allowSourceMaps);
            }
            return getExportName(node, allowComments, allowSourceMaps);
        }
        function copyPrologue(source, target, ensureUseStrict, visitor) {
            var offset = copyStandardPrologue(source, target, 0, ensureUseStrict);
            return copyCustomPrologue(source, target, offset, visitor);
        }
        function isUseStrictPrologue(node) {
            return ts.isStringLiteral(node.expression) && node.expression.text === "use strict";
        }
        function createUseStrictPrologue() {
            return ts.startOnNewLine(createExpressionStatement(createStringLiteral("use strict")));
        }
        function copyStandardPrologue(source, target, statementOffset, ensureUseStrict) {
            if (statementOffset === void 0) { statementOffset = 0; }
            ts.Debug.assert(target.length === 0, "Prologue directives should be at the first statement in the target statements array");
            var foundUseStrict = false;
            var numStatements = source.length;
            while (statementOffset < numStatements) {
                var statement = source[statementOffset];
                if (ts.isPrologueDirective(statement)) {
                    if (isUseStrictPrologue(statement)) {
                        foundUseStrict = true;
                    }
                    target.push(statement);
                }
                else {
                    break;
                }
                statementOffset++;
            }
            if (ensureUseStrict && !foundUseStrict) {
                target.push(createUseStrictPrologue());
            }
            return statementOffset;
        }
        function copyCustomPrologue(source, target, statementOffset, visitor, filter) {
            if (filter === void 0) { filter = ts.returnTrue; }
            var numStatements = source.length;
            while (statementOffset !== undefined && statementOffset < numStatements) {
                var statement = source[statementOffset];
                if (ts.getEmitFlags(statement) & 1048576 && filter(statement)) {
                    ts.append(target, visitor ? ts.visitNode(statement, visitor, ts.isStatement) : statement);
                }
                else {
                    break;
                }
                statementOffset++;
            }
            return statementOffset;
        }
        function ensureUseStrict(statements) {
            var foundUseStrict = ts.findUseStrictPrologue(statements);
            if (!foundUseStrict) {
                return ts.setTextRange(createNodeArray(__spreadArray([createUseStrictPrologue()], statements, true)), statements);
            }
            return statements;
        }
        function liftToBlock(nodes) {
            ts.Debug.assert(ts.every(nodes, ts.isStatementOrBlock), "Cannot lift nodes to a Block.");
            return ts.singleOrUndefined(nodes) || createBlock(nodes);
        }
        function findSpanEnd(array, test, start) {
            var i = start;
            while (i < array.length && test(array[i])) {
                i++;
            }
            return i;
        }
        function mergeLexicalEnvironment(statements, declarations) {
            if (!ts.some(declarations)) {
                return statements;
            }
            var leftStandardPrologueEnd = findSpanEnd(statements, ts.isPrologueDirective, 0);
            var leftHoistedFunctionsEnd = findSpanEnd(statements, ts.isHoistedFunction, leftStandardPrologueEnd);
            var leftHoistedVariablesEnd = findSpanEnd(statements, ts.isHoistedVariableStatement, leftHoistedFunctionsEnd);
            var rightStandardPrologueEnd = findSpanEnd(declarations, ts.isPrologueDirective, 0);
            var rightHoistedFunctionsEnd = findSpanEnd(declarations, ts.isHoistedFunction, rightStandardPrologueEnd);
            var rightHoistedVariablesEnd = findSpanEnd(declarations, ts.isHoistedVariableStatement, rightHoistedFunctionsEnd);
            var rightCustomPrologueEnd = findSpanEnd(declarations, ts.isCustomPrologue, rightHoistedVariablesEnd);
            ts.Debug.assert(rightCustomPrologueEnd === declarations.length, "Expected declarations to be valid standard or custom prologues");
            var left = ts.isNodeArray(statements) ? statements.slice() : statements;
            if (rightCustomPrologueEnd > rightHoistedVariablesEnd) {
                left.splice.apply(left, __spreadArray([leftHoistedVariablesEnd, 0], declarations.slice(rightHoistedVariablesEnd, rightCustomPrologueEnd), false));
            }
            if (rightHoistedVariablesEnd > rightHoistedFunctionsEnd) {
                left.splice.apply(left, __spreadArray([leftHoistedFunctionsEnd, 0], declarations.slice(rightHoistedFunctionsEnd, rightHoistedVariablesEnd), false));
            }
            if (rightHoistedFunctionsEnd > rightStandardPrologueEnd) {
                left.splice.apply(left, __spreadArray([leftStandardPrologueEnd, 0], declarations.slice(rightStandardPrologueEnd, rightHoistedFunctionsEnd), false));
            }
            if (rightStandardPrologueEnd > 0) {
                if (leftStandardPrologueEnd === 0) {
                    left.splice.apply(left, __spreadArray([0, 0], declarations.slice(0, rightStandardPrologueEnd), false));
                }
                else {
                    var leftPrologues = new ts.Map();
                    for (var i = 0; i < leftStandardPrologueEnd; i++) {
                        var leftPrologue = statements[i];
                        leftPrologues.set(leftPrologue.expression.text, true);
                    }
                    for (var i = rightStandardPrologueEnd - 1; i >= 0; i--) {
                        var rightPrologue = declarations[i];
                        if (!leftPrologues.has(rightPrologue.expression.text)) {
                            left.unshift(rightPrologue);
                        }
                    }
                }
            }
            if (ts.isNodeArray(statements)) {
                return ts.setTextRange(createNodeArray(left, statements.hasTrailingComma), statements);
            }
            return statements;
        }
        function updateModifiers(node, modifiers) {
            var _a;
            var modifierArray;
            if (typeof modifiers === "number") {
                modifierArray = createModifiersFromModifierFlags(modifiers);
            }
            else {
                modifierArray = modifiers;
            }
            return ts.isParameter(node) ? updateParameterDeclaration(node, node.decorators, modifierArray, node.dotDotDotToken, node.name, node.questionToken, node.type, node.initializer) :
                ts.isPropertySignature(node) ? updatePropertySignature(node, modifierArray, node.name, node.questionToken, node.type) :
                    ts.isPropertyDeclaration(node) ? updatePropertyDeclaration(node, node.decorators, modifierArray, node.name, (_a = node.questionToken) !== null && _a !== void 0 ? _a : node.exclamationToken, node.type, node.initializer) :
                        ts.isMethodSignature(node) ? updateMethodSignature(node, modifierArray, node.name, node.questionToken, node.typeParameters, node.parameters, node.type) :
                            ts.isMethodDeclaration(node) ? updateMethodDeclaration(node, node.decorators, modifierArray, node.asteriskToken, node.name, node.questionToken, node.typeParameters, node.parameters, node.type, node.body) :
                                ts.isConstructorDeclaration(node) ? updateConstructorDeclaration(node, node.decorators, modifierArray, node.parameters, node.body) :
                                    ts.isGetAccessorDeclaration(node) ? updateGetAccessorDeclaration(node, node.decorators, modifierArray, node.name, node.parameters, node.type, node.body) :
                                        ts.isSetAccessorDeclaration(node) ? updateSetAccessorDeclaration(node, node.decorators, modifierArray, node.name, node.parameters, node.body) :
                                            ts.isIndexSignatureDeclaration(node) ? updateIndexSignature(node, node.decorators, modifierArray, node.parameters, node.type) :
                                                ts.isFunctionExpression(node) ? updateFunctionExpression(node, modifierArray, node.asteriskToken, node.name, node.typeParameters, node.parameters, node.type, node.body) :
                                                    ts.isArrowFunction(node) ? updateArrowFunction(node, modifierArray, node.typeParameters, node.parameters, node.type, node.equalsGreaterThanToken, node.body) :
                                                        ts.isClassExpression(node) ? updateClassExpression(node, node.decorators, modifierArray, node.name, node.typeParameters, node.heritageClauses, node.members) :
                                                            ts.isVariableStatement(node) ? updateVariableStatement(node, modifierArray, node.declarationList) :
                                                                ts.isFunctionDeclaration(node) ? updateFunctionDeclaration(node, node.decorators, modifierArray, node.asteriskToken, node.name, node.typeParameters, node.parameters, node.type, node.body) :
                                                                    ts.isClassDeclaration(node) ? updateClassDeclaration(node, node.decorators, modifierArray, node.name, node.typeParameters, node.heritageClauses, node.members) :
                                                                        ts.isInterfaceDeclaration(node) ? updateInterfaceDeclaration(node, node.decorators, modifierArray, node.name, node.typeParameters, node.heritageClauses, node.members) :
                                                                            ts.isTypeAliasDeclaration(node) ? updateTypeAliasDeclaration(node, node.decorators, modifierArray, node.name, node.typeParameters, node.type) :
                                                                                ts.isEnumDeclaration(node) ? updateEnumDeclaration(node, node.decorators, modifierArray, node.name, node.members) :
                                                                                    ts.isModuleDeclaration(node) ? updateModuleDeclaration(node, node.decorators, modifierArray, node.name, node.body) :
                                                                                        ts.isImportEqualsDeclaration(node) ? updateImportEqualsDeclaration(node, node.decorators, modifierArray, node.isTypeOnly, node.name, node.moduleReference) :
                                                                                            ts.isImportDeclaration(node) ? updateImportDeclaration(node, node.decorators, modifierArray, node.importClause, node.moduleSpecifier, node.assertClause) :
                                                                                                ts.isExportAssignment(node) ? updateExportAssignment(node, node.decorators, modifierArray, node.expression) :
                                                                                                    ts.isExportDeclaration(node) ? updateExportDeclaration(node, node.decorators, modifierArray, node.isTypeOnly, node.exportClause, node.moduleSpecifier, node.assertClause) :
                                                                                                        ts.Debug.assertNever(node);
        }
        function asNodeArray(array) {
            return array ? createNodeArray(array) : undefined;
        }
        function asName(name) {
            return typeof name === "string" ? createIdentifier(name) :
                name;
        }
        function asExpression(value) {
            return typeof value === "string" ? createStringLiteral(value) :
                typeof value === "number" ? createNumericLiteral(value) :
                    typeof value === "boolean" ? value ? createTrue() : createFalse() :
                        value;
        }
        function asToken(value) {
            return typeof value === "number" ? createToken(value) : value;
        }
        function asEmbeddedStatement(statement) {
            return statement && ts.isNotEmittedStatement(statement) ? ts.setTextRange(setOriginalNode(createEmptyStatement(), statement), statement) : statement;
        }
    }
    ts.createNodeFactory = createNodeFactory;
    function updateWithoutOriginal(updated, original) {
        if (updated !== original) {
            ts.setTextRange(updated, original);
        }
        return updated;
    }
    function updateWithOriginal(updated, original) {
        if (updated !== original) {
            setOriginalNode(updated, original);
            ts.setTextRange(updated, original);
        }
        return updated;
    }
    function getDefaultTagNameForKind(kind) {
        switch (kind) {
            case 343: return "type";
            case 341: return "returns";
            case 342: return "this";
            case 339: return "enum";
            case 330: return "author";
            case 332: return "class";
            case 333: return "public";
            case 334: return "private";
            case 335: return "protected";
            case 336: return "readonly";
            case 337: return "override";
            case 344: return "template";
            case 345: return "typedef";
            case 340: return "param";
            case 347: return "prop";
            case 338: return "callback";
            case 328: return "augments";
            case 329: return "implements";
            default:
                return ts.Debug.fail("Unsupported kind: ".concat(ts.Debug.formatSyntaxKind(kind)));
        }
    }
    var rawTextScanner;
    var invalidValueSentinel = {};
    function getCookedText(kind, rawText) {
        if (!rawTextScanner) {
            rawTextScanner = ts.createScanner(99, false, 0);
        }
        switch (kind) {
            case 14:
                rawTextScanner.setText("`" + rawText + "`");
                break;
            case 15:
                rawTextScanner.setText("`" + rawText + "${");
                break;
            case 16:
                rawTextScanner.setText("}" + rawText + "${");
                break;
            case 17:
                rawTextScanner.setText("}" + rawText + "`");
                break;
        }
        var token = rawTextScanner.scan();
        if (token === 19) {
            token = rawTextScanner.reScanTemplateToken(false);
        }
        if (rawTextScanner.isUnterminated()) {
            rawTextScanner.setText(undefined);
            return invalidValueSentinel;
        }
        var tokenValue;
        switch (token) {
            case 14:
            case 15:
            case 16:
            case 17:
                tokenValue = rawTextScanner.getTokenValue();
                break;
        }
        if (tokenValue === undefined || rawTextScanner.scan() !== 1) {
            rawTextScanner.setText(undefined);
            return invalidValueSentinel;
        }
        rawTextScanner.setText(undefined);
        return tokenValue;
    }
    function propagateIdentifierNameFlags(node) {
        return propagateChildFlags(node) & ~16777216;
    }
    function propagatePropertyNameFlagsOfChild(node, transformFlags) {
        return transformFlags | (node.transformFlags & 33562624);
    }
    function propagateChildFlags(child) {
        if (!child)
            return 0;
        var childFlags = child.transformFlags & ~getTransformFlagsSubtreeExclusions(child.kind);
        return ts.isNamedDeclaration(child) && ts.isPropertyName(child.name) ? propagatePropertyNameFlagsOfChild(child.name, childFlags) : childFlags;
    }
    function propagateChildrenFlags(children) {
        return children ? children.transformFlags : 0;
    }
    function aggregateChildrenFlags(children) {
        var subtreeFlags = 0;
        for (var _i = 0, children_2 = children; _i < children_2.length; _i++) {
            var child = children_2[_i];
            subtreeFlags |= propagateChildFlags(child);
        }
        children.transformFlags = subtreeFlags;
    }
    function getTransformFlagsSubtreeExclusions(kind) {
        if (kind >= 177 && kind <= 200) {
            return -2;
        }
        switch (kind) {
            case 208:
            case 209:
            case 204:
                return 536887296;
            case 261:
                return 589443072;
            case 164:
                return 536870912;
            case 214:
                return 557748224;
            case 213:
            case 256:
                return 591310848;
            case 255:
                return 537165824;
            case 257:
            case 226:
                return 536940544;
            case 171:
                return 591306752;
            case 167:
                return 570433536;
            case 169:
            case 172:
            case 173:
                return 574529536;
            case 130:
            case 147:
            case 158:
            case 143:
            case 150:
            case 148:
            case 133:
            case 151:
            case 114:
            case 163:
            case 166:
            case 168:
            case 174:
            case 175:
            case 176:
            case 258:
            case 259:
                return -2;
            case 205:
                return 536973312;
            case 292:
                return 536903680;
            case 201:
            case 202:
                return 536887296;
            case 211:
            case 229:
            case 350:
            case 212:
            case 106:
                return 536870912;
            case 206:
            case 207:
                return 536870912;
            default:
                return 536870912;
        }
    }
    ts.getTransformFlagsSubtreeExclusions = getTransformFlagsSubtreeExclusions;
    var baseFactory = ts.createBaseNodeFactory();
    function makeSynthetic(node) {
        node.flags |= 8;
        return node;
    }
    var syntheticFactory = {
        createBaseSourceFileNode: function (kind) { return makeSynthetic(baseFactory.createBaseSourceFileNode(kind)); },
        createBaseIdentifierNode: function (kind) { return makeSynthetic(baseFactory.createBaseIdentifierNode(kind)); },
        createBasePrivateIdentifierNode: function (kind) { return makeSynthetic(baseFactory.createBasePrivateIdentifierNode(kind)); },
        createBaseTokenNode: function (kind) { return makeSynthetic(baseFactory.createBaseTokenNode(kind)); },
        createBaseNode: function (kind) { return makeSynthetic(baseFactory.createBaseNode(kind)); },
    };
    ts.factory = createNodeFactory(4, syntheticFactory);
    function createUnparsedSourceFile(textOrInputFiles, mapPathOrType, mapTextOrStripInternal) {
        var stripInternal;
        var bundleFileInfo;
        var fileName;
        var text;
        var length;
        var sourceMapPath;
        var sourceMapText;
        var getText;
        var getSourceMapText;
        var oldFileOfCurrentEmit;
        if (!ts.isString(textOrInputFiles)) {
            ts.Debug.assert(mapPathOrType === "js" || mapPathOrType === "dts");
            fileName = (mapPathOrType === "js" ? textOrInputFiles.javascriptPath : textOrInputFiles.declarationPath) || "";
            sourceMapPath = mapPathOrType === "js" ? textOrInputFiles.javascriptMapPath : textOrInputFiles.declarationMapPath;
            getText = function () { return mapPathOrType === "js" ? textOrInputFiles.javascriptText : textOrInputFiles.declarationText; };
            getSourceMapText = function () { return mapPathOrType === "js" ? textOrInputFiles.javascriptMapText : textOrInputFiles.declarationMapText; };
            length = function () { return getText().length; };
            if (textOrInputFiles.buildInfo && textOrInputFiles.buildInfo.bundle) {
                ts.Debug.assert(mapTextOrStripInternal === undefined || typeof mapTextOrStripInternal === "boolean");
                stripInternal = mapTextOrStripInternal;
                bundleFileInfo = mapPathOrType === "js" ? textOrInputFiles.buildInfo.bundle.js : textOrInputFiles.buildInfo.bundle.dts;
                oldFileOfCurrentEmit = textOrInputFiles.oldFileOfCurrentEmit;
            }
        }
        else {
            fileName = "";
            text = textOrInputFiles;
            length = textOrInputFiles.length;
            sourceMapPath = mapPathOrType;
            sourceMapText = mapTextOrStripInternal;
        }
        var node = oldFileOfCurrentEmit ?
            parseOldFileOfCurrentEmit(ts.Debug.checkDefined(bundleFileInfo)) :
            parseUnparsedSourceFile(bundleFileInfo, stripInternal, length);
        node.fileName = fileName;
        node.sourceMapPath = sourceMapPath;
        node.oldFileOfCurrentEmit = oldFileOfCurrentEmit;
        if (getText && getSourceMapText) {
            Object.defineProperty(node, "text", { get: getText });
            Object.defineProperty(node, "sourceMapText", { get: getSourceMapText });
        }
        else {
            ts.Debug.assert(!oldFileOfCurrentEmit);
            node.text = text !== null && text !== void 0 ? text : "";
            node.sourceMapText = sourceMapText;
        }
        return node;
    }
    ts.createUnparsedSourceFile = createUnparsedSourceFile;
    function parseUnparsedSourceFile(bundleFileInfo, stripInternal, length) {
        var prologues;
        var helpers;
        var referencedFiles;
        var typeReferenceDirectives;
        var libReferenceDirectives;
        var prependChildren;
        var texts;
        var hasNoDefaultLib;
        for (var _i = 0, _a = bundleFileInfo ? bundleFileInfo.sections : ts.emptyArray; _i < _a.length; _i++) {
            var section = _a[_i];
            switch (section.kind) {
                case "prologue":
                    prologues = ts.append(prologues, ts.setTextRange(ts.factory.createUnparsedPrologue(section.data), section));
                    break;
                case "emitHelpers":
                    helpers = ts.append(helpers, ts.getAllUnscopedEmitHelpers().get(section.data));
                    break;
                case "no-default-lib":
                    hasNoDefaultLib = true;
                    break;
                case "reference":
                    referencedFiles = ts.append(referencedFiles, { pos: -1, end: -1, fileName: section.data });
                    break;
                case "type":
                    typeReferenceDirectives = ts.append(typeReferenceDirectives, { pos: -1, end: -1, fileName: section.data });
                    break;
                case "type-import":
                    typeReferenceDirectives = ts.append(typeReferenceDirectives, { pos: -1, end: -1, fileName: section.data, resolutionMode: ts.ModuleKind.ESNext });
                    break;
                case "type-require":
                    typeReferenceDirectives = ts.append(typeReferenceDirectives, { pos: -1, end: -1, fileName: section.data, resolutionMode: ts.ModuleKind.CommonJS });
                    break;
                case "lib":
                    libReferenceDirectives = ts.append(libReferenceDirectives, { pos: -1, end: -1, fileName: section.data });
                    break;
                case "prepend":
                    var prependTexts = void 0;
                    for (var _b = 0, _c = section.texts; _b < _c.length; _b++) {
                        var text = _c[_b];
                        if (!stripInternal || text.kind !== "internal") {
                            prependTexts = ts.append(prependTexts, ts.setTextRange(ts.factory.createUnparsedTextLike(text.data, text.kind === "internal"), text));
                        }
                    }
                    prependChildren = ts.addRange(prependChildren, prependTexts);
                    texts = ts.append(texts, ts.factory.createUnparsedPrepend(section.data, prependTexts !== null && prependTexts !== void 0 ? prependTexts : ts.emptyArray));
                    break;
                case "internal":
                    if (stripInternal) {
                        if (!texts)
                            texts = [];
                        break;
                    }
                case "text":
                    texts = ts.append(texts, ts.setTextRange(ts.factory.createUnparsedTextLike(section.data, section.kind === "internal"), section));
                    break;
                default:
                    ts.Debug.assertNever(section);
            }
        }
        if (!texts) {
            var textNode = ts.factory.createUnparsedTextLike(undefined, false);
            ts.setTextRangePosWidth(textNode, 0, typeof length === "function" ? length() : length);
            texts = [textNode];
        }
        var node = ts.parseNodeFactory.createUnparsedSource(prologues !== null && prologues !== void 0 ? prologues : ts.emptyArray, undefined, texts);
        ts.setEachParent(prologues, node);
        ts.setEachParent(texts, node);
        ts.setEachParent(prependChildren, node);
        node.hasNoDefaultLib = hasNoDefaultLib;
        node.helpers = helpers;
        node.referencedFiles = referencedFiles || ts.emptyArray;
        node.typeReferenceDirectives = typeReferenceDirectives;
        node.libReferenceDirectives = libReferenceDirectives || ts.emptyArray;
        return node;
    }
    function parseOldFileOfCurrentEmit(bundleFileInfo) {
        var texts;
        var syntheticReferences;
        for (var _i = 0, _a = bundleFileInfo.sections; _i < _a.length; _i++) {
            var section = _a[_i];
            switch (section.kind) {
                case "internal":
                case "text":
                    texts = ts.append(texts, ts.setTextRange(ts.factory.createUnparsedTextLike(section.data, section.kind === "internal"), section));
                    break;
                case "no-default-lib":
                case "reference":
                case "type":
                case "type-import":
                case "type-require":
                case "lib":
                    syntheticReferences = ts.append(syntheticReferences, ts.setTextRange(ts.factory.createUnparsedSyntheticReference(section), section));
                    break;
                case "prologue":
                case "emitHelpers":
                case "prepend":
                    break;
                default:
                    ts.Debug.assertNever(section);
            }
        }
        var node = ts.factory.createUnparsedSource(ts.emptyArray, syntheticReferences, texts !== null && texts !== void 0 ? texts : ts.emptyArray);
        ts.setEachParent(syntheticReferences, node);
        ts.setEachParent(texts, node);
        node.helpers = ts.map(bundleFileInfo.sources && bundleFileInfo.sources.helpers, function (name) { return ts.getAllUnscopedEmitHelpers().get(name); });
        return node;
    }
    function createInputFiles(javascriptTextOrReadFileText, declarationTextOrJavascriptPath, javascriptMapPath, javascriptMapTextOrDeclarationPath, declarationMapPath, declarationMapTextOrBuildInfoPath, javascriptPath, declarationPath, buildInfoPath, buildInfo, oldFileOfCurrentEmit) {
        var node = ts.parseNodeFactory.createInputFiles();
        if (!ts.isString(javascriptTextOrReadFileText)) {
            var cache_1 = new ts.Map();
            var textGetter_1 = function (path) {
                if (path === undefined)
                    return undefined;
                var value = cache_1.get(path);
                if (value === undefined) {
                    value = javascriptTextOrReadFileText(path);
                    cache_1.set(path, value !== undefined ? value : false);
                }
                return value !== false ? value : undefined;
            };
            var definedTextGetter_1 = function (path) {
                var result = textGetter_1(path);
                return result !== undefined ? result : "/* Input file ".concat(path, " was missing */\r\n");
            };
            var buildInfo_1;
            var getAndCacheBuildInfo_1 = function (getText) {
                if (buildInfo_1 === undefined) {
                    var result = getText();
                    buildInfo_1 = result !== undefined ? ts.getBuildInfo(result) : false;
                }
                return buildInfo_1 || undefined;
            };
            node.javascriptPath = declarationTextOrJavascriptPath;
            node.javascriptMapPath = javascriptMapPath;
            node.declarationPath = ts.Debug.checkDefined(javascriptMapTextOrDeclarationPath);
            node.declarationMapPath = declarationMapPath;
            node.buildInfoPath = declarationMapTextOrBuildInfoPath;
            Object.defineProperties(node, {
                javascriptText: { get: function () { return definedTextGetter_1(declarationTextOrJavascriptPath); } },
                javascriptMapText: { get: function () { return textGetter_1(javascriptMapPath); } },
                declarationText: { get: function () { return definedTextGetter_1(ts.Debug.checkDefined(javascriptMapTextOrDeclarationPath)); } },
                declarationMapText: { get: function () { return textGetter_1(declarationMapPath); } },
                buildInfo: { get: function () { return getAndCacheBuildInfo_1(function () { return textGetter_1(declarationMapTextOrBuildInfoPath); }); } }
            });
        }
        else {
            node.javascriptText = javascriptTextOrReadFileText;
            node.javascriptMapPath = javascriptMapPath;
            node.javascriptMapText = javascriptMapTextOrDeclarationPath;
            node.declarationText = declarationTextOrJavascriptPath;
            node.declarationMapPath = declarationMapPath;
            node.declarationMapText = declarationMapTextOrBuildInfoPath;
            node.javascriptPath = javascriptPath;
            node.declarationPath = declarationPath;
            node.buildInfoPath = buildInfoPath;
            node.buildInfo = buildInfo;
            node.oldFileOfCurrentEmit = oldFileOfCurrentEmit;
        }
        return node;
    }
    ts.createInputFiles = createInputFiles;
    var SourceMapSource;
    function createSourceMapSource(fileName, text, skipTrivia) {
        return new (SourceMapSource || (SourceMapSource = ts.objectAllocator.getSourceMapSourceConstructor()))(fileName, text, skipTrivia);
    }
    ts.createSourceMapSource = createSourceMapSource;
    function setOriginalNode(node, original) {
        node.original = original;
        if (original) {
            var emitNode = original.emitNode;
            if (emitNode)
                node.emitNode = mergeEmitNode(emitNode, node.emitNode);
        }
        return node;
    }
    ts.setOriginalNode = setOriginalNode;
    function mergeEmitNode(sourceEmitNode, destEmitNode) {
        var flags = sourceEmitNode.flags, leadingComments = sourceEmitNode.leadingComments, trailingComments = sourceEmitNode.trailingComments, commentRange = sourceEmitNode.commentRange, sourceMapRange = sourceEmitNode.sourceMapRange, tokenSourceMapRanges = sourceEmitNode.tokenSourceMapRanges, constantValue = sourceEmitNode.constantValue, helpers = sourceEmitNode.helpers, startsOnNewLine = sourceEmitNode.startsOnNewLine;
        if (!destEmitNode)
            destEmitNode = {};
        if (leadingComments)
            destEmitNode.leadingComments = ts.addRange(leadingComments.slice(), destEmitNode.leadingComments);
        if (trailingComments)
            destEmitNode.trailingComments = ts.addRange(trailingComments.slice(), destEmitNode.trailingComments);
        if (flags)
            destEmitNode.flags = flags & ~268435456;
        if (commentRange)
            destEmitNode.commentRange = commentRange;
        if (sourceMapRange)
            destEmitNode.sourceMapRange = sourceMapRange;
        if (tokenSourceMapRanges)
            destEmitNode.tokenSourceMapRanges = mergeTokenSourceMapRanges(tokenSourceMapRanges, destEmitNode.tokenSourceMapRanges);
        if (constantValue !== undefined)
            destEmitNode.constantValue = constantValue;
        if (helpers) {
            for (var _i = 0, helpers_1 = helpers; _i < helpers_1.length; _i++) {
                var helper = helpers_1[_i];
                destEmitNode.helpers = ts.appendIfUnique(destEmitNode.helpers, helper);
            }
        }
        if (startsOnNewLine !== undefined)
            destEmitNode.startsOnNewLine = startsOnNewLine;
        return destEmitNode;
    }
    function mergeTokenSourceMapRanges(sourceRanges, destRanges) {
        if (!destRanges)
            destRanges = [];
        for (var key in sourceRanges) {
            destRanges[key] = sourceRanges[key];
        }
        return destRanges;
    }
})(ts || (ts = {}));
var ts;
(function (ts) {
    function getOrCreateEmitNode(node) {
        var _a;
        if (!node.emitNode) {
            if (ts.isParseTreeNode(node)) {
                if (node.kind === 305) {
                    return node.emitNode = { annotatedNodes: [node] };
                }
                var sourceFile = (_a = ts.getSourceFileOfNode(ts.getParseTreeNode(ts.getSourceFileOfNode(node)))) !== null && _a !== void 0 ? _a : ts.Debug.fail("Could not determine parsed source file.");
                getOrCreateEmitNode(sourceFile).annotatedNodes.push(node);
            }
            node.emitNode = {};
        }
        else {
            ts.Debug.assert(!(node.emitNode.flags & 268435456), "Invalid attempt to mutate an immutable node.");
        }
        return node.emitNode;
    }
    ts.getOrCreateEmitNode = getOrCreateEmitNode;
    function disposeEmitNodes(sourceFile) {
        var _a, _b;
        var annotatedNodes = (_b = (_a = ts.getSourceFileOfNode(ts.getParseTreeNode(sourceFile))) === null || _a === void 0 ? void 0 : _a.emitNode) === null || _b === void 0 ? void 0 : _b.annotatedNodes;
        if (annotatedNodes) {
            for (var _i = 0, annotatedNodes_1 = annotatedNodes; _i < annotatedNodes_1.length; _i++) {
                var node = annotatedNodes_1[_i];
                node.emitNode = undefined;
            }
        }
    }
    ts.disposeEmitNodes = disposeEmitNodes;
    function removeAllComments(node) {
        var emitNode = getOrCreateEmitNode(node);
        emitNode.flags |= 1536;
        emitNode.leadingComments = undefined;
        emitNode.trailingComments = undefined;
        return node;
    }
    ts.removeAllComments = removeAllComments;
    function setEmitFlags(node, emitFlags) {
        getOrCreateEmitNode(node).flags = emitFlags;
        return node;
    }
    ts.setEmitFlags = setEmitFlags;
    function addEmitFlags(node, emitFlags) {
        var emitNode = getOrCreateEmitNode(node);
        emitNode.flags = emitNode.flags | emitFlags;
        return node;
    }
    ts.addEmitFlags = addEmitFlags;
    function getSourceMapRange(node) {
        var _a, _b;
        return (_b = (_a = node.emitNode) === null || _a === void 0 ? void 0 : _a.sourceMapRange) !== null && _b !== void 0 ? _b : node;
    }
    ts.getSourceMapRange = getSourceMapRange;
    function setSourceMapRange(node, range) {
        getOrCreateEmitNode(node).sourceMapRange = range;
        return node;
    }
    ts.setSourceMapRange = setSourceMapRange;
    function getTokenSourceMapRange(node, token) {
        var _a, _b;
        return (_b = (_a = node.emitNode) === null || _a === void 0 ? void 0 : _a.tokenSourceMapRanges) === null || _b === void 0 ? void 0 : _b[token];
    }
    ts.getTokenSourceMapRange = getTokenSourceMapRange;
    function setTokenSourceMapRange(node, token, range) {
        var _a;
        var emitNode = getOrCreateEmitNode(node);
        var tokenSourceMapRanges = (_a = emitNode.tokenSourceMapRanges) !== null && _a !== void 0 ? _a : (emitNode.tokenSourceMapRanges = []);
        tokenSourceMapRanges[token] = range;
        return node;
    }
    ts.setTokenSourceMapRange = setTokenSourceMapRange;
    function getStartsOnNewLine(node) {
        var _a;
        return (_a = node.emitNode) === null || _a === void 0 ? void 0 : _a.startsOnNewLine;
    }
    ts.getStartsOnNewLine = getStartsOnNewLine;
    function setStartsOnNewLine(node, newLine) {
        getOrCreateEmitNode(node).startsOnNewLine = newLine;
        return node;
    }
    ts.setStartsOnNewLine = setStartsOnNewLine;
    function getCommentRange(node) {
        var _a, _b;
        return (_b = (_a = node.emitNode) === null || _a === void 0 ? void 0 : _a.commentRange) !== null && _b !== void 0 ? _b : node;
    }
    ts.getCommentRange = getCommentRange;
    function setCommentRange(node, range) {
        getOrCreateEmitNode(node).commentRange = range;
        return node;
    }
    ts.setCommentRange = setCommentRange;
    function getSyntheticLeadingComments(node) {
        var _a;
        return (_a = node.emitNode) === null || _a === void 0 ? void 0 : _a.leadingComments;
    }
    ts.getSyntheticLeadingComments = getSyntheticLeadingComments;
    function setSyntheticLeadingComments(node, comments) {
        getOrCreateEmitNode(node).leadingComments = comments;
        return node;
    }
    ts.setSyntheticLeadingComments = setSyntheticLeadingComments;
    function addSyntheticLeadingComment(node, kind, text, hasTrailingNewLine) {
        return setSyntheticLeadingComments(node, ts.append(getSyntheticLeadingComments(node), { kind: kind, pos: -1, end: -1, hasTrailingNewLine: hasTrailingNewLine, text: text }));
    }
    ts.addSyntheticLeadingComment = addSyntheticLeadingComment;
    function getSyntheticTrailingComments(node) {
        var _a;
        return (_a = node.emitNode) === null || _a === void 0 ? void 0 : _a.trailingComments;
    }
    ts.getSyntheticTrailingComments = getSyntheticTrailingComments;
    function setSyntheticTrailingComments(node, comments) {
        getOrCreateEmitNode(node).trailingComments = comments;
        return node;
    }
    ts.setSyntheticTrailingComments = setSyntheticTrailingComments;
    function addSyntheticTrailingComment(node, kind, text, hasTrailingNewLine) {
        return setSyntheticTrailingComments(node, ts.append(getSyntheticTrailingComments(node), { kind: kind, pos: -1, end: -1, hasTrailingNewLine: hasTrailingNewLine, text: text }));
    }
    ts.addSyntheticTrailingComment = addSyntheticTrailingComment;
    function moveSyntheticComments(node, original) {
        setSyntheticLeadingComments(node, getSyntheticLeadingComments(original));
        setSyntheticTrailingComments(node, getSyntheticTrailingComments(original));
        var emit = getOrCreateEmitNode(original);
        emit.leadingComments = undefined;
        emit.trailingComments = undefined;
        return node;
    }
    ts.moveSyntheticComments = moveSyntheticComments;
    function getConstantValue(node) {
        var _a;
        return (_a = node.emitNode) === null || _a === void 0 ? void 0 : _a.constantValue;
    }
    ts.getConstantValue = getConstantValue;
    function setConstantValue(node, value) {
        var emitNode = getOrCreateEmitNode(node);
        emitNode.constantValue = value;
        return node;
    }
    ts.setConstantValue = setConstantValue;
    function addEmitHelper(node, helper) {
        var emitNode = getOrCreateEmitNode(node);
        emitNode.helpers = ts.append(emitNode.helpers, helper);
        return node;
    }
    ts.addEmitHelper = addEmitHelper;
    function addEmitHelpers(node, helpers) {
        if (ts.some(helpers)) {
            var emitNode = getOrCreateEmitNode(node);
            for (var _i = 0, helpers_2 = helpers; _i < helpers_2.length; _i++) {
                var helper = helpers_2[_i];
                emitNode.helpers = ts.appendIfUnique(emitNode.helpers, helper);
            }
        }
        return node;
    }
    ts.addEmitHelpers = addEmitHelpers;
    function removeEmitHelper(node, helper) {
        var _a;
        var helpers = (_a = node.emitNode) === null || _a === void 0 ? void 0 : _a.helpers;
        if (helpers) {
            return ts.orderedRemoveItem(helpers, helper);
        }
        return false;
    }
    ts.removeEmitHelper = removeEmitHelper;
    function getEmitHelpers(node) {
        var _a;
        return (_a = node.emitNode) === null || _a === void 0 ? void 0 : _a.helpers;
    }
    ts.getEmitHelpers = getEmitHelpers;
    function moveEmitHelpers(source, target, predicate) {
        var sourceEmitNode = source.emitNode;
        var sourceEmitHelpers = sourceEmitNode && sourceEmitNode.helpers;
        if (!ts.some(sourceEmitHelpers))
            return;
        var targetEmitNode = getOrCreateEmitNode(target);
        var helpersRemoved = 0;
        for (var i = 0; i < sourceEmitHelpers.length; i++) {
            var helper = sourceEmitHelpers[i];
            if (predicate(helper)) {
                helpersRemoved++;
                targetEmitNode.helpers = ts.appendIfUnique(targetEmitNode.helpers, helper);
            }
            else if (helpersRemoved > 0) {
                sourceEmitHelpers[i - helpersRemoved] = helper;
            }
        }
        if (helpersRemoved > 0) {
            sourceEmitHelpers.length -= helpersRemoved;
        }
    }
    ts.moveEmitHelpers = moveEmitHelpers;
    function getSnippetElement(node) {
        var _a;
        return (_a = node.emitNode) === null || _a === void 0 ? void 0 : _a.snippetElement;
    }
    ts.getSnippetElement = getSnippetElement;
    function setSnippetElement(node, snippet) {
        var emitNode = getOrCreateEmitNode(node);
        emitNode.snippetElement = snippet;
        return node;
    }
    ts.setSnippetElement = setSnippetElement;
    function ignoreSourceNewlines(node) {
        getOrCreateEmitNode(node).flags |= 134217728;
        return node;
    }
    ts.ignoreSourceNewlines = ignoreSourceNewlines;
    function setTypeNode(node, type) {
        var emitNode = getOrCreateEmitNode(node);
        emitNode.typeNode = type;
        return node;
    }
    ts.setTypeNode = setTypeNode;
    function getTypeNode(node) {
        var _a;
        return (_a = node.emitNode) === null || _a === void 0 ? void 0 : _a.typeNode;
    }
    ts.getTypeNode = getTypeNode;
})(ts || (ts = {}));
var ts;
(function (ts) {
    function createEmitHelperFactory(context) {
        var factory = context.factory;
        var immutableTrue = ts.memoize(function () { return ts.setEmitFlags(factory.createTrue(), 268435456); });
        var immutableFalse = ts.memoize(function () { return ts.setEmitFlags(factory.createFalse(), 268435456); });
        return {
            getUnscopedHelperName: getUnscopedHelperName,
            createDecorateHelper: createDecorateHelper,
            createMetadataHelper: createMetadataHelper,
            createParamHelper: createParamHelper,
            createAssignHelper: createAssignHelper,
            createAwaitHelper: createAwaitHelper,
            createAsyncGeneratorHelper: createAsyncGeneratorHelper,
            createAsyncDelegatorHelper: createAsyncDelegatorHelper,
            createAsyncValuesHelper: createAsyncValuesHelper,
            createRestHelper: createRestHelper,
            createAwaiterHelper: createAwaiterHelper,
            createExtendsHelper: createExtendsHelper,
            createTemplateObjectHelper: createTemplateObjectHelper,
            createSpreadArrayHelper: createSpreadArrayHelper,
            createValuesHelper: createValuesHelper,
            createReadHelper: createReadHelper,
            createGeneratorHelper: createGeneratorHelper,
            createCreateBindingHelper: createCreateBindingHelper,
            createImportStarHelper: createImportStarHelper,
            createImportStarCallbackHelper: createImportStarCallbackHelper,
            createImportDefaultHelper: createImportDefaultHelper,
            createExportStarHelper: createExportStarHelper,
            createClassPrivateFieldGetHelper: createClassPrivateFieldGetHelper,
            createClassPrivateFieldSetHelper: createClassPrivateFieldSetHelper,
            createClassPrivateFieldInHelper: createClassPrivateFieldInHelper
        };
        function getUnscopedHelperName(name) {
            return ts.setEmitFlags(factory.createIdentifier(name), 4096 | 2);
        }
        function createDecorateHelper(decoratorExpressions, target, memberName, descriptor) {
            context.requestEmitHelper(ts.decorateHelper);
            var argumentsArray = [];
            argumentsArray.push(factory.createArrayLiteralExpression(decoratorExpressions, true));
            argumentsArray.push(target);
            if (memberName) {
                argumentsArray.push(memberName);
                if (descriptor) {
                    argumentsArray.push(descriptor);
                }
            }
            return factory.createCallExpression(getUnscopedHelperName("__decorate"), undefined, argumentsArray);
        }
        function createMetadataHelper(metadataKey, metadataValue) {
            context.requestEmitHelper(ts.metadataHelper);
            return factory.createCallExpression(getUnscopedHelperName("__metadata"), undefined, [
                factory.createStringLiteral(metadataKey),
                metadataValue
            ]);
        }
        function createParamHelper(expression, parameterOffset, location) {
            context.requestEmitHelper(ts.paramHelper);
            return ts.setTextRange(factory.createCallExpression(getUnscopedHelperName("__param"), undefined, [
                factory.createNumericLiteral(parameterOffset + ""),
                expression
            ]), location);
        }
        function createAssignHelper(attributesSegments) {
            if (ts.getEmitScriptTarget(context.getCompilerOptions()) >= 2) {
                return factory.createCallExpression(factory.createPropertyAccessExpression(factory.createIdentifier("Object"), "assign"), undefined, attributesSegments);
            }
            context.requestEmitHelper(ts.assignHelper);
            return factory.createCallExpression(getUnscopedHelperName("__assign"), undefined, attributesSegments);
        }
        function createAwaitHelper(expression) {
            context.requestEmitHelper(ts.awaitHelper);
            return factory.createCallExpression(getUnscopedHelperName("__await"), undefined, [expression]);
        }
        function createAsyncGeneratorHelper(generatorFunc, hasLexicalThis) {
            context.requestEmitHelper(ts.awaitHelper);
            context.requestEmitHelper(ts.asyncGeneratorHelper);
            (generatorFunc.emitNode || (generatorFunc.emitNode = {})).flags |= 262144 | 524288;
            return factory.createCallExpression(getUnscopedHelperName("__asyncGenerator"), undefined, [
                hasLexicalThis ? factory.createThis() : factory.createVoidZero(),
                factory.createIdentifier("arguments"),
                generatorFunc
            ]);
        }
        function createAsyncDelegatorHelper(expression) {
            context.requestEmitHelper(ts.awaitHelper);
            context.requestEmitHelper(ts.asyncDelegator);
            return factory.createCallExpression(getUnscopedHelperName("__asyncDelegator"), undefined, [expression]);
        }
        function createAsyncValuesHelper(expression) {
            context.requestEmitHelper(ts.asyncValues);
            return factory.createCallExpression(getUnscopedHelperName("__asyncValues"), undefined, [expression]);
        }
        function createRestHelper(value, elements, computedTempVariables, location) {
            context.requestEmitHelper(ts.restHelper);
            var propertyNames = [];
            var computedTempVariableOffset = 0;
            for (var i = 0; i < elements.length - 1; i++) {
                var propertyName = ts.getPropertyNameOfBindingOrAssignmentElement(elements[i]);
                if (propertyName) {
                    if (ts.isComputedPropertyName(propertyName)) {
                        ts.Debug.assertIsDefined(computedTempVariables, "Encountered computed property name but 'computedTempVariables' argument was not provided.");
                        var temp = computedTempVariables[computedTempVariableOffset];
                        computedTempVariableOffset++;
                        propertyNames.push(factory.createConditionalExpression(factory.createTypeCheck(temp, "symbol"), undefined, temp, undefined, factory.createAdd(temp, factory.createStringLiteral(""))));
                    }
                    else {
                        propertyNames.push(factory.createStringLiteralFromNode(propertyName));
                    }
                }
            }
            return factory.createCallExpression(getUnscopedHelperName("__rest"), undefined, [
                value,
                ts.setTextRange(factory.createArrayLiteralExpression(propertyNames), location)
            ]);
        }
        function createAwaiterHelper(hasLexicalThis, hasLexicalArguments, promiseConstructor, body) {
            context.requestEmitHelper(ts.awaiterHelper);
            var generatorFunc = factory.createFunctionExpression(undefined, factory.createToken(41), undefined, undefined, [], undefined, body);
            (generatorFunc.emitNode || (generatorFunc.emitNode = {})).flags |= 262144 | 524288;
            return factory.createCallExpression(getUnscopedHelperName("__awaiter"), undefined, [
                hasLexicalThis ? factory.createThis() : factory.createVoidZero(),
                hasLexicalArguments ? factory.createIdentifier("arguments") : factory.createVoidZero(),
                promiseConstructor ? ts.createExpressionFromEntityName(factory, promiseConstructor) : factory.createVoidZero(),
                generatorFunc
            ]);
        }
        function createExtendsHelper(name) {
            context.requestEmitHelper(ts.extendsHelper);
            return factory.createCallExpression(getUnscopedHelperName("__extends"), undefined, [name, factory.createUniqueName("_super", 16 | 32)]);
        }
        function createTemplateObjectHelper(cooked, raw) {
            context.requestEmitHelper(ts.templateObjectHelper);
            return factory.createCallExpression(getUnscopedHelperName("__makeTemplateObject"), undefined, [cooked, raw]);
        }
        function createSpreadArrayHelper(to, from, packFrom) {
            context.requestEmitHelper(ts.spreadArrayHelper);
            return factory.createCallExpression(getUnscopedHelperName("__spreadArray"), undefined, [to, from, packFrom ? immutableTrue() : immutableFalse()]);
        }
        function createValuesHelper(expression) {
            context.requestEmitHelper(ts.valuesHelper);
            return factory.createCallExpression(getUnscopedHelperName("__values"), undefined, [expression]);
        }
        function createReadHelper(iteratorRecord, count) {
            context.requestEmitHelper(ts.readHelper);
            return factory.createCallExpression(getUnscopedHelperName("__read"), undefined, count !== undefined
                ? [iteratorRecord, factory.createNumericLiteral(count + "")]
                : [iteratorRecord]);
        }
        function createGeneratorHelper(body) {
            context.requestEmitHelper(ts.generatorHelper);
            return factory.createCallExpression(getUnscopedHelperName("__generator"), undefined, [factory.createThis(), body]);
        }
        function createCreateBindingHelper(module, inputName, outputName) {
            context.requestEmitHelper(ts.createBindingHelper);
            return factory.createCallExpression(getUnscopedHelperName("__createBinding"), undefined, __spreadArray([factory.createIdentifier("exports"), module, inputName], (outputName ? [outputName] : []), true));
        }
        function createImportStarHelper(expression) {
            context.requestEmitHelper(ts.importStarHelper);
            return factory.createCallExpression(getUnscopedHelperName("__importStar"), undefined, [expression]);
        }
        function createImportStarCallbackHelper() {
            context.requestEmitHelper(ts.importStarHelper);
            return getUnscopedHelperName("__importStar");
        }
        function createImportDefaultHelper(expression) {
            context.requestEmitHelper(ts.importDefaultHelper);
            return factory.createCallExpression(getUnscopedHelperName("__importDefault"), undefined, [expression]);
        }
        function createExportStarHelper(moduleExpression, exportsExpression) {
            if (exportsExpression === void 0) { exportsExpression = factory.createIdentifier("exports"); }
            context.requestEmitHelper(ts.exportStarHelper);
            context.requestEmitHelper(ts.createBindingHelper);
            return factory.createCallExpression(getUnscopedHelperName("__exportStar"), undefined, [moduleExpression, exportsExpression]);
        }
        function createClassPrivateFieldGetHelper(receiver, state, kind, f) {
            context.requestEmitHelper(ts.classPrivateFieldGetHelper);
            var args;
            if (!f) {
                args = [receiver, state, factory.createStringLiteral(kind)];
            }
            else {
                args = [receiver, state, factory.createStringLiteral(kind), f];
            }
            return factory.createCallExpression(getUnscopedHelperName("__classPrivateFieldGet"), undefined, args);
        }
        function createClassPrivateFieldSetHelper(receiver, state, value, kind, f) {
            context.requestEmitHelper(ts.classPrivateFieldSetHelper);
            var args;
            if (!f) {
                args = [receiver, state, value, factory.createStringLiteral(kind)];
            }
            else {
                args = [receiver, state, value, factory.createStringLiteral(kind), f];
            }
            return factory.createCallExpression(getUnscopedHelperName("__classPrivateFieldSet"), undefined, args);
        }
        function createClassPrivateFieldInHelper(state, receiver) {
            context.requestEmitHelper(ts.classPrivateFieldInHelper);
            return factory.createCallExpression(getUnscopedHelperName("__classPrivateFieldIn"), undefined, [state, receiver]);
        }
    }
    ts.createEmitHelperFactory = createEmitHelperFactory;
    function compareEmitHelpers(x, y) {
        if (x === y)
            return 0;
        if (x.priority === y.priority)
            return 0;
        if (x.priority === undefined)
            return 1;
        if (y.priority === undefined)
            return -1;
        return ts.compareValues(x.priority, y.priority);
    }
    ts.compareEmitHelpers = compareEmitHelpers;
    function helperString(input) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        return function (uniqueName) {
            var result = "";
            for (var i = 0; i < args.length; i++) {
                result += input[i];
                result += uniqueName(args[i]);
            }
            result += input[input.length - 1];
            return result;
        };
    }
    ts.helperString = helperString;
    ts.decorateHelper = {
        name: "typescript:decorate",
        importName: "__decorate",
        scoped: false,
        priority: 2,
        text: "\n            var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n                var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n                if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n                else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n                return c > 3 && r && Object.defineProperty(target, key, r), r;\n            };"
    };
    ts.metadataHelper = {
        name: "typescript:metadata",
        importName: "__metadata",
        scoped: false,
        priority: 3,
        text: "\n            var __metadata = (this && this.__metadata) || function (k, v) {\n                if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n            };"
    };
    ts.paramHelper = {
        name: "typescript:param",
        importName: "__param",
        scoped: false,
        priority: 4,
        text: "\n            var __param = (this && this.__param) || function (paramIndex, decorator) {\n                return function (target, key) { decorator(target, key, paramIndex); }\n            };"
    };
    ts.assignHelper = {
        name: "typescript:assign",
        importName: "__assign",
        scoped: false,
        priority: 1,
        text: "\n            var __assign = (this && this.__assign) || function () {\n                __assign = Object.assign || function(t) {\n                    for (var s, i = 1, n = arguments.length; i < n; i++) {\n                        s = arguments[i];\n                        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                            t[p] = s[p];\n                    }\n                    return t;\n                };\n                return __assign.apply(this, arguments);\n            };"
    };
    ts.awaitHelper = {
        name: "typescript:await",
        importName: "__await",
        scoped: false,
        text: "\n            var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }"
    };
    ts.asyncGeneratorHelper = {
        name: "typescript:asyncGenerator",
        importName: "__asyncGenerator",
        scoped: false,
        dependencies: [ts.awaitHelper],
        text: "\n            var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {\n                if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n                var g = generator.apply(thisArg, _arguments || []), i, q = [];\n                return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\n                function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\n                function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n                function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n                function fulfill(value) { resume(\"next\", value); }\n                function reject(value) { resume(\"throw\", value); }\n                function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n            };"
    };
    ts.asyncDelegator = {
        name: "typescript:asyncDelegator",
        importName: "__asyncDelegator",
        scoped: false,
        dependencies: [ts.awaitHelper],
        text: "\n            var __asyncDelegator = (this && this.__asyncDelegator) || function (o) {\n                var i, p;\n                return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\n                function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\n            };"
    };
    ts.asyncValues = {
        name: "typescript:asyncValues",
        importName: "__asyncValues",
        scoped: false,
        text: "\n            var __asyncValues = (this && this.__asyncValues) || function (o) {\n                if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n                var m = o[Symbol.asyncIterator], i;\n                return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n                function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n                function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n            };"
    };
    ts.restHelper = {
        name: "typescript:rest",
        importName: "__rest",
        scoped: false,
        text: "\n            var __rest = (this && this.__rest) || function (s, e) {\n                var t = {};\n                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n                    t[p] = s[p];\n                if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n                    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n                        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                            t[p[i]] = s[p[i]];\n                    }\n                return t;\n            };"
    };
    ts.awaiterHelper = {
        name: "typescript:awaiter",
        importName: "__awaiter",
        scoped: false,
        priority: 5,
        text: "\n            var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n                function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n                return new (P || (P = Promise))(function (resolve, reject) {\n                    function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n                    function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n                    function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n                    step((generator = generator.apply(thisArg, _arguments || [])).next());\n                });\n            };"
    };
    ts.extendsHelper = {
        name: "typescript:extends",
        importName: "__extends",
        scoped: false,
        priority: 0,
        text: "\n            var __extends = (this && this.__extends) || (function () {\n                var extendStatics = function (d, b) {\n                    extendStatics = Object.setPrototypeOf ||\n                        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n                        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n                    return extendStatics(d, b);\n                };\n\n                return function (d, b) {\n                    if (typeof b !== \"function\" && b !== null)\n                        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n                    extendStatics(d, b);\n                    function __() { this.constructor = d; }\n                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n                };\n            })();"
    };
    ts.templateObjectHelper = {
        name: "typescript:makeTemplateObject",
        importName: "__makeTemplateObject",
        scoped: false,
        priority: 0,
        text: "\n            var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {\n                if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\n                return cooked;\n            };"
    };
    ts.readHelper = {
        name: "typescript:read",
        importName: "__read",
        scoped: false,
        text: "\n            var __read = (this && this.__read) || function (o, n) {\n                var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n                if (!m) return o;\n                var i = m.call(o), r, ar = [], e;\n                try {\n                    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n                }\n                catch (error) { e = { error: error }; }\n                finally {\n                    try {\n                        if (r && !r.done && (m = i[\"return\"])) m.call(i);\n                    }\n                    finally { if (e) throw e.error; }\n                }\n                return ar;\n            };"
    };
    ts.spreadArrayHelper = {
        name: "typescript:spreadArray",
        importName: "__spreadArray",
        scoped: false,
        text: "\n            var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n                if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n                    if (ar || !(i in from)) {\n                        if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n                        ar[i] = from[i];\n                    }\n                }\n                return to.concat(ar || Array.prototype.slice.call(from));\n            };"
    };
    ts.valuesHelper = {
        name: "typescript:values",
        importName: "__values",
        scoped: false,
        text: "\n            var __values = (this && this.__values) || function(o) {\n                var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n                if (m) return m.call(o);\n                if (o && typeof o.length === \"number\") return {\n                    next: function () {\n                        if (o && i >= o.length) o = void 0;\n                        return { value: o && o[i++], done: !o };\n                    }\n                };\n                throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n            };"
    };
    ts.generatorHelper = {
        name: "typescript:generator",
        importName: "__generator",
        scoped: false,
        priority: 6,
        text: "\n            var __generator = (this && this.__generator) || function (thisArg, body) {\n                var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n                return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n                function verb(n) { return function (v) { return step([n, v]); }; }\n                function step(op) {\n                    if (f) throw new TypeError(\"Generator is already executing.\");\n                    while (_) try {\n                        if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n                        if (y = 0, t) op = [op[0] & 2, t.value];\n                        switch (op[0]) {\n                            case 0: case 1: t = op; break;\n                            case 4: _.label++; return { value: op[1], done: false };\n                            case 5: _.label++; y = op[1]; op = [0]; continue;\n                            case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                            default:\n                                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                                if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                                if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                                if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                                if (t[2]) _.ops.pop();\n                                _.trys.pop(); continue;\n                        }\n                        op = body.call(thisArg, _);\n                    } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n                    if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n                }\n            };"
    };
    ts.createBindingHelper = {
        name: "typescript:commonjscreatebinding",
        importName: "__createBinding",
        scoped: false,
        priority: 1,
        text: "\n            var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n                if (k2 === undefined) k2 = k;\n                var desc = Object.getOwnPropertyDescriptor(m, k);\n                if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n                  desc = { enumerable: true, get: function() { return m[k]; } };\n                }\n                Object.defineProperty(o, k2, desc);\n            }) : (function(o, m, k, k2) {\n                if (k2 === undefined) k2 = k;\n                o[k2] = m[k];\n            }));"
    };
    ts.setModuleDefaultHelper = {
        name: "typescript:commonjscreatevalue",
        importName: "__setModuleDefault",
        scoped: false,
        priority: 1,
        text: "\n            var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n                Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n            }) : function(o, v) {\n                o[\"default\"] = v;\n            });"
    };
    ts.importStarHelper = {
        name: "typescript:commonjsimportstar",
        importName: "__importStar",
        scoped: false,
        dependencies: [ts.createBindingHelper, ts.setModuleDefaultHelper],
        priority: 2,
        text: "\n            var __importStar = (this && this.__importStar) || function (mod) {\n                if (mod && mod.__esModule) return mod;\n                var result = {};\n                if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n                __setModuleDefault(result, mod);\n                return result;\n            };"
    };
    ts.importDefaultHelper = {
        name: "typescript:commonjsimportdefault",
        importName: "__importDefault",
        scoped: false,
        text: "\n            var __importDefault = (this && this.__importDefault) || function (mod) {\n                return (mod && mod.__esModule) ? mod : { \"default\": mod };\n            };"
    };
    ts.exportStarHelper = {
        name: "typescript:export-star",
        importName: "__exportStar",
        scoped: false,
        dependencies: [ts.createBindingHelper],
        priority: 2,
        text: "\n            var __exportStar = (this && this.__exportStar) || function(m, exports) {\n                for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n            };"
    };
    ts.classPrivateFieldGetHelper = {
        name: "typescript:classPrivateFieldGet",
        importName: "__classPrivateFieldGet",
        scoped: false,
        text: "\n            var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n                if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n                if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n                return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n            };"
    };
    ts.classPrivateFieldSetHelper = {
        name: "typescript:classPrivateFieldSet",
        importName: "__classPrivateFieldSet",
        scoped: false,
        text: "\n            var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n                if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n                if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n                if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n                return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n            };"
    };
    ts.classPrivateFieldInHelper = {
        name: "typescript:classPrivateFieldIn",
        importName: "__classPrivateFieldIn",
        scoped: false,
        text: "\n            var __classPrivateFieldIn = (this && this.__classPrivateFieldIn) || function(state, receiver) {\n                if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\n                return typeof state === \"function\" ? receiver === state : state.has(receiver);\n            };"
    };
    var allUnscopedEmitHelpers;
    function getAllUnscopedEmitHelpers() {
        return allUnscopedEmitHelpers || (allUnscopedEmitHelpers = ts.arrayToMap([
            ts.decorateHelper,
            ts.metadataHelper,
            ts.paramHelper,
            ts.assignHelper,
            ts.awaitHelper,
            ts.asyncGeneratorHelper,
            ts.asyncDelegator,
            ts.asyncValues,
            ts.restHelper,
            ts.awaiterHelper,
            ts.extendsHelper,
            ts.templateObjectHelper,
            ts.spreadArrayHelper,
            ts.valuesHelper,
            ts.readHelper,
            ts.generatorHelper,
            ts.importStarHelper,
            ts.importDefaultHelper,
            ts.exportStarHelper,
            ts.classPrivateFieldGetHelper,
            ts.classPrivateFieldSetHelper,
            ts.classPrivateFieldInHelper,
            ts.createBindingHelper,
            ts.setModuleDefaultHelper
        ], function (helper) { return helper.name; }));
    }
    ts.getAllUnscopedEmitHelpers = getAllUnscopedEmitHelpers;
    ts.asyncSuperHelper = {
        name: "typescript:async-super",
        scoped: true,
        text: helperString(__makeTemplateObject(["\n            const ", " = name => super[name];"], ["\n            const ", " = name => super[name];"]), "_superIndex")
    };
    ts.advancedAsyncSuperHelper = {
        name: "typescript:advanced-async-super",
        scoped: true,
        text: helperString(__makeTemplateObject(["\n            const ", " = (function (geti, seti) {\n                const cache = Object.create(null);\n                return name => cache[name] || (cache[name] = { get value() { return geti(name); }, set value(v) { seti(name, v); } });\n            })(name => super[name], (name, value) => super[name] = value);"], ["\n            const ", " = (function (geti, seti) {\n                const cache = Object.create(null);\n                return name => cache[name] || (cache[name] = { get value() { return geti(name); }, set value(v) { seti(name, v); } });\n            })(name => super[name], (name, value) => super[name] = value);"]), "_superIndex")
    };
    function isCallToHelper(firstSegment, helperName) {
        return ts.isCallExpression(firstSegment)
            && ts.isIdentifier(firstSegment.expression)
            && (ts.getEmitFlags(firstSegment.expression) & 4096) !== 0
            && firstSegment.expression.escapedText === helperName;
    }
    ts.isCallToHelper = isCallToHelper;
})(ts || (ts = {}));
var ts;
(function (ts) {
    function isNumericLiteral(node) {
        return node.kind === 8;
    }
    ts.isNumericLiteral = isNumericLiteral;
    function isBigIntLiteral(node) {
        return node.kind === 9;
    }
    ts.isBigIntLiteral = isBigIntLiteral;
    function isStringLiteral(node) {
        return node.kind === 10;
    }
    ts.isStringLiteral = isStringLiteral;
    function isJsxText(node) {
        return node.kind === 11;
    }
    ts.isJsxText = isJsxText;
    function isRegularExpressionLiteral(node) {
        return node.kind === 13;
    }
    ts.isRegularExpressionLiteral = isRegularExpressionLiteral;
    function isNoSubstitutionTemplateLiteral(node) {
        return node.kind === 14;
    }
    ts.isNoSubstitutionTemplateLiteral = isNoSubstitutionTemplateLiteral;
    function isTemplateHead(node) {
        return node.kind === 15;
    }
    ts.isTemplateHead = isTemplateHead;
    function isTemplateMiddle(node) {
        return node.kind === 16;
    }
    ts.isTemplateMiddle = isTemplateMiddle;
    function isTemplateTail(node) {
        return node.kind === 17;
    }
    ts.isTemplateTail = isTemplateTail;
    function isDotDotDotToken(node) {
        return node.kind === 25;
    }
    ts.isDotDotDotToken = isDotDotDotToken;
    function isCommaToken(node) {
        return node.kind === 27;
    }
    ts.isCommaToken = isCommaToken;
    function isPlusToken(node) {
        return node.kind === 39;
    }
    ts.isPlusToken = isPlusToken;
    function isMinusToken(node) {
        return node.kind === 40;
    }
    ts.isMinusToken = isMinusToken;
    function isAsteriskToken(node) {
        return node.kind === 41;
    }
    ts.isAsteriskToken = isAsteriskToken;
    function isExclamationToken(node) {
        return node.kind === 53;
    }
    ts.isExclamationToken = isExclamationToken;
    function isQuestionToken(node) {
        return node.kind === 57;
    }
    ts.isQuestionToken = isQuestionToken;
    function isColonToken(node) {
        return node.kind === 58;
    }
    ts.isColonToken = isColonToken;
    function isQuestionDotToken(node) {
        return node.kind === 28;
    }
    ts.isQuestionDotToken = isQuestionDotToken;
    function isEqualsGreaterThanToken(node) {
        return node.kind === 38;
    }
    ts.isEqualsGreaterThanToken = isEqualsGreaterThanToken;
    function isIdentifier(node) {
        return node.kind === 79;
    }
    ts.isIdentifier = isIdentifier;
    function isPrivateIdentifier(node) {
        return node.kind === 80;
    }
    ts.isPrivateIdentifier = isPrivateIdentifier;
    function isExportModifier(node) {
        return node.kind === 93;
    }
    ts.isExportModifier = isExportModifier;
    function isAsyncModifier(node) {
        return node.kind === 131;
    }
    ts.isAsyncModifier = isAsyncModifier;
    function isAssertsKeyword(node) {
        return node.kind === 128;
    }
    ts.isAssertsKeyword = isAssertsKeyword;
    function isAwaitKeyword(node) {
        return node.kind === 132;
    }
    ts.isAwaitKeyword = isAwaitKeyword;
    function isReadonlyKeyword(node) {
        return node.kind === 145;
    }
    ts.isReadonlyKeyword = isReadonlyKeyword;
    function isStaticModifier(node) {
        return node.kind === 124;
    }
    ts.isStaticModifier = isStaticModifier;
    function isAbstractModifier(node) {
        return node.kind === 126;
    }
    ts.isAbstractModifier = isAbstractModifier;
    function isSuperKeyword(node) {
        return node.kind === 106;
    }
    ts.isSuperKeyword = isSuperKeyword;
    function isImportKeyword(node) {
        return node.kind === 100;
    }
    ts.isImportKeyword = isImportKeyword;
    function isQualifiedName(node) {
        return node.kind === 161;
    }
    ts.isQualifiedName = isQualifiedName;
    function isComputedPropertyName(node) {
        return node.kind === 162;
    }
    ts.isComputedPropertyName = isComputedPropertyName;
    function isTypeParameterDeclaration(node) {
        return node.kind === 163;
    }
    ts.isTypeParameterDeclaration = isTypeParameterDeclaration;
    function isParameter(node) {
        return node.kind === 164;
    }
    ts.isParameter = isParameter;
    function isDecorator(node) {
        return node.kind === 165;
    }
    ts.isDecorator = isDecorator;
    function isPropertySignature(node) {
        return node.kind === 166;
    }
    ts.isPropertySignature = isPropertySignature;
    function isPropertyDeclaration(node) {
        return node.kind === 167;
    }
    ts.isPropertyDeclaration = isPropertyDeclaration;
    function isMethodSignature(node) {
        return node.kind === 168;
    }
    ts.isMethodSignature = isMethodSignature;
    function isMethodDeclaration(node) {
        return node.kind === 169;
    }
    ts.isMethodDeclaration = isMethodDeclaration;
    function isClassStaticBlockDeclaration(node) {
        return node.kind === 170;
    }
    ts.isClassStaticBlockDeclaration = isClassStaticBlockDeclaration;
    function isConstructorDeclaration(node) {
        return node.kind === 171;
    }
    ts.isConstructorDeclaration = isConstructorDeclaration;
    function isGetAccessorDeclaration(node) {
        return node.kind === 172;
    }
    ts.isGetAccessorDeclaration = isGetAccessorDeclaration;
    function isSetAccessorDeclaration(node) {
        return node.kind === 173;
    }
    ts.isSetAccessorDeclaration = isSetAccessorDeclaration;
    function isCallSignatureDeclaration(node) {
        return node.kind === 174;
    }
    ts.isCallSignatureDeclaration = isCallSignatureDeclaration;
    function isConstructSignatureDeclaration(node) {
        return node.kind === 175;
    }
    ts.isConstructSignatureDeclaration = isConstructSignatureDeclaration;
    function isIndexSignatureDeclaration(node) {
        return node.kind === 176;
    }
    ts.isIndexSignatureDeclaration = isIndexSignatureDeclaration;
    function isTypePredicateNode(node) {
        return node.kind === 177;
    }
    ts.isTypePredicateNode = isTypePredicateNode;
    function isTypeReferenceNode(node) {
        return node.kind === 178;
    }
    ts.isTypeReferenceNode = isTypeReferenceNode;
    function isFunctionTypeNode(node) {
        return node.kind === 179;
    }
    ts.isFunctionTypeNode = isFunctionTypeNode;
    function isConstructorTypeNode(node) {
        return node.kind === 180;
    }
    ts.isConstructorTypeNode = isConstructorTypeNode;
    function isTypeQueryNode(node) {
        return node.kind === 181;
    }
    ts.isTypeQueryNode = isTypeQueryNode;
    function isTypeLiteralNode(node) {
        return node.kind === 182;
    }
    ts.isTypeLiteralNode = isTypeLiteralNode;
    function isArrayTypeNode(node) {
        return node.kind === 183;
    }
    ts.isArrayTypeNode = isArrayTypeNode;
    function isTupleTypeNode(node) {
        return node.kind === 184;
    }
    ts.isTupleTypeNode = isTupleTypeNode;
    function isNamedTupleMember(node) {
        return node.kind === 197;
    }
    ts.isNamedTupleMember = isNamedTupleMember;
    function isOptionalTypeNode(node) {
        return node.kind === 185;
    }
    ts.isOptionalTypeNode = isOptionalTypeNode;
    function isRestTypeNode(node) {
        return node.kind === 186;
    }
    ts.isRestTypeNode = isRestTypeNode;
    function isUnionTypeNode(node) {
        return node.kind === 187;
    }
    ts.isUnionTypeNode = isUnionTypeNode;
    function isIntersectionTypeNode(node) {
        return node.kind === 188;
    }
    ts.isIntersectionTypeNode = isIntersectionTypeNode;
    function isConditionalTypeNode(node) {
        return node.kind === 189;
    }
    ts.isConditionalTypeNode = isConditionalTypeNode;
    function isInferTypeNode(node) {
        return node.kind === 190;
    }
    ts.isInferTypeNode = isInferTypeNode;
    function isParenthesizedTypeNode(node) {
        return node.kind === 191;
    }
    ts.isParenthesizedTypeNode = isParenthesizedTypeNode;
    function isThisTypeNode(node) {
        return node.kind === 192;
    }
    ts.isThisTypeNode = isThisTypeNode;
    function isTypeOperatorNode(node) {
        return node.kind === 193;
    }
    ts.isTypeOperatorNode = isTypeOperatorNode;
    function isIndexedAccessTypeNode(node) {
        return node.kind === 194;
    }
    ts.isIndexedAccessTypeNode = isIndexedAccessTypeNode;
    function isMappedTypeNode(node) {
        return node.kind === 195;
    }
    ts.isMappedTypeNode = isMappedTypeNode;
    function isLiteralTypeNode(node) {
        return node.kind === 196;
    }
    ts.isLiteralTypeNode = isLiteralTypeNode;
    function isImportTypeNode(node) {
        return node.kind === 200;
    }
    ts.isImportTypeNode = isImportTypeNode;
    function isTemplateLiteralTypeSpan(node) {
        return node.kind === 199;
    }
    ts.isTemplateLiteralTypeSpan = isTemplateLiteralTypeSpan;
    function isTemplateLiteralTypeNode(node) {
        return node.kind === 198;
    }
    ts.isTemplateLiteralTypeNode = isTemplateLiteralTypeNode;
    function isObjectBindingPattern(node) {
        return node.kind === 201;
    }
    ts.isObjectBindingPattern = isObjectBindingPattern;
    function isArrayBindingPattern(node) {
        return node.kind === 202;
    }
    ts.isArrayBindingPattern = isArrayBindingPattern;
    function isBindingElement(node) {
        return node.kind === 203;
    }
    ts.isBindingElement = isBindingElement;
    function isArrayLiteralExpression(node) {
        return node.kind === 204;
    }
    ts.isArrayLiteralExpression = isArrayLiteralExpression;
    function isObjectLiteralExpression(node) {
        return node.kind === 205;
    }
    ts.isObjectLiteralExpression = isObjectLiteralExpression;
    function isPropertyAccessExpression(node) {
        return node.kind === 206;
    }
    ts.isPropertyAccessExpression = isPropertyAccessExpression;
    function isElementAccessExpression(node) {
        return node.kind === 207;
    }
    ts.isElementAccessExpression = isElementAccessExpression;
    function isCallExpression(node) {
        return node.kind === 208;
    }
    ts.isCallExpression = isCallExpression;
    function isNewExpression(node) {
        return node.kind === 209;
    }
    ts.isNewExpression = isNewExpression;
    function isTaggedTemplateExpression(node) {
        return node.kind === 210;
    }
    ts.isTaggedTemplateExpression = isTaggedTemplateExpression;
    function isTypeAssertionExpression(node) {
        return node.kind === 211;
    }
    ts.isTypeAssertionExpression = isTypeAssertionExpression;
    function isParenthesizedExpression(node) {
        return node.kind === 212;
    }
    ts.isParenthesizedExpression = isParenthesizedExpression;
    function isFunctionExpression(node) {
        return node.kind === 213;
    }
    ts.isFunctionExpression = isFunctionExpression;
    function isArrowFunction(node) {
        return node.kind === 214;
    }
    ts.isArrowFunction = isArrowFunction;
    function isDeleteExpression(node) {
        return node.kind === 215;
    }
    ts.isDeleteExpression = isDeleteExpression;
    function isTypeOfExpression(node) {
        return node.kind === 216;
    }
    ts.isTypeOfExpression = isTypeOfExpression;
    function isVoidExpression(node) {
        return node.kind === 217;
    }
    ts.isVoidExpression = isVoidExpression;
    function isAwaitExpression(node) {
        return node.kind === 218;
    }
    ts.isAwaitExpression = isAwaitExpression;
    function isPrefixUnaryExpression(node) {
        return node.kind === 219;
    }
    ts.isPrefixUnaryExpression = isPrefixUnaryExpression;
    function isPostfixUnaryExpression(node) {
        return node.kind === 220;
    }
    ts.isPostfixUnaryExpression = isPostfixUnaryExpression;
    function isBinaryExpression(node) {
        return node.kind === 221;
    }
    ts.isBinaryExpression = isBinaryExpression;
    function isConditionalExpression(node) {
        return node.kind === 222;
    }
    ts.isConditionalExpression = isConditionalExpression;
    function isTemplateExpression(node) {
        return node.kind === 223;
    }
    ts.isTemplateExpression = isTemplateExpression;
    function isYieldExpression(node) {
        return node.kind === 224;
    }
    ts.isYieldExpression = isYieldExpression;
    function isSpreadElement(node) {
        return node.kind === 225;
    }
    ts.isSpreadElement = isSpreadElement;
    function isClassExpression(node) {
        return node.kind === 226;
    }
    ts.isClassExpression = isClassExpression;
    function isOmittedExpression(node) {
        return node.kind === 227;
    }
    ts.isOmittedExpression = isOmittedExpression;
    function isExpressionWithTypeArguments(node) {
        return node.kind === 228;
    }
    ts.isExpressionWithTypeArguments = isExpressionWithTypeArguments;
    function isAsExpression(node) {
        return node.kind === 229;
    }
    ts.isAsExpression = isAsExpression;
    function isNonNullExpression(node) {
        return node.kind === 230;
    }
    ts.isNonNullExpression = isNonNullExpression;
    function isMetaProperty(node) {
        return node.kind === 231;
    }
    ts.isMetaProperty = isMetaProperty;
    function isSyntheticExpression(node) {
        return node.kind === 232;
    }
    ts.isSyntheticExpression = isSyntheticExpression;
    function isPartiallyEmittedExpression(node) {
        return node.kind === 350;
    }
    ts.isPartiallyEmittedExpression = isPartiallyEmittedExpression;
    function isCommaListExpression(node) {
        return node.kind === 351;
    }
    ts.isCommaListExpression = isCommaListExpression;
    function isTemplateSpan(node) {
        return node.kind === 233;
    }
    ts.isTemplateSpan = isTemplateSpan;
    function isSemicolonClassElement(node) {
        return node.kind === 234;
    }
    ts.isSemicolonClassElement = isSemicolonClassElement;
    function isBlock(node) {
        return node.kind === 235;
    }
    ts.isBlock = isBlock;
    function isVariableStatement(node) {
        return node.kind === 237;
    }
    ts.isVariableStatement = isVariableStatement;
    function isEmptyStatement(node) {
        return node.kind === 236;
    }
    ts.isEmptyStatement = isEmptyStatement;
    function isExpressionStatement(node) {
        return node.kind === 238;
    }
    ts.isExpressionStatement = isExpressionStatement;
    function isIfStatement(node) {
        return node.kind === 239;
    }
    ts.isIfStatement = isIfStatement;
    function isDoStatement(node) {
        return node.kind === 240;
    }
    ts.isDoStatement = isDoStatement;
    function isWhileStatement(node) {
        return node.kind === 241;
    }
    ts.isWhileStatement = isWhileStatement;
    function isForStatement(node) {
        return node.kind === 242;
    }
    ts.isForStatement = isForStatement;
    function isForInStatement(node) {
        return node.kind === 243;
    }
    ts.isForInStatement = isForInStatement;
    function isForOfStatement(node) {
        return node.kind === 244;
    }
    ts.isForOfStatement = isForOfStatement;
    function isContinueStatement(node) {
        return node.kind === 245;
    }
    ts.isContinueStatement = isContinueStatement;
    function isBreakStatement(node) {
        return node.kind === 246;
    }
    ts.isBreakStatement = isBreakStatement;
    function isReturnStatement(node) {
        return node.kind === 247;
    }
    ts.isReturnStatement = isReturnStatement;
    function isWithStatement(node) {
        return node.kind === 248;
    }
    ts.isWithStatement = isWithStatement;
    function isSwitchStatement(node) {
        return node.kind === 249;
    }
    ts.isSwitchStatement = isSwitchStatement;
    function isLabeledStatement(node) {
        return node.kind === 250;
    }
    ts.isLabeledStatement = isLabeledStatement;
    function isThrowStatement(node) {
        return node.kind === 251;
    }
    ts.isThrowStatement = isThrowStatement;
    function isTryStatement(node) {
        return node.kind === 252;
    }
    ts.isTryStatement = isTryStatement;
    function isDebuggerStatement(node) {
        return node.kind === 253;
    }
    ts.isDebuggerStatement = isDebuggerStatement;
    function isVariableDeclaration(node) {
        return node.kind === 254;
    }
    ts.isVariableDeclaration = isVariableDeclaration;
    function isVariableDeclarationList(node) {
        return node.kind === 255;
    }
    ts.isVariableDeclarationList = isVariableDeclarationList;
    function isFunctionDeclaration(node) {
        return node.kind === 256;
    }
    ts.isFunctionDeclaration = isFunctionDeclaration;
    function isClassDeclaration(node) {
        return node.kind === 257;
    }
    ts.isClassDeclaration = isClassDeclaration;
    function isInterfaceDeclaration(node) {
        return node.kind === 258;
    }
    ts.isInterfaceDeclaration = isInterfaceDeclaration;
    function isTypeAliasDeclaration(node) {
        return node.kind === 259;
    }
    ts.isTypeAliasDeclaration = isTypeAliasDeclaration;
    function isEnumDeclaration(node) {
        return node.kind === 260;
    }
    ts.isEnumDeclaration = isEnumDeclaration;
    function isModuleDeclaration(node) {
        return node.kind === 261;
    }
    ts.isModuleDeclaration = isModuleDeclaration;
    function isModuleBlock(node) {
        return node.kind === 262;
    }
    ts.isModuleBlock = isModuleBlock;
    function isCaseBlock(node) {
        return node.kind === 263;
    }
    ts.isCaseBlock = isCaseBlock;
    function isNamespaceExportDeclaration(node) {
        return node.kind === 264;
    }
    ts.isNamespaceExportDeclaration = isNamespaceExportDeclaration;
    function isImportEqualsDeclaration(node) {
        return node.kind === 265;
    }
    ts.isImportEqualsDeclaration = isImportEqualsDeclaration;
    function isImportDeclaration(node) {
        return node.kind === 266;
    }
    ts.isImportDeclaration = isImportDeclaration;
    function isImportClause(node) {
        return node.kind === 267;
    }
    ts.isImportClause = isImportClause;
    function isImportTypeAssertionContainer(node) {
        return node.kind === 295;
    }
    ts.isImportTypeAssertionContainer = isImportTypeAssertionContainer;
    function isAssertClause(node) {
        return node.kind === 293;
    }
    ts.isAssertClause = isAssertClause;
    function isAssertEntry(node) {
        return node.kind === 294;
    }
    ts.isAssertEntry = isAssertEntry;
    function isNamespaceImport(node) {
        return node.kind === 268;
    }
    ts.isNamespaceImport = isNamespaceImport;
    function isNamespaceExport(node) {
        return node.kind === 274;
    }
    ts.isNamespaceExport = isNamespaceExport;
    function isNamedImports(node) {
        return node.kind === 269;
    }
    ts.isNamedImports = isNamedImports;
    function isImportSpecifier(node) {
        return node.kind === 270;
    }
    ts.isImportSpecifier = isImportSpecifier;
    function isExportAssignment(node) {
        return node.kind === 271;
    }
    ts.isExportAssignment = isExportAssignment;
    function isExportDeclaration(node) {
        return node.kind === 272;
    }
    ts.isExportDeclaration = isExportDeclaration;
    function isNamedExports(node) {
        return node.kind === 273;
    }
    ts.isNamedExports = isNamedExports;
    function isExportSpecifier(node) {
        return node.kind === 275;
    }
    ts.isExportSpecifier = isExportSpecifier;
    function isMissingDeclaration(node) {
        return node.kind === 276;
    }
    ts.isMissingDeclaration = isMissingDeclaration;
    function isNotEmittedStatement(node) {
        return node.kind === 349;
    }
    ts.isNotEmittedStatement = isNotEmittedStatement;
    function isSyntheticReference(node) {
        return node.kind === 354;
    }
    ts.isSyntheticReference = isSyntheticReference;
    function isMergeDeclarationMarker(node) {
        return node.kind === 352;
    }
    ts.isMergeDeclarationMarker = isMergeDeclarationMarker;
    function isEndOfDeclarationMarker(node) {
        return node.kind === 353;
    }
    ts.isEndOfDeclarationMarker = isEndOfDeclarationMarker;
    function isExternalModuleReference(node) {
        return node.kind === 277;
    }
    ts.isExternalModuleReference = isExternalModuleReference;
    function isJsxElement(node) {
        return node.kind === 278;
    }
    ts.isJsxElement = isJsxElement;
    function isJsxSelfClosingElement(node) {
        return node.kind === 279;
    }
    ts.isJsxSelfClosingElement = isJsxSelfClosingElement;
    function isJsxOpeningElement(node) {
        return node.kind === 280;
    }
    ts.isJsxOpeningElement = isJsxOpeningElement;
    function isJsxClosingElement(node) {
        return node.kind === 281;
    }
    ts.isJsxClosingElement = isJsxClosingElement;
    function isJsxFragment(node) {
        return node.kind === 282;
    }
    ts.isJsxFragment = isJsxFragment;
    function isJsxOpeningFragment(node) {
        return node.kind === 283;
    }
    ts.isJsxOpeningFragment = isJsxOpeningFragment;
    function isJsxClosingFragment(node) {
        return node.kind === 284;
    }
    ts.isJsxClosingFragment = isJsxClosingFragment;
    function isJsxAttribute(node) {
        return node.kind === 285;
    }
    ts.isJsxAttribute = isJsxAttribute;
    function isJsxAttributes(node) {
        return node.kind === 286;
    }
    ts.isJsxAttributes = isJsxAttributes;
    function isJsxSpreadAttribute(node) {
        return node.kind === 287;
    }
    ts.isJsxSpreadAttribute = isJsxSpreadAttribute;
    function isJsxExpression(node) {
        return node.kind === 288;
    }
    ts.isJsxExpression = isJsxExpression;
    function isCaseClause(node) {
        return node.kind === 289;
    }
    ts.isCaseClause = isCaseClause;
    function isDefaultClause(node) {
        return node.kind === 290;
    }
    ts.isDefaultClause = isDefaultClause;
    function isHeritageClause(node) {
        return node.kind === 291;
    }
    ts.isHeritageClause = isHeritageClause;
    function isCatchClause(node) {
        return node.kind === 292;
    }
    ts.isCatchClause = isCatchClause;
    function isPropertyAssignment(node) {
        return node.kind === 296;
    }
    ts.isPropertyAssignment = isPropertyAssignment;
    function isShorthandPropertyAssignment(node) {
        return node.kind === 297;
    }
    ts.isShorthandPropertyAssignment = isShorthandPropertyAssignment;
    function isSpreadAssignment(node) {
        return node.kind === 298;
    }
    ts.isSpreadAssignment = isSpreadAssignment;
    function isEnumMember(node) {
        return node.kind === 299;
    }
    ts.isEnumMember = isEnumMember;
    function isUnparsedPrepend(node) {
        return node.kind === 301;
    }
    ts.isUnparsedPrepend = isUnparsedPrepend;
    function isSourceFile(node) {
        return node.kind === 305;
    }
    ts.isSourceFile = isSourceFile;
    function isBundle(node) {
        return node.kind === 306;
    }
    ts.isBundle = isBundle;
    function isUnparsedSource(node) {
        return node.kind === 307;
    }
    ts.isUnparsedSource = isUnparsedSource;
    function isJSDocTypeExpression(node) {
        return node.kind === 309;
    }
    ts.isJSDocTypeExpression = isJSDocTypeExpression;
    function isJSDocNameReference(node) {
        return node.kind === 310;
    }
    ts.isJSDocNameReference = isJSDocNameReference;
    function isJSDocMemberName(node) {
        return node.kind === 311;
    }
    ts.isJSDocMemberName = isJSDocMemberName;
    function isJSDocLink(node) {
        return node.kind === 324;
    }
    ts.isJSDocLink = isJSDocLink;
    function isJSDocLinkCode(node) {
        return node.kind === 325;
    }
    ts.isJSDocLinkCode = isJSDocLinkCode;
    function isJSDocLinkPlain(node) {
        return node.kind === 326;
    }
    ts.isJSDocLinkPlain = isJSDocLinkPlain;
    function isJSDocAllType(node) {
        return node.kind === 312;
    }
    ts.isJSDocAllType = isJSDocAllType;
    function isJSDocUnknownType(node) {
        return node.kind === 313;
    }
    ts.isJSDocUnknownType = isJSDocUnknownType;
    function isJSDocNullableType(node) {
        return node.kind === 314;
    }
    ts.isJSDocNullableType = isJSDocNullableType;
    function isJSDocNonNullableType(node) {
        return node.kind === 315;
    }
    ts.isJSDocNonNullableType = isJSDocNonNullableType;
    function isJSDocOptionalType(node) {
        return node.kind === 316;
    }
    ts.isJSDocOptionalType = isJSDocOptionalType;
    function isJSDocFunctionType(node) {
        return node.kind === 317;
    }
    ts.isJSDocFunctionType = isJSDocFunctionType;
    function isJSDocVariadicType(node) {
        return node.kind === 318;
    }
    ts.isJSDocVariadicType = isJSDocVariadicType;
    function isJSDocNamepathType(node) {
        return node.kind === 319;
    }
    ts.isJSDocNamepathType = isJSDocNamepathType;
    function isJSDoc(node) {
        return node.kind === 320;
    }
    ts.isJSDoc = isJSDoc;
    function isJSDocTypeLiteral(node) {
        return node.kind === 322;
    }
    ts.isJSDocTypeLiteral = isJSDocTypeLiteral;
    function isJSDocSignature(node) {
        return node.kind === 323;
    }
    ts.isJSDocSignature = isJSDocSignature;
    function isJSDocAugmentsTag(node) {
        return node.kind === 328;
    }
    ts.isJSDocAugmentsTag = isJSDocAugmentsTag;
    function isJSDocAuthorTag(node) {
        return node.kind === 330;
    }
    ts.isJSDocAuthorTag = isJSDocAuthorTag;
    function isJSDocClassTag(node) {
        return node.kind === 332;
    }
    ts.isJSDocClassTag = isJSDocClassTag;
    function isJSDocCallbackTag(node) {
        return node.kind === 338;
    }
    ts.isJSDocCallbackTag = isJSDocCallbackTag;
    function isJSDocPublicTag(node) {
        return node.kind === 333;
    }
    ts.isJSDocPublicTag = isJSDocPublicTag;
    function isJSDocPrivateTag(node) {
        return node.kind === 334;
    }
    ts.isJSDocPrivateTag = isJSDocPrivateTag;
    function isJSDocProtectedTag(node) {
        return node.kind === 335;
    }
    ts.isJSDocProtectedTag = isJSDocProtectedTag;
    function isJSDocReadonlyTag(node) {
        return node.kind === 336;
    }
    ts.isJSDocReadonlyTag = isJSDocReadonlyTag;
    function isJSDocOverrideTag(node) {
        return node.kind === 337;
    }
    ts.isJSDocOverrideTag = isJSDocOverrideTag;
    function isJSDocDeprecatedTag(node) {
        return node.kind === 331;
    }
    ts.isJSDocDeprecatedTag = isJSDocDeprecatedTag;
    function isJSDocSeeTag(node) {
        return node.kind === 346;
    }
    ts.isJSDocSeeTag = isJSDocSeeTag;
    function isJSDocEnumTag(node) {
        return node.kind === 339;
    }
    ts.isJSDocEnumTag = isJSDocEnumTag;
    function isJSDocParameterTag(node) {
        return node.kind === 340;
    }
    ts.isJSDocParameterTag = isJSDocParameterTag;
    function isJSDocReturnTag(node) {
        return node.kind === 341;
    }
    ts.isJSDocReturnTag = isJSDocReturnTag;
    function isJSDocThisTag(node) {
        return node.kind === 342;
    }
    ts.isJSDocThisTag = isJSDocThisTag;
    function isJSDocTypeTag(node) {
        return node.kind === 343;
    }
    ts.isJSDocTypeTag = isJSDocTypeTag;
    function isJSDocTemplateTag(node) {
        return node.kind === 344;
    }
    ts.isJSDocTemplateTag = isJSDocTemplateTag;
    function isJSDocTypedefTag(node) {
        return node.kind === 345;
    }
    ts.isJSDocTypedefTag = isJSDocTypedefTag;
    function isJSDocUnknownTag(node) {
        return node.kind === 327;
    }
    ts.isJSDocUnknownTag = isJSDocUnknownTag;
    function isJSDocPropertyTag(node) {
        return node.kind === 347;
    }
    ts.isJSDocPropertyTag = isJSDocPropertyTag;
    function isJSDocImplementsTag(node) {
        return node.kind === 329;
    }
    ts.isJSDocImplementsTag = isJSDocImplementsTag;
    function isSyntaxList(n) {
        return n.kind === 348;
    }
    ts.isSyntaxList = isSyntaxList;
})(ts || (ts = {}));
var ts;
(function (ts) {
    function createEmptyExports(factory) {
        return factory.createExportDeclaration(undefined, undefined, false, factory.createNamedExports([]), undefined);
    }
    ts.createEmptyExports = createEmptyExports;
    function createMemberAccessForPropertyName(factory, target, memberName, location) {
        if (ts.isComputedPropertyName(memberName)) {
            return ts.setTextRange(factory.createElementAccessExpression(target, memberName.expression), location);
        }
        else {
            var expression = ts.setTextRange(ts.isMemberName(memberName)
                ? factory.createPropertyAccessExpression(target, memberName)
                : factory.createElementAccessExpression(target, memberName), memberName);
            ts.getOrCreateEmitNode(expression).flags |= 64;
            return expression;
        }
    }
    ts.createMemberAccessForPropertyName = createMemberAccessForPropertyName;
    function createReactNamespace(reactNamespace, parent) {
        var react = ts.parseNodeFactory.createIdentifier(reactNamespace || "React");
        ts.setParent(react, ts.getParseTreeNode(parent));
        return react;
    }
    function createJsxFactoryExpressionFromEntityName(factory, jsxFactory, parent) {
        if (ts.isQualifiedName(jsxFactory)) {
            var left = createJsxFactoryExpressionFromEntityName(factory, jsxFactory.left, parent);
            var right = factory.createIdentifier(ts.idText(jsxFactory.right));
            right.escapedText = jsxFactory.right.escapedText;
            return factory.createPropertyAccessExpression(left, right);
        }
        else {
            return createReactNamespace(ts.idText(jsxFactory), parent);
        }
    }
    function createJsxFactoryExpression(factory, jsxFactoryEntity, reactNamespace, parent) {
        return jsxFactoryEntity ?
            createJsxFactoryExpressionFromEntityName(factory, jsxFactoryEntity, parent) :
            factory.createPropertyAccessExpression(createReactNamespace(reactNamespace, parent), "createElement");
    }
    ts.createJsxFactoryExpression = createJsxFactoryExpression;
    function createJsxFragmentFactoryExpression(factory, jsxFragmentFactoryEntity, reactNamespace, parent) {
        return jsxFragmentFactoryEntity ?
            createJsxFactoryExpressionFromEntityName(factory, jsxFragmentFactoryEntity, parent) :
            factory.createPropertyAccessExpression(createReactNamespace(reactNamespace, parent), "Fragment");
    }
    function createExpressionForJsxElement(factory, callee, tagName, props, children, location) {
        var argumentsList = [tagName];
        if (props) {
            argumentsList.push(props);
        }
        if (children && children.length > 0) {
            if (!props) {
                argumentsList.push(factory.createNull());
            }
            if (children.length > 1) {
                for (var _i = 0, children_3 = children; _i < children_3.length; _i++) {
                    var child = children_3[_i];
                    startOnNewLine(child);
                    argumentsList.push(child);
                }
            }
            else {
                argumentsList.push(children[0]);
            }
        }
        return ts.setTextRange(factory.createCallExpression(callee, undefined, argumentsList), location);
    }
    ts.createExpressionForJsxElement = createExpressionForJsxElement;
    function createExpressionForJsxFragment(factory, jsxFactoryEntity, jsxFragmentFactoryEntity, reactNamespace, children, parentElement, location) {
        var tagName = createJsxFragmentFactoryExpression(factory, jsxFragmentFactoryEntity, reactNamespace, parentElement);
        var argumentsList = [tagName, factory.createNull()];
        if (children && children.length > 0) {
            if (children.length > 1) {
                for (var _i = 0, children_4 = children; _i < children_4.length; _i++) {
                    var child = children_4[_i];
                    startOnNewLine(child);
                    argumentsList.push(child);
                }
            }
            else {
                argumentsList.push(children[0]);
            }
        }
        return ts.setTextRange(factory.createCallExpression(createJsxFactoryExpression(factory, jsxFactoryEntity, reactNamespace, parentElement), undefined, argumentsList), location);
    }
    ts.createExpressionForJsxFragment = createExpressionForJsxFragment;
    function createForOfBindingStatement(factory, node, boundValue) {
        if (ts.isVariableDeclarationList(node)) {
            var firstDeclaration = ts.first(node.declarations);
            var updatedDeclaration = factory.updateVariableDeclaration(firstDeclaration, firstDeclaration.name, undefined, undefined, boundValue);
            return ts.setTextRange(factory.createVariableStatement(undefined, factory.updateVariableDeclarationList(node, [updatedDeclaration])), node);
        }
        else {
            var updatedExpression = ts.setTextRange(factory.createAssignment(node, boundValue), node);
            return ts.setTextRange(factory.createExpressionStatement(updatedExpression), node);
        }
    }
    ts.createForOfBindingStatement = createForOfBindingStatement;
    function insertLeadingStatement(factory, dest, source) {
        if (ts.isBlock(dest)) {
            return factory.updateBlock(dest, ts.setTextRange(factory.createNodeArray(__spreadArray([source], dest.statements, true)), dest.statements));
        }
        else {
            return factory.createBlock(factory.createNodeArray([dest, source]), true);
        }
    }
    ts.insertLeadingStatement = insertLeadingStatement;
    function createExpressionFromEntityName(factory, node) {
        if (ts.isQualifiedName(node)) {
            var left = createExpressionFromEntityName(factory, node.left);
            var right = ts.setParent(ts.setTextRange(factory.cloneNode(node.right), node.right), node.right.parent);
            return ts.setTextRange(factory.createPropertyAccessExpression(left, right), node);
        }
        else {
            return ts.setParent(ts.setTextRange(factory.cloneNode(node), node), node.parent);
        }
    }
    ts.createExpressionFromEntityName = createExpressionFromEntityName;
    function createExpressionForPropertyName(factory, memberName) {
        if (ts.isIdentifier(memberName)) {
            return factory.createStringLiteralFromNode(memberName);
        }
        else if (ts.isComputedPropertyName(memberName)) {
            return ts.setParent(ts.setTextRange(factory.cloneNode(memberName.expression), memberName.expression), memberName.expression.parent);
        }
        else {
            return ts.setParent(ts.setTextRange(factory.cloneNode(memberName), memberName), memberName.parent);
        }
    }
    ts.createExpressionForPropertyName = createExpressionForPropertyName;
    function createExpressionForAccessorDeclaration(factory, properties, property, receiver, multiLine) {
        var _a = ts.getAllAccessorDeclarations(properties, property), firstAccessor = _a.firstAccessor, getAccessor = _a.getAccessor, setAccessor = _a.setAccessor;
        if (property === firstAccessor) {
            return ts.setTextRange(factory.createObjectDefinePropertyCall(receiver, createExpressionForPropertyName(factory, property.name), factory.createPropertyDescriptor({
                enumerable: factory.createFalse(),
                configurable: true,
                get: getAccessor && ts.setTextRange(ts.setOriginalNode(factory.createFunctionExpression(getAccessor.modifiers, undefined, undefined, undefined, getAccessor.parameters, undefined, getAccessor.body), getAccessor), getAccessor),
                set: setAccessor && ts.setTextRange(ts.setOriginalNode(factory.createFunctionExpression(setAccessor.modifiers, undefined, undefined, undefined, setAccessor.parameters, undefined, setAccessor.body), setAccessor), setAccessor)
            }, !multiLine)), firstAccessor);
        }
        return undefined;
    }
    function createExpressionForPropertyAssignment(factory, property, receiver) {
        return ts.setOriginalNode(ts.setTextRange(factory.createAssignment(createMemberAccessForPropertyName(factory, receiver, property.name, property.name), property.initializer), property), property);
    }
    function createExpressionForShorthandPropertyAssignment(factory, property, receiver) {
        return ts.setOriginalNode(ts.setTextRange(factory.createAssignment(createMemberAccessForPropertyName(factory, receiver, property.name, property.name), factory.cloneNode(property.name)), property), property);
    }
    function createExpressionForMethodDeclaration(factory, method, receiver) {
        return ts.setOriginalNode(ts.setTextRange(factory.createAssignment(createMemberAccessForPropertyName(factory, receiver, method.name, method.name), ts.setOriginalNode(ts.setTextRange(factory.createFunctionExpression(method.modifiers, method.asteriskToken, undefined, undefined, method.parameters, undefined, method.body), method), method)), method), method);
    }
    function createExpressionForObjectLiteralElementLike(factory, node, property, receiver) {
        if (property.name && ts.isPrivateIdentifier(property.name)) {
            ts.Debug.failBadSyntaxKind(property.name, "Private identifiers are not allowed in object literals.");
        }
        switch (property.kind) {
            case 172:
            case 173:
                return createExpressionForAccessorDeclaration(factory, node.properties, property, receiver, !!node.multiLine);
            case 296:
                return createExpressionForPropertyAssignment(factory, property, receiver);
            case 297:
                return createExpressionForShorthandPropertyAssignment(factory, property, receiver);
            case 169:
                return createExpressionForMethodDeclaration(factory, property, receiver);
        }
    }
    ts.createExpressionForObjectLiteralElementLike = createExpressionForObjectLiteralElementLike;
    function expandPreOrPostfixIncrementOrDecrementExpression(factory, node, expression, recordTempVariable, resultVariable) {
        var operator = node.operator;
        ts.Debug.assert(operator === 45 || operator === 46, "Expected 'node' to be a pre- or post-increment or pre- or post-decrement expression");
        var temp = factory.createTempVariable(recordTempVariable);
        expression = factory.createAssignment(temp, expression);
        ts.setTextRange(expression, node.operand);
        var operation = ts.isPrefixUnaryExpression(node) ?
            factory.createPrefixUnaryExpression(operator, temp) :
            factory.createPostfixUnaryExpression(temp, operator);
        ts.setTextRange(operation, node);
        if (resultVariable) {
            operation = factory.createAssignment(resultVariable, operation);
            ts.setTextRange(operation, node);
        }
        expression = factory.createComma(expression, operation);
        ts.setTextRange(expression, node);
        if (ts.isPostfixUnaryExpression(node)) {
            expression = factory.createComma(expression, temp);
            ts.setTextRange(expression, node);
        }
        return expression;
    }
    ts.expandPreOrPostfixIncrementOrDecrementExpression = expandPreOrPostfixIncrementOrDecrementExpression;
    function isInternalName(node) {
        return (ts.getEmitFlags(node) & 32768) !== 0;
    }
    ts.isInternalName = isInternalName;
    function isLocalName(node) {
        return (ts.getEmitFlags(node) & 16384) !== 0;
    }
    ts.isLocalName = isLocalName;
    function isExportName(node) {
        return (ts.getEmitFlags(node) & 8192) !== 0;
    }
    ts.isExportName = isExportName;
    function isUseStrictPrologue(node) {
        return ts.isStringLiteral(node.expression) && node.expression.text === "use strict";
    }
    function findUseStrictPrologue(statements) {
        for (var _i = 0, statements_1 = statements; _i < statements_1.length; _i++) {
            var statement = statements_1[_i];
            if (ts.isPrologueDirective(statement)) {
                if (isUseStrictPrologue(statement)) {
                    return statement;
                }
            }
            else {
                break;
            }
        }
        return undefined;
    }
    ts.findUseStrictPrologue = findUseStrictPrologue;
    function startsWithUseStrict(statements) {
        var firstStatement = ts.firstOrUndefined(statements);
        return firstStatement !== undefined
            && ts.isPrologueDirective(firstStatement)
            && isUseStrictPrologue(firstStatement);
    }
    ts.startsWithUseStrict = startsWithUseStrict;
    function isCommaSequence(node) {
        return node.kind === 221 && node.operatorToken.kind === 27 ||
            node.kind === 351;
    }
    ts.isCommaSequence = isCommaSequence;
    function isJSDocTypeAssertion(node) {
        return ts.isParenthesizedExpression(node)
            && ts.isInJSFile(node)
            && !!ts.getJSDocTypeTag(node);
    }
    ts.isJSDocTypeAssertion = isJSDocTypeAssertion;
    function getJSDocTypeAssertionType(node) {
        var type = ts.getJSDocType(node);
        ts.Debug.assertIsDefined(type);
        return type;
    }
    ts.getJSDocTypeAssertionType = getJSDocTypeAssertionType;
    function isOuterExpression(node, kinds) {
        if (kinds === void 0) { kinds = 15; }
        switch (node.kind) {
            case 212:
                if (kinds & 16 && isJSDocTypeAssertion(node)) {
                    return false;
                }
                return (kinds & 1) !== 0;
            case 211:
            case 229:
                return (kinds & 2) !== 0;
            case 230:
                return (kinds & 4) !== 0;
            case 350:
                return (kinds & 8) !== 0;
        }
        return false;
    }
    ts.isOuterExpression = isOuterExpression;
    function skipOuterExpressions(node, kinds) {
        if (kinds === void 0) { kinds = 15; }
        while (isOuterExpression(node, kinds)) {
            node = node.expression;
        }
        return node;
    }
    ts.skipOuterExpressions = skipOuterExpressions;
    function skipAssertions(node) {
        return skipOuterExpressions(node, 6);
    }
    ts.skipAssertions = skipAssertions;
    function startOnNewLine(node) {
        return ts.setStartsOnNewLine(node, true);
    }
    ts.startOnNewLine = startOnNewLine;
    function getExternalHelpersModuleName(node) {
        var parseNode = ts.getOriginalNode(node, ts.isSourceFile);
        var emitNode = parseNode && parseNode.emitNode;
        return emitNode && emitNode.externalHelpersModuleName;
    }
    ts.getExternalHelpersModuleName = getExternalHelpersModuleName;
    function hasRecordedExternalHelpers(sourceFile) {
        var parseNode = ts.getOriginalNode(sourceFile, ts.isSourceFile);
        var emitNode = parseNode && parseNode.emitNode;
        return !!emitNode && (!!emitNode.externalHelpersModuleName || !!emitNode.externalHelpers);
    }
    ts.hasRecordedExternalHelpers = hasRecordedExternalHelpers;
    function createExternalHelpersImportDeclarationIfNeeded(nodeFactory, helperFactory, sourceFile, compilerOptions, hasExportStarsToExportValues, hasImportStar, hasImportDefault) {
        if (compilerOptions.importHelpers && ts.isEffectiveExternalModule(sourceFile, compilerOptions)) {
            var namedBindings = void 0;
            var moduleKind = ts.getEmitModuleKind(compilerOptions);
            if ((moduleKind >= ts.ModuleKind.ES2015 && moduleKind <= ts.ModuleKind.ESNext) || sourceFile.impliedNodeFormat === ts.ModuleKind.ESNext) {
                var helpers = ts.getEmitHelpers(sourceFile);
                if (helpers) {
                    var helperNames = [];
                    for (var _i = 0, helpers_3 = helpers; _i < helpers_3.length; _i++) {
                        var helper = helpers_3[_i];
                        if (!helper.scoped) {
                            var importName = helper.importName;
                            if (importName) {
                                ts.pushIfUnique(helperNames, importName);
                            }
                        }
                    }
                    if (ts.some(helperNames)) {
                        helperNames.sort(ts.compareStringsCaseSensitive);
                        namedBindings = nodeFactory.createNamedImports(ts.map(helperNames, function (name) { return ts.isFileLevelUniqueName(sourceFile, name)
                            ? nodeFactory.createImportSpecifier(false, undefined, nodeFactory.createIdentifier(name))
                            : nodeFactory.createImportSpecifier(false, nodeFactory.createIdentifier(name), helperFactory.getUnscopedHelperName(name)); }));
                        var parseNode = ts.getOriginalNode(sourceFile, ts.isSourceFile);
                        var emitNode = ts.getOrCreateEmitNode(parseNode);
                        emitNode.externalHelpers = true;
                    }
                }
            }
            else {
                var externalHelpersModuleName = getOrCreateExternalHelpersModuleNameIfNeeded(nodeFactory, sourceFile, compilerOptions, hasExportStarsToExportValues, hasImportStar || hasImportDefault);
                if (externalHelpersModuleName) {
                    namedBindings = nodeFactory.createNamespaceImport(externalHelpersModuleName);
                }
            }
            if (namedBindings) {
                var externalHelpersImportDeclaration = nodeFactory.createImportDeclaration(undefined, undefined, nodeFactory.createImportClause(false, undefined, namedBindings), nodeFactory.createStringLiteral(ts.externalHelpersModuleNameText), undefined);
                ts.addEmitFlags(externalHelpersImportDeclaration, 67108864);
                return externalHelpersImportDeclaration;
            }
        }
    }
    ts.createExternalHelpersImportDeclarationIfNeeded = createExternalHelpersImportDeclarationIfNeeded;
    function getOrCreateExternalHelpersModuleNameIfNeeded(factory, node, compilerOptions, hasExportStarsToExportValues, hasImportStarOrImportDefault) {
        if (compilerOptions.importHelpers && ts.isEffectiveExternalModule(node, compilerOptions)) {
            var externalHelpersModuleName = getExternalHelpersModuleName(node);
            if (externalHelpersModuleName) {
                return externalHelpersModuleName;
            }
            var moduleKind = ts.getEmitModuleKind(compilerOptions);
            var create = (hasExportStarsToExportValues || (ts.getESModuleInterop(compilerOptions) && hasImportStarOrImportDefault))
                && moduleKind !== ts.ModuleKind.System
                && (moduleKind < ts.ModuleKind.ES2015 || node.impliedNodeFormat === ts.ModuleKind.CommonJS);
            if (!create) {
                var helpers = ts.getEmitHelpers(node);
                if (helpers) {
                    for (var _i = 0, helpers_4 = helpers; _i < helpers_4.length; _i++) {
                        var helper = helpers_4[_i];
                        if (!helper.scoped) {
                            create = true;
                            break;
                        }
                    }
                }
            }
            if (create) {
                var parseNode = ts.getOriginalNode(node, ts.isSourceFile);
                var emitNode = ts.getOrCreateEmitNode(parseNode);
                return emitNode.externalHelpersModuleName || (emitNode.externalHelpersModuleName = factory.createUniqueName(ts.externalHelpersModuleNameText));
            }
        }
    }
    ts.getOrCreateExternalHelpersModuleNameIfNeeded = getOrCreateExternalHelpersModuleNameIfNeeded;
    function getLocalNameForExternalImport(factory, node, sourceFile) {
        var namespaceDeclaration = ts.getNamespaceDeclarationNode(node);
        if (namespaceDeclaration && !ts.isDefaultImport(node) && !ts.isExportNamespaceAsDefaultDeclaration(node)) {
            var name = namespaceDeclaration.name;
            return ts.isGeneratedIdentifier(name) ? name : factory.createIdentifier(ts.getSourceTextOfNodeFromSourceFile(sourceFile, name) || ts.idText(name));
        }
        if (node.kind === 266 && node.importClause) {
            return factory.getGeneratedNameForNode(node);
        }
        if (node.kind === 272 && node.moduleSpecifier) {
            return factory.getGeneratedNameForNode(node);
        }
        return undefined;
    }
    ts.getLocalNameForExternalImport = getLocalNameForExternalImport;
    function getExternalModuleNameLiteral(factory, importNode, sourceFile, host, resolver, compilerOptions) {
        var moduleName = ts.getExternalModuleName(importNode);
        if (moduleName && ts.isStringLiteral(moduleName)) {
            return tryGetModuleNameFromDeclaration(importNode, host, factory, resolver, compilerOptions)
                || tryRenameExternalModule(factory, moduleName, sourceFile)
                || factory.cloneNode(moduleName);
        }
        return undefined;
    }
    ts.getExternalModuleNameLiteral = getExternalModuleNameLiteral;
    function tryRenameExternalModule(factory, moduleName, sourceFile) {
        var rename = sourceFile.renamedDependencies && sourceFile.renamedDependencies.get(moduleName.text);
        return rename ? factory.createStringLiteral(rename) : undefined;
    }
    function tryGetModuleNameFromFile(factory, file, host, options) {
        if (!file) {
            return undefined;
        }
        if (file.moduleName) {
            return factory.createStringLiteral(file.moduleName);
        }
        if (!file.isDeclarationFile && ts.outFile(options)) {
            return factory.createStringLiteral(ts.getExternalModuleNameFromPath(host, file.fileName));
        }
        return undefined;
    }
    ts.tryGetModuleNameFromFile = tryGetModuleNameFromFile;
    function tryGetModuleNameFromDeclaration(declaration, host, factory, resolver, compilerOptions) {
        return tryGetModuleNameFromFile(factory, resolver.getExternalModuleFileFromDeclaration(declaration), host, compilerOptions);
    }
    function getInitializerOfBindingOrAssignmentElement(bindingElement) {
        if (ts.isDeclarationBindingElement(bindingElement)) {
            return bindingElement.initializer;
        }
        if (ts.isPropertyAssignment(bindingElement)) {
            var initializer = bindingElement.initializer;
            return ts.isAssignmentExpression(initializer, true)
                ? initializer.right
                : undefined;
        }
        if (ts.isShorthandPropertyAssignment(bindingElement)) {
            return bindingElement.objectAssignmentInitializer;
        }
        if (ts.isAssignmentExpression(bindingElement, true)) {
            return bindingElement.right;
        }
        if (ts.isSpreadElement(bindingElement)) {
            return getInitializerOfBindingOrAssignmentElement(bindingElement.expression);
        }
    }
    ts.getInitializerOfBindingOrAssignmentElement = getInitializerOfBindingOrAssignmentElement;
    function getTargetOfBindingOrAssignmentElement(bindingElement) {
        if (ts.isDeclarationBindingElement(bindingElement)) {
            return bindingElement.name;
        }
        if (ts.isObjectLiteralElementLike(bindingElement)) {
            switch (bindingElement.kind) {
                case 296:
                    return getTargetOfBindingOrAssignmentElement(bindingElement.initializer);
                case 297:
                    return bindingElement.name;
                case 298:
                    return getTargetOfBindingOrAssignmentElement(bindingElement.expression);
            }
            return undefined;
        }
        if (ts.isAssignmentExpression(bindingElement, true)) {
            return getTargetOfBindingOrAssignmentElement(bindingElement.left);
        }
        if (ts.isSpreadElement(bindingElement)) {
            return getTargetOfBindingOrAssignmentElement(bindingElement.expression);
        }
        return bindingElement;
    }
    ts.getTargetOfBindingOrAssignmentElement = getTargetOfBindingOrAssignmentElement;
    function getRestIndicatorOfBindingOrAssignmentElement(bindingElement) {
        switch (bindingElement.kind) {
            case 164:
            case 203:
                return bindingElement.dotDotDotToken;
            case 225:
            case 298:
                return bindingElement;
        }
        return undefined;
    }
    ts.getRestIndicatorOfBindingOrAssignmentElement = getRestIndicatorOfBindingOrAssignmentElement;
    function getPropertyNameOfBindingOrAssignmentElement(bindingElement) {
        var propertyName = tryGetPropertyNameOfBindingOrAssignmentElement(bindingElement);
        ts.Debug.assert(!!propertyName || ts.isSpreadAssignment(bindingElement), "Invalid property name for binding element.");
        return propertyName;
    }
    ts.getPropertyNameOfBindingOrAssignmentElement = getPropertyNameOfBindingOrAssignmentElement;
    function tryGetPropertyNameOfBindingOrAssignmentElement(bindingElement) {
        switch (bindingElement.kind) {
            case 203:
                if (bindingElement.propertyName) {
                    var propertyName = bindingElement.propertyName;
                    if (ts.isPrivateIdentifier(propertyName)) {
                        return ts.Debug.failBadSyntaxKind(propertyName);
                    }
                    return ts.isComputedPropertyName(propertyName) && isStringOrNumericLiteral(propertyName.expression)
                        ? propertyName.expression
                        : propertyName;
                }
                break;
            case 296:
                if (bindingElement.name) {
                    var propertyName = bindingElement.name;
                    if (ts.isPrivateIdentifier(propertyName)) {
                        return ts.Debug.failBadSyntaxKind(propertyName);
                    }
                    return ts.isComputedPropertyName(propertyName) && isStringOrNumericLiteral(propertyName.expression)
                        ? propertyName.expression
                        : propertyName;
                }
                break;
            case 298:
                if (bindingElement.name && ts.isPrivateIdentifier(bindingElement.name)) {
                    return ts.Debug.failBadSyntaxKind(bindingElement.name);
                }
                return bindingElement.name;
        }
        var target = getTargetOfBindingOrAssignmentElement(bindingElement);
        if (target && ts.isPropertyName(target)) {
            return target;
        }
    }
    ts.tryGetPropertyNameOfBindingOrAssignmentElement = tryGetPropertyNameOfBindingOrAssignmentElement;
    function isStringOrNumericLiteral(node) {
        var kind = node.kind;
        return kind === 10
            || kind === 8;
    }
    function getElementsOfBindingOrAssignmentPattern(name) {
        switch (name.kind) {
            case 201:
            case 202:
            case 204:
                return name.elements;
            case 205:
                return name.properties;
        }
    }
    ts.getElementsOfBindingOrAssignmentPattern = getElementsOfBindingOrAssignmentPattern;
    function getJSDocTypeAliasName(fullName) {
        if (fullName) {
            var rightNode = fullName;
            while (true) {
                if (ts.isIdentifier(rightNode) || !rightNode.body) {
                    return ts.isIdentifier(rightNode) ? rightNode : rightNode.name;
                }
                rightNode = rightNode.body;
            }
        }
    }
    ts.getJSDocTypeAliasName = getJSDocTypeAliasName;
    function canHaveModifiers(node) {
        var kind = node.kind;
        return kind === 164
            || kind === 166
            || kind === 167
            || kind === 168
            || kind === 169
            || kind === 171
            || kind === 172
            || kind === 173
            || kind === 176
            || kind === 213
            || kind === 214
            || kind === 226
            || kind === 237
            || kind === 256
            || kind === 257
            || kind === 258
            || kind === 259
            || kind === 260
            || kind === 261
            || kind === 265
            || kind === 266
            || kind === 271
            || kind === 272;
    }
    ts.canHaveModifiers = canHaveModifiers;
    ts.isTypeNodeOrTypeParameterDeclaration = ts.or(ts.isTypeNode, ts.isTypeParameterDeclaration);
    ts.isQuestionOrExclamationToken = ts.or(ts.isQuestionToken, ts.isExclamationToken);
    ts.isIdentifierOrThisTypeNode = ts.or(ts.isIdentifier, ts.isThisTypeNode);
    ts.isReadonlyKeywordOrPlusOrMinusToken = ts.or(ts.isReadonlyKeyword, ts.isPlusToken, ts.isMinusToken);
    ts.isQuestionOrPlusOrMinusToken = ts.or(ts.isQuestionToken, ts.isPlusToken, ts.isMinusToken);
    ts.isModuleName = ts.or(ts.isIdentifier, ts.isStringLiteral);
    function isLiteralTypeLikeExpression(node) {
        var kind = node.kind;
        return kind === 104
            || kind === 110
            || kind === 95
            || ts.isLiteralExpression(node)
            || ts.isPrefixUnaryExpression(node);
    }
    ts.isLiteralTypeLikeExpression = isLiteralTypeLikeExpression;
    function isExponentiationOperator(kind) {
        return kind === 42;
    }
    function isMultiplicativeOperator(kind) {
        return kind === 41
            || kind === 43
            || kind === 44;
    }
    function isMultiplicativeOperatorOrHigher(kind) {
        return isExponentiationOperator(kind)
            || isMultiplicativeOperator(kind);
    }
    function isAdditiveOperator(kind) {
        return kind === 39
            || kind === 40;
    }
    function isAdditiveOperatorOrHigher(kind) {
        return isAdditiveOperator(kind)
            || isMultiplicativeOperatorOrHigher(kind);
    }
    function isShiftOperator(kind) {
        return kind === 47
            || kind === 48
            || kind === 49;
    }
    function isShiftOperatorOrHigher(kind) {
        return isShiftOperator(kind)
            || isAdditiveOperatorOrHigher(kind);
    }
    function isRelationalOperator(kind) {
        return kind === 29
            || kind === 32
            || kind === 31
            || kind === 33
            || kind === 102
            || kind === 101;
    }
    function isRelationalOperatorOrHigher(kind) {
        return isRelationalOperator(kind)
            || isShiftOperatorOrHigher(kind);
    }
    function isEqualityOperator(kind) {
        return kind === 34
            || kind === 36
            || kind === 35
            || kind === 37;
    }
    function isEqualityOperatorOrHigher(kind) {
        return isEqualityOperator(kind)
            || isRelationalOperatorOrHigher(kind);
    }
    function isBitwiseOperator(kind) {
        return kind === 50
            || kind === 51
            || kind === 52;
    }
    function isBitwiseOperatorOrHigher(kind) {
        return isBitwiseOperator(kind)
            || isEqualityOperatorOrHigher(kind);
    }
    function isLogicalOperator(kind) {
        return kind === 55
            || kind === 56;
    }
    function isLogicalOperatorOrHigher(kind) {
        return isLogicalOperator(kind)
            || isBitwiseOperatorOrHigher(kind);
    }
    function isAssignmentOperatorOrHigher(kind) {
        return kind === 60
            || isLogicalOperatorOrHigher(kind)
            || ts.isAssignmentOperator(kind);
    }
    function isBinaryOperator(kind) {
        return isAssignmentOperatorOrHigher(kind)
            || kind === 27;
    }
    function isBinaryOperatorToken(node) {
        return isBinaryOperator(node.kind);
    }
    ts.isBinaryOperatorToken = isBinaryOperatorToken;
    var BinaryExpressionState;
    (function (BinaryExpressionState) {
        function enter(machine, stackIndex, stateStack, nodeStack, userStateStack, _resultHolder, outerState) {
            var prevUserState = stackIndex > 0 ? userStateStack[stackIndex - 1] : undefined;
            ts.Debug.assertEqual(stateStack[stackIndex], enter);
            userStateStack[stackIndex] = machine.onEnter(nodeStack[stackIndex], prevUserState, outerState);
            stateStack[stackIndex] = nextState(machine, enter);
            return stackIndex;
        }
        BinaryExpressionState.enter = enter;
        function left(machine, stackIndex, stateStack, nodeStack, userStateStack, _resultHolder, _outerState) {
            ts.Debug.assertEqual(stateStack[stackIndex], left);
            ts.Debug.assertIsDefined(machine.onLeft);
            stateStack[stackIndex] = nextState(machine, left);
            var nextNode = machine.onLeft(nodeStack[stackIndex].left, userStateStack[stackIndex], nodeStack[stackIndex]);
            if (nextNode) {
                checkCircularity(stackIndex, nodeStack, nextNode);
                return pushStack(stackIndex, stateStack, nodeStack, userStateStack, nextNode);
            }
            return stackIndex;
        }
        BinaryExpressionState.left = left;
        function operator(machine, stackIndex, stateStack, nodeStack, userStateStack, _resultHolder, _outerState) {
            ts.Debug.assertEqual(stateStack[stackIndex], operator);
            ts.Debug.assertIsDefined(machine.onOperator);
            stateStack[stackIndex] = nextState(machine, operator);
            machine.onOperator(nodeStack[stackIndex].operatorToken, userStateStack[stackIndex], nodeStack[stackIndex]);
            return stackIndex;
        }
        BinaryExpressionState.operator = operator;
        function right(machine, stackIndex, stateStack, nodeStack, userStateStack, _resultHolder, _outerState) {
            ts.Debug.assertEqual(stateStack[stackIndex], right);
            ts.Debug.assertIsDefined(machine.onRight);
            stateStack[stackIndex] = nextState(machine, right);
            var nextNode = machine.onRight(nodeStack[stackIndex].right, userStateStack[stackIndex], nodeStack[stackIndex]);
            if (nextNode) {
                checkCircularity(stackIndex, nodeStack, nextNode);
                return pushStack(stackIndex, stateStack, nodeStack, userStateStack, nextNode);
            }
            return stackIndex;
        }
        BinaryExpressionState.right = right;
        function exit(machine, stackIndex, stateStack, nodeStack, userStateStack, resultHolder, _outerState) {
            ts.Debug.assertEqual(stateStack[stackIndex], exit);
            stateStack[stackIndex] = nextState(machine, exit);
            var result = machine.onExit(nodeStack[stackIndex], userStateStack[stackIndex]);
            if (stackIndex > 0) {
                stackIndex--;
                if (machine.foldState) {
                    var side = stateStack[stackIndex] === exit ? "right" : "left";
                    userStateStack[stackIndex] = machine.foldState(userStateStack[stackIndex], result, side);
                }
            }
            else {
                resultHolder.value = result;
            }
            return stackIndex;
        }
        BinaryExpressionState.exit = exit;
        function done(_machine, stackIndex, stateStack, _nodeStack, _userStateStack, _resultHolder, _outerState) {
            ts.Debug.assertEqual(stateStack[stackIndex], done);
            return stackIndex;
        }
        BinaryExpressionState.done = done;
        function nextState(machine, currentState) {
            switch (currentState) {
                case enter:
                    if (machine.onLeft)
                        return left;
                case left:
                    if (machine.onOperator)
                        return operator;
                case operator:
                    if (machine.onRight)
                        return right;
                case right: return exit;
                case exit: return done;
                case done: return done;
                default: ts.Debug.fail("Invalid state");
            }
        }
        BinaryExpressionState.nextState = nextState;
        function pushStack(stackIndex, stateStack, nodeStack, userStateStack, node) {
            stackIndex++;
            stateStack[stackIndex] = enter;
            nodeStack[stackIndex] = node;
            userStateStack[stackIndex] = undefined;
            return stackIndex;
        }
        function checkCircularity(stackIndex, nodeStack, node) {
            if (ts.Debug.shouldAssert(2)) {
                while (stackIndex >= 0) {
                    ts.Debug.assert(nodeStack[stackIndex] !== node, "Circular traversal detected.");
                    stackIndex--;
                }
            }
        }
    })(BinaryExpressionState || (BinaryExpressionState = {}));
    var BinaryExpressionStateMachine = (function () {
        function BinaryExpressionStateMachine(onEnter, onLeft, onOperator, onRight, onExit, foldState) {
            this.onEnter = onEnter;
            this.onLeft = onLeft;
            this.onOperator = onOperator;
            this.onRight = onRight;
            this.onExit = onExit;
            this.foldState = foldState;
        }
        return BinaryExpressionStateMachine;
    }());
    function createBinaryExpressionTrampoline(onEnter, onLeft, onOperator, onRight, onExit, foldState) {
        var machine = new BinaryExpressionStateMachine(onEnter, onLeft, onOperator, onRight, onExit, foldState);
        return trampoline;
        function trampoline(node, outerState) {
            var resultHolder = { value: undefined };
            var stateStack = [BinaryExpressionState.enter];
            var nodeStack = [node];
            var userStateStack = [undefined];
            var stackIndex = 0;
            while (stateStack[stackIndex] !== BinaryExpressionState.done) {
                stackIndex = stateStack[stackIndex](machine, stackIndex, stateStack, nodeStack, userStateStack, resultHolder, outerState);
            }
            ts.Debug.assertEqual(stackIndex, 0);
            return resultHolder.value;
        }
    }
    ts.createBinaryExpressionTrampoline = createBinaryExpressionTrampoline;
})(ts || (ts = {}));
var ts;
(function (ts) {
    function setTextRange(range, location) {
        return location ? ts.setTextRangePosEnd(range, location.pos, location.end) : range;
    }
    ts.setTextRange = setTextRange;
})(ts || (ts = {}));
var ts;
(function (ts) {
    var NodeConstructor;
    var TokenConstructor;
    var IdentifierConstructor;
    var PrivateIdentifierConstructor;
    var SourceFileConstructor;
    ts.parseBaseNodeFactory = {
        createBaseSourceFileNode: function (kind) { return new (SourceFileConstructor || (SourceFileConstructor = ts.objectAllocator.getSourceFileConstructor()))(kind, -1, -1); },
        createBaseIdentifierNode: function (kind) { return new (IdentifierConstructor || (IdentifierConstructor = ts.objectAllocator.getIdentifierConstructor()))(kind, -1, -1); },
        createBasePrivateIdentifierNode: function (kind) { return new (PrivateIdentifierConstructor || (PrivateIdentifierConstructor = ts.objectAllocator.getPrivateIdentifierConstructor()))(kind, -1, -1); },
        createBaseTokenNode: function (kind) { return new (TokenConstructor || (TokenConstructor = ts.objectAllocator.getTokenConstructor()))(kind, -1, -1); },
        createBaseNode: function (kind) { return new (NodeConstructor || (NodeConstructor = ts.objectAllocator.getNodeConstructor()))(kind, -1, -1); },
    };
    ts.parseNodeFactory = ts.createNodeFactory(1, ts.parseBaseNodeFactory);
    function visitNode(cbNode, node) {
        return node && cbNode(node);
    }
    function visitNodes(cbNode, cbNodes, nodes) {
        if (nodes) {
            if (cbNodes) {
                return cbNodes(nodes);
            }
            for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
                var node = nodes_1[_i];
                var result = cbNode(node);
                if (result) {
                    return result;
                }
            }
        }
    }
    function isJSDocLikeText(text, start) {
        return text.charCodeAt(start + 1) === 42 &&
            text.charCodeAt(start + 2) === 42 &&
            text.charCodeAt(start + 3) !== 47;
    }
    ts.isJSDocLikeText = isJSDocLikeText;
    function isFileProbablyExternalModule(sourceFile) {
        return ts.forEach(sourceFile.statements, isAnExternalModuleIndicatorNode) ||
            getImportMetaIfNecessary(sourceFile);
    }
    ts.isFileProbablyExternalModule = isFileProbablyExternalModule;
    function isAnExternalModuleIndicatorNode(node) {
        return hasModifierOfKind(node, 93)
            || ts.isImportEqualsDeclaration(node) && ts.isExternalModuleReference(node.moduleReference)
            || ts.isImportDeclaration(node)
            || ts.isExportAssignment(node)
            || ts.isExportDeclaration(node) ? node : undefined;
    }
    function getImportMetaIfNecessary(sourceFile) {
        return sourceFile.flags & 4194304 ?
            walkTreeForImportMeta(sourceFile) :
            undefined;
    }
    function walkTreeForImportMeta(node) {
        return isImportMeta(node) ? node : forEachChild(node, walkTreeForImportMeta);
    }
    function hasModifierOfKind(node, kind) {
        return ts.some(node.modifiers, function (m) { return m.kind === kind; });
    }
    function isImportMeta(node) {
        return ts.isMetaProperty(node) && node.keywordToken === 100 && node.name.escapedText === "meta";
    }
    function forEachChild(node, cbNode, cbNodes) {
        if (!node || node.kind <= 160) {
            return;
        }
        switch (node.kind) {
            case 161:
                return visitNode(cbNode, node.left) ||
                    visitNode(cbNode, node.right);
            case 163:
                return visitNodes(cbNode, cbNodes, node.modifiers) ||
                    visitNode(cbNode, node.name) ||
                    visitNode(cbNode, node.constraint) ||
                    visitNode(cbNode, node.default) ||
                    visitNode(cbNode, node.expression);
            case 297:
                return visitNodes(cbNode, cbNodes, node.decorators) ||
                    visitNodes(cbNode, cbNodes, node.modifiers) ||
                    visitNode(cbNode, node.name) ||
                    visitNode(cbNode, node.questionToken) ||
                    visitNode(cbNode, node.exclamationToken) ||
                    visitNode(cbNode, node.equalsToken) ||
                    visitNode(cbNode, node.objectAssignmentInitializer);
            case 298:
                return visitNode(cbNode, node.expression);
            case 164:
                return visitNodes(cbNode, cbNodes, node.decorators) ||
                    visitNodes(cbNode, cbNodes, node.modifiers) ||
                    visitNode(cbNode, node.dotDotDotToken) ||
                    visitNode(cbNode, node.name) ||
                    visitNode(cbNode, node.questionToken) ||
                    visitNode(cbNode, node.type) ||
                    visitNode(cbNode, node.initializer);
            case 167:
                return visitNodes(cbNode, cbNodes, node.decorators) ||
                    visitNodes(cbNode, cbNodes, node.modifiers) ||
                    visitNode(cbNode, node.name) ||
                    visitNode(cbNode, node.questionToken) ||
                    visitNode(cbNode, node.exclamationToken) ||
                    visitNode(cbNode, node.type) ||
                    visitNode(cbNode, node.initializer);
            case 166:
                return visitNodes(cbNode, cbNodes, node.decorators) ||
                    visitNodes(cbNode, cbNodes, node.modifiers) ||
                    visitNode(cbNode, node.name) ||
                    visitNode(cbNode, node.questionToken) ||
                    visitNode(cbNode, node.type) ||
                    visitNode(cbNode, node.initializer);
            case 296:
                return visitNodes(cbNode, cbNodes, node.decorators) ||
                    visitNodes(cbNode, cbNodes, node.modifiers) ||
                    visitNode(cbNode, node.name) ||
                    visitNode(cbNode, node.questionToken) ||
                    visitNode(cbNode, node.initializer);
            case 254:
                return visitNodes(cbNode, cbNodes, node.decorators) ||
                    visitNodes(cbNode, cbNodes, node.modifiers) ||
                    visitNode(cbNode, node.name) ||
                    visitNode(cbNode, node.exclamationToken) ||
                    visitNode(cbNode, node.type) ||
                    visitNode(cbNode, node.initializer);
            case 203:
                return visitNodes(cbNode, cbNodes, node.decorators) ||
                    visitNodes(cbNode, cbNodes, node.modifiers) ||
                    visitNode(cbNode, node.dotDotDotToken) ||
                    visitNode(cbNode, node.propertyName) ||
                    visitNode(cbNode, node.name) ||
                    visitNode(cbNode, node.initializer);
            case 179:
            case 180:
            case 174:
            case 175:
            case 176:
                return visitNodes(cbNode, cbNodes, node.decorators) ||
                    visitNodes(cbNode, cbNodes, node.modifiers) ||
                    visitNodes(cbNode, cbNodes, node.typeParameters) ||
                    visitNodes(cbNode, cbNodes, node.parameters) ||
                    visitNode(cbNode, node.type);
            case 169:
            case 168:
            case 171:
            case 172:
            case 173:
            case 213:
            case 256:
            case 214:
                return visitNodes(cbNode, cbNodes, node.decorators) ||
                    visitNodes(cbNode, cbNodes, node.modifiers) ||
                    visitNode(cbNode, node.asteriskToken) ||
                    visitNode(cbNode, node.name) ||
                    visitNode(cbNode, node.questionToken) ||
                    visitNode(cbNode, node.exclamationToken) ||
                    visitNodes(cbNode, cbNodes, node.typeParameters) ||
                    visitNodes(cbNode, cbNodes, node.parameters) ||
                    visitNode(cbNode, node.type) ||
                    visitNode(cbNode, node.equalsGreaterThanToken) ||
                    visitNode(cbNode, node.body);
            case 170:
                return visitNodes(cbNode, cbNodes, node.decorators) ||
                    visitNodes(cbNode, cbNodes, node.modifiers) ||
                    visitNode(cbNode, node.body);
            case 178:
                return visitNode(cbNode, node.typeName) ||
                    visitNodes(cbNode, cbNodes, node.typeArguments);
            case 177:
                return visitNode(cbNode, node.assertsModifier) ||
                    visitNode(cbNode, node.parameterName) ||
                    visitNode(cbNode, node.type);
            case 181:
                return visitNode(cbNode, node.exprName) ||
                    visitNodes(cbNode, cbNodes, node.typeArguments);
            case 182:
                return visitNodes(cbNode, cbNodes, node.members);
            case 183:
                return visitNode(cbNode, node.elementType);
            case 184:
                return visitNodes(cbNode, cbNodes, node.elements);
            case 187:
            case 188:
                return visitNodes(cbNode, cbNodes, node.types);
            case 189:
                return visitNode(cbNode, node.checkType) ||
                    visitNode(cbNode, node.extendsType) ||
                    visitNode(cbNode, node.trueType) ||
                    visitNode(cbNode, node.falseType);
            case 190:
                return visitNode(cbNode, node.typeParameter);
            case 200:
                return visitNode(cbNode, node.argument) ||
                    visitNode(cbNode, node.assertions) ||
                    visitNode(cbNode, node.qualifier) ||
                    visitNodes(cbNode, cbNodes, node.typeArguments);
            case 295:
                return visitNode(cbNode, node.assertClause);
            case 191:
            case 193:
                return visitNode(cbNode, node.type);
            case 194:
                return visitNode(cbNode, node.objectType) ||
                    visitNode(cbNode, node.indexType);
            case 195:
                return visitNode(cbNode, node.readonlyToken) ||
                    visitNode(cbNode, node.typeParameter) ||
                    visitNode(cbNode, node.nameType) ||
                    visitNode(cbNode, node.questionToken) ||
                    visitNode(cbNode, node.type) ||
                    visitNodes(cbNode, cbNodes, node.members);
            case 196:
                return visitNode(cbNode, node.literal);
            case 197:
                return visitNode(cbNode, node.dotDotDotToken) ||
                    visitNode(cbNode, node.name) ||
                    visitNode(cbNode, node.questionToken) ||
                    visitNode(cbNode, node.type);
            case 201:
            case 202:
                return visitNodes(cbNode, cbNodes, node.elements);
            case 204:
                return visitNodes(cbNode, cbNodes, node.elements);
            case 205:
                return visitNodes(cbNode, cbNodes, node.properties);
            case 206:
                return visitNode(cbNode, node.expression) ||
                    visitNode(cbNode, node.questionDotToken) ||
                    visitNode(cbNode, node.name);
            case 207:
                return visitNode(cbNode, node.expression) ||
                    visitNode(cbNode, node.questionDotToken) ||
                    visitNode(cbNode, node.argumentExpression);
            case 208:
            case 209:
                return visitNode(cbNode, node.expression) ||
                    visitNode(cbNode, node.questionDotToken) ||
                    visitNodes(cbNode, cbNodes, node.typeArguments) ||
                    visitNodes(cbNode, cbNodes, node.arguments);
            case 210:
                return visitNode(cbNode, node.tag) ||
                    visitNode(cbNode, node.questionDotToken) ||
                    visitNodes(cbNode, cbNodes, node.typeArguments) ||
                    visitNode(cbNode, node.template);
            case 211:
                return visitNode(cbNode, node.type) ||
                    visitNode(cbNode, node.expression);
            case 212:
                return visitNode(cbNode, node.expression);
            case 215:
                return visitNode(cbNode, node.expression);
            case 216:
                return visitNode(cbNode, node.expression);
            case 217:
                return visitNode(cbNode, node.expression);
            case 219:
                return visitNode(cbNode, node.operand);
            case 224:
                return visitNode(cbNode, node.asteriskToken) ||
                    visitNode(cbNode, node.expression);
            case 218:
                return visitNode(cbNode, node.expression);
            case 220:
                return visitNode(cbNode, node.operand);
            case 221:
                return visitNode(cbNode, node.left) ||
                    visitNode(cbNode, node.operatorToken) ||
                    visitNode(cbNode, node.right);
            case 229:
                return visitNode(cbNode, node.expression) ||
                    visitNode(cbNode, node.type);
            case 230:
                return visitNode(cbNode, node.expression);
            case 231:
                return visitNode(cbNode, node.name);
            case 222:
                return visitNode(cbNode, node.condition) ||
                    visitNode(cbNode, node.questionToken) ||
                    visitNode(cbNode, node.whenTrue) ||
                    visitNode(cbNode, node.colonToken) ||
                    visitNode(cbNode, node.whenFalse);
            case 225:
                return visitNode(cbNode, node.expression);
            case 235:
            case 262:
                return visitNodes(cbNode, cbNodes, node.statements);
            case 305:
                return visitNodes(cbNode, cbNodes, node.statements) ||
                    visitNode(cbNode, node.endOfFileToken);
            case 237:
                return visitNodes(cbNode, cbNodes, node.decorators) ||
                    visitNodes(cbNode, cbNodes, node.modifiers) ||
                    visitNode(cbNode, node.declarationList);
            case 255:
                return visitNodes(cbNode, cbNodes, node.declarations);
            case 238:
                return visitNode(cbNode, node.expression);
            case 239:
                return visitNode(cbNode, node.expression) ||
                    visitNode(cbNode, node.thenStatement) ||
                    visitNode(cbNode, node.elseStatement);
            case 240:
                return visitNode(cbNode, node.statement) ||
                    visitNode(cbNode, node.expression);
            case 241:
                return visitNode(cbNode, node.expression) ||
                    visitNode(cbNode, node.statement);
            case 242:
                return visitNode(cbNode, node.initializer) ||
                    visitNode(cbNode, node.condition) ||
                    visitNode(cbNode, node.incrementor) ||
                    visitNode(cbNode, node.statement);
            case 243:
                return visitNode(cbNode, node.initializer) ||
                    visitNode(cbNode, node.expression) ||
                    visitNode(cbNode, node.statement);
            case 244:
                return visitNode(cbNode, node.awaitModifier) ||
                    visitNode(cbNode, node.initializer) ||
                    visitNode(cbNode, node.expression) ||
                    visitNode(cbNode, node.statement);
            case 245:
            case 246:
                return visitNode(cbNode, node.label);
            case 247:
                return visitNode(cbNode, node.expression);
            case 248:
                return visitNode(cbNode, node.expression) ||
                    visitNode(cbNode, node.statement);
            case 249:
                return visitNode(cbNode, node.expression) ||
                    visitNode(cbNode, node.caseBlock);
            case 263:
                return visitNodes(cbNode, cbNodes, node.clauses);
            case 289:
                return visitNode(cbNode, node.expression) ||
                    visitNodes(cbNode, cbNodes, node.statements);
            case 290:
                return visitNodes(cbNode, cbNodes, node.statements);
            case 250:
                return visitNode(cbNode, node.label) ||
                    visitNode(cbNode, node.statement);
            case 251:
                return visitNode(cbNode, node.expression);
            case 252:
                return visitNode(cbNode, node.tryBlock) ||
                    visitNode(cbNode, node.catchClause) ||
                    visitNode(cbNode, node.finallyBlock);
            case 292:
                return visitNode(cbNode, node.variableDeclaration) ||
                    visitNode(cbNode, node.block);
            case 165:
                return visitNode(cbNode, node.expression);
            case 257:
            case 226:
                return visitNodes(cbNode, cbNodes, node.decorators) ||
                    visitNodes(cbNode, cbNodes, node.modifiers) ||
                    visitNode(cbNode, node.name) ||
                    visitNodes(cbNode, cbNodes, node.typeParameters) ||
                    visitNodes(cbNode, cbNodes, node.heritageClauses) ||
                    visitNodes(cbNode, cbNodes, node.members);
            case 258:
                return visitNodes(cbNode, cbNodes, node.decorators) ||
                    visitNodes(cbNode, cbNodes, node.modifiers) ||
                    visitNode(cbNode, node.name) ||
                    visitNodes(cbNode, cbNodes, node.typeParameters) ||
                    visitNodes(cbNode, cbNodes, node.heritageClauses) ||
                    visitNodes(cbNode, cbNodes, node.members);
            case 259:
                return visitNodes(cbNode, cbNodes, node.decorators) ||
                    visitNodes(cbNode, cbNodes, node.modifiers) ||
                    visitNode(cbNode, node.name) ||
                    visitNodes(cbNode, cbNodes, node.typeParameters) ||
                    visitNode(cbNode, node.type);
            case 260:
                return visitNodes(cbNode, cbNodes, node.decorators) ||
                    visitNodes(cbNode, cbNodes, node.modifiers) ||
                    visitNode(cbNode, node.name) ||
                    visitNodes(cbNode, cbNodes, node.members);
            case 299:
                return visitNode(cbNode, node.name) ||
                    visitNode(cbNode, node.initializer);
            case 261:
                return visitNodes(cbNode, cbNodes, node.decorators) ||
                    visitNodes(cbNode, cbNodes, node.modifiers) ||
                    visitNode(cbNode, node.name) ||
                    visitNode(cbNode, node.body);
            case 265:
                return visitNodes(cbNode, cbNodes, node.decorators) ||
                    visitNodes(cbNode, cbNodes, node.modifiers) ||
                    visitNode(cbNode, node.name) ||
                    visitNode(cbNode, node.moduleReference);
            case 266:
                return visitNodes(cbNode, cbNodes, node.decorators) ||
                    visitNodes(cbNode, cbNodes, node.modifiers) ||
                    visitNode(cbNode, node.importClause) ||
                    visitNode(cbNode, node.moduleSpecifier) ||
                    visitNode(cbNode, node.assertClause);
            case 267:
                return visitNode(cbNode, node.name) ||
                    visitNode(cbNode, node.namedBindings);
            case 293:
                return visitNodes(cbNode, cbNodes, node.elements);
            case 294:
                return visitNode(cbNode, node.name) ||
                    visitNode(cbNode, node.value);
            case 264:
                return visitNode(cbNode, node.name);
            case 268:
                return visitNode(cbNode, node.name);
            case 274:
                return visitNode(cbNode, node.name);
            case 269:
            case 273:
                return visitNodes(cbNode, cbNodes, node.elements);
            case 272:
                return visitNodes(cbNode, cbNodes, node.decorators) ||
                    visitNodes(cbNode, cbNodes, node.modifiers) ||
                    visitNode(cbNode, node.exportClause) ||
                    visitNode(cbNode, node.moduleSpecifier) ||
                    visitNode(cbNode, node.assertClause);
            case 270:
            case 275:
                return visitNode(cbNode, node.propertyName) ||
                    visitNode(cbNode, node.name);
            case 271:
                return visitNodes(cbNode, cbNodes, node.decorators) ||
                    visitNodes(cbNode, cbNodes, node.modifiers) ||
                    visitNode(cbNode, node.expression);
            case 223:
                return visitNode(cbNode, node.head) || visitNodes(cbNode, cbNodes, node.templateSpans);
            case 233:
                return visitNode(cbNode, node.expression) || visitNode(cbNode, node.literal);
            case 198:
                return visitNode(cbNode, node.head) || visitNodes(cbNode, cbNodes, node.templateSpans);
            case 199:
                return visitNode(cbNode, node.type) || visitNode(cbNode, node.literal);
            case 162:
                return visitNode(cbNode, node.expression);
            case 291:
                return visitNodes(cbNode, cbNodes, node.types);
            case 228:
                return visitNode(cbNode, node.expression) ||
                    visitNodes(cbNode, cbNodes, node.typeArguments);
            case 277:
                return visitNode(cbNode, node.expression);
            case 276:
                return visitNodes(cbNode, cbNodes, node.decorators);
            case 351:
                return visitNodes(cbNode, cbNodes, node.elements);
            case 278:
                return visitNode(cbNode, node.openingElement) ||
                    visitNodes(cbNode, cbNodes, node.children) ||
                    visitNode(cbNode, node.closingElement);
            case 282:
                return visitNode(cbNode, node.openingFragment) ||
                    visitNodes(cbNode, cbNodes, node.children) ||
                    visitNode(cbNode, node.closingFragment);
            case 279:
            case 280:
                return visitNode(cbNode, node.tagName) ||
                    visitNodes(cbNode, cbNodes, node.typeArguments) ||
                    visitNode(cbNode, node.attributes);
            case 286:
                return visitNodes(cbNode, cbNodes, node.properties);
            case 285:
                return visitNode(cbNode, node.name) ||
                    visitNode(cbNode, node.initializer);
            case 287:
                return visitNode(cbNode, node.expression);
            case 288:
                return visitNode(cbNode, node.dotDotDotToken) ||
                    visitNode(cbNode, node.expression);
            case 281:
                return visitNode(cbNode, node.tagName);
            case 185:
            case 186:
            case 309:
            case 315:
            case 314:
            case 316:
            case 318:
                return visitNode(cbNode, node.type);
            case 317:
                return visitNodes(cbNode, cbNodes, node.parameters) ||
                    visitNode(cbNode, node.type);
            case 320:
                return (typeof node.comment === "string" ? undefined : visitNodes(cbNode, cbNodes, node.comment))
                    || visitNodes(cbNode, cbNodes, node.tags);
            case 346:
                return visitNode(cbNode, node.tagName) ||
                    visitNode(cbNode, node.name) ||
                    (typeof node.comment === "string" ? undefined : visitNodes(cbNode, cbNodes, node.comment));
            case 310:
                return visitNode(cbNode, node.name);
            case 311:
                return visitNode(cbNode, node.left) ||
                    visitNode(cbNode, node.right);
            case 340:
            case 347:
                return visitNode(cbNode, node.tagName) ||
                    (node.isNameFirst
                        ? visitNode(cbNode, node.name) ||
                            visitNode(cbNode, node.typeExpression) ||
                            (typeof node.comment === "string" ? undefined : visitNodes(cbNode, cbNodes, node.comment))
                        : visitNode(cbNode, node.typeExpression) ||
                            visitNode(cbNode, node.name) ||
                            (typeof node.comment === "string" ? undefined : visitNodes(cbNode, cbNodes, node.comment)));
            case 330:
                return visitNode(cbNode, node.tagName) ||
                    (typeof node.comment === "string" ? undefined : visitNodes(cbNode, cbNodes, node.comment));
            case 329:
                return visitNode(cbNode, node.tagName) ||
                    visitNode(cbNode, node.class) ||
                    (typeof node.comment === "string" ? undefined : visitNodes(cbNode, cbNodes, node.comment));
            case 328:
                return visitNode(cbNode, node.tagName) ||
                    visitNode(cbNode, node.class) ||
                    (typeof node.comment === "string" ? undefined : visitNodes(cbNode, cbNodes, node.comment));
            case 344:
                return visitNode(cbNode, node.tagName) ||
                    visitNode(cbNode, node.constraint) ||
                    visitNodes(cbNode, cbNodes, node.typeParameters) ||
                    (typeof node.comment === "string" ? undefined : visitNodes(cbNode, cbNodes, node.comment));
            case 345:
                return visitNode(cbNode, node.tagName) ||
                    (node.typeExpression &&
                        node.typeExpression.kind === 309
                        ? visitNode(cbNode, node.typeExpression) ||
                            visitNode(cbNode, node.fullName) ||
                            (typeof node.comment === "string" ? undefined : visitNodes(cbNode, cbNodes, node.comment))
                        : visitNode(cbNode, node.fullName) ||
                            visitNode(cbNode, node.typeExpression) ||
                            (typeof node.comment === "string" ? undefined : visitNodes(cbNode, cbNodes, node.comment)));
            case 338:
                return visitNode(cbNode, node.tagName) ||
                    visitNode(cbNode, node.fullName) ||
                    visitNode(cbNode, node.typeExpression) ||
                    (typeof node.comment === "string" ? undefined : visitNodes(cbNode, cbNodes, node.comment));
            case 341:
            case 343:
            case 342:
            case 339:
                return visitNode(cbNode, node.tagName) ||
                    visitNode(cbNode, node.typeExpression) ||
                    (typeof node.comment === "string" ? undefined : visitNodes(cbNode, cbNodes, node.comment));
            case 323:
                return ts.forEach(node.typeParameters, cbNode) ||
                    ts.forEach(node.parameters, cbNode) ||
                    visitNode(cbNode, node.type);
            case 324:
            case 325:
            case 326:
                return visitNode(cbNode, node.name);
            case 322:
                return ts.forEach(node.jsDocPropertyTags, cbNode);
            case 327:
            case 332:
            case 333:
            case 334:
            case 335:
            case 336:
            case 331:
                return visitNode(cbNode, node.tagName)
                    || (typeof node.comment === "string" ? undefined : visitNodes(cbNode, cbNodes, node.comment));
            case 350:
                return visitNode(cbNode, node.expression);
        }
    }
    ts.forEachChild = forEachChild;
    function forEachChildRecursively(rootNode, cbNode, cbNodes) {
        var queue = gatherPossibleChildren(rootNode);
        var parents = [];
        while (parents.length < queue.length) {
            parents.push(rootNode);
        }
        while (queue.length !== 0) {
            var current = queue.pop();
            var parent = parents.pop();
            if (ts.isArray(current)) {
                if (cbNodes) {
                    var res = cbNodes(current, parent);
                    if (res) {
                        if (res === "skip")
                            continue;
                        return res;
                    }
                }
                for (var i = current.length - 1; i >= 0; --i) {
                    queue.push(current[i]);
                    parents.push(parent);
                }
            }
            else {
                var res = cbNode(current, parent);
                if (res) {
                    if (res === "skip")
                        continue;
                    return res;
                }
                if (current.kind >= 161) {
                    for (var _i = 0, _a = gatherPossibleChildren(current); _i < _a.length; _i++) {
                        var child = _a[_i];
                        queue.push(child);
                        parents.push(current);
                    }
                }
            }
        }
    }
    ts.forEachChildRecursively = forEachChildRecursively;
    function gatherPossibleChildren(node) {
        var children = [];
        forEachChild(node, addWorkItem, addWorkItem);
        return children;
        function addWorkItem(n) {
            children.unshift(n);
        }
    }
    function setExternalModuleIndicator(sourceFile) {
        sourceFile.externalModuleIndicator = isFileProbablyExternalModule(sourceFile);
    }
    function createSourceFile(fileName, sourceText, languageVersionOrOptions, setParentNodes, scriptKind) {
        if (setParentNodes === void 0) { setParentNodes = false; }
        ts.tracing === null || ts.tracing === void 0 ? void 0 : ts.tracing.push("parse", "createSourceFile", { path: fileName }, true);
        ts.performance.mark("beforeParse");
        var result;
        ts.perfLogger.logStartParseSourceFile(fileName);
        var _a = typeof languageVersionOrOptions === "object" ? languageVersionOrOptions : { languageVersion: languageVersionOrOptions }, languageVersion = _a.languageVersion, overrideSetExternalModuleIndicator = _a.setExternalModuleIndicator, format = _a.impliedNodeFormat;
        if (languageVersion === 100) {
            result = Parser.parseSourceFile(fileName, sourceText, languageVersion, undefined, setParentNodes, 6, ts.noop);
        }
        else {
            var setIndicator = format === undefined ? overrideSetExternalModuleIndicator : function (file) {
                file.impliedNodeFormat = format;
                return (overrideSetExternalModuleIndicator || setExternalModuleIndicator)(file);
            };
            result = Parser.parseSourceFile(fileName, sourceText, languageVersion, undefined, setParentNodes, scriptKind, setIndicator);
        }
        ts.perfLogger.logStopParseSourceFile();
        ts.performance.mark("afterParse");
        ts.performance.measure("Parse", "beforeParse", "afterParse");
        ts.tracing === null || ts.tracing === void 0 ? void 0 : ts.tracing.pop();
        return result;
    }
    ts.createSourceFile = createSourceFile;
    function parseIsolatedEntityName(text, languageVersion) {
        return Parser.parseIsolatedEntityName(text, languageVersion);
    }
    ts.parseIsolatedEntityName = parseIsolatedEntityName;
    function parseJsonText(fileName, sourceText) {
        return Parser.parseJsonText(fileName, sourceText);
    }
    ts.parseJsonText = parseJsonText;
    function isExternalModule(file) {
        return file.externalModuleIndicator !== undefined;
    }
    ts.isExternalModule = isExternalModule;
    function updateSourceFile(sourceFile, newText, textChangeRange, aggressiveChecks) {
        if (aggressiveChecks === void 0) { aggressiveChecks = false; }
        var newSourceFile = IncrementalParser.updateSourceFile(sourceFile, newText, textChangeRange, aggressiveChecks);
        newSourceFile.flags |= (sourceFile.flags & 6291456);
        return newSourceFile;
    }
    ts.updateSourceFile = updateSourceFile;
    function parseIsolatedJSDocComment(content, start, length) {
        var result = Parser.JSDocParser.parseIsolatedJSDocComment(content, start, length);
        if (result && result.jsDoc) {
            Parser.fixupParentReferences(result.jsDoc);
        }
        return result;
    }
    ts.parseIsolatedJSDocComment = parseIsolatedJSDocComment;
    function parseJSDocTypeExpressionForTests(content, start, length) {
        return Parser.JSDocParser.parseJSDocTypeExpressionForTests(content, start, length);
    }
    ts.parseJSDocTypeExpressionForTests = parseJSDocTypeExpressionForTests;
    var Parser;
    (function (Parser) {
        var scanner = ts.createScanner(99, true);
        var disallowInAndDecoratorContext = 4096 | 16384;
        var NodeConstructor;
        var TokenConstructor;
        var IdentifierConstructor;
        var PrivateIdentifierConstructor;
        var SourceFileConstructor;
        function countNode(node) {
            nodeCount++;
            return node;
        }
        var baseNodeFactory = {
            createBaseSourceFileNode: function (kind) { return countNode(new SourceFileConstructor(kind, 0, 0)); },
            createBaseIdentifierNode: function (kind) { return countNode(new IdentifierConstructor(kind, 0, 0)); },
            createBasePrivateIdentifierNode: function (kind) { return countNode(new PrivateIdentifierConstructor(kind, 0, 0)); },
            createBaseTokenNode: function (kind) { return countNode(new TokenConstructor(kind, 0, 0)); },
            createBaseNode: function (kind) { return countNode(new NodeConstructor(kind, 0, 0)); }
        };
        var factory = ts.createNodeFactory(1 | 2 | 8, baseNodeFactory);
        var fileName;
        var sourceFlags;
        var sourceText;
        var languageVersion;
        var scriptKind;
        var languageVariant;
        var parseDiagnostics;
        var jsDocDiagnostics;
        var syntaxCursor;
        var currentToken;
        var nodeCount;
        var identifiers;
        var privateIdentifiers;
        var identifierCount;
        var parsingContext;
        var notParenthesizedArrow;
        var contextFlags;
        var topLevel = true;
        var parseErrorBeforeNextFinishedNode = false;
        function parseSourceFile(fileName, sourceText, languageVersion, syntaxCursor, setParentNodes, scriptKind, setExternalModuleIndicatorOverride) {
            var _a;
            if (setParentNodes === void 0) { setParentNodes = false; }
            scriptKind = ts.ensureScriptKind(fileName, scriptKind);
            if (scriptKind === 6) {
                var result_3 = parseJsonText(fileName, sourceText, languageVersion, syntaxCursor, setParentNodes);
                ts.convertToObjectWorker(result_3, (_a = result_3.statements[0]) === null || _a === void 0 ? void 0 : _a.expression, result_3.parseDiagnostics, false, undefined, undefined);
                result_3.referencedFiles = ts.emptyArray;
                result_3.typeReferenceDirectives = ts.emptyArray;
                result_3.libReferenceDirectives = ts.emptyArray;
                result_3.amdDependencies = ts.emptyArray;
                result_3.hasNoDefaultLib = false;
                result_3.pragmas = ts.emptyMap;
                return result_3;
            }
            initializeState(fileName, sourceText, languageVersion, syntaxCursor, scriptKind);
            var result = parseSourceFileWorker(languageVersion, setParentNodes, scriptKind, setExternalModuleIndicatorOverride || setExternalModuleIndicator);
            clearState();
            return result;
        }
        Parser.parseSourceFile = parseSourceFile;
        function parseIsolatedEntityName(content, languageVersion) {
            initializeState("", content, languageVersion, undefined, 1);
            nextToken();
            var entityName = parseEntityName(true);
            var isInvalid = token() === 1 && !parseDiagnostics.length;
            clearState();
            return isInvalid ? entityName : undefined;
        }
        Parser.parseIsolatedEntityName = parseIsolatedEntityName;
        function parseJsonText(fileName, sourceText, languageVersion, syntaxCursor, setParentNodes) {
            if (languageVersion === void 0) { languageVersion = 2; }
            if (setParentNodes === void 0) { setParentNodes = false; }
            initializeState(fileName, sourceText, languageVersion, syntaxCursor, 6);
            sourceFlags = contextFlags;
            nextToken();
            var pos = getNodePos();
            var statements, endOfFileToken;
            if (token() === 1) {
                statements = createNodeArray([], pos, pos);
                endOfFileToken = parseTokenNode();
            }
            else {
                var expressions = void 0;
                while (token() !== 1) {
                    var expression_1 = void 0;
                    switch (token()) {
                        case 22:
                            expression_1 = parseArrayLiteralExpression();
                            break;
                        case 110:
                        case 95:
                        case 104:
                            expression_1 = parseTokenNode();
                            break;
                        case 40:
                            if (lookAhead(function () { return nextToken() === 8 && nextToken() !== 58; })) {
                                expression_1 = parsePrefixUnaryExpression();
                            }
                            else {
                                expression_1 = parseObjectLiteralExpression();
                            }
                            break;
                        case 8:
                        case 10:
                            if (lookAhead(function () { return nextToken() !== 58; })) {
                                expression_1 = parseLiteralNode();
                                break;
                            }
                        default:
                            expression_1 = parseObjectLiteralExpression();
                            break;
                    }
                    if (expressions && ts.isArray(expressions)) {
                        expressions.push(expression_1);
                    }
                    else if (expressions) {
                        expressions = [expressions, expression_1];
                    }
                    else {
                        expressions = expression_1;
                        if (token() !== 1) {
                            parseErrorAtCurrentToken(ts.Diagnostics.Unexpected_token);
                        }
                    }
                }
                var expression = ts.isArray(expressions) ? finishNode(factory.createArrayLiteralExpression(expressions), pos) : ts.Debug.checkDefined(expressions);
                var statement = factory.createExpressionStatement(expression);
                finishNode(statement, pos);
                statements = createNodeArray([statement], pos);
                endOfFileToken = parseExpectedToken(1, ts.Diagnostics.Unexpected_token);
            }
            var sourceFile = createSourceFile(fileName, 2, 6, false, statements, endOfFileToken, sourceFlags, ts.noop);
            if (setParentNodes) {
                fixupParentReferences(sourceFile);
            }
            sourceFile.nodeCount = nodeCount;
            sourceFile.identifierCount = identifierCount;
            sourceFile.identifiers = identifiers;
            sourceFile.parseDiagnostics = ts.attachFileToDiagnostics(parseDiagnostics, sourceFile);
            if (jsDocDiagnostics) {
                sourceFile.jsDocDiagnostics = ts.attachFileToDiagnostics(jsDocDiagnostics, sourceFile);
            }
            var result = sourceFile;
            clearState();
            return result;
        }
        Parser.parseJsonText = parseJsonText;
        function initializeState(_fileName, _sourceText, _languageVersion, _syntaxCursor, _scriptKind) {
            NodeConstructor = ts.objectAllocator.getNodeConstructor();
            TokenConstructor = ts.objectAllocator.getTokenConstructor();
            IdentifierConstructor = ts.objectAllocator.getIdentifierConstructor();
            PrivateIdentifierConstructor = ts.objectAllocator.getPrivateIdentifierConstructor();
            SourceFileConstructor = ts.objectAllocator.getSourceFileConstructor();
            fileName = ts.normalizePath(_fileName);
            sourceText = _sourceText;
            languageVersion = _languageVersion;
            syntaxCursor = _syntaxCursor;
            scriptKind = _scriptKind;
            languageVariant = ts.getLanguageVariant(_scriptKind);
            parseDiagnostics = [];
            parsingContext = 0;
            identifiers = new ts.Map();
            privateIdentifiers = new ts.Map();
            identifierCount = 0;
            nodeCount = 0;
            sourceFlags = 0;
            topLevel = true;
            switch (scriptKind) {
                case 1:
                case 2:
                    contextFlags = 262144;
                    break;
                case 6:
                    contextFlags = 262144 | 67108864;
                    break;
                default:
                    contextFlags = 0;
                    break;
            }
            parseErrorBeforeNextFinishedNode = false;
            scanner.setText(sourceText);
            scanner.setOnError(scanError);
            scanner.setScriptTarget(languageVersion);
            scanner.setLanguageVariant(languageVariant);
        }
        function clearState() {
            scanner.clearCommentDirectives();
            scanner.setText("");
            scanner.setOnError(undefined);
            sourceText = undefined;
            languageVersion = undefined;
            syntaxCursor = undefined;
            scriptKind = undefined;
            languageVariant = undefined;
            sourceFlags = 0;
            parseDiagnostics = undefined;
            jsDocDiagnostics = undefined;
            parsingContext = 0;
            identifiers = undefined;
            notParenthesizedArrow = undefined;
            topLevel = true;
        }
        function parseSourceFileWorker(languageVersion, setParentNodes, scriptKind, setExternalModuleIndicator) {
            var isDeclarationFile = isDeclarationFileName(fileName);
            if (isDeclarationFile) {
                contextFlags |= 16777216;
            }
            sourceFlags = contextFlags;
            nextToken();
            var statements = parseList(0, parseStatement);
            ts.Debug.assert(token() === 1);
            var endOfFileToken = addJSDocComment(parseTokenNode());
            var sourceFile = createSourceFile(fileName, languageVersion, scriptKind, isDeclarationFile, statements, endOfFileToken, sourceFlags, setExternalModuleIndicator);
            processCommentPragmas(sourceFile, sourceText);
            processPragmasIntoFields(sourceFile, reportPragmaDiagnostic);
            sourceFile.commentDirectives = scanner.getCommentDirectives();
            sourceFile.nodeCount = nodeCount;
            sourceFile.identifierCount = identifierCount;
            sourceFile.identifiers = identifiers;
            sourceFile.parseDiagnostics = ts.attachFileToDiagnostics(parseDiagnostics, sourceFile);
            if (jsDocDiagnostics) {
                sourceFile.jsDocDiagnostics = ts.attachFileToDiagnostics(jsDocDiagnostics, sourceFile);
            }
            if (setParentNodes) {
                fixupParentReferences(sourceFile);
            }
            return sourceFile;
            function reportPragmaDiagnostic(pos, end, diagnostic) {
                parseDiagnostics.push(ts.createDetachedDiagnostic(fileName, pos, end, diagnostic));
            }
        }
        function withJSDoc(node, hasJSDoc) {
            return hasJSDoc ? addJSDocComment(node) : node;
        }
        var hasDeprecatedTag = false;
        function addJSDocComment(node) {
            ts.Debug.assert(!node.jsDoc);
            var jsDoc = ts.mapDefined(ts.getJSDocCommentRanges(node, sourceText), function (comment) { return JSDocParser.parseJSDocComment(node, comment.pos, comment.end - comment.pos); });
            if (jsDoc.length)
                node.jsDoc = jsDoc;
            if (hasDeprecatedTag) {
                hasDeprecatedTag = false;
                node.flags |= 268435456;
            }
            return node;
        }
        function reparseTopLevelAwait(sourceFile) {
            var savedSyntaxCursor = syntaxCursor;
            var baseSyntaxCursor = IncrementalParser.createSyntaxCursor(sourceFile);
            syntaxCursor = { currentNode: currentNode };
            var statements = [];
            var savedParseDiagnostics = parseDiagnostics;
            parseDiagnostics = [];
            var pos = 0;
            var start = findNextStatementWithAwait(sourceFile.statements, 0);
            var _loop_3 = function () {
                var prevStatement = sourceFile.statements[pos];
                var nextStatement = sourceFile.statements[start];
                ts.addRange(statements, sourceFile.statements, pos, start);
                pos = findNextStatementWithoutAwait(sourceFile.statements, start);
                var diagnosticStart = ts.findIndex(savedParseDiagnostics, function (diagnostic) { return diagnostic.start >= prevStatement.pos; });
                var diagnosticEnd = diagnosticStart >= 0 ? ts.findIndex(savedParseDiagnostics, function (diagnostic) { return diagnostic.start >= nextStatement.pos; }, diagnosticStart) : -1;
                if (diagnosticStart >= 0) {
                    ts.addRange(parseDiagnostics, savedParseDiagnostics, diagnosticStart, diagnosticEnd >= 0 ? diagnosticEnd : undefined);
                }
                speculationHelper(function () {
                    var savedContextFlags = contextFlags;
                    contextFlags |= 32768;
                    scanner.setTextPos(nextStatement.pos);
                    nextToken();
                    while (token() !== 1) {
                        var startPos = scanner.getStartPos();
                        var statement = parseListElement(0, parseStatement);
                        statements.push(statement);
                        if (startPos === scanner.getStartPos()) {
                            nextToken();
                        }
                        if (pos >= 0) {
                            var nonAwaitStatement = sourceFile.statements[pos];
                            if (statement.end === nonAwaitStatement.pos) {
                                break;
                            }
                            if (statement.end > nonAwaitStatement.pos) {
                                pos = findNextStatementWithoutAwait(sourceFile.statements, pos + 1);
                            }
                        }
                    }
                    contextFlags = savedContextFlags;
                }, 2);
                start = pos >= 0 ? findNextStatementWithAwait(sourceFile.statements, pos) : -1;
            };
            while (start !== -1) {
                _loop_3();
            }
            if (pos >= 0) {
                var prevStatement_1 = sourceFile.statements[pos];
                ts.addRange(statements, sourceFile.statements, pos);
                var diagnosticStart = ts.findIndex(savedParseDiagnostics, function (diagnostic) { return diagnostic.start >= prevStatement_1.pos; });
                if (diagnosticStart >= 0) {
                    ts.addRange(parseDiagnostics, savedParseDiagnostics, diagnosticStart);
                }
            }
            syntaxCursor = savedSyntaxCursor;
            return factory.updateSourceFile(sourceFile, ts.setTextRange(factory.createNodeArray(statements), sourceFile.statements));
            function containsPossibleTopLevelAwait(node) {
                return !(node.flags & 32768)
                    && !!(node.transformFlags & 16777216);
            }
            function findNextStatementWithAwait(statements, start) {
                for (var i = start; i < statements.length; i++) {
                    if (containsPossibleTopLevelAwait(statements[i])) {
                        return i;
                    }
                }
                return -1;
            }
            function findNextStatementWithoutAwait(statements, start) {
                for (var i = start; i < statements.length; i++) {
                    if (!containsPossibleTopLevelAwait(statements[i])) {
                        return i;
                    }
                }
                return -1;
            }
            function currentNode(position) {
                var node = baseSyntaxCursor.currentNode(position);
                if (topLevel && node && containsPossibleTopLevelAwait(node)) {
                    node.intersectsChange = true;
                }
                return node;
            }
        }
        function fixupParentReferences(rootNode) {
            ts.setParentRecursive(rootNode, true);
        }
        Parser.fixupParentReferences = fixupParentReferences;
        function createSourceFile(fileName, languageVersion, scriptKind, isDeclarationFile, statements, endOfFileToken, flags, setExternalModuleIndicator) {
            var sourceFile = factory.createSourceFile(statements, endOfFileToken, flags);
            ts.setTextRangePosWidth(sourceFile, 0, sourceText.length);
            setFields(sourceFile);
            if (!isDeclarationFile && isExternalModule(sourceFile) && sourceFile.transformFlags & 16777216) {
                sourceFile = reparseTopLevelAwait(sourceFile);
                setFields(sourceFile);
            }
            return sourceFile;
            function setFields(sourceFile) {
                sourceFile.text = sourceText;
                sourceFile.bindDiagnostics = [];
                sourceFile.bindSuggestionDiagnostics = undefined;
                sourceFile.languageVersion = languageVersion;
                sourceFile.fileName = fileName;
                sourceFile.languageVariant = ts.getLanguageVariant(scriptKind);
                sourceFile.isDeclarationFile = isDeclarationFile;
                sourceFile.scriptKind = scriptKind;
                setExternalModuleIndicator(sourceFile);
                sourceFile.setExternalModuleIndicator = setExternalModuleIndicator;
            }
        }
        function setContextFlag(val, flag) {
            if (val) {
                contextFlags |= flag;
            }
            else {
                contextFlags &= ~flag;
            }
        }
        function setDisallowInContext(val) {
            setContextFlag(val, 4096);
        }
        function setYieldContext(val) {
            setContextFlag(val, 8192);
        }
        function setDecoratorContext(val) {
            setContextFlag(val, 16384);
        }
        function setAwaitContext(val) {
            setContextFlag(val, 32768);
        }
        function doOutsideOfContext(context, func) {
            var contextFlagsToClear = context & contextFlags;
            if (contextFlagsToClear) {
                setContextFlag(false, contextFlagsToClear);
                var result = func();
                setContextFlag(true, contextFlagsToClear);
                return result;
            }
            return func();
        }
        function doInsideOfContext(context, func) {
            var contextFlagsToSet = context & ~contextFlags;
            if (contextFlagsToSet) {
                setContextFlag(true, contextFlagsToSet);
                var result = func();
                setContextFlag(false, contextFlagsToSet);
                return result;
            }
            return func();
        }
        function allowInAnd(func) {
            return doOutsideOfContext(4096, func);
        }
        function disallowInAnd(func) {
            return doInsideOfContext(4096, func);
        }
        function allowConditionalTypesAnd(func) {
            return doOutsideOfContext(65536, func);
        }
        function disallowConditionalTypesAnd(func) {
            return doInsideOfContext(65536, func);
        }
        function doInYieldContext(func) {
            return doInsideOfContext(8192, func);
        }
        function doInDecoratorContext(func) {
            return doInsideOfContext(16384, func);
        }
        function doInAwaitContext(func) {
            return doInsideOfContext(32768, func);
        }
        function doOutsideOfAwaitContext(func) {
            return doOutsideOfContext(32768, func);
        }
        function doInYieldAndAwaitContext(func) {
            return doInsideOfContext(8192 | 32768, func);
        }
        function doOutsideOfYieldAndAwaitContext(func) {
            return doOutsideOfContext(8192 | 32768, func);
        }
        function inContext(flags) {
            return (contextFlags & flags) !== 0;
        }
        function inYieldContext() {
            return inContext(8192);
        }
        function inDisallowInContext() {
            return inContext(4096);
        }
        function inDisallowConditionalTypesContext() {
            return inContext(65536);
        }
        function inDecoratorContext() {
            return inContext(16384);
        }
        function inAwaitContext() {
            return inContext(32768);
        }
        function parseErrorAtCurrentToken(message, arg0) {
            return parseErrorAt(scanner.getTokenPos(), scanner.getTextPos(), message, arg0);
        }
        function parseErrorAtPosition(start, length, message, arg0) {
            var lastError = ts.lastOrUndefined(parseDiagnostics);
            var result;
            if (!lastError || start !== lastError.start) {
                result = ts.createDetachedDiagnostic(fileName, start, length, message, arg0);
                parseDiagnostics.push(result);
            }
            parseErrorBeforeNextFinishedNode = true;
            return result;
        }
        function parseErrorAt(start, end, message, arg0) {
            return parseErrorAtPosition(start, end - start, message, arg0);
        }
        function parseErrorAtRange(range, message, arg0) {
            parseErrorAt(range.pos, range.end, message, arg0);
        }
        function scanError(message, length) {
            parseErrorAtPosition(scanner.getTextPos(), length, message);
        }
        function getNodePos() {
            return scanner.getStartPos();
        }
        function hasPrecedingJSDocComment() {
            return scanner.hasPrecedingJSDocComment();
        }
        function token() {
            return currentToken;
        }
        function nextTokenWithoutCheck() {
            return currentToken = scanner.scan();
        }
        function nextTokenAnd(func) {
            nextToken();
            return func();
        }
        function nextToken() {
            if (ts.isKeyword(currentToken) && (scanner.hasUnicodeEscape() || scanner.hasExtendedUnicodeEscape())) {
                parseErrorAt(scanner.getTokenPos(), scanner.getTextPos(), ts.Diagnostics.Keywords_cannot_contain_escape_characters);
            }
            return nextTokenWithoutCheck();
        }
        function nextTokenJSDoc() {
            return currentToken = scanner.scanJsDocToken();
        }
        function reScanGreaterToken() {
            return currentToken = scanner.reScanGreaterToken();
        }
        function reScanSlashToken() {
            return currentToken = scanner.reScanSlashToken();
        }
        function reScanTemplateToken(isTaggedTemplate) {
            return currentToken = scanner.reScanTemplateToken(isTaggedTemplate);
        }
        function reScanTemplateHeadOrNoSubstitutionTemplate() {
            return currentToken = scanner.reScanTemplateHeadOrNoSubstitutionTemplate();
        }
        function reScanLessThanToken() {
            return currentToken = scanner.reScanLessThanToken();
        }
        function reScanHashToken() {
            return currentToken = scanner.reScanHashToken();
        }
        function scanJsxIdentifier() {
            return currentToken = scanner.scanJsxIdentifier();
        }
        function scanJsxText() {
            return currentToken = scanner.scanJsxToken();
        }
        function scanJsxAttributeValue() {
            return currentToken = scanner.scanJsxAttributeValue();
        }
        function speculationHelper(callback, speculationKind) {
            var saveToken = currentToken;
            var saveParseDiagnosticsLength = parseDiagnostics.length;
            var saveParseErrorBeforeNextFinishedNode = parseErrorBeforeNextFinishedNode;
            var saveContextFlags = contextFlags;
            var result = speculationKind !== 0
                ? scanner.lookAhead(callback)
                : scanner.tryScan(callback);
            ts.Debug.assert(saveContextFlags === contextFlags);
            if (!result || speculationKind !== 0) {
                currentToken = saveToken;
                if (speculationKind !== 2) {
                    parseDiagnostics.length = saveParseDiagnosticsLength;
                }
                parseErrorBeforeNextFinishedNode = saveParseErrorBeforeNextFinishedNode;
            }
            return result;
        }
        function lookAhead(callback) {
            return speculationHelper(callback, 1);
        }
        function tryParse(callback) {
            return speculationHelper(callback, 0);
        }
        function isBindingIdentifier() {
            if (token() === 79) {
                return true;
            }
            return token() > 116;
        }
        function isIdentifier() {
            if (token() === 79) {
                return true;
            }
            if (token() === 125 && inYieldContext()) {
                return false;
            }
            if (token() === 132 && inAwaitContext()) {
                return false;
            }
            return token() > 116;
        }
        function parseExpected(kind, diagnosticMessage, shouldAdvance) {
            if (shouldAdvance === void 0) { shouldAdvance = true; }
            if (token() === kind) {
                if (shouldAdvance) {
                    nextToken();
                }
                return true;
            }
            if (diagnosticMessage) {
                parseErrorAtCurrentToken(diagnosticMessage);
            }
            else {
                parseErrorAtCurrentToken(ts.Diagnostics._0_expected, ts.tokenToString(kind));
            }
            return false;
        }
        var viableKeywordSuggestions = Object.keys(ts.textToKeywordObj).filter(function (keyword) { return keyword.length > 2; });
        function parseErrorForMissingSemicolonAfter(node) {
            var _a;
            if (ts.isTaggedTemplateExpression(node)) {
                parseErrorAt(ts.skipTrivia(sourceText, node.template.pos), node.template.end, ts.Diagnostics.Module_declaration_names_may_only_use_or_quoted_strings);
                return;
            }
            var expressionText = ts.isIdentifier(node) ? ts.idText(node) : undefined;
            if (!expressionText || !ts.isIdentifierText(expressionText, languageVersion)) {
                parseErrorAtCurrentToken(ts.Diagnostics._0_expected, ts.tokenToString(26));
                return;
            }
            var pos = ts.skipTrivia(sourceText, node.pos);
            switch (expressionText) {
                case "const":
                case "let":
                case "var":
                    parseErrorAt(pos, node.end, ts.Diagnostics.Variable_declaration_not_allowed_at_this_location);
                    return;
                case "declare":
                    return;
                case "interface":
                    parseErrorForInvalidName(ts.Diagnostics.Interface_name_cannot_be_0, ts.Diagnostics.Interface_must_be_given_a_name, 18);
                    return;
                case "is":
                    parseErrorAt(pos, scanner.getTextPos(), ts.Diagnostics.A_type_predicate_is_only_allowed_in_return_type_position_for_functions_and_methods);
                    return;
                case "module":
                case "namespace":
                    parseErrorForInvalidName(ts.Diagnostics.Namespace_name_cannot_be_0, ts.Diagnostics.Namespace_must_be_given_a_name, 18);
                    return;
                case "type":
                    parseErrorForInvalidName(ts.Diagnostics.Type_alias_name_cannot_be_0, ts.Diagnostics.Type_alias_must_be_given_a_name, 63);
                    return;
            }
            var suggestion = (_a = ts.getSpellingSuggestion(expressionText, viableKeywordSuggestions, function (n) { return n; })) !== null && _a !== void 0 ? _a : getSpaceSuggestion(expressionText);
            if (suggestion) {
                parseErrorAt(pos, node.end, ts.Diagnostics.Unknown_keyword_or_identifier_Did_you_mean_0, suggestion);
                return;
            }
            if (token() === 0) {
                return;
            }
            parseErrorAt(pos, node.end, ts.Diagnostics.Unexpected_keyword_or_identifier);
        }
        function parseErrorForInvalidName(nameDiagnostic, blankDiagnostic, tokenIfBlankName) {
            if (token() === tokenIfBlankName) {
                parseErrorAtCurrentToken(blankDiagnostic);
            }
            else {
                parseErrorAtCurrentToken(nameDiagnostic, scanner.getTokenValue());
            }
        }
        function getSpaceSuggestion(expressionText) {
            for (var _i = 0, viableKeywordSuggestions_1 = viableKeywordSuggestions; _i < viableKeywordSuggestions_1.length; _i++) {
                var keyword = viableKeywordSuggestions_1[_i];
                if (expressionText.length > keyword.length + 2 && ts.startsWith(expressionText, keyword)) {
                    return "".concat(keyword, " ").concat(expressionText.slice(keyword.length));
                }
            }
            return undefined;
        }
        function parseSemicolonAfterPropertyName(name, type, initializer) {
            if (token() === 59 && !scanner.hasPrecedingLineBreak()) {
                parseErrorAtCurrentToken(ts.Diagnostics.Decorators_must_precede_the_name_and_all_keywords_of_property_declarations);
                return;
            }
            if (token() === 20) {
                parseErrorAtCurrentToken(ts.Diagnostics.Cannot_start_a_function_call_in_a_type_annotation);
                nextToken();
                return;
            }
            if (type && !canParseSemicolon()) {
                if (initializer) {
                    parseErrorAtCurrentToken(ts.Diagnostics._0_expected, ts.tokenToString(26));
                }
                else {
                    parseErrorAtCurrentToken(ts.Diagnostics.Expected_for_property_initializer);
                }
                return;
            }
            if (tryParseSemicolon()) {
                return;
            }
            if (initializer) {
                parseErrorAtCurrentToken(ts.Diagnostics._0_expected, ts.tokenToString(26));
                return;
            }
            parseErrorForMissingSemicolonAfter(name);
        }
        function parseExpectedJSDoc(kind) {
            if (token() === kind) {
                nextTokenJSDoc();
                return true;
            }
            parseErrorAtCurrentToken(ts.Diagnostics._0_expected, ts.tokenToString(kind));
            return false;
        }
        function parseExpectedMatchingBrackets(openKind, closeKind, openParsed, openPosition) {
            if (token() === closeKind) {
                nextToken();
                return;
            }
            var lastError = parseErrorAtCurrentToken(ts.Diagnostics._0_expected, ts.tokenToString(closeKind));
            if (!openParsed) {
                return;
            }
            if (lastError) {
                ts.addRelatedInfo(lastError, ts.createDetachedDiagnostic(fileName, openPosition, 1, ts.Diagnostics.The_parser_expected_to_find_a_1_to_match_the_0_token_here, ts.tokenToString(openKind), ts.tokenToString(closeKind)));
            }
        }
        function parseOptional(t) {
            if (token() === t) {
                nextToken();
                return true;
            }
            return false;
        }
        function parseOptionalToken(t) {
            if (token() === t) {
                return parseTokenNode();
            }
            return undefined;
        }
        function parseOptionalTokenJSDoc(t) {
            if (token() === t) {
                return parseTokenNodeJSDoc();
            }
            return undefined;
        }
        function parseExpectedToken(t, diagnosticMessage, arg0) {
            return parseOptionalToken(t) ||
                createMissingNode(t, false, diagnosticMessage || ts.Diagnostics._0_expected, arg0 || ts.tokenToString(t));
        }
        function parseExpectedTokenJSDoc(t) {
            return parseOptionalTokenJSDoc(t) ||
                createMissingNode(t, false, ts.Diagnostics._0_expected, ts.tokenToString(t));
        }
        function parseTokenNode() {
            var pos = getNodePos();
            var kind = token();
            nextToken();
            return finishNode(factory.createToken(kind), pos);
        }
        function parseTokenNodeJSDoc() {
            var pos = getNodePos();
            var kind = token();
            nextTokenJSDoc();
            return finishNode(factory.createToken(kind), pos);
        }
        function canParseSemicolon() {
            if (token() === 26) {
                return true;
            }
            return token() === 19 || token() === 1 || scanner.hasPrecedingLineBreak();
        }
        function tryParseSemicolon() {
            if (!canParseSemicolon()) {
                return false;
            }
            if (token() === 26) {
                nextToken();
            }
            return true;
        }
        function parseSemicolon() {
            return tryParseSemicolon() || parseExpected(26);
        }
        function createNodeArray(elements, pos, end, hasTrailingComma) {
            var array = factory.createNodeArray(elements, hasTrailingComma);
            ts.setTextRangePosEnd(array, pos, end !== null && end !== void 0 ? end : scanner.getStartPos());
            return array;
        }
        function finishNode(node, pos, end) {
            ts.setTextRangePosEnd(node, pos, end !== null && end !== void 0 ? end : scanner.getStartPos());
            if (contextFlags) {
                node.flags |= contextFlags;
            }
            if (parseErrorBeforeNextFinishedNode) {
                parseErrorBeforeNextFinishedNode = false;
                node.flags |= 131072;
            }
            return node;
        }
        function createMissingNode(kind, reportAtCurrentPosition, diagnosticMessage, arg0) {
            if (reportAtCurrentPosition) {
                parseErrorAtPosition(scanner.getStartPos(), 0, diagnosticMessage, arg0);
            }
            else if (diagnosticMessage) {
                parseErrorAtCurrentToken(diagnosticMessage, arg0);
            }
            var pos = getNodePos();
            var result = kind === 79 ? factory.createIdentifier("", undefined, undefined) :
                ts.isTemplateLiteralKind(kind) ? factory.createTemplateLiteralLikeNode(kind, "", "", undefined) :
                    kind === 8 ? factory.createNumericLiteral("", undefined) :
                        kind === 10 ? factory.createStringLiteral("", undefined) :
                            kind === 276 ? factory.createMissingDeclaration() :
                                factory.createToken(kind);
            return finishNode(result, pos);
        }
        function internIdentifier(text) {
            var identifier = identifiers.get(text);
            if (identifier === undefined) {
                identifiers.set(text, identifier = text);
            }
            return identifier;
        }
        function createIdentifier(isIdentifier, diagnosticMessage, privateIdentifierDiagnosticMessage) {
            if (isIdentifier) {
                identifierCount++;
                var pos = getNodePos();
                var originalKeywordKind = token();
                var text = internIdentifier(scanner.getTokenValue());
                nextTokenWithoutCheck();
                return finishNode(factory.createIdentifier(text, undefined, originalKeywordKind), pos);
            }
            if (token() === 80) {
                parseErrorAtCurrentToken(privateIdentifierDiagnosticMessage || ts.Diagnostics.Private_identifiers_are_not_allowed_outside_class_bodies);
                return createIdentifier(true);
            }
            if (token() === 0 && scanner.tryScan(function () { return scanner.reScanInvalidIdentifier() === 79; })) {
                return createIdentifier(true);
            }
            identifierCount++;
            var reportAtCurrentPosition = token() === 1;
            var isReservedWord = scanner.isReservedWord();
            var msgArg = scanner.getTokenText();
            var defaultMessage = isReservedWord ?
                ts.Diagnostics.Identifier_expected_0_is_a_reserved_word_that_cannot_be_used_here :
                ts.Diagnostics.Identifier_expected;
            return createMissingNode(79, reportAtCurrentPosition, diagnosticMessage || defaultMessage, msgArg);
        }
        function parseBindingIdentifier(privateIdentifierDiagnosticMessage) {
            return createIdentifier(isBindingIdentifier(), undefined, privateIdentifierDiagnosticMessage);
        }
        function parseIdentifier(diagnosticMessage, privateIdentifierDiagnosticMessage) {
            return createIdentifier(isIdentifier(), diagnosticMessage, privateIdentifierDiagnosticMessage);
        }
        function parseIdentifierName(diagnosticMessage) {
            return createIdentifier(ts.tokenIsIdentifierOrKeyword(token()), diagnosticMessage);
        }
        function isLiteralPropertyName() {
            return ts.tokenIsIdentifierOrKeyword(token()) ||
                token() === 10 ||
                token() === 8;
        }
        function isAssertionKey() {
            return ts.tokenIsIdentifierOrKeyword(token()) ||
                token() === 10;
        }
        function parsePropertyNameWorker(allowComputedPropertyNames) {
            if (token() === 10 || token() === 8) {
                var node = parseLiteralNode();
                node.text = internIdentifier(node.text);
                return node;
            }
            if (allowComputedPropertyNames && token() === 22) {
                return parseComputedPropertyName();
            }
            if (token() === 80) {
                return parsePrivateIdentifier();
            }
            return parseIdentifierName();
        }
        function parsePropertyName() {
            return parsePropertyNameWorker(true);
        }
        function parseComputedPropertyName() {
            var pos = getNodePos();
            parseExpected(22);
            var expression = allowInAnd(parseExpression);
            parseExpected(23);
            return finishNode(factory.createComputedPropertyName(expression), pos);
        }
        function internPrivateIdentifier(text) {
            var privateIdentifier = privateIdentifiers.get(text);
            if (privateIdentifier === undefined) {
                privateIdentifiers.set(text, privateIdentifier = text);
            }
            return privateIdentifier;
        }
        function parsePrivateIdentifier() {
            var pos = getNodePos();
            var node = factory.createPrivateIdentifier(internPrivateIdentifier(scanner.getTokenText()));
            nextToken();
            return finishNode(node, pos);
        }
        function parseContextualModifier(t) {
            return token() === t && tryParse(nextTokenCanFollowModifier);
        }
        function nextTokenIsOnSameLineAndCanFollowModifier() {
            nextToken();
            if (scanner.hasPrecedingLineBreak()) {
                return false;
            }
            return canFollowModifier();
        }
        function nextTokenCanFollowModifier() {
            switch (token()) {
                case 85:
                    return nextToken() === 92;
                case 93:
                    nextToken();
                    if (token() === 88) {
                        return lookAhead(nextTokenCanFollowDefaultKeyword);
                    }
                    if (token() === 152) {
                        return lookAhead(nextTokenCanFollowExportModifier);
                    }
                    return canFollowExportModifier();
                case 88:
                    return nextTokenCanFollowDefaultKeyword();
                case 124:
                case 136:
                case 149:
                    nextToken();
                    return canFollowModifier();
                default:
                    return nextTokenIsOnSameLineAndCanFollowModifier();
            }
        }
        function canFollowExportModifier() {
            return token() !== 41
                && token() !== 127
                && token() !== 18
                && canFollowModifier();
        }
        function nextTokenCanFollowExportModifier() {
            nextToken();
            return canFollowExportModifier();
        }
        function parseAnyContextualModifier() {
            return ts.isModifierKind(token()) && tryParse(nextTokenCanFollowModifier);
        }
        function canFollowModifier() {
            return token() === 22
                || token() === 18
                || token() === 41
                || token() === 25
                || isLiteralPropertyName();
        }
        function nextTokenCanFollowDefaultKeyword() {
            nextToken();
            return token() === 84 || token() === 98 ||
                token() === 118 ||
                (token() === 126 && lookAhead(nextTokenIsClassKeywordOnSameLine)) ||
                (token() === 131 && lookAhead(nextTokenIsFunctionKeywordOnSameLine));
        }
        function isListElement(parsingContext, inErrorRecovery) {
            var node = currentNode(parsingContext);
            if (node) {
                return true;
            }
            switch (parsingContext) {
                case 0:
                case 1:
                case 3:
                    return !(token() === 26 && inErrorRecovery) && isStartOfStatement();
                case 2:
                    return token() === 82 || token() === 88;
                case 4:
                    return lookAhead(isTypeMemberStart);
                case 5:
                    return lookAhead(isClassMemberStart) || (token() === 26 && !inErrorRecovery);
                case 6:
                    return token() === 22 || isLiteralPropertyName();
                case 12:
                    switch (token()) {
                        case 22:
                        case 41:
                        case 25:
                        case 24:
                            return true;
                        default:
                            return isLiteralPropertyName();
                    }
                case 18:
                    return isLiteralPropertyName();
                case 9:
                    return token() === 22 || token() === 25 || isLiteralPropertyName();
                case 24:
                    return isAssertionKey();
                case 7:
                    if (token() === 18) {
                        return lookAhead(isValidHeritageClauseObjectLiteral);
                    }
                    if (!inErrorRecovery) {
                        return isStartOfLeftHandSideExpression() && !isHeritageClauseExtendsOrImplementsKeyword();
                    }
                    else {
                        return isIdentifier() && !isHeritageClauseExtendsOrImplementsKeyword();
                    }
                case 8:
                    return isBindingIdentifierOrPrivateIdentifierOrPattern();
                case 10:
                    return token() === 27 || token() === 25 || isBindingIdentifierOrPrivateIdentifierOrPattern();
                case 19:
                    return token() === 101 || isIdentifier();
                case 15:
                    switch (token()) {
                        case 27:
                        case 24:
                            return true;
                    }
                case 11:
                    return token() === 25 || isStartOfExpression();
                case 16:
                    return isStartOfParameter(false);
                case 17:
                    return isStartOfParameter(true);
                case 20:
                case 21:
                    return token() === 27 || isStartOfType();
                case 22:
                    return isHeritageClause();
                case 23:
                    return ts.tokenIsIdentifierOrKeyword(token());
                case 13:
                    return ts.tokenIsIdentifierOrKeyword(token()) || token() === 18;
                case 14:
                    return true;
            }
            return ts.Debug.fail("Non-exhaustive case in 'isListElement'.");
        }
        function isValidHeritageClauseObjectLiteral() {
            ts.Debug.assert(token() === 18);
            if (nextToken() === 19) {
                var next = nextToken();
                return next === 27 || next === 18 || next === 94 || next === 117;
            }
            return true;
        }
        function nextTokenIsIdentifier() {
            nextToken();
            return isIdentifier();
        }
        function nextTokenIsIdentifierOrKeyword() {
            nextToken();
            return ts.tokenIsIdentifierOrKeyword(token());
        }
        function nextTokenIsIdentifierOrKeywordOrGreaterThan() {
            nextToken();
            return ts.tokenIsIdentifierOrKeywordOrGreaterThan(token());
        }
        function isHeritageClauseExtendsOrImplementsKeyword() {
            if (token() === 117 ||
                token() === 94) {
                return lookAhead(nextTokenIsStartOfExpression);
            }
            return false;
        }
        function nextTokenIsStartOfExpression() {
            nextToken();
            return isStartOfExpression();
        }
        function nextTokenIsStartOfType() {
            nextToken();
            return isStartOfType();
        }
        function isListTerminator(kind) {
            if (token() === 1) {
                return true;
            }
            switch (kind) {
                case 1:
                case 2:
                case 4:
                case 5:
                case 6:
                case 12:
                case 9:
                case 23:
                case 24:
                    return token() === 19;
                case 3:
                    return token() === 19 || token() === 82 || token() === 88;
                case 7:
                    return token() === 18 || token() === 94 || token() === 117;
                case 8:
                    return isVariableDeclaratorListTerminator();
                case 19:
                    return token() === 31 || token() === 20 || token() === 18 || token() === 94 || token() === 117;
                case 11:
                    return token() === 21 || token() === 26;
                case 15:
                case 21:
                case 10:
                    return token() === 23;
                case 17:
                case 16:
                case 18:
                    return token() === 21 || token() === 23;
                case 20:
                    return token() !== 27;
                case 22:
                    return token() === 18 || token() === 19;
                case 13:
                    return token() === 31 || token() === 43;
                case 14:
                    return token() === 29 && lookAhead(nextTokenIsSlash);
                default:
                    return false;
            }
        }
        function isVariableDeclaratorListTerminator() {
            if (canParseSemicolon()) {
                return true;
            }
            if (isInOrOfKeyword(token())) {
                return true;
            }
            if (token() === 38) {
                return true;
            }
            return false;
        }
        function isInSomeParsingContext() {
            for (var kind = 0; kind < 25; kind++) {
                if (parsingContext & (1 << kind)) {
                    if (isListElement(kind, true) || isListTerminator(kind)) {
                        return true;
                    }
                }
            }
            return false;
        }
        function parseList(kind, parseElement) {
            var saveParsingContext = parsingContext;
            parsingContext |= 1 << kind;
            var list = [];
            var listPos = getNodePos();
            while (!isListTerminator(kind)) {
                if (isListElement(kind, false)) {
                    list.push(parseListElement(kind, parseElement));
                    continue;
                }
                if (abortParsingListOrMoveToNextToken(kind)) {
                    break;
                }
            }
            parsingContext = saveParsingContext;
            return createNodeArray(list, listPos);
        }
        function parseListElement(parsingContext, parseElement) {
            var node = currentNode(parsingContext);
            if (node) {
                return consumeNode(node);
            }
            return parseElement();
        }
        function currentNode(parsingContext) {
            if (!syntaxCursor || !isReusableParsingContext(parsingContext) || parseErrorBeforeNextFinishedNode) {
                return undefined;
            }
            var node = syntaxCursor.currentNode(scanner.getStartPos());
            if (ts.nodeIsMissing(node) || node.intersectsChange || ts.containsParseError(node)) {
                return undefined;
            }
            var nodeContextFlags = node.flags & 50720768;
            if (nodeContextFlags !== contextFlags) {
                return undefined;
            }
            if (!canReuseNode(node, parsingContext)) {
                return undefined;
            }
            if (node.jsDocCache) {
                node.jsDocCache = undefined;
            }
            return node;
        }
        function consumeNode(node) {
            scanner.setTextPos(node.end);
            nextToken();
            return node;
        }
        function isReusableParsingContext(parsingContext) {
            switch (parsingContext) {
                case 5:
                case 2:
                case 0:
                case 1:
                case 3:
                case 6:
                case 4:
                case 8:
                case 17:
                case 16:
                    return true;
            }
            return false;
        }
        function canReuseNode(node, parsingContext) {
            switch (parsingContext) {
                case 5:
                    return isReusableClassMember(node);
                case 2:
                    return isReusableSwitchClause(node);
                case 0:
                case 1:
                case 3:
                    return isReusableStatement(node);
                case 6:
                    return isReusableEnumMember(node);
                case 4:
                    return isReusableTypeMember(node);
                case 8:
                    return isReusableVariableDeclaration(node);
                case 17:
                case 16:
                    return isReusableParameter(node);
            }
            return false;
        }
        function isReusableClassMember(node) {
            if (node) {
                switch (node.kind) {
                    case 171:
                    case 176:
                    case 172:
                    case 173:
                    case 167:
                    case 234:
                        return true;
                    case 169:
                        var methodDeclaration = node;
                        var nameIsConstructor = methodDeclaration.name.kind === 79 &&
                            methodDeclaration.name.originalKeywordKind === 134;
                        return !nameIsConstructor;
                }
            }
            return false;
        }
        function isReusableSwitchClause(node) {
            if (node) {
                switch (node.kind) {
                    case 289:
                    case 290:
                        return true;
                }
            }
            return false;
        }
        function isReusableStatement(node) {
            if (node) {
                switch (node.kind) {
                    case 256:
                    case 237:
                    case 235:
                    case 239:
                    case 238:
                    case 251:
                    case 247:
                    case 249:
                    case 246:
                    case 245:
                    case 243:
                    case 244:
                    case 242:
                    case 241:
                    case 248:
                    case 236:
                    case 252:
                    case 250:
                    case 240:
                    case 253:
                    case 266:
                    case 265:
                    case 272:
                    case 271:
                    case 261:
                    case 257:
                    case 258:
                    case 260:
                    case 259:
                        return true;
                }
            }
            return false;
        }
        function isReusableEnumMember(node) {
            return node.kind === 299;
        }
        function isReusableTypeMember(node) {
            if (node) {
                switch (node.kind) {
                    case 175:
                    case 168:
                    case 176:
                    case 166:
                    case 174:
                        return true;
                }
            }
            return false;
        }
        function isReusableVariableDeclaration(node) {
            if (node.kind !== 254) {
                return false;
            }
            var variableDeclarator = node;
            return variableDeclarator.initializer === undefined;
        }
        function isReusableParameter(node) {
            if (node.kind !== 164) {
                return false;
            }
            var parameter = node;
            return parameter.initializer === undefined;
        }
        function abortParsingListOrMoveToNextToken(kind) {
            parsingContextErrors(kind);
            if (isInSomeParsingContext()) {
                return true;
            }
            nextToken();
            return false;
        }
        function parsingContextErrors(context) {
            switch (context) {
                case 0:
                    return token() === 88
                        ? parseErrorAtCurrentToken(ts.Diagnostics._0_expected, ts.tokenToString(93))
                        : parseErrorAtCurrentToken(ts.Diagnostics.Declaration_or_statement_expected);
                case 1: return parseErrorAtCurrentToken(ts.Diagnostics.Declaration_or_statement_expected);
                case 2: return parseErrorAtCurrentToken(ts.Diagnostics.case_or_default_expected);
                case 3: return parseErrorAtCurrentToken(ts.Diagnostics.Statement_expected);
                case 18:
                case 4: return parseErrorAtCurrentToken(ts.Diagnostics.Property_or_signature_expected);
                case 5: return parseErrorAtCurrentToken(ts.Diagnostics.Unexpected_token_A_constructor_method_accessor_or_property_was_expected);
                case 6: return parseErrorAtCurrentToken(ts.Diagnostics.Enum_member_expected);
                case 7: return parseErrorAtCurrentToken(ts.Diagnostics.Expression_expected);
                case 8:
                    return ts.isKeyword(token())
                        ? parseErrorAtCurrentToken(ts.Diagnostics._0_is_not_allowed_as_a_variable_declaration_name, ts.tokenToString(token()))
                        : parseErrorAtCurrentToken(ts.Diagnostics.Variable_declaration_expected);
                case 9: return parseErrorAtCurrentToken(ts.Diagnostics.Property_destructuring_pattern_expected);
                case 10: return parseErrorAtCurrentToken(ts.Diagnostics.Array_element_destructuring_pattern_expected);
                case 11: return parseErrorAtCurrentToken(ts.Diagnostics.Argument_expression_expected);
                case 12: return parseErrorAtCurrentToken(ts.Diagnostics.Property_assignment_expected);
                case 15: return parseErrorAtCurrentToken(ts.Diagnostics.Expression_or_comma_expected);
                case 17: return parseErrorAtCurrentToken(ts.Diagnostics.Parameter_declaration_expected);
                case 16:
                    return ts.isKeyword(token())
                        ? parseErrorAtCurrentToken(ts.Diagnostics._0_is_not_allowed_as_a_parameter_name, ts.tokenToString(token()))
                        : parseErrorAtCurrentToken(ts.Diagnostics.Parameter_declaration_expected);
                case 19: return parseErrorAtCurrentToken(ts.Diagnostics.Type_parameter_declaration_expected);
                case 20: return parseErrorAtCurrentToken(ts.Diagnostics.Type_argument_expected);
                case 21: return parseErrorAtCurrentToken(ts.Diagnostics.Type_expected);
                case 22: return parseErrorAtCurrentToken(ts.Diagnostics.Unexpected_token_expected);
                case 23: return parseErrorAtCurrentToken(ts.Diagnostics.Identifier_expected);
                case 13: return parseErrorAtCurrentToken(ts.Diagnostics.Identifier_expected);
                case 14: return parseErrorAtCurrentToken(ts.Diagnostics.Identifier_expected);
                default: return [undefined];
            }
        }
        function parseDelimitedList(kind, parseElement, considerSemicolonAsDelimiter) {
            var saveParsingContext = parsingContext;
            parsingContext |= 1 << kind;
            var list = [];
            var listPos = getNodePos();
            var commaStart = -1;
            while (true) {
                if (isListElement(kind, false)) {
                    var startPos = scanner.getStartPos();
                    var result = parseListElement(kind, parseElement);
                    if (!result) {
                        parsingContext = saveParsingContext;
                        return undefined;
                    }
                    list.push(result);
                    commaStart = scanner.getTokenPos();
                    if (parseOptional(27)) {
                        continue;
                    }
                    commaStart = -1;
                    if (isListTerminator(kind)) {
                        break;
                    }
                    parseExpected(27, getExpectedCommaDiagnostic(kind));
                    if (considerSemicolonAsDelimiter && token() === 26 && !scanner.hasPrecedingLineBreak()) {
                        nextToken();
                    }
                    if (startPos === scanner.getStartPos()) {
                        nextToken();
                    }
                    continue;
                }
                if (isListTerminator(kind)) {
                    break;
                }
                if (abortParsingListOrMoveToNextToken(kind)) {
                    break;
                }
            }
            parsingContext = saveParsingContext;
            return createNodeArray(list, listPos, undefined, commaStart >= 0);
        }
        function getExpectedCommaDiagnostic(kind) {
            return kind === 6 ? ts.Diagnostics.An_enum_member_name_must_be_followed_by_a_or : undefined;
        }
        function createMissingList() {
            var list = createNodeArray([], getNodePos());
            list.isMissingList = true;
            return list;
        }
        function isMissingList(arr) {
            return !!arr.isMissingList;
        }
        function parseBracketedList(kind, parseElement, open, close) {
            if (parseExpected(open)) {
                var result = parseDelimitedList(kind, parseElement);
                parseExpected(close);
                return result;
            }
            return createMissingList();
        }
        function parseEntityName(allowReservedWords, diagnosticMessage) {
            var pos = getNodePos();
            var entity = allowReservedWords ? parseIdentifierName(diagnosticMessage) : parseIdentifier(diagnosticMessage);
            var dotPos = getNodePos();
            while (parseOptional(24)) {
                if (token() === 29) {
                    entity.jsdocDotPos = dotPos;
                    break;
                }
                dotPos = getNodePos();
                entity = finishNode(factory.createQualifiedName(entity, parseRightSideOfDot(allowReservedWords, false)), pos);
            }
            return entity;
        }
        function createQualifiedName(entity, name) {
            return finishNode(factory.createQualifiedName(entity, name), entity.pos);
        }
        function parseRightSideOfDot(allowIdentifierNames, allowPrivateIdentifiers) {
            if (scanner.hasPrecedingLineBreak() && ts.tokenIsIdentifierOrKeyword(token())) {
                var matchesPattern = lookAhead(nextTokenIsIdentifierOrKeywordOnSameLine);
                if (matchesPattern) {
                    return createMissingNode(79, true, ts.Diagnostics.Identifier_expected);
                }
            }
            if (token() === 80) {
                var node = parsePrivateIdentifier();
                return allowPrivateIdentifiers ? node : createMissingNode(79, true, ts.Diagnostics.Identifier_expected);
            }
            return allowIdentifierNames ? parseIdentifierName() : parseIdentifier();
        }
        function parseTemplateSpans(isTaggedTemplate) {
            var pos = getNodePos();
            var list = [];
            var node;
            do {
                node = parseTemplateSpan(isTaggedTemplate);
                list.push(node);
            } while (node.literal.kind === 16);
            return createNodeArray(list, pos);
        }
        function parseTemplateExpression(isTaggedTemplate) {
            var pos = getNodePos();
            return finishNode(factory.createTemplateExpression(parseTemplateHead(isTaggedTemplate), parseTemplateSpans(isTaggedTemplate)), pos);
        }
        function parseTemplateType() {
            var pos = getNodePos();
            return finishNode(factory.createTemplateLiteralType(parseTemplateHead(false), parseTemplateTypeSpans()), pos);
        }
        function parseTemplateTypeSpans() {
            var pos = getNodePos();
            var list = [];
            var node;
            do {
                node = parseTemplateTypeSpan();
                list.push(node);
            } while (node.literal.kind === 16);
            return createNodeArray(list, pos);
        }
        function parseTemplateTypeSpan() {
            var pos = getNodePos();
            return finishNode(factory.createTemplateLiteralTypeSpan(parseType(), parseLiteralOfTemplateSpan(false)), pos);
        }
        function parseLiteralOfTemplateSpan(isTaggedTemplate) {
            if (token() === 19) {
                reScanTemplateToken(isTaggedTemplate);
                return parseTemplateMiddleOrTemplateTail();
            }
            else {
                return parseExpectedToken(17, ts.Diagnostics._0_expected, ts.tokenToString(19));
            }
        }
        function parseTemplateSpan(isTaggedTemplate) {
            var pos = getNodePos();
            return finishNode(factory.createTemplateSpan(allowInAnd(parseExpression), parseLiteralOfTemplateSpan(isTaggedTemplate)), pos);
        }
        function parseLiteralNode() {
            return parseLiteralLikeNode(token());
        }
        function parseTemplateHead(isTaggedTemplate) {
            if (isTaggedTemplate) {
                reScanTemplateHeadOrNoSubstitutionTemplate();
            }
            var fragment = parseLiteralLikeNode(token());
            ts.Debug.assert(fragment.kind === 15, "Template head has wrong token kind");
            return fragment;
        }
        function parseTemplateMiddleOrTemplateTail() {
            var fragment = parseLiteralLikeNode(token());
            ts.Debug.assert(fragment.kind === 16 || fragment.kind === 17, "Template fragment has wrong token kind");
            return fragment;
        }
        function getTemplateLiteralRawText(kind) {
            var isLast = kind === 14 || kind === 17;
            var tokenText = scanner.getTokenText();
            return tokenText.substring(1, tokenText.length - (scanner.isUnterminated() ? 0 : isLast ? 1 : 2));
        }
        function parseLiteralLikeNode(kind) {
            var pos = getNodePos();
            var node = ts.isTemplateLiteralKind(kind) ? factory.createTemplateLiteralLikeNode(kind, scanner.getTokenValue(), getTemplateLiteralRawText(kind), scanner.getTokenFlags() & 2048) :
                kind === 8 ? factory.createNumericLiteral(scanner.getTokenValue(), scanner.getNumericLiteralFlags()) :
                    kind === 10 ? factory.createStringLiteral(scanner.getTokenValue(), undefined, scanner.hasExtendedUnicodeEscape()) :
                        ts.isLiteralKind(kind) ? factory.createLiteralLikeNode(kind, scanner.getTokenValue()) :
                            ts.Debug.fail();
            if (scanner.hasExtendedUnicodeEscape()) {
                node.hasExtendedUnicodeEscape = true;
            }
            if (scanner.isUnterminated()) {
                node.isUnterminated = true;
            }
            nextToken();
            return finishNode(node, pos);
        }
        function parseEntityNameOfTypeReference() {
            return parseEntityName(true, ts.Diagnostics.Type_expected);
        }
        function parseTypeArgumentsOfTypeReference() {
            if (!scanner.hasPrecedingLineBreak() && reScanLessThanToken() === 29) {
                return parseBracketedList(20, parseType, 29, 31);
            }
        }
        function parseTypeReference() {
            var pos = getNodePos();
            return finishNode(factory.createTypeReferenceNode(parseEntityNameOfTypeReference(), parseTypeArgumentsOfTypeReference()), pos);
        }
        function typeHasArrowFunctionBlockingParseError(node) {
            switch (node.kind) {
                case 178:
                    return ts.nodeIsMissing(node.typeName);
                case 179:
                case 180: {
                    var _a = node, parameters = _a.parameters, type = _a.type;
                    return isMissingList(parameters) || typeHasArrowFunctionBlockingParseError(type);
                }
                case 191:
                    return typeHasArrowFunctionBlockingParseError(node.type);
                default:
                    return false;
            }
        }
        function parseThisTypePredicate(lhs) {
            nextToken();
            return finishNode(factory.createTypePredicateNode(undefined, lhs, parseType()), lhs.pos);
        }
        function parseThisTypeNode() {
            var pos = getNodePos();
            nextToken();
            return finishNode(factory.createThisTypeNode(), pos);
        }
        function parseJSDocAllType() {
            var pos = getNodePos();
            nextToken();
            return finishNode(factory.createJSDocAllType(), pos);
        }
        function parseJSDocNonNullableType() {
            var pos = getNodePos();
            nextToken();
            return finishNode(factory.createJSDocNonNullableType(parseNonArrayType(), false), pos);
        }
        function parseJSDocUnknownOrNullableType() {
            var pos = getNodePos();
            nextToken();
            if (token() === 27 ||
                token() === 19 ||
                token() === 21 ||
                token() === 31 ||
                token() === 63 ||
                token() === 51) {
                return finishNode(factory.createJSDocUnknownType(), pos);
            }
            else {
                return finishNode(factory.createJSDocNullableType(parseType(), false), pos);
            }
        }
        function parseJSDocFunctionType() {
            var pos = getNodePos();
            var hasJSDoc = hasPrecedingJSDocComment();
            if (lookAhead(nextTokenIsOpenParen)) {
                nextToken();
                var parameters = parseParameters(4 | 32);
                var type = parseReturnType(58, false);
                return withJSDoc(finishNode(factory.createJSDocFunctionType(parameters, type), pos), hasJSDoc);
            }
            return finishNode(factory.createTypeReferenceNode(parseIdentifierName(), undefined), pos);
        }
        function parseJSDocParameter() {
            var pos = getNodePos();
            var name;
            if (token() === 108 || token() === 103) {
                name = parseIdentifierName();
                parseExpected(58);
            }
            return finishNode(factory.createParameterDeclaration(undefined, undefined, undefined, name, undefined, parseJSDocType(), undefined), pos);
        }
        function parseJSDocType() {
            scanner.setInJSDocType(true);
            var pos = getNodePos();
            if (parseOptional(141)) {
                var moduleTag = factory.createJSDocNamepathType(undefined);
                terminate: while (true) {
                    switch (token()) {
                        case 19:
                        case 1:
                        case 27:
                        case 5:
                            break terminate;
                        default:
                            nextTokenJSDoc();
                    }
                }
                scanner.setInJSDocType(false);
                return finishNode(moduleTag, pos);
            }
            var hasDotDotDot = parseOptional(25);
            var type = parseTypeOrTypePredicate();
            scanner.setInJSDocType(false);
            if (hasDotDotDot) {
                type = finishNode(factory.createJSDocVariadicType(type), pos);
            }
            if (token() === 63) {
                nextToken();
                return finishNode(factory.createJSDocOptionalType(type), pos);
            }
            return type;
        }
        function parseTypeQuery() {
            var pos = getNodePos();
            parseExpected(112);
            var entityName = parseEntityName(true);
            var typeArguments = !scanner.hasPrecedingLineBreak() ? tryParseTypeArguments() : undefined;
            return finishNode(factory.createTypeQueryNode(entityName, typeArguments), pos);
        }
        function parseTypeParameter() {
            var pos = getNodePos();
            var modifiers = parseModifiers();
            var name = parseIdentifier();
            var constraint;
            var expression;
            if (parseOptional(94)) {
                if (isStartOfType() || !isStartOfExpression()) {
                    constraint = parseType();
                }
                else {
                    expression = parseUnaryExpressionOrHigher();
                }
            }
            var defaultType = parseOptional(63) ? parseType() : undefined;
            var node = factory.createTypeParameterDeclaration(modifiers, name, constraint, defaultType);
            node.expression = expression;
            return finishNode(node, pos);
        }
        function parseTypeParameters() {
            if (token() === 29) {
                return parseBracketedList(19, parseTypeParameter, 29, 31);
            }
        }
        function isStartOfParameter(isJSDocParameter) {
            return token() === 25 ||
                isBindingIdentifierOrPrivateIdentifierOrPattern() ||
                ts.isModifierKind(token()) ||
                token() === 59 ||
                isStartOfType(!isJSDocParameter);
        }
        function parseNameOfParameter(modifiers) {
            var name = parseIdentifierOrPattern(ts.Diagnostics.Private_identifiers_cannot_be_used_as_parameters);
            if (ts.getFullWidth(name) === 0 && !ts.some(modifiers) && ts.isModifierKind(token())) {
                nextToken();
            }
            return name;
        }
        function isParameterNameStart() {
            return isBindingIdentifier() || token() === 22 || token() === 18;
        }
        function parseParameter(inOuterAwaitContext) {
            return parseParameterWorker(inOuterAwaitContext);
        }
        function parseParameterForSpeculation(inOuterAwaitContext) {
            return parseParameterWorker(inOuterAwaitContext, false);
        }
        function parseParameterWorker(inOuterAwaitContext, allowAmbiguity) {
            if (allowAmbiguity === void 0) { allowAmbiguity = true; }
            var pos = getNodePos();
            var hasJSDoc = hasPrecedingJSDocComment();
            var decorators = inOuterAwaitContext ? doInAwaitContext(parseDecorators) : parseDecorators();
            if (token() === 108) {
                var node_1 = factory.createParameterDeclaration(decorators, undefined, undefined, createIdentifier(true), undefined, parseTypeAnnotation(), undefined);
                if (decorators) {
                    parseErrorAtRange(decorators[0], ts.Diagnostics.Decorators_may_not_be_applied_to_this_parameters);
                }
                return withJSDoc(finishNode(node_1, pos), hasJSDoc);
            }
            var savedTopLevel = topLevel;
            topLevel = false;
            var modifiers = parseModifiers();
            var dotDotDotToken = parseOptionalToken(25);
            if (!allowAmbiguity && !isParameterNameStart()) {
                return undefined;
            }
            var node = withJSDoc(finishNode(factory.createParameterDeclaration(decorators, modifiers, dotDotDotToken, parseNameOfParameter(modifiers), parseOptionalToken(57), parseTypeAnnotation(), parseInitializer()), pos), hasJSDoc);
            topLevel = savedTopLevel;
            return node;
        }
        function parseReturnType(returnToken, isType) {
            if (shouldParseReturnType(returnToken, isType)) {
                return allowConditionalTypesAnd(parseTypeOrTypePredicate);
            }
        }
        function shouldParseReturnType(returnToken, isType) {
            if (returnToken === 38) {
                parseExpected(returnToken);
                return true;
            }
            else if (parseOptional(58)) {
                return true;
            }
            else if (isType && token() === 38) {
                parseErrorAtCurrentToken(ts.Diagnostics._0_expected, ts.tokenToString(58));
                nextToken();
                return true;
            }
            return false;
        }
        function parseParametersWorker(flags, allowAmbiguity) {
            var savedYieldContext = inYieldContext();
            var savedAwaitContext = inAwaitContext();
            setYieldContext(!!(flags & 1));
            setAwaitContext(!!(flags & 2));
            var parameters = flags & 32 ?
                parseDelimitedList(17, parseJSDocParameter) :
                parseDelimitedList(16, function () { return allowAmbiguity ? parseParameter(savedAwaitContext) : parseParameterForSpeculation(savedAwaitContext); });
            setYieldContext(savedYieldContext);
            setAwaitContext(savedAwaitContext);
            return parameters;
        }
        function parseParameters(flags) {
            if (!parseExpected(20)) {
                return createMissingList();
            }
            var parameters = parseParametersWorker(flags, true);
            parseExpected(21);
            return parameters;
        }
        function parseTypeMemberSemicolon() {
            if (parseOptional(27)) {
                return;
            }
            parseSemicolon();
        }
        function parseSignatureMember(kind) {
            var pos = getNodePos();
            var hasJSDoc = hasPrecedingJSDocComment();
            if (kind === 175) {
                parseExpected(103);
            }
            var typeParameters = parseTypeParameters();
            var parameters = parseParameters(4);
            var type = parseReturnType(58, true);
            parseTypeMemberSemicolon();
            var node = kind === 174
                ? factory.createCallSignature(typeParameters, parameters, type)
                : factory.createConstructSignature(typeParameters, parameters, type);
            return withJSDoc(finishNode(node, pos), hasJSDoc);
        }
        function isIndexSignature() {
            return token() === 22 && lookAhead(isUnambiguouslyIndexSignature);
        }
        function isUnambiguouslyIndexSignature() {
            nextToken();
            if (token() === 25 || token() === 23) {
                return true;
            }
            if (ts.isModifierKind(token())) {
                nextToken();
                if (isIdentifier()) {
                    return true;
                }
            }
            else if (!isIdentifier()) {
                return false;
            }
            else {
                nextToken();
            }
            if (token() === 58 || token() === 27) {
                return true;
            }
            if (token() !== 57) {
                return false;
            }
            nextToken();
            return token() === 58 || token() === 27 || token() === 23;
        }
        function parseIndexSignatureDeclaration(pos, hasJSDoc, decorators, modifiers) {
            var parameters = parseBracketedList(16, function () { return parseParameter(false); }, 22, 23);
            var type = parseTypeAnnotation();
            parseTypeMemberSemicolon();
            var node = factory.createIndexSignature(decorators, modifiers, parameters, type);
            return withJSDoc(finishNode(node, pos), hasJSDoc);
        }
        function parsePropertyOrMethodSignature(pos, hasJSDoc, modifiers) {
            var name = parsePropertyName();
            var questionToken = parseOptionalToken(57);
            var node;
            if (token() === 20 || token() === 29) {
                var typeParameters = parseTypeParameters();
                var parameters = parseParameters(4);
                var type = parseReturnType(58, true);
                node = factory.createMethodSignature(modifiers, name, questionToken, typeParameters, parameters, type);
            }
            else {
                var type = parseTypeAnnotation();
                node = factory.createPropertySignature(modifiers, name, questionToken, type);
                if (token() === 63)
                    node.initializer = parseInitializer();
            }
            parseTypeMemberSemicolon();
            return withJSDoc(finishNode(node, pos), hasJSDoc);
        }
        function isTypeMemberStart() {
            if (token() === 20 ||
                token() === 29 ||
                token() === 136 ||
                token() === 149) {
                return true;
            }
            var idToken = false;
            while (ts.isModifierKind(token())) {
                idToken = true;
                nextToken();
            }
            if (token() === 22) {
                return true;
            }
            if (isLiteralPropertyName()) {
                idToken = true;
                nextToken();
            }
            if (idToken) {
                return token() === 20 ||
                    token() === 29 ||
                    token() === 57 ||
                    token() === 58 ||
                    token() === 27 ||
                    canParseSemicolon();
            }
            return false;
        }
        function parseTypeMember() {
            if (token() === 20 || token() === 29) {
                return parseSignatureMember(174);
            }
            if (token() === 103 && lookAhead(nextTokenIsOpenParenOrLessThan)) {
                return parseSignatureMember(175);
            }
            var pos = getNodePos();
            var hasJSDoc = hasPrecedingJSDocComment();
            var modifiers = parseModifiers();
            if (parseContextualModifier(136)) {
                return parseAccessorDeclaration(pos, hasJSDoc, undefined, modifiers, 172);
            }
            if (parseContextualModifier(149)) {
                return parseAccessorDeclaration(pos, hasJSDoc, undefined, modifiers, 173);
            }
            if (isIndexSignature()) {
                return parseIndexSignatureDeclaration(pos, hasJSDoc, undefined, modifiers);
            }
            return parsePropertyOrMethodSignature(pos, hasJSDoc, modifiers);
        }
        function nextTokenIsOpenParenOrLessThan() {
            nextToken();
            return token() === 20 || token() === 29;
        }
        function nextTokenIsDot() {
            return nextToken() === 24;
        }
        function nextTokenIsOpenParenOrLessThanOrDot() {
            switch (nextToken()) {
                case 20:
                case 29:
                case 24:
                    return true;
            }
            return false;
        }
        function parseTypeLiteral() {
            var pos = getNodePos();
            return finishNode(factory.createTypeLiteralNode(parseObjectTypeMembers()), pos);
        }
        function parseObjectTypeMembers() {
            var members;
            if (parseExpected(18)) {
                members = parseList(4, parseTypeMember);
                parseExpected(19);
            }
            else {
                members = createMissingList();
            }
            return members;
        }
        function isStartOfMappedType() {
            nextToken();
            if (token() === 39 || token() === 40) {
                return nextToken() === 145;
            }
            if (token() === 145) {
                nextToken();
            }
            return token() === 22 && nextTokenIsIdentifier() && nextToken() === 101;
        }
        function parseMappedTypeParameter() {
            var pos = getNodePos();
            var name = parseIdentifierName();
            parseExpected(101);
            var type = parseType();
            return finishNode(factory.createTypeParameterDeclaration(undefined, name, type, undefined), pos);
        }
        function parseMappedType() {
            var pos = getNodePos();
            parseExpected(18);
            var readonlyToken;
            if (token() === 145 || token() === 39 || token() === 40) {
                readonlyToken = parseTokenNode();
                if (readonlyToken.kind !== 145) {
                    parseExpected(145);
                }
            }
            parseExpected(22);
            var typeParameter = parseMappedTypeParameter();
            var nameType = parseOptional(127) ? parseType() : undefined;
            parseExpected(23);
            var questionToken;
            if (token() === 57 || token() === 39 || token() === 40) {
                questionToken = parseTokenNode();
                if (questionToken.kind !== 57) {
                    parseExpected(57);
                }
            }
            var type = parseTypeAnnotation();
            parseSemicolon();
            var members = parseList(4, parseTypeMember);
            parseExpected(19);
            return finishNode(factory.createMappedTypeNode(readonlyToken, typeParameter, nameType, questionToken, type, members), pos);
        }
        function parseTupleElementType() {
            var pos = getNodePos();
            if (parseOptional(25)) {
                return finishNode(factory.createRestTypeNode(parseType()), pos);
            }
            var type = parseType();
            if (ts.isJSDocNullableType(type) && type.pos === type.type.pos) {
                var node = factory.createOptionalTypeNode(type.type);
                ts.setTextRange(node, type);
                node.flags = type.flags;
                return node;
            }
            return type;
        }
        function isNextTokenColonOrQuestionColon() {
            return nextToken() === 58 || (token() === 57 && nextToken() === 58);
        }
        function isTupleElementName() {
            if (token() === 25) {
                return ts.tokenIsIdentifierOrKeyword(nextToken()) && isNextTokenColonOrQuestionColon();
            }
            return ts.tokenIsIdentifierOrKeyword(token()) && isNextTokenColonOrQuestionColon();
        }
        function parseTupleElementNameOrTupleElementType() {
            if (lookAhead(isTupleElementName)) {
                var pos = getNodePos();
                var hasJSDoc = hasPrecedingJSDocComment();
                var dotDotDotToken = parseOptionalToken(25);
                var name = parseIdentifierName();
                var questionToken = parseOptionalToken(57);
                parseExpected(58);
                var type = parseTupleElementType();
                var node = factory.createNamedTupleMember(dotDotDotToken, name, questionToken, type);
                return withJSDoc(finishNode(node, pos), hasJSDoc);
            }
            return parseTupleElementType();
        }
        function parseTupleType() {
            var pos = getNodePos();
            return finishNode(factory.createTupleTypeNode(parseBracketedList(21, parseTupleElementNameOrTupleElementType, 22, 23)), pos);
        }
        function parseParenthesizedType() {
            var pos = getNodePos();
            parseExpected(20);
            var type = parseType();
            parseExpected(21);
            return finishNode(factory.createParenthesizedType(type), pos);
        }
        function parseModifiersForConstructorType() {
            var modifiers;
            if (token() === 126) {
                var pos = getNodePos();
                nextToken();
                var modifier = finishNode(factory.createToken(126), pos);
                modifiers = createNodeArray([modifier], pos);
            }
            return modifiers;
        }
        function parseFunctionOrConstructorType() {
            var pos = getNodePos();
            var hasJSDoc = hasPrecedingJSDocComment();
            var modifiers = parseModifiersForConstructorType();
            var isConstructorType = parseOptional(103);
            var typeParameters = parseTypeParameters();
            var parameters = parseParameters(4);
            var type = parseReturnType(38, false);
            var node = isConstructorType
                ? factory.createConstructorTypeNode(modifiers, typeParameters, parameters, type)
                : factory.createFunctionTypeNode(typeParameters, parameters, type);
            if (!isConstructorType)
                node.modifiers = modifiers;
            return withJSDoc(finishNode(node, pos), hasJSDoc);
        }
        function parseKeywordAndNoDot() {
            var node = parseTokenNode();
            return token() === 24 ? undefined : node;
        }
        function parseLiteralTypeNode(negative) {
            var pos = getNodePos();
            if (negative) {
                nextToken();
            }
            var expression = token() === 110 || token() === 95 || token() === 104 ?
                parseTokenNode() :
                parseLiteralLikeNode(token());
            if (negative) {
                expression = finishNode(factory.createPrefixUnaryExpression(40, expression), pos);
            }
            return finishNode(factory.createLiteralTypeNode(expression), pos);
        }
        function isStartOfTypeOfImportType() {
            nextToken();
            return token() === 100;
        }
        function parseImportTypeAssertions() {
            var pos = getNodePos();
            var openBracePosition = scanner.getTokenPos();
            parseExpected(18);
            var multiLine = scanner.hasPrecedingLineBreak();
            parseExpected(129);
            parseExpected(58);
            var clause = parseAssertClause(true);
            if (!parseExpected(19)) {
                var lastError = ts.lastOrUndefined(parseDiagnostics);
                if (lastError && lastError.code === ts.Diagnostics._0_expected.code) {
                    ts.addRelatedInfo(lastError, ts.createDetachedDiagnostic(fileName, openBracePosition, 1, ts.Diagnostics.The_parser_expected_to_find_a_1_to_match_the_0_token_here, "{", "}"));
                }
            }
            return finishNode(factory.createImportTypeAssertionContainer(clause, multiLine), pos);
        }
        function parseImportType() {
            sourceFlags |= 2097152;
            var pos = getNodePos();
            var isTypeOf = parseOptional(112);
            parseExpected(100);
            parseExpected(20);
            var type = parseType();
            var assertions;
            if (parseOptional(27)) {
                assertions = parseImportTypeAssertions();
            }
            parseExpected(21);
            var qualifier = parseOptional(24) ? parseEntityNameOfTypeReference() : undefined;
            var typeArguments = parseTypeArgumentsOfTypeReference();
            return finishNode(factory.createImportTypeNode(type, assertions, qualifier, typeArguments, isTypeOf), pos);
        }
        function nextTokenIsNumericOrBigIntLiteral() {
            nextToken();
            return token() === 8 || token() === 9;
        }
        function parseNonArrayType() {
            switch (token()) {
                case 130:
                case 155:
                case 150:
                case 147:
                case 158:
                case 151:
                case 133:
                case 153:
                case 143:
                case 148:
                    return tryParse(parseKeywordAndNoDot) || parseTypeReference();
                case 66:
                    scanner.reScanAsteriskEqualsToken();
                case 41:
                    return parseJSDocAllType();
                case 60:
                    scanner.reScanQuestionToken();
                case 57:
                    return parseJSDocUnknownOrNullableType();
                case 98:
                    return parseJSDocFunctionType();
                case 53:
                    return parseJSDocNonNullableType();
                case 14:
                case 10:
                case 8:
                case 9:
                case 110:
                case 95:
                case 104:
                    return parseLiteralTypeNode();
                case 40:
                    return lookAhead(nextTokenIsNumericOrBigIntLiteral) ? parseLiteralTypeNode(true) : parseTypeReference();
                case 114:
                    return parseTokenNode();
                case 108: {
                    var thisKeyword = parseThisTypeNode();
                    if (token() === 139 && !scanner.hasPrecedingLineBreak()) {
                        return parseThisTypePredicate(thisKeyword);
                    }
                    else {
                        return thisKeyword;
                    }
                }
                case 112:
                    return lookAhead(isStartOfTypeOfImportType) ? parseImportType() : parseTypeQuery();
                case 18:
                    return lookAhead(isStartOfMappedType) ? parseMappedType() : parseTypeLiteral();
                case 22:
                    return parseTupleType();
                case 20:
                    return parseParenthesizedType();
                case 100:
                    return parseImportType();
                case 128:
                    return lookAhead(nextTokenIsIdentifierOrKeywordOnSameLine) ? parseAssertsTypePredicate() : parseTypeReference();
                case 15:
                    return parseTemplateType();
                default:
                    return parseTypeReference();
            }
        }
        function isStartOfType(inStartOfParameter) {
            switch (token()) {
                case 130:
                case 155:
                case 150:
                case 147:
                case 158:
                case 133:
                case 145:
                case 151:
                case 154:
                case 114:
                case 153:
                case 104:
                case 108:
                case 112:
                case 143:
                case 18:
                case 22:
                case 29:
                case 51:
                case 50:
                case 103:
                case 10:
                case 8:
                case 9:
                case 110:
                case 95:
                case 148:
                case 41:
                case 57:
                case 53:
                case 25:
                case 137:
                case 100:
                case 128:
                case 14:
                case 15:
                    return true;
                case 98:
                    return !inStartOfParameter;
                case 40:
                    return !inStartOfParameter && lookAhead(nextTokenIsNumericOrBigIntLiteral);
                case 20:
                    return !inStartOfParameter && lookAhead(isStartOfParenthesizedOrFunctionType);
                default:
                    return isIdentifier();
            }
        }
        function isStartOfParenthesizedOrFunctionType() {
            nextToken();
            return token() === 21 || isStartOfParameter(false) || isStartOfType();
        }
        function parsePostfixTypeOrHigher() {
            var pos = getNodePos();
            var type = parseNonArrayType();
            while (!scanner.hasPrecedingLineBreak()) {
                switch (token()) {
                    case 53:
                        nextToken();
                        type = finishNode(factory.createJSDocNonNullableType(type, true), pos);
                        break;
                    case 57:
                        if (lookAhead(nextTokenIsStartOfType)) {
                            return type;
                        }
                        nextToken();
                        type = finishNode(factory.createJSDocNullableType(type, true), pos);
                        break;
                    case 22:
                        parseExpected(22);
                        if (isStartOfType()) {
                            var indexType = parseType();
                            parseExpected(23);
                            type = finishNode(factory.createIndexedAccessTypeNode(type, indexType), pos);
                        }
                        else {
                            parseExpected(23);
                            type = finishNode(factory.createArrayTypeNode(type), pos);
                        }
                        break;
                    default:
                        return type;
                }
            }
            return type;
        }
        function parseTypeOperator(operator) {
            var pos = getNodePos();
            parseExpected(operator);
            return finishNode(factory.createTypeOperatorNode(operator, parseTypeOperatorOrHigher()), pos);
        }
        function tryParseConstraintOfInferType() {
            if (parseOptional(94)) {
                var constraint = disallowConditionalTypesAnd(parseType);
                if (inDisallowConditionalTypesContext() || token() !== 57) {
                    return constraint;
                }
            }
        }
        function parseTypeParameterOfInferType() {
            var pos = getNodePos();
            var name = parseIdentifier();
            var constraint = tryParse(tryParseConstraintOfInferType);
            var node = factory.createTypeParameterDeclaration(undefined, name, constraint);
            return finishNode(node, pos);
        }
        function parseInferType() {
            var pos = getNodePos();
            parseExpected(137);
            return finishNode(factory.createInferTypeNode(parseTypeParameterOfInferType()), pos);
        }
        function parseTypeOperatorOrHigher() {
            var operator = token();
            switch (operator) {
                case 140:
                case 154:
                case 145:
                    return parseTypeOperator(operator);
                case 137:
                    return parseInferType();
            }
            return allowConditionalTypesAnd(parsePostfixTypeOrHigher);
        }
        function parseFunctionOrConstructorTypeToError(isInUnionType) {
            if (isStartOfFunctionTypeOrConstructorType()) {
                var type = parseFunctionOrConstructorType();
                var diagnostic = void 0;
                if (ts.isFunctionTypeNode(type)) {
                    diagnostic = isInUnionType
                        ? ts.Diagnostics.Function_type_notation_must_be_parenthesized_when_used_in_a_union_type
                        : ts.Diagnostics.Function_type_notation_must_be_parenthesized_when_used_in_an_intersection_type;
                }
                else {
                    diagnostic = isInUnionType
                        ? ts.Diagnostics.Constructor_type_notation_must_be_parenthesized_when_used_in_a_union_type
                        : ts.Diagnostics.Constructor_type_notation_must_be_parenthesized_when_used_in_an_intersection_type;
                }
                parseErrorAtRange(type, diagnostic);
                return type;
            }
            return undefined;
        }
        function parseUnionOrIntersectionType(operator, parseConstituentType, createTypeNode) {
            var pos = getNodePos();
            var isUnionType = operator === 51;
            var hasLeadingOperator = parseOptional(operator);
            var type = hasLeadingOperator && parseFunctionOrConstructorTypeToError(isUnionType)
                || parseConstituentType();
            if (token() === operator || hasLeadingOperator) {
                var types = [type];
                while (parseOptional(operator)) {
                    types.push(parseFunctionOrConstructorTypeToError(isUnionType) || parseConstituentType());
                }
                type = finishNode(createTypeNode(createNodeArray(types, pos)), pos);
            }
            return type;
        }
        function parseIntersectionTypeOrHigher() {
            return parseUnionOrIntersectionType(50, parseTypeOperatorOrHigher, factory.createIntersectionTypeNode);
        }
        function parseUnionTypeOrHigher() {
            return parseUnionOrIntersectionType(51, parseIntersectionTypeOrHigher, factory.createUnionTypeNode);
        }
        function nextTokenIsNewKeyword() {
            nextToken();
            return token() === 103;
        }
        function isStartOfFunctionTypeOrConstructorType() {
            if (token() === 29) {
                return true;
            }
            if (token() === 20 && lookAhead(isUnambiguouslyStartOfFunctionType)) {
                return true;
            }
            return token() === 103 ||
                token() === 126 && lookAhead(nextTokenIsNewKeyword);
        }
        function skipParameterStart() {
            if (ts.isModifierKind(token())) {
                parseModifiers();
            }
            if (isIdentifier() || token() === 108) {
                nextToken();
                return true;
            }
            if (token() === 22 || token() === 18) {
                var previousErrorCount = parseDiagnostics.length;
                parseIdentifierOrPattern();
                return previousErrorCount === parseDiagnostics.length;
            }
            return false;
        }
        function isUnambiguouslyStartOfFunctionType() {
            nextToken();
            if (token() === 21 || token() === 25) {
                return true;
            }
            if (skipParameterStart()) {
                if (token() === 58 || token() === 27 ||
                    token() === 57 || token() === 63) {
                    return true;
                }
                if (token() === 21) {
                    nextToken();
                    if (token() === 38) {
                        return true;
                    }
                }
            }
            return false;
        }
        function parseTypeOrTypePredicate() {
            var pos = getNodePos();
            var typePredicateVariable = isIdentifier() && tryParse(parseTypePredicatePrefix);
            var type = parseType();
            if (typePredicateVariable) {
                return finishNode(factory.createTypePredicateNode(undefined, typePredicateVariable, type), pos);
            }
            else {
                return type;
            }
        }
        function parseTypePredicatePrefix() {
            var id = parseIdentifier();
            if (token() === 139 && !scanner.hasPrecedingLineBreak()) {
                nextToken();
                return id;
            }
        }
        function parseAssertsTypePredicate() {
            var pos = getNodePos();
            var assertsModifier = parseExpectedToken(128);
            var parameterName = token() === 108 ? parseThisTypeNode() : parseIdentifier();
            var type = parseOptional(139) ? parseType() : undefined;
            return finishNode(factory.createTypePredicateNode(assertsModifier, parameterName, type), pos);
        }
        function parseType() {
            if (contextFlags & 40960) {
                return doOutsideOfContext(40960, parseType);
            }
            if (isStartOfFunctionTypeOrConstructorType()) {
                return parseFunctionOrConstructorType();
            }
            var pos = getNodePos();
            var type = parseUnionTypeOrHigher();
            if (!inDisallowConditionalTypesContext() && !scanner.hasPrecedingLineBreak() && parseOptional(94)) {
                var extendsType = disallowConditionalTypesAnd(parseType);
                parseExpected(57);
                var trueType = allowConditionalTypesAnd(parseType);
                parseExpected(58);
                var falseType = allowConditionalTypesAnd(parseType);
                return finishNode(factory.createConditionalTypeNode(type, extendsType, trueType, falseType), pos);
            }
            return type;
        }
        function parseTypeAnnotation() {
            return parseOptional(58) ? parseType() : undefined;
        }
        function isStartOfLeftHandSideExpression() {
            switch (token()) {
                case 108:
                case 106:
                case 104:
                case 110:
                case 95:
                case 8:
                case 9:
                case 10:
                case 14:
                case 15:
                case 20:
                case 22:
                case 18:
                case 98:
                case 84:
                case 103:
                case 43:
                case 68:
                case 79:
                    return true;
                case 100:
                    return lookAhead(nextTokenIsOpenParenOrLessThanOrDot);
                default:
                    return isIdentifier();
            }
        }
        function isStartOfExpression() {
            if (isStartOfLeftHandSideExpression()) {
                return true;
            }
            switch (token()) {
                case 39:
                case 40:
                case 54:
                case 53:
                case 89:
                case 112:
                case 114:
                case 45:
                case 46:
                case 29:
                case 132:
                case 125:
                case 80:
                    return true;
                default:
                    if (isBinaryOperator()) {
                        return true;
                    }
                    return isIdentifier();
            }
        }
        function isStartOfExpressionStatement() {
            return token() !== 18 &&
                token() !== 98 &&
                token() !== 84 &&
                token() !== 59 &&
                isStartOfExpression();
        }
        function parseExpression() {
            var saveDecoratorContext = inDecoratorContext();
            if (saveDecoratorContext) {
                setDecoratorContext(false);
            }
            var pos = getNodePos();
            var expr = parseAssignmentExpressionOrHigher();
            var operatorToken;
            while ((operatorToken = parseOptionalToken(27))) {
                expr = makeBinaryExpression(expr, operatorToken, parseAssignmentExpressionOrHigher(), pos);
            }
            if (saveDecoratorContext) {
                setDecoratorContext(true);
            }
            return expr;
        }
        function parseInitializer() {
            return parseOptional(63) ? parseAssignmentExpressionOrHigher() : undefined;
        }
        function parseAssignmentExpressionOrHigher() {
            if (isYieldExpression()) {
                return parseYieldExpression();
            }
            var arrowExpression = tryParseParenthesizedArrowFunctionExpression() || tryParseAsyncSimpleArrowFunctionExpression();
            if (arrowExpression) {
                return arrowExpression;
            }
            var pos = getNodePos();
            var expr = parseBinaryExpressionOrHigher(0);
            if (expr.kind === 79 && token() === 38) {
                return parseSimpleArrowFunctionExpression(pos, expr, undefined);
            }
            if (ts.isLeftHandSideExpression(expr) && ts.isAssignmentOperator(reScanGreaterToken())) {
                return makeBinaryExpression(expr, parseTokenNode(), parseAssignmentExpressionOrHigher(), pos);
            }
            return parseConditionalExpressionRest(expr, pos);
        }
        function isYieldExpression() {
            if (token() === 125) {
                if (inYieldContext()) {
                    return true;
                }
                return lookAhead(nextTokenIsIdentifierOrKeywordOrLiteralOnSameLine);
            }
            return false;
        }
        function nextTokenIsIdentifierOnSameLine() {
            nextToken();
            return !scanner.hasPrecedingLineBreak() && isIdentifier();
        }
        function parseYieldExpression() {
            var pos = getNodePos();
            nextToken();
            if (!scanner.hasPrecedingLineBreak() &&
                (token() === 41 || isStartOfExpression())) {
                return finishNode(factory.createYieldExpression(parseOptionalToken(41), parseAssignmentExpressionOrHigher()), pos);
            }
            else {
                return finishNode(factory.createYieldExpression(undefined, undefined), pos);
            }
        }
        function parseSimpleArrowFunctionExpression(pos, identifier, asyncModifier) {
            ts.Debug.assert(token() === 38, "parseSimpleArrowFunctionExpression should only have been called if we had a =>");
            var parameter = factory.createParameterDeclaration(undefined, undefined, undefined, identifier, undefined, undefined, undefined);
            finishNode(parameter, identifier.pos);
            var parameters = createNodeArray([parameter], parameter.pos, parameter.end);
            var equalsGreaterThanToken = parseExpectedToken(38);
            var body = parseArrowFunctionExpressionBody(!!asyncModifier);
            var node = factory.createArrowFunction(asyncModifier, undefined, parameters, undefined, equalsGreaterThanToken, body);
            return addJSDocComment(finishNode(node, pos));
        }
        function tryParseParenthesizedArrowFunctionExpression() {
            var triState = isParenthesizedArrowFunctionExpression();
            if (triState === 0) {
                return undefined;
            }
            return triState === 1 ?
                parseParenthesizedArrowFunctionExpression(true) :
                tryParse(parsePossibleParenthesizedArrowFunctionExpression);
        }
        function isParenthesizedArrowFunctionExpression() {
            if (token() === 20 || token() === 29 || token() === 131) {
                return lookAhead(isParenthesizedArrowFunctionExpressionWorker);
            }
            if (token() === 38) {
                return 1;
            }
            return 0;
        }
        function isParenthesizedArrowFunctionExpressionWorker() {
            if (token() === 131) {
                nextToken();
                if (scanner.hasPrecedingLineBreak()) {
                    return 0;
                }
                if (token() !== 20 && token() !== 29) {
                    return 0;
                }
            }
            var first = token();
            var second = nextToken();
            if (first === 20) {
                if (second === 21) {
                    var third = nextToken();
                    switch (third) {
                        case 38:
                        case 58:
                        case 18:
                            return 1;
                        default:
                            return 0;
                    }
                }
                if (second === 22 || second === 18) {
                    return 2;
                }
                if (second === 25) {
                    return 1;
                }
                if (ts.isModifierKind(second) && second !== 131 && lookAhead(nextTokenIsIdentifier)) {
                    if (lookAhead(function () { return nextToken() === 127; })) {
                        return 0;
                    }
                    return 1;
                }
                if (!isIdentifier() && second !== 108) {
                    return 0;
                }
                switch (nextToken()) {
                    case 58:
                        return 1;
                    case 57:
                        nextToken();
                        if (token() === 58 || token() === 27 || token() === 63 || token() === 21) {
                            return 1;
                        }
                        return 0;
                    case 27:
                    case 63:
                    case 21:
                        return 2;
                }
                return 0;
            }
            else {
                ts.Debug.assert(first === 29);
                if (!isIdentifier()) {
                    return 0;
                }
                if (languageVariant === 1) {
                    var isArrowFunctionInJsx = lookAhead(function () {
                        var third = nextToken();
                        if (third === 94) {
                            var fourth = nextToken();
                            switch (fourth) {
                                case 63:
                                case 31:
                                    return false;
                                default:
                                    return true;
                            }
                        }
                        else if (third === 27 || third === 63) {
                            return true;
                        }
                        return false;
                    });
                    if (isArrowFunctionInJsx) {
                        return 1;
                    }
                    return 0;
                }
                return 2;
            }
        }
        function parsePossibleParenthesizedArrowFunctionExpression() {
            var tokenPos = scanner.getTokenPos();
            if (notParenthesizedArrow === null || notParenthesizedArrow === void 0 ? void 0 : notParenthesizedArrow.has(tokenPos)) {
                return undefined;
            }
            var result = parseParenthesizedArrowFunctionExpression(false);
            if (!result) {
                (notParenthesizedArrow || (notParenthesizedArrow = new ts.Set())).add(tokenPos);
            }
            return result;
        }
        function tryParseAsyncSimpleArrowFunctionExpression() {
            if (token() === 131) {
                if (lookAhead(isUnParenthesizedAsyncArrowFunctionWorker) === 1) {
                    var pos = getNodePos();
                    var asyncModifier = parseModifiersForArrowFunction();
                    var expr = parseBinaryExpressionOrHigher(0);
                    return parseSimpleArrowFunctionExpression(pos, expr, asyncModifier);
                }
            }
            return undefined;
        }
        function isUnParenthesizedAsyncArrowFunctionWorker() {
            if (token() === 131) {
                nextToken();
                if (scanner.hasPrecedingLineBreak() || token() === 38) {
                    return 0;
                }
                var expr = parseBinaryExpressionOrHigher(0);
                if (!scanner.hasPrecedingLineBreak() && expr.kind === 79 && token() === 38) {
                    return 1;
                }
            }
            return 0;
        }
        function parseParenthesizedArrowFunctionExpression(allowAmbiguity) {
            var pos = getNodePos();
            var hasJSDoc = hasPrecedingJSDocComment();
            var modifiers = parseModifiersForArrowFunction();
            var isAsync = ts.some(modifiers, ts.isAsyncModifier) ? 2 : 0;
            var typeParameters = parseTypeParameters();
            var parameters;
            if (!parseExpected(20)) {
                if (!allowAmbiguity) {
                    return undefined;
                }
                parameters = createMissingList();
            }
            else {
                if (!allowAmbiguity) {
                    var maybeParameters = parseParametersWorker(isAsync, allowAmbiguity);
                    if (!maybeParameters) {
                        return undefined;
                    }
                    parameters = maybeParameters;
                }
                else {
                    parameters = parseParametersWorker(isAsync, allowAmbiguity);
                }
                if (!parseExpected(21) && !allowAmbiguity) {
                    return undefined;
                }
            }
            var type = parseReturnType(58, false);
            if (type && !allowAmbiguity && typeHasArrowFunctionBlockingParseError(type)) {
                return undefined;
            }
            var unwrappedType = type;
            while ((unwrappedType === null || unwrappedType === void 0 ? void 0 : unwrappedType.kind) === 191) {
                unwrappedType = unwrappedType.type;
            }
            var hasJSDocFunctionType = unwrappedType && ts.isJSDocFunctionType(unwrappedType);
            if (!allowAmbiguity && token() !== 38 && (hasJSDocFunctionType || token() !== 18)) {
                return undefined;
            }
            var lastToken = token();
            var equalsGreaterThanToken = parseExpectedToken(38);
            var body = (lastToken === 38 || lastToken === 18)
                ? parseArrowFunctionExpressionBody(ts.some(modifiers, ts.isAsyncModifier))
                : parseIdentifier();
            var node = factory.createArrowFunction(modifiers, typeParameters, parameters, type, equalsGreaterThanToken, body);
            return withJSDoc(finishNode(node, pos), hasJSDoc);
        }
        function parseArrowFunctionExpressionBody(isAsync) {
            if (token() === 18) {
                return parseFunctionBlock(isAsync ? 2 : 0);
            }
            if (token() !== 26 &&
                token() !== 98 &&
                token() !== 84 &&
                isStartOfStatement() &&
                !isStartOfExpressionStatement()) {
                return parseFunctionBlock(16 | (isAsync ? 2 : 0));
            }
            var savedTopLevel = topLevel;
            topLevel = false;
            var node = isAsync
                ? doInAwaitContext(parseAssignmentExpressionOrHigher)
                : doOutsideOfAwaitContext(parseAssignmentExpressionOrHigher);
            topLevel = savedTopLevel;
            return node;
        }
        function parseConditionalExpressionRest(leftOperand, pos) {
            var questionToken = parseOptionalToken(57);
            if (!questionToken) {
                return leftOperand;
            }
            var colonToken;
            return finishNode(factory.createConditionalExpression(leftOperand, questionToken, doOutsideOfContext(disallowInAndDecoratorContext, parseAssignmentExpressionOrHigher), colonToken = parseExpectedToken(58), ts.nodeIsPresent(colonToken)
                ? parseAssignmentExpressionOrHigher()
                : createMissingNode(79, false, ts.Diagnostics._0_expected, ts.tokenToString(58))), pos);
        }
        function parseBinaryExpressionOrHigher(precedence) {
            var pos = getNodePos();
            var leftOperand = parseUnaryExpressionOrHigher();
            return parseBinaryExpressionRest(precedence, leftOperand, pos);
        }
        function isInOrOfKeyword(t) {
            return t === 101 || t === 160;
        }
        function parseBinaryExpressionRest(precedence, leftOperand, pos) {
            while (true) {
                reScanGreaterToken();
                var newPrecedence = ts.getBinaryOperatorPrecedence(token());
                var consumeCurrentOperator = token() === 42 ?
                    newPrecedence >= precedence :
                    newPrecedence > precedence;
                if (!consumeCurrentOperator) {
                    break;
                }
                if (token() === 101 && inDisallowInContext()) {
                    break;
                }
                if (token() === 127) {
                    if (scanner.hasPrecedingLineBreak()) {
                        break;
                    }
                    else {
                        nextToken();
                        leftOperand = makeAsExpression(leftOperand, parseType());
                    }
                }
                else {
                    leftOperand = makeBinaryExpression(leftOperand, parseTokenNode(), parseBinaryExpressionOrHigher(newPrecedence), pos);
                }
            }
            return leftOperand;
        }
        function isBinaryOperator() {
            if (inDisallowInContext() && token() === 101) {
                return false;
            }
            return ts.getBinaryOperatorPrecedence(token()) > 0;
        }
        function makeBinaryExpression(left, operatorToken, right, pos) {
            return finishNode(factory.createBinaryExpression(left, operatorToken, right), pos);
        }
        function makeAsExpression(left, right) {
            return finishNode(factory.createAsExpression(left, right), left.pos);
        }
        function parsePrefixUnaryExpression() {
            var pos = getNodePos();
            return finishNode(factory.createPrefixUnaryExpression(token(), nextTokenAnd(parseSimpleUnaryExpression)), pos);
        }
        function parseDeleteExpression() {
            var pos = getNodePos();
            return finishNode(factory.createDeleteExpression(nextTokenAnd(parseSimpleUnaryExpression)), pos);
        }
        function parseTypeOfExpression() {
            var pos = getNodePos();
            return finishNode(factory.createTypeOfExpression(nextTokenAnd(parseSimpleUnaryExpression)), pos);
        }
        function parseVoidExpression() {
            var pos = getNodePos();
            return finishNode(factory.createVoidExpression(nextTokenAnd(parseSimpleUnaryExpression)), pos);
        }
        function isAwaitExpression() {
            if (token() === 132) {
                if (inAwaitContext()) {
                    return true;
                }
                return lookAhead(nextTokenIsIdentifierOrKeywordOrLiteralOnSameLine);
            }
            return false;
        }
        function parseAwaitExpression() {
            var pos = getNodePos();
            return finishNode(factory.createAwaitExpression(nextTokenAnd(parseSimpleUnaryExpression)), pos);
        }
        function parseUnaryExpressionOrHigher() {
            if (isUpdateExpression()) {
                var pos = getNodePos();
                var updateExpression = parseUpdateExpression();
                return token() === 42 ?
                    parseBinaryExpressionRest(ts.getBinaryOperatorPrecedence(token()), updateExpression, pos) :
                    updateExpression;
            }
            var unaryOperator = token();
            var simpleUnaryExpression = parseSimpleUnaryExpression();
            if (token() === 42) {
                var pos = ts.skipTrivia(sourceText, simpleUnaryExpression.pos);
                var end = simpleUnaryExpression.end;
                if (simpleUnaryExpression.kind === 211) {
                    parseErrorAt(pos, end, ts.Diagnostics.A_type_assertion_expression_is_not_allowed_in_the_left_hand_side_of_an_exponentiation_expression_Consider_enclosing_the_expression_in_parentheses);
                }
                else {
                    parseErrorAt(pos, end, ts.Diagnostics.An_unary_expression_with_the_0_operator_is_not_allowed_in_the_left_hand_side_of_an_exponentiation_expression_Consider_enclosing_the_expression_in_parentheses, ts.tokenToString(unaryOperator));
                }
            }
            return simpleUnaryExpression;
        }
        function parseSimpleUnaryExpression() {
            switch (token()) {
                case 39:
                case 40:
                case 54:
                case 53:
                    return parsePrefixUnaryExpression();
                case 89:
                    return parseDeleteExpression();
                case 112:
                    return parseTypeOfExpression();
                case 114:
                    return parseVoidExpression();
                case 29:
                    return parseTypeAssertion();
                case 132:
                    if (isAwaitExpression()) {
                        return parseAwaitExpression();
                    }
                default:
                    return parseUpdateExpression();
            }
        }
        function isUpdateExpression() {
            switch (token()) {
                case 39:
                case 40:
                case 54:
                case 53:
                case 89:
                case 112:
                case 114:
                case 132:
                    return false;
                case 29:
                    if (languageVariant !== 1) {
                        return false;
                    }
                default:
                    return true;
            }
        }
        function parseUpdateExpression() {
            if (token() === 45 || token() === 46) {
                var pos = getNodePos();
                return finishNode(factory.createPrefixUnaryExpression(token(), nextTokenAnd(parseLeftHandSideExpressionOrHigher)), pos);
            }
            else if (languageVariant === 1 && token() === 29 && lookAhead(nextTokenIsIdentifierOrKeywordOrGreaterThan)) {
                return parseJsxElementOrSelfClosingElementOrFragment(true);
            }
            var expression = parseLeftHandSideExpressionOrHigher();
            ts.Debug.assert(ts.isLeftHandSideExpression(expression));
            if ((token() === 45 || token() === 46) && !scanner.hasPrecedingLineBreak()) {
                var operator = token();
                nextToken();
                return finishNode(factory.createPostfixUnaryExpression(expression, operator), expression.pos);
            }
            return expression;
        }
        function parseLeftHandSideExpressionOrHigher() {
            var pos = getNodePos();
            var expression;
            if (token() === 100) {
                if (lookAhead(nextTokenIsOpenParenOrLessThan)) {
                    sourceFlags |= 2097152;
                    expression = parseTokenNode();
                }
                else if (lookAhead(nextTokenIsDot)) {
                    nextToken();
                    nextToken();
                    expression = finishNode(factory.createMetaProperty(100, parseIdentifierName()), pos);
                    sourceFlags |= 4194304;
                }
                else {
                    expression = parseMemberExpressionOrHigher();
                }
            }
            else {
                expression = token() === 106 ? parseSuperExpression() : parseMemberExpressionOrHigher();
            }
            return parseCallExpressionRest(pos, expression);
        }
        function parseMemberExpressionOrHigher() {
            var pos = getNodePos();
            var expression = parsePrimaryExpression();
            return parseMemberExpressionRest(pos, expression, true);
        }
        function parseSuperExpression() {
            var pos = getNodePos();
            var expression = parseTokenNode();
            if (token() === 29) {
                var startPos = getNodePos();
                var typeArguments = tryParse(parseTypeArgumentsInExpression);
                if (typeArguments !== undefined) {
                    parseErrorAt(startPos, getNodePos(), ts.Diagnostics.super_may_not_use_type_arguments);
                }
            }
            if (token() === 20 || token() === 24 || token() === 22) {
                return expression;
            }
            parseExpectedToken(24, ts.Diagnostics.super_must_be_followed_by_an_argument_list_or_member_access);
            return finishNode(factory.createPropertyAccessExpression(expression, parseRightSideOfDot(true, true)), pos);
        }
        function parseJsxElementOrSelfClosingElementOrFragment(inExpressionContext, topInvalidNodePosition, openingTag) {
            var pos = getNodePos();
            var opening = parseJsxOpeningOrSelfClosingElementOrOpeningFragment(inExpressionContext);
            var result;
            if (opening.kind === 280) {
                var children = parseJsxChildren(opening);
                var closingElement = void 0;
                var lastChild = children[children.length - 1];
                if ((lastChild === null || lastChild === void 0 ? void 0 : lastChild.kind) === 278
                    && !tagNamesAreEquivalent(lastChild.openingElement.tagName, lastChild.closingElement.tagName)
                    && tagNamesAreEquivalent(opening.tagName, lastChild.closingElement.tagName)) {
                    var end = lastChild.children.end;
                    var newLast = finishNode(factory.createJsxElement(lastChild.openingElement, lastChild.children, finishNode(factory.createJsxClosingElement(finishNode(factory.createIdentifier(""), end, end)), end, end)), lastChild.openingElement.pos, end);
                    children = createNodeArray(__spreadArray(__spreadArray([], children.slice(0, children.length - 1), true), [newLast], false), children.pos, end);
                    closingElement = lastChild.closingElement;
                }
                else {
                    closingElement = parseJsxClosingElement(opening, inExpressionContext);
                    if (!tagNamesAreEquivalent(opening.tagName, closingElement.tagName)) {
                        if (openingTag && ts.isJsxOpeningElement(openingTag) && tagNamesAreEquivalent(closingElement.tagName, openingTag.tagName)) {
                            parseErrorAtRange(opening.tagName, ts.Diagnostics.JSX_element_0_has_no_corresponding_closing_tag, ts.getTextOfNodeFromSourceText(sourceText, opening.tagName));
                        }
                        else {
                            parseErrorAtRange(closingElement.tagName, ts.Diagnostics.Expected_corresponding_JSX_closing_tag_for_0, ts.getTextOfNodeFromSourceText(sourceText, opening.tagName));
                        }
                    }
                }
                result = finishNode(factory.createJsxElement(opening, children, closingElement), pos);
            }
            else if (opening.kind === 283) {
                result = finishNode(factory.createJsxFragment(opening, parseJsxChildren(opening), parseJsxClosingFragment(inExpressionContext)), pos);
            }
            else {
                ts.Debug.assert(opening.kind === 279);
                result = opening;
            }
            if (inExpressionContext && token() === 29) {
                var topBadPos_1 = typeof topInvalidNodePosition === "undefined" ? result.pos : topInvalidNodePosition;
                var invalidElement = tryParse(function () { return parseJsxElementOrSelfClosingElementOrFragment(true, topBadPos_1); });
                if (invalidElement) {
                    var operatorToken = createMissingNode(27, false);
                    ts.setTextRangePosWidth(operatorToken, invalidElement.pos, 0);
                    parseErrorAt(ts.skipTrivia(sourceText, topBadPos_1), invalidElement.end, ts.Diagnostics.JSX_expressions_must_have_one_parent_element);
                    return finishNode(factory.createBinaryExpression(result, operatorToken, invalidElement), pos);
                }
            }
            return result;
        }
        function parseJsxText() {
            var pos = getNodePos();
            var node = factory.createJsxText(scanner.getTokenValue(), currentToken === 12);
            currentToken = scanner.scanJsxToken();
            return finishNode(node, pos);
        }
        function parseJsxChild(openingTag, token) {
            switch (token) {
                case 1:
                    if (ts.isJsxOpeningFragment(openingTag)) {
                        parseErrorAtRange(openingTag, ts.Diagnostics.JSX_fragment_has_no_corresponding_closing_tag);
                    }
                    else {
                        var tag = openingTag.tagName;
                        var start = ts.skipTrivia(sourceText, tag.pos);
                        parseErrorAt(start, tag.end, ts.Diagnostics.JSX_element_0_has_no_corresponding_closing_tag, ts.getTextOfNodeFromSourceText(sourceText, openingTag.tagName));
                    }
                    return undefined;
                case 30:
                case 7:
                    return undefined;
                case 11:
                case 12:
                    return parseJsxText();
                case 18:
                    return parseJsxExpression(false);
                case 29:
                    return parseJsxElementOrSelfClosingElementOrFragment(false, undefined, openingTag);
                default:
                    return ts.Debug.assertNever(token);
            }
        }
        function parseJsxChildren(openingTag) {
            var list = [];
            var listPos = getNodePos();
            var saveParsingContext = parsingContext;
            parsingContext |= 1 << 14;
            while (true) {
                var child = parseJsxChild(openingTag, currentToken = scanner.reScanJsxToken());
                if (!child)
                    break;
                list.push(child);
                if (ts.isJsxOpeningElement(openingTag)
                    && (child === null || child === void 0 ? void 0 : child.kind) === 278
                    && !tagNamesAreEquivalent(child.openingElement.tagName, child.closingElement.tagName)
                    && tagNamesAreEquivalent(openingTag.tagName, child.closingElement.tagName)) {
                    break;
                }
            }
            parsingContext = saveParsingContext;
            return createNodeArray(list, listPos);
        }
        function parseJsxAttributes() {
            var pos = getNodePos();
            return finishNode(factory.createJsxAttributes(parseList(13, parseJsxAttribute)), pos);
        }
        function parseJsxOpeningOrSelfClosingElementOrOpeningFragment(inExpressionContext) {
            var pos = getNodePos();
            parseExpected(29);
            if (token() === 31) {
                scanJsxText();
                return finishNode(factory.createJsxOpeningFragment(), pos);
            }
            var tagName = parseJsxElementName();
            var typeArguments = (contextFlags & 262144) === 0 ? tryParseTypeArguments() : undefined;
            var attributes = parseJsxAttributes();
            var node;
            if (token() === 31) {
                scanJsxText();
                node = factory.createJsxOpeningElement(tagName, typeArguments, attributes);
            }
            else {
                parseExpected(43);
                if (parseExpected(31, undefined, false)) {
                    if (inExpressionContext) {
                        nextToken();
                    }
                    else {
                        scanJsxText();
                    }
                }
                node = factory.createJsxSelfClosingElement(tagName, typeArguments, attributes);
            }
            return finishNode(node, pos);
        }
        function parseJsxElementName() {
            var pos = getNodePos();
            scanJsxIdentifier();
            var expression = token() === 108 ?
                parseTokenNode() : parseIdentifierName();
            while (parseOptional(24)) {
                expression = finishNode(factory.createPropertyAccessExpression(expression, parseRightSideOfDot(true, false)), pos);
            }
            return expression;
        }
        function parseJsxExpression(inExpressionContext) {
            var pos = getNodePos();
            if (!parseExpected(18)) {
                return undefined;
            }
            var dotDotDotToken;
            var expression;
            if (token() !== 19) {
                dotDotDotToken = parseOptionalToken(25);
                expression = parseExpression();
            }
            if (inExpressionContext) {
                parseExpected(19);
            }
            else {
                if (parseExpected(19, undefined, false)) {
                    scanJsxText();
                }
            }
            return finishNode(factory.createJsxExpression(dotDotDotToken, expression), pos);
        }
        function parseJsxAttribute() {
            if (token() === 18) {
                return parseJsxSpreadAttribute();
            }
            scanJsxIdentifier();
            var pos = getNodePos();
            return finishNode(factory.createJsxAttribute(parseIdentifierName(), token() !== 63 ? undefined :
                scanJsxAttributeValue() === 10 ? parseLiteralNode() :
                    parseJsxExpression(true)), pos);
        }
        function parseJsxSpreadAttribute() {
            var pos = getNodePos();
            parseExpected(18);
            parseExpected(25);
            var expression = parseExpression();
            parseExpected(19);
            return finishNode(factory.createJsxSpreadAttribute(expression), pos);
        }
        function parseJsxClosingElement(open, inExpressionContext) {
            var pos = getNodePos();
            parseExpected(30);
            var tagName = parseJsxElementName();
            if (parseExpected(31, undefined, false)) {
                if (inExpressionContext || !tagNamesAreEquivalent(open.tagName, tagName)) {
                    nextToken();
                }
                else {
                    scanJsxText();
                }
            }
            return finishNode(factory.createJsxClosingElement(tagName), pos);
        }
        function parseJsxClosingFragment(inExpressionContext) {
            var pos = getNodePos();
            parseExpected(30);
            if (ts.tokenIsIdentifierOrKeyword(token())) {
                parseErrorAtRange(parseJsxElementName(), ts.Diagnostics.Expected_corresponding_closing_tag_for_JSX_fragment);
            }
            if (parseExpected(31, undefined, false)) {
                if (inExpressionContext) {
                    nextToken();
                }
                else {
                    scanJsxText();
                }
            }
            return finishNode(factory.createJsxJsxClosingFragment(), pos);
        }
        function parseTypeAssertion() {
            var pos = getNodePos();
            parseExpected(29);
            var type = parseType();
            parseExpected(31);
            var expression = parseSimpleUnaryExpression();
            return finishNode(factory.createTypeAssertion(type, expression), pos);
        }
        function nextTokenIsIdentifierOrKeywordOrOpenBracketOrTemplate() {
            nextToken();
            return ts.tokenIsIdentifierOrKeyword(token())
                || token() === 22
                || isTemplateStartOfTaggedTemplate();
        }
        function isStartOfOptionalPropertyOrElementAccessChain() {
            return token() === 28
                && lookAhead(nextTokenIsIdentifierOrKeywordOrOpenBracketOrTemplate);
        }
        function tryReparseOptionalChain(node) {
            if (node.flags & 32) {
                return true;
            }
            if (ts.isNonNullExpression(node)) {
                var expr = node.expression;
                while (ts.isNonNullExpression(expr) && !(expr.flags & 32)) {
                    expr = expr.expression;
                }
                if (expr.flags & 32) {
                    while (ts.isNonNullExpression(node)) {
                        node.flags |= 32;
                        node = node.expression;
                    }
                    return true;
                }
            }
            return false;
        }
        function parsePropertyAccessExpressionRest(pos, expression, questionDotToken) {
            var name = parseRightSideOfDot(true, true);
            var isOptionalChain = questionDotToken || tryReparseOptionalChain(expression);
            var propertyAccess = isOptionalChain ?
                factory.createPropertyAccessChain(expression, questionDotToken, name) :
                factory.createPropertyAccessExpression(expression, name);
            if (isOptionalChain && ts.isPrivateIdentifier(propertyAccess.name)) {
                parseErrorAtRange(propertyAccess.name, ts.Diagnostics.An_optional_chain_cannot_contain_private_identifiers);
            }
            return finishNode(propertyAccess, pos);
        }
        function parseElementAccessExpressionRest(pos, expression, questionDotToken) {
            var argumentExpression;
            if (token() === 23) {
                argumentExpression = createMissingNode(79, true, ts.Diagnostics.An_element_access_expression_should_take_an_argument);
            }
            else {
                var argument = allowInAnd(parseExpression);
                if (ts.isStringOrNumericLiteralLike(argument)) {
                    argument.text = internIdentifier(argument.text);
                }
                argumentExpression = argument;
            }
            parseExpected(23);
            var indexedAccess = questionDotToken || tryReparseOptionalChain(expression) ?
                factory.createElementAccessChain(expression, questionDotToken, argumentExpression) :
                factory.createElementAccessExpression(expression, argumentExpression);
            return finishNode(indexedAccess, pos);
        }
        function parseMemberExpressionRest(pos, expression, allowOptionalChain) {
            while (true) {
                var questionDotToken = void 0;
                var isPropertyAccess = false;
                if (allowOptionalChain && isStartOfOptionalPropertyOrElementAccessChain()) {
                    questionDotToken = parseExpectedToken(28);
                    isPropertyAccess = ts.tokenIsIdentifierOrKeyword(token());
                }
                else {
                    isPropertyAccess = parseOptional(24);
                }
                if (isPropertyAccess) {
                    expression = parsePropertyAccessExpressionRest(pos, expression, questionDotToken);
                    continue;
                }
                if ((questionDotToken || !inDecoratorContext()) && parseOptional(22)) {
                    expression = parseElementAccessExpressionRest(pos, expression, questionDotToken);
                    continue;
                }
                if (isTemplateStartOfTaggedTemplate()) {
                    expression = !questionDotToken && expression.kind === 228 ?
                        parseTaggedTemplateRest(pos, expression.expression, questionDotToken, expression.typeArguments) :
                        parseTaggedTemplateRest(pos, expression, questionDotToken, undefined);
                    continue;
                }
                if (!questionDotToken) {
                    if (token() === 53 && !scanner.hasPrecedingLineBreak()) {
                        nextToken();
                        expression = finishNode(factory.createNonNullExpression(expression), pos);
                        continue;
                    }
                    var typeArguments = tryParse(parseTypeArgumentsInExpression);
                    if (typeArguments) {
                        expression = finishNode(factory.createExpressionWithTypeArguments(expression, typeArguments), pos);
                        continue;
                    }
                }
                return expression;
            }
        }
        function isTemplateStartOfTaggedTemplate() {
            return token() === 14 || token() === 15;
        }
        function parseTaggedTemplateRest(pos, tag, questionDotToken, typeArguments) {
            var tagExpression = factory.createTaggedTemplateExpression(tag, typeArguments, token() === 14 ?
                (reScanTemplateHeadOrNoSubstitutionTemplate(), parseLiteralNode()) :
                parseTemplateExpression(true));
            if (questionDotToken || tag.flags & 32) {
                tagExpression.flags |= 32;
            }
            tagExpression.questionDotToken = questionDotToken;
            return finishNode(tagExpression, pos);
        }
        function parseCallExpressionRest(pos, expression) {
            while (true) {
                expression = parseMemberExpressionRest(pos, expression, true);
                var typeArguments = void 0;
                var questionDotToken = parseOptionalToken(28);
                if (questionDotToken) {
                    typeArguments = tryParse(parseTypeArgumentsInExpression);
                    if (isTemplateStartOfTaggedTemplate()) {
                        expression = parseTaggedTemplateRest(pos, expression, questionDotToken, typeArguments);
                        continue;
                    }
                }
                if (typeArguments || token() === 20) {
                    if (!questionDotToken && expression.kind === 228) {
                        typeArguments = expression.typeArguments;
                        expression = expression.expression;
                    }
                    var argumentList = parseArgumentList();
                    var callExpr = questionDotToken || tryReparseOptionalChain(expression) ?
                        factory.createCallChain(expression, questionDotToken, typeArguments, argumentList) :
                        factory.createCallExpression(expression, typeArguments, argumentList);
                    expression = finishNode(callExpr, pos);
                    continue;
                }
                if (questionDotToken) {
                    var name = createMissingNode(79, false, ts.Diagnostics.Identifier_expected);
                    expression = finishNode(factory.createPropertyAccessChain(expression, questionDotToken, name), pos);
                }
                break;
            }
            return expression;
        }
        function parseArgumentList() {
            parseExpected(20);
            var result = parseDelimitedList(11, parseArgumentExpression);
            parseExpected(21);
            return result;
        }
        function parseTypeArgumentsInExpression() {
            if ((contextFlags & 262144) !== 0) {
                return undefined;
            }
            if (reScanLessThanToken() !== 29) {
                return undefined;
            }
            nextToken();
            var typeArguments = parseDelimitedList(20, parseType);
            if (!parseExpected(31)) {
                return undefined;
            }
            return typeArguments && canFollowTypeArgumentsInExpression() ? typeArguments : undefined;
        }
        function canFollowTypeArgumentsInExpression() {
            switch (token()) {
                case 20:
                case 14:
                case 15:
                    return true;
            }
            return !isStartOfExpression();
        }
        function parsePrimaryExpression() {
            switch (token()) {
                case 8:
                case 9:
                case 10:
                case 14:
                    return parseLiteralNode();
                case 108:
                case 106:
                case 104:
                case 110:
                case 95:
                    return parseTokenNode();
                case 20:
                    return parseParenthesizedExpression();
                case 22:
                    return parseArrayLiteralExpression();
                case 18:
                    return parseObjectLiteralExpression();
                case 131:
                    if (!lookAhead(nextTokenIsFunctionKeywordOnSameLine)) {
                        break;
                    }
                    return parseFunctionExpression();
                case 84:
                    return parseClassExpression();
                case 98:
                    return parseFunctionExpression();
                case 103:
                    return parseNewExpressionOrNewDotTarget();
                case 43:
                case 68:
                    if (reScanSlashToken() === 13) {
                        return parseLiteralNode();
                    }
                    break;
                case 15:
                    return parseTemplateExpression(false);
                case 80:
                    return parsePrivateIdentifier();
            }
            return parseIdentifier(ts.Diagnostics.Expression_expected);
        }
        function parseParenthesizedExpression() {
            var pos = getNodePos();
            var hasJSDoc = hasPrecedingJSDocComment();
            parseExpected(20);
            var expression = allowInAnd(parseExpression);
            parseExpected(21);
            return withJSDoc(finishNode(factory.createParenthesizedExpression(expression), pos), hasJSDoc);
        }
        function parseSpreadElement() {
            var pos = getNodePos();
            parseExpected(25);
            var expression = parseAssignmentExpressionOrHigher();
            return finishNode(factory.createSpreadElement(expression), pos);
        }
        function parseArgumentOrArrayLiteralElement() {
            return token() === 25 ? parseSpreadElement() :
                token() === 27 ? finishNode(factory.createOmittedExpression(), getNodePos()) :
                    parseAssignmentExpressionOrHigher();
        }
        function parseArgumentExpression() {
            return doOutsideOfContext(disallowInAndDecoratorContext, parseArgumentOrArrayLiteralElement);
        }
        function parseArrayLiteralExpression() {
            var pos = getNodePos();
            var openBracketPosition = scanner.getTokenPos();
            var openBracketParsed = parseExpected(22);
            var multiLine = scanner.hasPrecedingLineBreak();
            var elements = parseDelimitedList(15, parseArgumentOrArrayLiteralElement);
            parseExpectedMatchingBrackets(22, 23, openBracketParsed, openBracketPosition);
            return finishNode(factory.createArrayLiteralExpression(elements, multiLine), pos);
        }
        function parseObjectLiteralElement() {
            var pos = getNodePos();
            var hasJSDoc = hasPrecedingJSDocComment();
            if (parseOptionalToken(25)) {
                var expression = parseAssignmentExpressionOrHigher();
                return withJSDoc(finishNode(factory.createSpreadAssignment(expression), pos), hasJSDoc);
            }
            var decorators = parseDecorators();
            var modifiers = parseModifiers();
            if (parseContextualModifier(136)) {
                return parseAccessorDeclaration(pos, hasJSDoc, decorators, modifiers, 172);
            }
            if (parseContextualModifier(149)) {
                return parseAccessorDeclaration(pos, hasJSDoc, decorators, modifiers, 173);
            }
            var asteriskToken = parseOptionalToken(41);
            var tokenIsIdentifier = isIdentifier();
            var name = parsePropertyName();
            var questionToken = parseOptionalToken(57);
            var exclamationToken = parseOptionalToken(53);
            if (asteriskToken || token() === 20 || token() === 29) {
                return parseMethodDeclaration(pos, hasJSDoc, decorators, modifiers, asteriskToken, name, questionToken, exclamationToken);
            }
            var node;
            var isShorthandPropertyAssignment = tokenIsIdentifier && (token() !== 58);
            if (isShorthandPropertyAssignment) {
                var equalsToken = parseOptionalToken(63);
                var objectAssignmentInitializer = equalsToken ? allowInAnd(parseAssignmentExpressionOrHigher) : undefined;
                node = factory.createShorthandPropertyAssignment(name, objectAssignmentInitializer);
                node.equalsToken = equalsToken;
            }
            else {
                parseExpected(58);
                var initializer = allowInAnd(parseAssignmentExpressionOrHigher);
                node = factory.createPropertyAssignment(name, initializer);
            }
            node.decorators = decorators;
            node.modifiers = modifiers;
            node.questionToken = questionToken;
            node.exclamationToken = exclamationToken;
            return withJSDoc(finishNode(node, pos), hasJSDoc);
        }
        function parseObjectLiteralExpression() {
            var pos = getNodePos();
            var openBracePosition = scanner.getTokenPos();
            var openBraceParsed = parseExpected(18);
            var multiLine = scanner.hasPrecedingLineBreak();
            var properties = parseDelimitedList(12, parseObjectLiteralElement, true);
            parseExpectedMatchingBrackets(18, 19, openBraceParsed, openBracePosition);
            return finishNode(factory.createObjectLiteralExpression(properties, multiLine), pos);
        }
        function parseFunctionExpression() {
            var savedDecoratorContext = inDecoratorContext();
            setDecoratorContext(false);
            var pos = getNodePos();
            var hasJSDoc = hasPrecedingJSDocComment();
            var modifiers = parseModifiers();
            parseExpected(98);
            var asteriskToken = parseOptionalToken(41);
            var isGenerator = asteriskToken ? 1 : 0;
            var isAsync = ts.some(modifiers, ts.isAsyncModifier) ? 2 : 0;
            var name = isGenerator && isAsync ? doInYieldAndAwaitContext(parseOptionalBindingIdentifier) :
                isGenerator ? doInYieldContext(parseOptionalBindingIdentifier) :
                    isAsync ? doInAwaitContext(parseOptionalBindingIdentifier) :
                        parseOptionalBindingIdentifier();
            var typeParameters = parseTypeParameters();
            var parameters = parseParameters(isGenerator | isAsync);
            var type = parseReturnType(58, false);
            var body = parseFunctionBlock(isGenerator | isAsync);
            setDecoratorContext(savedDecoratorContext);
            var node = factory.createFunctionExpression(modifiers, asteriskToken, name, typeParameters, parameters, type, body);
            return withJSDoc(finishNode(node, pos), hasJSDoc);
        }
        function parseOptionalBindingIdentifier() {
            return isBindingIdentifier() ? parseBindingIdentifier() : undefined;
        }
        function parseNewExpressionOrNewDotTarget() {
            var pos = getNodePos();
            parseExpected(103);
            if (parseOptional(24)) {
                var name = parseIdentifierName();
                return finishNode(factory.createMetaProperty(103, name), pos);
            }
            var expressionPos = getNodePos();
            var expression = parseMemberExpressionRest(expressionPos, parsePrimaryExpression(), false);
            var typeArguments;
            if (expression.kind === 228) {
                typeArguments = expression.typeArguments;
                expression = expression.expression;
            }
            var argumentList = token() === 20 ? parseArgumentList() : undefined;
            return finishNode(factory.createNewExpression(expression, typeArguments, argumentList), pos);
        }
        function parseBlock(ignoreMissingOpenBrace, diagnosticMessage) {
            var pos = getNodePos();
            var hasJSDoc = hasPrecedingJSDocComment();
            var openBracePosition = scanner.getTokenPos();
            var openBraceParsed = parseExpected(18, diagnosticMessage);
            if (openBraceParsed || ignoreMissingOpenBrace) {
                var multiLine = scanner.hasPrecedingLineBreak();
                var statements = parseList(1, parseStatement);
                parseExpectedMatchingBrackets(18, 19, openBraceParsed, openBracePosition);
                var result = withJSDoc(finishNode(factory.createBlock(statements, multiLine), pos), hasJSDoc);
                if (token() === 63) {
                    parseErrorAtCurrentToken(ts.Diagnostics.Declaration_or_statement_expected_This_follows_a_block_of_statements_so_if_you_intended_to_write_a_destructuring_assignment_you_might_need_to_wrap_the_the_whole_assignment_in_parentheses);
                    nextToken();
                }
                return result;
            }
            else {
                var statements = createMissingList();
                return withJSDoc(finishNode(factory.createBlock(statements, undefined), pos), hasJSDoc);
            }
        }
        function parseFunctionBlock(flags, diagnosticMessage) {
            var savedYieldContext = inYieldContext();
            setYieldContext(!!(flags & 1));
            var savedAwaitContext = inAwaitContext();
            setAwaitContext(!!(flags & 2));
            var savedTopLevel = topLevel;
            topLevel = false;
            var saveDecoratorContext = inDecoratorContext();
            if (saveDecoratorContext) {
                setDecoratorContext(false);
            }
            var block = parseBlock(!!(flags & 16), diagnosticMessage);
            if (saveDecoratorContext) {
                setDecoratorContext(true);
            }
            topLevel = savedTopLevel;
            setYieldContext(savedYieldContext);
            setAwaitContext(savedAwaitContext);
            return block;
        }
        function parseEmptyStatement() {
            var pos = getNodePos();
            var hasJSDoc = hasPrecedingJSDocComment();
            parseExpected(26);
            return withJSDoc(finishNode(factory.createEmptyStatement(), pos), hasJSDoc);
        }
        function parseIfStatement() {
            var pos = getNodePos();
            var hasJSDoc = hasPrecedingJSDocComment();
            parseExpected(99);
            var openParenPosition = scanner.getTokenPos();
            var openParenParsed = parseExpected(20);
            var expression = allowInAnd(parseExpression);
            parseExpectedMatchingBrackets(20, 21, openParenParsed, openParenPosition);
            var thenStatement = parseStatement();
            var elseStatement = parseOptional(91) ? parseStatement() : undefined;
            return withJSDoc(finishNode(factory.createIfStatement(expression, thenStatement, elseStatement), pos), hasJSDoc);
        }
        function parseDoStatement() {
            var pos = getNodePos();
            var hasJSDoc = hasPrecedingJSDocComment();
            parseExpected(90);
            var statement = parseStatement();
            parseExpected(115);
            var openParenPosition = scanner.getTokenPos();
            var openParenParsed = parseExpected(20);
            var expression = allowInAnd(parseExpression);
            parseExpectedMatchingBrackets(20, 21, openParenParsed, openParenPosition);
            parseOptional(26);
            return withJSDoc(finishNode(factory.createDoStatement(statement, expression), pos), hasJSDoc);
        }
        function parseWhileStatement() {
            var pos = getNodePos();
            var hasJSDoc = hasPrecedingJSDocComment();
            parseExpected(115);
            var openParenPosition = scanner.getTokenPos();
            var openParenParsed = parseExpected(20);
            var expression = allowInAnd(parseExpression);
            parseExpectedMatchingBrackets(20, 21, openParenParsed, openParenPosition);
            var statement = parseStatement();
            return withJSDoc(finishNode(factory.createWhileStatement(expression, statement), pos), hasJSDoc);
        }
        function parseForOrForInOrForOfStatement() {
            var pos = getNodePos();
            var hasJSDoc = hasPrecedingJSDocComment();
            parseExpected(97);
            var awaitToken = parseOptionalToken(132);
            parseExpected(20);
            var initializer;
            if (token() !== 26) {
                if (token() === 113 || token() === 119 || token() === 85) {
                    initializer = parseVariableDeclarationList(true);
                }
                else {
                    initializer = disallowInAnd(parseExpression);
                }
            }
            var node;
            if (awaitToken ? parseExpected(160) : parseOptional(160)) {
                var expression = allowInAnd(parseAssignmentExpressionOrHigher);
                parseExpected(21);
                node = factory.createForOfStatement(awaitToken, initializer, expression, parseStatement());
            }
            else if (parseOptional(101)) {
                var expression = allowInAnd(parseExpression);
                parseExpected(21);
                node = factory.createForInStatement(initializer, expression, parseStatement());
            }
            else {
                parseExpected(26);
                var condition = token() !== 26 && token() !== 21
                    ? allowInAnd(parseExpression)
                    : undefined;
                parseExpected(26);
                var incrementor = token() !== 21
                    ? allowInAnd(parseExpression)
                    : undefined;
                parseExpected(21);
                node = factory.createForStatement(initializer, condition, incrementor, parseStatement());
            }
            return withJSDoc(finishNode(node, pos), hasJSDoc);
        }
        function parseBreakOrContinueStatement(kind) {
            var pos = getNodePos();
            var hasJSDoc = hasPrecedingJSDocComment();
            parseExpected(kind === 246 ? 81 : 86);
            var label = canParseSemicolon() ? undefined : parseIdentifier();
            parseSemicolon();
            var node = kind === 246
                ? factory.createBreakStatement(label)
                : factory.createContinueStatement(label);
            return withJSDoc(finishNode(node, pos), hasJSDoc);
        }
        function parseReturnStatement() {
            var pos = getNodePos();
            var hasJSDoc = hasPrecedingJSDocComment();
            parseExpected(105);
            var expression = canParseSemicolon() ? undefined : allowInAnd(parseExpression);
            parseSemicolon();
            return withJSDoc(finishNode(factory.createReturnStatement(expression), pos), hasJSDoc);
        }
        function parseWithStatement() {
            var pos = getNodePos();
            var hasJSDoc = hasPrecedingJSDocComment();
            parseExpected(116);
            var openParenPosition = scanner.getTokenPos();
            var openParenParsed = parseExpected(20);
            var expression = allowInAnd(parseExpression);
            parseExpectedMatchingBrackets(20, 21, openParenParsed, openParenPosition);
            var statement = doInsideOfContext(33554432, parseStatement);
            return withJSDoc(finishNode(factory.createWithStatement(expression, statement), pos), hasJSDoc);
        }
        function parseCaseClause() {
            var pos = getNodePos();
            var hasJSDoc = hasPrecedingJSDocComment();
            parseExpected(82);
            var expression = allowInAnd(parseExpression);
            parseExpected(58);
            var statements = parseList(3, parseStatement);
            return withJSDoc(finishNode(factory.createCaseClause(expression, statements), pos), hasJSDoc);
        }
        function parseDefaultClause() {
            var pos = getNodePos();
            parseExpected(88);
            parseExpected(58);
            var statements = parseList(3, parseStatement);
            return finishNode(factory.createDefaultClause(statements), pos);
        }
        function parseCaseOrDefaultClause() {
            return token() === 82 ? parseCaseClause() : parseDefaultClause();
        }
        function parseCaseBlock() {
            var pos = getNodePos();
            parseExpected(18);
            var clauses = parseList(2, parseCaseOrDefaultClause);
            parseExpected(19);
            return finishNode(factory.createCaseBlock(clauses), pos);
        }
        function parseSwitchStatement() {
            var pos = getNodePos();
            var hasJSDoc = hasPrecedingJSDocComment();
            parseExpected(107);
            parseExpected(20);
            var expression = allowInAnd(parseExpression);
            parseExpected(21);
            var caseBlock = parseCaseBlock();
            return withJSDoc(finishNode(factory.createSwitchStatement(expression, caseBlock), pos), hasJSDoc);
        }
        function parseThrowStatement() {
            var pos = getNodePos();
            var hasJSDoc = hasPrecedingJSDocComment();
            parseExpected(109);
            var expression = scanner.hasPrecedingLineBreak() ? undefined : allowInAnd(parseExpression);
            if (expression === undefined) {
                identifierCount++;
                expression = finishNode(factory.createIdentifier(""), getNodePos());
            }
            if (!tryParseSemicolon()) {
                parseErrorForMissingSemicolonAfter(expression);
            }
            return withJSDoc(finishNode(factory.createThrowStatement(expression), pos), hasJSDoc);
        }
        function parseTryStatement() {
            var pos = getNodePos();
            var hasJSDoc = hasPrecedingJSDocComment();
            parseExpected(111);
            var tryBlock = parseBlock(false);
            var catchClause = token() === 83 ? parseCatchClause() : undefined;
            var finallyBlock;
            if (!catchClause || token() === 96) {
                parseExpected(96, ts.Diagnostics.catch_or_finally_expected);
                finallyBlock = parseBlock(false);
            }
            return withJSDoc(finishNode(factory.createTryStatement(tryBlock, catchClause, finallyBlock), pos), hasJSDoc);
        }
        function parseCatchClause() {
            var pos = getNodePos();
            parseExpected(83);
            var variableDeclaration;
            if (parseOptional(20)) {
                variableDeclaration = parseVariableDeclaration();
                parseExpected(21);
            }
            else {
                variableDeclaration = undefined;
            }
            var block = parseBlock(false);
            return finishNode(factory.createCatchClause(variableDeclaration, block), pos);
        }
        function parseDebuggerStatement() {
            var pos = getNodePos();
            var hasJSDoc = hasPrecedingJSDocComment();
            parseExpected(87);
            parseSemicolon();
            return withJSDoc(finishNode(factory.createDebuggerStatement(), pos), hasJSDoc);
        }
        function parseExpressionOrLabeledStatement() {
            var pos = getNodePos();
            var hasJSDoc = hasPrecedingJSDocComment();
            var node;
            var hasParen = token() === 20;
            var expression = allowInAnd(parseExpression);
            if (ts.isIdentifier(expression) && parseOptional(58)) {
                node = factory.createLabeledStatement(expression, parseStatement());
            }
            else {
                if (!tryParseSemicolon()) {
                    parseErrorForMissingSemicolonAfter(expression);
                }
                node = factory.createExpressionStatement(expression);
                if (hasParen) {
                    hasJSDoc = false;
                }
            }
            return withJSDoc(finishNode(node, pos), hasJSDoc);
        }
        function nextTokenIsIdentifierOrKeywordOnSameLine() {
            nextToken();
            return ts.tokenIsIdentifierOrKeyword(token()) && !scanner.hasPrecedingLineBreak();
        }
        function nextTokenIsClassKeywordOnSameLine() {
            nextToken();
            return token() === 84 && !scanner.hasPrecedingLineBreak();
        }
        function nextTokenIsFunctionKeywordOnSameLine() {
            nextToken();
            return token() === 98 && !scanner.hasPrecedingLineBreak();
        }
        function nextTokenIsIdentifierOrKeywordOrLiteralOnSameLine() {
            nextToken();
            return (ts.tokenIsIdentifierOrKeyword(token()) || token() === 8 || token() === 9 || token() === 10) && !scanner.hasPrecedingLineBreak();
        }
        function isDeclaration() {
            while (true) {
                switch (token()) {
                    case 113:
                    case 119:
                    case 85:
                    case 98:
                    case 84:
                    case 92:
                        return true;
                    case 118:
                    case 152:
                        return nextTokenIsIdentifierOnSameLine();
                    case 141:
                    case 142:
                        return nextTokenIsIdentifierOrStringLiteralOnSameLine();
                    case 126:
                    case 131:
                    case 135:
                    case 121:
                    case 122:
                    case 123:
                    case 145:
                        nextToken();
                        if (scanner.hasPrecedingLineBreak()) {
                            return false;
                        }
                        continue;
                    case 157:
                        nextToken();
                        return token() === 18 || token() === 79 || token() === 93;
                    case 100:
                        nextToken();
                        return token() === 10 || token() === 41 ||
                            token() === 18 || ts.tokenIsIdentifierOrKeyword(token());
                    case 93:
                        var currentToken_1 = nextToken();
                        if (currentToken_1 === 152) {
                            currentToken_1 = lookAhead(nextToken);
                        }
                        if (currentToken_1 === 63 || currentToken_1 === 41 ||
                            currentToken_1 === 18 || currentToken_1 === 88 ||
                            currentToken_1 === 127) {
                            return true;
                        }
                        continue;
                    case 124:
                        nextToken();
                        continue;
                    default:
                        return false;
                }
            }
        }
        function isStartOfDeclaration() {
            return lookAhead(isDeclaration);
        }
        function isStartOfStatement() {
            switch (token()) {
                case 59:
                case 26:
                case 18:
                case 113:
                case 119:
                case 98:
                case 84:
                case 92:
                case 99:
                case 90:
                case 115:
                case 97:
                case 86:
                case 81:
                case 105:
                case 116:
                case 107:
                case 109:
                case 111:
                case 87:
                case 83:
                case 96:
                    return true;
                case 100:
                    return isStartOfDeclaration() || lookAhead(nextTokenIsOpenParenOrLessThanOrDot);
                case 85:
                case 93:
                    return isStartOfDeclaration();
                case 131:
                case 135:
                case 118:
                case 141:
                case 142:
                case 152:
                case 157:
                    return true;
                case 123:
                case 121:
                case 122:
                case 124:
                case 145:
                    return isStartOfDeclaration() || !lookAhead(nextTokenIsIdentifierOrKeywordOnSameLine);
                default:
                    return isStartOfExpression();
            }
        }
        function nextTokenIsBindingIdentifierOrStartOfDestructuring() {
            nextToken();
            return isBindingIdentifier() || token() === 18 || token() === 22;
        }
        function isLetDeclaration() {
            return lookAhead(nextTokenIsBindingIdentifierOrStartOfDestructuring);
        }
        function parseStatement() {
            switch (token()) {
                case 26:
                    return parseEmptyStatement();
                case 18:
                    return parseBlock(false);
                case 113:
                    return parseVariableStatement(getNodePos(), hasPrecedingJSDocComment(), undefined, undefined);
                case 119:
                    if (isLetDeclaration()) {
                        return parseVariableStatement(getNodePos(), hasPrecedingJSDocComment(), undefined, undefined);
                    }
                    break;
                case 98:
                    return parseFunctionDeclaration(getNodePos(), hasPrecedingJSDocComment(), undefined, undefined);
                case 84:
                    return parseClassDeclaration(getNodePos(), hasPrecedingJSDocComment(), undefined, undefined);
                case 99:
                    return parseIfStatement();
                case 90:
                    return parseDoStatement();
                case 115:
                    return parseWhileStatement();
                case 97:
                    return parseForOrForInOrForOfStatement();
                case 86:
                    return parseBreakOrContinueStatement(245);
                case 81:
                    return parseBreakOrContinueStatement(246);
                case 105:
                    return parseReturnStatement();
                case 116:
                    return parseWithStatement();
                case 107:
                    return parseSwitchStatement();
                case 109:
                    return parseThrowStatement();
                case 111:
                case 83:
                case 96:
                    return parseTryStatement();
                case 87:
                    return parseDebuggerStatement();
                case 59:
                    return parseDeclaration();
                case 131:
                case 118:
                case 152:
                case 141:
                case 142:
                case 135:
                case 85:
                case 92:
                case 93:
                case 100:
                case 121:
                case 122:
                case 123:
                case 126:
                case 124:
                case 145:
                case 157:
                    if (isStartOfDeclaration()) {
                        return parseDeclaration();
                    }
                    break;
            }
            return parseExpressionOrLabeledStatement();
        }
        function isDeclareModifier(modifier) {
            return modifier.kind === 135;
        }
        function parseDeclaration() {
            var isAmbient = ts.some(lookAhead(function () { return (parseDecorators(), parseModifiers()); }), isDeclareModifier);
            if (isAmbient) {
                var node = tryReuseAmbientDeclaration();
                if (node) {
                    return node;
                }
            }
            var pos = getNodePos();
            var hasJSDoc = hasPrecedingJSDocComment();
            var decorators = parseDecorators();
            var modifiers = parseModifiers();
            if (isAmbient) {
                for (var _i = 0, _a = modifiers; _i < _a.length; _i++) {
                    var m = _a[_i];
                    m.flags |= 16777216;
                }
                return doInsideOfContext(16777216, function () { return parseDeclarationWorker(pos, hasJSDoc, decorators, modifiers); });
            }
            else {
                return parseDeclarationWorker(pos, hasJSDoc, decorators, modifiers);
            }
        }
        function tryReuseAmbientDeclaration() {
            return doInsideOfContext(16777216, function () {
                var node = currentNode(parsingContext);
                if (node) {
                    return consumeNode(node);
                }
            });
        }
        function parseDeclarationWorker(pos, hasJSDoc, decorators, modifiers) {
            switch (token()) {
                case 113:
                case 119:
                case 85:
                    return parseVariableStatement(pos, hasJSDoc, decorators, modifiers);
                case 98:
                    return parseFunctionDeclaration(pos, hasJSDoc, decorators, modifiers);
                case 84:
                    return parseClassDeclaration(pos, hasJSDoc, decorators, modifiers);
                case 118:
                    return parseInterfaceDeclaration(pos, hasJSDoc, decorators, modifiers);
                case 152:
                    return parseTypeAliasDeclaration(pos, hasJSDoc, decorators, modifiers);
                case 92:
                    return parseEnumDeclaration(pos, hasJSDoc, decorators, modifiers);
                case 157:
                case 141:
                case 142:
                    return parseModuleDeclaration(pos, hasJSDoc, decorators, modifiers);
                case 100:
                    return parseImportDeclarationOrImportEqualsDeclaration(pos, hasJSDoc, decorators, modifiers);
                case 93:
                    nextToken();
                    switch (token()) {
                        case 88:
                        case 63:
                            return parseExportAssignment(pos, hasJSDoc, decorators, modifiers);
                        case 127:
                            return parseNamespaceExportDeclaration(pos, hasJSDoc, decorators, modifiers);
                        default:
                            return parseExportDeclaration(pos, hasJSDoc, decorators, modifiers);
                    }
                default:
                    if (decorators || modifiers) {
                        var missing = createMissingNode(276, true, ts.Diagnostics.Declaration_expected);
                        ts.setTextRangePos(missing, pos);
                        missing.decorators = decorators;
                        missing.modifiers = modifiers;
                        return missing;
                    }
                    return undefined;
            }
        }
        function nextTokenIsIdentifierOrStringLiteralOnSameLine() {
            nextToken();
            return !scanner.hasPrecedingLineBreak() && (isIdentifier() || token() === 10);
        }
        function parseFunctionBlockOrSemicolon(flags, diagnosticMessage) {
            if (token() !== 18 && canParseSemicolon()) {
                parseSemicolon();
                return;
            }
            return parseFunctionBlock(flags, diagnosticMessage);
        }
        function parseArrayBindingElement() {
            var pos = getNodePos();
            if (token() === 27) {
                return finishNode(factory.createOmittedExpression(), pos);
            }
            var dotDotDotToken = parseOptionalToken(25);
            var name = parseIdentifierOrPattern();
            var initializer = parseInitializer();
            return finishNode(factory.createBindingElement(dotDotDotToken, undefined, name, initializer), pos);
        }
        function parseObjectBindingElement() {
            var pos = getNodePos();
            var dotDotDotToken = parseOptionalToken(25);
            var tokenIsIdentifier = isBindingIdentifier();
            var propertyName = parsePropertyName();
            var name;
            if (tokenIsIdentifier && token() !== 58) {
                name = propertyName;
                propertyName = undefined;
            }
            else {
                parseExpected(58);
                name = parseIdentifierOrPattern();
            }
            var initializer = parseInitializer();
            return finishNode(factory.createBindingElement(dotDotDotToken, propertyName, name, initializer), pos);
        }
        function parseObjectBindingPattern() {
            var pos = getNodePos();
            parseExpected(18);
            var elements = parseDelimitedList(9, parseObjectBindingElement);
            parseExpected(19);
            return finishNode(factory.createObjectBindingPattern(elements), pos);
        }
        function parseArrayBindingPattern() {
            var pos = getNodePos();
            parseExpected(22);
            var elements = parseDelimitedList(10, parseArrayBindingElement);
            parseExpected(23);
            return finishNode(factory.createArrayBindingPattern(elements), pos);
        }
        function isBindingIdentifierOrPrivateIdentifierOrPattern() {
            return token() === 18
                || token() === 22
                || token() === 80
                || isBindingIdentifier();
        }
        function parseIdentifierOrPattern(privateIdentifierDiagnosticMessage) {
            if (token() === 22) {
                return parseArrayBindingPattern();
            }
            if (token() === 18) {
                return parseObjectBindingPattern();
            }
            return parseBindingIdentifier(privateIdentifierDiagnosticMessage);
        }
        function parseVariableDeclarationAllowExclamation() {
            return parseVariableDeclaration(true);
        }
        function parseVariableDeclaration(allowExclamation) {
            var pos = getNodePos();
            var hasJSDoc = hasPrecedingJSDocComment();
            var name = parseIdentifierOrPattern(ts.Diagnostics.Private_identifiers_are_not_allowed_in_variable_declarations);
            var exclamationToken;
            if (allowExclamation && name.kind === 79 &&
                token() === 53 && !scanner.hasPrecedingLineBreak()) {
                exclamationToken = parseTokenNode();
            }
            var type = parseTypeAnnotation();
            var initializer = isInOrOfKeyword(token()) ? undefined : parseInitializer();
            var node = factory.createVariableDeclaration(name, exclamationToken, type, initializer);
            return withJSDoc(finishNode(node, pos), hasJSDoc);
        }
        function parseVariableDeclarationList(inForStatementInitializer) {
            var pos = getNodePos();
            var flags = 0;
            switch (token()) {
                case 113:
                    break;
                case 119:
                    flags |= 1;
                    break;
                case 85:
                    flags |= 2;
                    break;
                default:
                    ts.Debug.fail();
            }
            nextToken();
            var declarations;
            if (token() === 160 && lookAhead(canFollowContextualOfKeyword)) {
                declarations = createMissingList();
            }
            else {
                var savedDisallowIn = inDisallowInContext();
                setDisallowInContext(inForStatementInitializer);
                declarations = parseDelimitedList(8, inForStatementInitializer ? parseVariableDeclaration : parseVariableDeclarationAllowExclamation);
                setDisallowInContext(savedDisallowIn);
            }
            return finishNode(factory.createVariableDeclarationList(declarations, flags), pos);
        }
        function canFollowContextualOfKeyword() {
            return nextTokenIsIdentifier() && nextToken() === 21;
        }
        function parseVariableStatement(pos, hasJSDoc, decorators, modifiers) {
            var declarationList = parseVariableDeclarationList(false);
            parseSemicolon();
            var node = factory.createVariableStatement(modifiers, declarationList);
            node.decorators = decorators;
            return withJSDoc(finishNode(node, pos), hasJSDoc);
        }
        function parseFunctionDeclaration(pos, hasJSDoc, decorators, modifiers) {
            var savedAwaitContext = inAwaitContext();
            var modifierFlags = ts.modifiersToFlags(modifiers);
            parseExpected(98);
            var asteriskToken = parseOptionalToken(41);
            var name = modifierFlags & 512 ? parseOptionalBindingIdentifier() : parseBindingIdentifier();
            var isGenerator = asteriskToken ? 1 : 0;
            var isAsync = modifierFlags & 256 ? 2 : 0;
            var typeParameters = parseTypeParameters();
            if (modifierFlags & 1)
                setAwaitContext(true);
            var parameters = parseParameters(isGenerator | isAsync);
            var type = parseReturnType(58, false);
            var body = parseFunctionBlockOrSemicolon(isGenerator | isAsync, ts.Diagnostics.or_expected);
            setAwaitContext(savedAwaitContext);
            var node = factory.createFunctionDeclaration(decorators, modifiers, asteriskToken, name, typeParameters, parameters, type, body);
            return withJSDoc(finishNode(node, pos), hasJSDoc);
        }
        function parseConstructorName() {
            if (token() === 134) {
                return parseExpected(134);
            }
            if (token() === 10 && lookAhead(nextToken) === 20) {
                return tryParse(function () {
                    var literalNode = parseLiteralNode();
                    return literalNode.text === "constructor" ? literalNode : undefined;
                });
            }
        }
        function tryParseConstructorDeclaration(pos, hasJSDoc, decorators, modifiers) {
            return tryParse(function () {
                if (parseConstructorName()) {
                    var typeParameters = parseTypeParameters();
                    var parameters = parseParameters(0);
                    var type = parseReturnType(58, false);
                    var body = parseFunctionBlockOrSemicolon(0, ts.Diagnostics.or_expected);
                    var node = factory.createConstructorDeclaration(decorators, modifiers, parameters, body);
                    node.typeParameters = typeParameters;
                    node.type = type;
                    return withJSDoc(finishNode(node, pos), hasJSDoc);
                }
            });
        }
        function parseMethodDeclaration(pos, hasJSDoc, decorators, modifiers, asteriskToken, name, questionToken, exclamationToken, diagnosticMessage) {
            var isGenerator = asteriskToken ? 1 : 0;
            var isAsync = ts.some(modifiers, ts.isAsyncModifier) ? 2 : 0;
            var typeParameters = parseTypeParameters();
            var parameters = parseParameters(isGenerator | isAsync);
            var type = parseReturnType(58, false);
            var body = parseFunctionBlockOrSemicolon(isGenerator | isAsync, diagnosticMessage);
            var node = factory.createMethodDeclaration(decorators, modifiers, asteriskToken, name, questionToken, typeParameters, parameters, type, body);
            node.exclamationToken = exclamationToken;
            return withJSDoc(finishNode(node, pos), hasJSDoc);
        }
        function parsePropertyDeclaration(pos, hasJSDoc, decorators, modifiers, name, questionToken) {
            var exclamationToken = !questionToken && !scanner.hasPrecedingLineBreak() ? parseOptionalToken(53) : undefined;
            var type = parseTypeAnnotation();
            var initializer = doOutsideOfContext(8192 | 32768 | 4096, parseInitializer);
            parseSemicolonAfterPropertyName(name, type, initializer);
            var node = factory.createPropertyDeclaration(decorators, modifiers, name, questionToken || exclamationToken, type, initializer);
            return withJSDoc(finishNode(node, pos), hasJSDoc);
        }
        function parsePropertyOrMethodDeclaration(pos, hasJSDoc, decorators, modifiers) {
            var asteriskToken = parseOptionalToken(41);
            var name = parsePropertyName();
            var questionToken = parseOptionalToken(57);
            if (asteriskToken || token() === 20 || token() === 29) {
                return parseMethodDeclaration(pos, hasJSDoc, decorators, modifiers, asteriskToken, name, questionToken, undefined, ts.Diagnostics.or_expected);
            }
            return parsePropertyDeclaration(pos, hasJSDoc, decorators, modifiers, name, questionToken);
        }
        function parseAccessorDeclaration(pos, hasJSDoc, decorators, modifiers, kind) {
            var name = parsePropertyName();
            var typeParameters = parseTypeParameters();
            var parameters = parseParameters(0);
            var type = parseReturnType(58, false);
            var body = parseFunctionBlockOrSemicolon(0);
            var node = kind === 172
                ? factory.createGetAccessorDeclaration(decorators, modifiers, name, parameters, type, body)
                : factory.createSetAccessorDeclaration(decorators, modifiers, name, parameters, body);
            node.typeParameters = typeParameters;
            if (type && node.kind === 173)
                node.type = type;
            return withJSDoc(finishNode(node, pos), hasJSDoc);
        }
        function isClassMemberStart() {
            var idToken;
            if (token() === 59) {
                return true;
            }
            while (ts.isModifierKind(token())) {
                idToken = token();
                if (ts.isClassMemberModifier(idToken)) {
                    return true;
                }
                nextToken();
            }
            if (token() === 41) {
                return true;
            }
            if (isLiteralPropertyName()) {
                idToken = token();
                nextToken();
            }
            if (token() === 22) {
                return true;
            }
            if (idToken !== undefined) {
                if (!ts.isKeyword(idToken) || idToken === 149 || idToken === 136) {
                    return true;
                }
                switch (token()) {
                    case 20:
                    case 29:
                    case 53:
                    case 58:
                    case 63:
                    case 57:
                        return true;
                    default:
                        return canParseSemicolon();
                }
            }
            return false;
        }
        function parseClassStaticBlockDeclaration(pos, hasJSDoc, decorators, modifiers) {
            parseExpectedToken(124);
            var body = parseClassStaticBlockBody();
            return withJSDoc(finishNode(factory.createClassStaticBlockDeclaration(decorators, modifiers, body), pos), hasJSDoc);
        }
        function parseClassStaticBlockBody() {
            var savedYieldContext = inYieldContext();
            var savedAwaitContext = inAwaitContext();
            setYieldContext(false);
            setAwaitContext(true);
            var body = parseBlock(false);
            setYieldContext(savedYieldContext);
            setAwaitContext(savedAwaitContext);
            return body;
        }
        function parseDecoratorExpression() {
            if (inAwaitContext() && token() === 132) {
                var pos = getNodePos();
                var awaitExpression = parseIdentifier(ts.Diagnostics.Expression_expected);
                nextToken();
                var memberExpression = parseMemberExpressionRest(pos, awaitExpression, true);
                return parseCallExpressionRest(pos, memberExpression);
            }
            return parseLeftHandSideExpressionOrHigher();
        }
        function tryParseDecorator() {
            var pos = getNodePos();
            if (!parseOptional(59)) {
                return undefined;
            }
            var expression = doInDecoratorContext(parseDecoratorExpression);
            return finishNode(factory.createDecorator(expression), pos);
        }
        function parseDecorators() {
            var pos = getNodePos();
            var list, decorator;
            while (decorator = tryParseDecorator()) {
                list = ts.append(list, decorator);
            }
            return list && createNodeArray(list, pos);
        }
        function tryParseModifier(permitInvalidConstAsModifier, stopOnStartOfClassStaticBlock, hasSeenStaticModifier) {
            var pos = getNodePos();
            var kind = token();
            if (token() === 85 && permitInvalidConstAsModifier) {
                if (!tryParse(nextTokenIsOnSameLineAndCanFollowModifier)) {
                    return undefined;
                }
            }
            else if (stopOnStartOfClassStaticBlock && token() === 124 && lookAhead(nextTokenIsOpenBrace)) {
                return undefined;
            }
            else if (hasSeenStaticModifier && token() === 124) {
                return undefined;
            }
            else {
                if (!parseAnyContextualModifier()) {
                    return undefined;
                }
            }
            return finishNode(factory.createToken(kind), pos);
        }
        function parseModifiers(permitInvalidConstAsModifier, stopOnStartOfClassStaticBlock) {
            var pos = getNodePos();
            var list, modifier, hasSeenStatic = false;
            while (modifier = tryParseModifier(permitInvalidConstAsModifier, stopOnStartOfClassStaticBlock, hasSeenStatic)) {
                if (modifier.kind === 124)
                    hasSeenStatic = true;
                list = ts.append(list, modifier);
            }
            return list && createNodeArray(list, pos);
        }
        function parseModifiersForArrowFunction() {
            var modifiers;
            if (token() === 131) {
                var pos = getNodePos();
                nextToken();
                var modifier = finishNode(factory.createToken(131), pos);
                modifiers = createNodeArray([modifier], pos);
            }
            return modifiers;
        }
        function parseClassElement() {
            var pos = getNodePos();
            if (token() === 26) {
                nextToken();
                return finishNode(factory.createSemicolonClassElement(), pos);
            }
            var hasJSDoc = hasPrecedingJSDocComment();
            var decorators = parseDecorators();
            var modifiers = parseModifiers(true, true);
            if (token() === 124 && lookAhead(nextTokenIsOpenBrace)) {
                return parseClassStaticBlockDeclaration(pos, hasJSDoc, decorators, modifiers);
            }
            if (parseContextualModifier(136)) {
                return parseAccessorDeclaration(pos, hasJSDoc, decorators, modifiers, 172);
            }
            if (parseContextualModifier(149)) {
                return parseAccessorDeclaration(pos, hasJSDoc, decorators, modifiers, 173);
            }
            if (token() === 134 || token() === 10) {
                var constructorDeclaration = tryParseConstructorDeclaration(pos, hasJSDoc, decorators, modifiers);
                if (constructorDeclaration) {
                    return constructorDeclaration;
                }
            }
            if (isIndexSignature()) {
                return parseIndexSignatureDeclaration(pos, hasJSDoc, decorators, modifiers);
            }
            if (ts.tokenIsIdentifierOrKeyword(token()) ||
                token() === 10 ||
                token() === 8 ||
                token() === 41 ||
                token() === 22) {
                var isAmbient = ts.some(modifiers, isDeclareModifier);
                if (isAmbient) {
                    for (var _i = 0, _a = modifiers; _i < _a.length; _i++) {
                        var m = _a[_i];
                        m.flags |= 16777216;
                    }
                    return doInsideOfContext(16777216, function () { return parsePropertyOrMethodDeclaration(pos, hasJSDoc, decorators, modifiers); });
                }
                else {
                    return parsePropertyOrMethodDeclaration(pos, hasJSDoc, decorators, modifiers);
                }
            }
            if (decorators || modifiers) {
                var name = createMissingNode(79, true, ts.Diagnostics.Declaration_expected);
                return parsePropertyDeclaration(pos, hasJSDoc, decorators, modifiers, name, undefined);
            }
            return ts.Debug.fail("Should not have attempted to parse class member declaration.");
        }
        function parseClassExpression() {
            return parseClassDeclarationOrExpression(getNodePos(), hasPrecedingJSDocComment(), undefined, undefined, 226);
        }
        function parseClassDeclaration(pos, hasJSDoc, decorators, modifiers) {
            return parseClassDeclarationOrExpression(pos, hasJSDoc, decorators, modifiers, 257);
        }
        function parseClassDeclarationOrExpression(pos, hasJSDoc, decorators, modifiers, kind) {
            var savedAwaitContext = inAwaitContext();
            parseExpected(84);
            var name = parseNameOfClassDeclarationOrExpression();
            var typeParameters = parseTypeParameters();
            if (ts.some(modifiers, ts.isExportModifier))
                setAwaitContext(true);
            var heritageClauses = parseHeritageClauses();
            var members;
            if (parseExpected(18)) {
                members = parseClassMembers();
                parseExpected(19);
            }
            else {
                members = createMissingList();
            }
            setAwaitContext(savedAwaitContext);
            var node = kind === 257
                ? factory.createClassDeclaration(decorators, modifiers, name, typeParameters, heritageClauses, members)
                : factory.createClassExpression(decorators, modifiers, name, typeParameters, heritageClauses, members);
            return withJSDoc(finishNode(node, pos), hasJSDoc);
        }
        function parseNameOfClassDeclarationOrExpression() {
            return isBindingIdentifier() && !isImplementsClause()
                ? createIdentifier(isBindingIdentifier())
                : undefined;
        }
        function isImplementsClause() {
            return token() === 117 && lookAhead(nextTokenIsIdentifierOrKeyword);
        }
        function parseHeritageClauses() {
            if (isHeritageClause()) {
                return parseList(22, parseHeritageClause);
            }
            return undefined;
        }
        function parseHeritageClause() {
            var pos = getNodePos();
            var tok = token();
            ts.Debug.assert(tok === 94 || tok === 117);
            nextToken();
            var types = parseDelimitedList(7, parseExpressionWithTypeArguments);
            return finishNode(factory.createHeritageClause(tok, types), pos);
        }
        function parseExpressionWithTypeArguments() {
            var pos = getNodePos();
            var expression = parseLeftHandSideExpressionOrHigher();
            if (expression.kind === 228) {
                return expression;
            }
            var typeArguments = tryParseTypeArguments();
            return finishNode(factory.createExpressionWithTypeArguments(expression, typeArguments), pos);
        }
        function tryParseTypeArguments() {
            return token() === 29 ?
                parseBracketedList(20, parseType, 29, 31) : undefined;
        }
        function isHeritageClause() {
            return token() === 94 || token() === 117;
        }
        function parseClassMembers() {
            return parseList(5, parseClassElement);
        }
        function parseInterfaceDeclaration(pos, hasJSDoc, decorators, modifiers) {
            parseExpected(118);
            var name = parseIdentifier();
            var typeParameters = parseTypeParameters();
            var heritageClauses = parseHeritageClauses();
            var members = parseObjectTypeMembers();
            var node = factory.createInterfaceDeclaration(decorators, modifiers, name, typeParameters, heritageClauses, members);
            return withJSDoc(finishNode(node, pos), hasJSDoc);
        }
        function parseTypeAliasDeclaration(pos, hasJSDoc, decorators, modifiers) {
            parseExpected(152);
            var name = parseIdentifier();
            var typeParameters = parseTypeParameters();
            parseExpected(63);
            var type = token() === 138 && tryParse(parseKeywordAndNoDot) || parseType();
            parseSemicolon();
            var node = factory.createTypeAliasDeclaration(decorators, modifiers, name, typeParameters, type);
            return withJSDoc(finishNode(node, pos), hasJSDoc);
        }
        function parseEnumMember() {
            var pos = getNodePos();
            var hasJSDoc = hasPrecedingJSDocComment();
            var name = parsePropertyName();
            var initializer = allowInAnd(parseInitializer);
            return withJSDoc(finishNode(factory.createEnumMember(name, initializer), pos), hasJSDoc);
        }
        function parseEnumDeclaration(pos, hasJSDoc, decorators, modifiers) {
            parseExpected(92);
            var name = parseIdentifier();
            var members;
            if (parseExpected(18)) {
                members = doOutsideOfYieldAndAwaitContext(function () { return parseDelimitedList(6, parseEnumMember); });
                parseExpected(19);
            }
            else {
                members = createMissingList();
            }
            var node = factory.createEnumDeclaration(decorators, modifiers, name, members);
            return withJSDoc(finishNode(node, pos), hasJSDoc);
        }
        function parseModuleBlock() {
            var pos = getNodePos();
            var statements;
            if (parseExpected(18)) {
                statements = parseList(1, parseStatement);
                parseExpected(19);
            }
            else {
                statements = createMissingList();
            }
            return finishNode(factory.createModuleBlock(statements), pos);
        }
        function parseModuleOrNamespaceDeclaration(pos, hasJSDoc, decorators, modifiers, flags) {
            var namespaceFlag = flags & 16;
            var name = parseIdentifier();
            var body = parseOptional(24)
                ? parseModuleOrNamespaceDeclaration(getNodePos(), false, undefined, undefined, 4 | namespaceFlag)
                : parseModuleBlock();
            var node = factory.createModuleDeclaration(decorators, modifiers, name, body, flags);
            return withJSDoc(finishNode(node, pos), hasJSDoc);
        }
        function parseAmbientExternalModuleDeclaration(pos, hasJSDoc, decorators, modifiers) {
            var flags = 0;
            var name;
            if (token() === 157) {
                name = parseIdentifier();
                flags |= 1024;
            }
            else {
                name = parseLiteralNode();
                name.text = internIdentifier(name.text);
            }
            var body;
            if (token() === 18) {
                body = parseModuleBlock();
            }
            else {
                parseSemicolon();
            }
            var node = factory.createModuleDeclaration(decorators, modifiers, name, body, flags);
            return withJSDoc(finishNode(node, pos), hasJSDoc);
        }
        function parseModuleDeclaration(pos, hasJSDoc, decorators, modifiers) {
            var flags = 0;
            if (token() === 157) {
                return parseAmbientExternalModuleDeclaration(pos, hasJSDoc, decorators, modifiers);
            }
            else if (parseOptional(142)) {
                flags |= 16;
            }
            else {
                parseExpected(141);
                if (token() === 10) {
                    return parseAmbientExternalModuleDeclaration(pos, hasJSDoc, decorators, modifiers);
                }
            }
            return parseModuleOrNamespaceDeclaration(pos, hasJSDoc, decorators, modifiers, flags);
        }
        function isExternalModuleReference() {
            return token() === 146 &&
                lookAhead(nextTokenIsOpenParen);
        }
        function nextTokenIsOpenParen() {
            return nextToken() === 20;
        }
        function nextTokenIsOpenBrace() {
            return nextToken() === 18;
        }
        function nextTokenIsSlash() {
            return nextToken() === 43;
        }
        function parseNamespaceExportDeclaration(pos, hasJSDoc, decorators, modifiers) {
            parseExpected(127);
            parseExpected(142);
            var name = parseIdentifier();
            parseSemicolon();
            var node = factory.createNamespaceExportDeclaration(name);
            node.decorators = decorators;
            node.modifiers = modifiers;
            return withJSDoc(finishNode(node, pos), hasJSDoc);
        }
        function parseImportDeclarationOrImportEqualsDeclaration(pos, hasJSDoc, decorators, modifiers) {
            parseExpected(100);
            var afterImportPos = scanner.getStartPos();
            var identifier;
            if (isIdentifier()) {
                identifier = parseIdentifier();
            }
            var isTypeOnly = false;
            if (token() !== 156 &&
                (identifier === null || identifier === void 0 ? void 0 : identifier.escapedText) === "type" &&
                (isIdentifier() || tokenAfterImportDefinitelyProducesImportDeclaration())) {
                isTypeOnly = true;
                identifier = isIdentifier() ? parseIdentifier() : undefined;
            }
            if (identifier && !tokenAfterImportedIdentifierDefinitelyProducesImportDeclaration()) {
                return parseImportEqualsDeclaration(pos, hasJSDoc, decorators, modifiers, identifier, isTypeOnly);
            }
            var importClause;
            if (identifier ||
                token() === 41 ||
                token() === 18) {
                importClause = parseImportClause(identifier, afterImportPos, isTypeOnly);
                parseExpected(156);
            }
            var moduleSpecifier = parseModuleSpecifier();
            var assertClause;
            if (token() === 129 && !scanner.hasPrecedingLineBreak()) {
                assertClause = parseAssertClause();
            }
            parseSemicolon();
            var node = factory.createImportDeclaration(decorators, modifiers, importClause, moduleSpecifier, assertClause);
            return withJSDoc(finishNode(node, pos), hasJSDoc);
        }
        function parseAssertEntry() {
            var pos = getNodePos();
            var name = ts.tokenIsIdentifierOrKeyword(token()) ? parseIdentifierName() : parseLiteralLikeNode(10);
            parseExpected(58);
            var value = parseAssignmentExpressionOrHigher();
            return finishNode(factory.createAssertEntry(name, value), pos);
        }
        function parseAssertClause(skipAssertKeyword) {
            var pos = getNodePos();
            if (!skipAssertKeyword) {
                parseExpected(129);
            }
            var openBracePosition = scanner.getTokenPos();
            if (parseExpected(18)) {
                var multiLine = scanner.hasPrecedingLineBreak();
                var elements = parseDelimitedList(24, parseAssertEntry, true);
                if (!parseExpected(19)) {
                    var lastError = ts.lastOrUndefined(parseDiagnostics);
                    if (lastError && lastError.code === ts.Diagnostics._0_expected.code) {
                        ts.addRelatedInfo(lastError, ts.createDetachedDiagnostic(fileName, openBracePosition, 1, ts.Diagnostics.The_parser_expected_to_find_a_1_to_match_the_0_token_here, "{", "}"));
                    }
                }
                return finishNode(factory.createAssertClause(elements, multiLine), pos);
            }
            else {
                var elements = createNodeArray([], getNodePos(), undefined, false);
                return finishNode(factory.createAssertClause(elements, false), pos);
            }
        }
        function tokenAfterImportDefinitelyProducesImportDeclaration() {
            return token() === 41 || token() === 18;
        }
        function tokenAfterImportedIdentifierDefinitelyProducesImportDeclaration() {
            return token() === 27 || token() === 156;
        }
        function parseImportEqualsDeclaration(pos, hasJSDoc, decorators, modifiers, identifier, isTypeOnly) {
            parseExpected(63);
            var moduleReference = parseModuleReference();
            parseSemicolon();
            var node = factory.createImportEqualsDeclaration(decorators, modifiers, isTypeOnly, identifier, moduleReference);
            var finished = withJSDoc(finishNode(node, pos), hasJSDoc);
            return finished;
        }
        function parseImportClause(identifier, pos, isTypeOnly) {
            var namedBindings;
            if (!identifier ||
                parseOptional(27)) {
                namedBindings = token() === 41 ? parseNamespaceImport() : parseNamedImportsOrExports(269);
            }
            return finishNode(factory.createImportClause(isTypeOnly, identifier, namedBindings), pos);
        }
        function parseModuleReference() {
            return isExternalModuleReference()
                ? parseExternalModuleReference()
                : parseEntityName(false);
        }
        function parseExternalModuleReference() {
            var pos = getNodePos();
            parseExpected(146);
            parseExpected(20);
            var expression = parseModuleSpecifier();
            parseExpected(21);
            return finishNode(factory.createExternalModuleReference(expression), pos);
        }
        function parseModuleSpecifier() {
            if (token() === 10) {
                var result = parseLiteralNode();
                result.text = internIdentifier(result.text);
                return result;
            }
            else {
                return parseExpression();
            }
        }
        function parseNamespaceImport() {
            var pos = getNodePos();
            parseExpected(41);
            parseExpected(127);
            var name = parseIdentifier();
            return finishNode(factory.createNamespaceImport(name), pos);
        }
        function parseNamedImportsOrExports(kind) {
            var pos = getNodePos();
            var node = kind === 269
                ? factory.createNamedImports(parseBracketedList(23, parseImportSpecifier, 18, 19))
                : factory.createNamedExports(parseBracketedList(23, parseExportSpecifier, 18, 19));
            return finishNode(node, pos);
        }
        function parseExportSpecifier() {
            var hasJSDoc = hasPrecedingJSDocComment();
            return withJSDoc(parseImportOrExportSpecifier(275), hasJSDoc);
        }
        function parseImportSpecifier() {
            return parseImportOrExportSpecifier(270);
        }
        function parseImportOrExportSpecifier(kind) {
            var pos = getNodePos();
            var checkIdentifierIsKeyword = ts.isKeyword(token()) && !isIdentifier();
            var checkIdentifierStart = scanner.getTokenPos();
            var checkIdentifierEnd = scanner.getTextPos();
            var isTypeOnly = false;
            var propertyName;
            var canParseAsKeyword = true;
            var name = parseIdentifierName();
            if (name.escapedText === "type") {
                if (token() === 127) {
                    var firstAs = parseIdentifierName();
                    if (token() === 127) {
                        var secondAs = parseIdentifierName();
                        if (ts.tokenIsIdentifierOrKeyword(token())) {
                            isTypeOnly = true;
                            propertyName = firstAs;
                            name = parseNameWithKeywordCheck();
                            canParseAsKeyword = false;
                        }
                        else {
                            propertyName = name;
                            name = secondAs;
                            canParseAsKeyword = false;
                        }
                    }
                    else if (ts.tokenIsIdentifierOrKeyword(token())) {
                        propertyName = name;
                        canParseAsKeyword = false;
                        name = parseNameWithKeywordCheck();
                    }
                    else {
                        isTypeOnly = true;
                        name = firstAs;
                    }
                }
                else if (ts.tokenIsIdentifierOrKeyword(token())) {
                    isTypeOnly = true;
                    name = parseNameWithKeywordCheck();
                }
            }
            if (canParseAsKeyword && token() === 127) {
                propertyName = name;
                parseExpected(127);
                name = parseNameWithKeywordCheck();
            }
            if (kind === 270 && checkIdentifierIsKeyword) {
                parseErrorAt(checkIdentifierStart, checkIdentifierEnd, ts.Diagnostics.Identifier_expected);
            }
            var node = kind === 270
                ? factory.createImportSpecifier(isTypeOnly, propertyName, name)
                : factory.createExportSpecifier(isTypeOnly, propertyName, name);
            return finishNode(node, pos);
            function parseNameWithKeywordCheck() {
                checkIdentifierIsKeyword = ts.isKeyword(token()) && !isIdentifier();
                checkIdentifierStart = scanner.getTokenPos();
                checkIdentifierEnd = scanner.getTextPos();
                return parseIdentifierName();
            }
        }
        function parseNamespaceExport(pos) {
            return finishNode(factory.createNamespaceExport(parseIdentifierName()), pos);
        }
        function parseExportDeclaration(pos, hasJSDoc, decorators, modifiers) {
            var savedAwaitContext = inAwaitContext();
            setAwaitContext(true);
            var exportClause;
            var moduleSpecifier;
            var assertClause;
            var isTypeOnly = parseOptional(152);
            var namespaceExportPos = getNodePos();
            if (parseOptional(41)) {
                if (parseOptional(127)) {
                    exportClause = parseNamespaceExport(namespaceExportPos);
                }
                parseExpected(156);
                moduleSpecifier = parseModuleSpecifier();
            }
            else {
                exportClause = parseNamedImportsOrExports(273);
                if (token() === 156 || (token() === 10 && !scanner.hasPrecedingLineBreak())) {
                    parseExpected(156);
                    moduleSpecifier = parseModuleSpecifier();
                }
            }
            if (moduleSpecifier && token() === 129 && !scanner.hasPrecedingLineBreak()) {
                assertClause = parseAssertClause();
            }
            parseSemicolon();
            setAwaitContext(savedAwaitContext);
            var node = factory.createExportDeclaration(decorators, modifiers, isTypeOnly, exportClause, moduleSpecifier, assertClause);
            return withJSDoc(finishNode(node, pos), hasJSDoc);
        }
        function parseExportAssignment(pos, hasJSDoc, decorators, modifiers) {
            var savedAwaitContext = inAwaitContext();
            setAwaitContext(true);
            var isExportEquals;
            if (parseOptional(63)) {
                isExportEquals = true;
            }
            else {
                parseExpected(88);
            }
            var expression = parseAssignmentExpressionOrHigher();
            parseSemicolon();
            setAwaitContext(savedAwaitContext);
            var node = factory.createExportAssignment(decorators, modifiers, isExportEquals, expression);
            return withJSDoc(finishNode(node, pos), hasJSDoc);
        }
        var JSDocParser;
        (function (JSDocParser) {
            function parseJSDocTypeExpressionForTests(content, start, length) {
                initializeState("file.js", content, 99, undefined, 1);
                scanner.setText(content, start, length);
                currentToken = scanner.scan();
                var jsDocTypeExpression = parseJSDocTypeExpression();
                var sourceFile = createSourceFile("file.js", 99, 1, false, [], factory.createToken(1), 0, ts.noop);
                var diagnostics = ts.attachFileToDiagnostics(parseDiagnostics, sourceFile);
                if (jsDocDiagnostics) {
                    sourceFile.jsDocDiagnostics = ts.attachFileToDiagnostics(jsDocDiagnostics, sourceFile);
                }
                clearState();
                return jsDocTypeExpression ? { jsDocTypeExpression: jsDocTypeExpression, diagnostics: diagnostics } : undefined;
            }
            JSDocParser.parseJSDocTypeExpressionForTests = parseJSDocTypeExpressionForTests;
            function parseJSDocTypeExpression(mayOmitBraces) {
                var pos = getNodePos();
                var hasBrace = (mayOmitBraces ? parseOptional : parseExpected)(18);
                var type = doInsideOfContext(8388608, parseJSDocType);
                if (!mayOmitBraces || hasBrace) {
                    parseExpectedJSDoc(19);
                }
                var result = factory.createJSDocTypeExpression(type);
                fixupParentReferences(result);
                return finishNode(result, pos);
            }
            JSDocParser.parseJSDocTypeExpression = parseJSDocTypeExpression;
            function parseJSDocNameReference() {
                var pos = getNodePos();
                var hasBrace = parseOptional(18);
                var p2 = getNodePos();
                var entityName = parseEntityName(false);
                while (token() === 80) {
                    reScanHashToken();
                    nextTokenJSDoc();
                    entityName = finishNode(factory.createJSDocMemberName(entityName, parseIdentifier()), p2);
                }
                if (hasBrace) {
                    parseExpectedJSDoc(19);
                }
                var result = factory.createJSDocNameReference(entityName);
                fixupParentReferences(result);
                return finishNode(result, pos);
            }
            JSDocParser.parseJSDocNameReference = parseJSDocNameReference;
            function parseIsolatedJSDocComment(content, start, length) {
                initializeState("", content, 99, undefined, 1);
                var jsDoc = doInsideOfContext(8388608, function () { return parseJSDocCommentWorker(start, length); });
                var sourceFile = { languageVariant: 0, text: content };
                var diagnostics = ts.attachFileToDiagnostics(parseDiagnostics, sourceFile);
                clearState();
                return jsDoc ? { jsDoc: jsDoc, diagnostics: diagnostics } : undefined;
            }
            JSDocParser.parseIsolatedJSDocComment = parseIsolatedJSDocComment;
            function parseJSDocComment(parent, start, length) {
                var saveToken = currentToken;
                var saveParseDiagnosticsLength = parseDiagnostics.length;
                var saveParseErrorBeforeNextFinishedNode = parseErrorBeforeNextFinishedNode;
                var comment = doInsideOfContext(8388608, function () { return parseJSDocCommentWorker(start, length); });
                ts.setParent(comment, parent);
                if (contextFlags & 262144) {
                    if (!jsDocDiagnostics) {
                        jsDocDiagnostics = [];
                    }
                    jsDocDiagnostics.push.apply(jsDocDiagnostics, parseDiagnostics);
                }
                currentToken = saveToken;
                parseDiagnostics.length = saveParseDiagnosticsLength;
                parseErrorBeforeNextFinishedNode = saveParseErrorBeforeNextFinishedNode;
                return comment;
            }
            JSDocParser.parseJSDocComment = parseJSDocComment;
            function parseJSDocCommentWorker(start, length) {
                if (start === void 0) { start = 0; }
                var content = sourceText;
                var end = length === undefined ? content.length : start + length;
                length = end - start;
                ts.Debug.assert(start >= 0);
                ts.Debug.assert(start <= end);
                ts.Debug.assert(end <= content.length);
                if (!isJSDocLikeText(content, start)) {
                    return undefined;
                }
                var tags;
                var tagsPos;
                var tagsEnd;
                var linkEnd;
                var commentsPos;
                var comments = [];
                var parts = [];
                return scanner.scanRange(start + 3, length - 5, function () {
                    var state = 1;
                    var margin;
                    var indent = start - (content.lastIndexOf("\n", start) + 1) + 4;
                    function pushComment(text) {
                        if (!margin) {
                            margin = indent;
                        }
                        comments.push(text);
                        indent += text.length;
                    }
                    nextTokenJSDoc();
                    while (parseOptionalJsdoc(5))
                        ;
                    if (parseOptionalJsdoc(4)) {
                        state = 0;
                        indent = 0;
                    }
                    loop: while (true) {
                        switch (token()) {
                            case 59:
                                if (state === 0 || state === 1) {
                                    removeTrailingWhitespace(comments);
                                    if (!commentsPos)
                                        commentsPos = getNodePos();
                                    addTag(parseTag(indent));
                                    state = 0;
                                    margin = undefined;
                                }
                                else {
                                    pushComment(scanner.getTokenText());
                                }
                                break;
                            case 4:
                                comments.push(scanner.getTokenText());
                                state = 0;
                                indent = 0;
                                break;
                            case 41:
                                var asterisk = scanner.getTokenText();
                                if (state === 1 || state === 2) {
                                    state = 2;
                                    pushComment(asterisk);
                                }
                                else {
                                    state = 1;
                                    indent += asterisk.length;
                                }
                                break;
                            case 5:
                                var whitespace = scanner.getTokenText();
                                if (state === 2) {
                                    comments.push(whitespace);
                                }
                                else if (margin !== undefined && indent + whitespace.length > margin) {
                                    comments.push(whitespace.slice(margin - indent));
                                }
                                indent += whitespace.length;
                                break;
                            case 1:
                                break loop;
                            case 18:
                                state = 2;
                                var commentEnd = scanner.getStartPos();
                                var linkStart = scanner.getTextPos() - 1;
                                var link = parseJSDocLink(linkStart);
                                if (link) {
                                    if (!linkEnd) {
                                        removeLeadingNewlines(comments);
                                    }
                                    parts.push(finishNode(factory.createJSDocText(comments.join("")), linkEnd !== null && linkEnd !== void 0 ? linkEnd : start, commentEnd));
                                    parts.push(link);
                                    comments = [];
                                    linkEnd = scanner.getTextPos();
                                    break;
                                }
                            default:
                                state = 2;
                                pushComment(scanner.getTokenText());
                                break;
                        }
                        nextTokenJSDoc();
                    }
                    removeTrailingWhitespace(comments);
                    if (parts.length && comments.length) {
                        parts.push(finishNode(factory.createJSDocText(comments.join("")), linkEnd !== null && linkEnd !== void 0 ? linkEnd : start, commentsPos));
                    }
                    if (parts.length && tags)
                        ts.Debug.assertIsDefined(commentsPos, "having parsed tags implies that the end of the comment span should be set");
                    var tagsArray = tags && createNodeArray(tags, tagsPos, tagsEnd);
                    return finishNode(factory.createJSDocComment(parts.length ? createNodeArray(parts, start, commentsPos) : comments.length ? comments.join("") : undefined, tagsArray), start, end);
                });
                function removeLeadingNewlines(comments) {
                    while (comments.length && (comments[0] === "\n" || comments[0] === "\r")) {
                        comments.shift();
                    }
                }
                function removeTrailingWhitespace(comments) {
                    while (comments.length && comments[comments.length - 1].trim() === "") {
                        comments.pop();
                    }
                }
                function isNextNonwhitespaceTokenEndOfFile() {
                    while (true) {
                        nextTokenJSDoc();
                        if (token() === 1) {
                            return true;
                        }
                        if (!(token() === 5 || token() === 4)) {
                            return false;
                        }
                    }
                }
                function skipWhitespace() {
                    if (token() === 5 || token() === 4) {
                        if (lookAhead(isNextNonwhitespaceTokenEndOfFile)) {
                            return;
                        }
                    }
                    while (token() === 5 || token() === 4) {
                        nextTokenJSDoc();
                    }
                }
                function skipWhitespaceOrAsterisk() {
                    if (token() === 5 || token() === 4) {
                        if (lookAhead(isNextNonwhitespaceTokenEndOfFile)) {
                            return "";
                        }
                    }
                    var precedingLineBreak = scanner.hasPrecedingLineBreak();
                    var seenLineBreak = false;
                    var indentText = "";
                    while ((precedingLineBreak && token() === 41) || token() === 5 || token() === 4) {
                        indentText += scanner.getTokenText();
                        if (token() === 4) {
                            precedingLineBreak = true;
                            seenLineBreak = true;
                            indentText = "";
                        }
                        else if (token() === 41) {
                            precedingLineBreak = false;
                        }
                        nextTokenJSDoc();
                    }
                    return seenLineBreak ? indentText : "";
                }
                function parseTag(margin) {
                    ts.Debug.assert(token() === 59);
                    var start = scanner.getTokenPos();
                    nextTokenJSDoc();
                    var tagName = parseJSDocIdentifierName(undefined);
                    var indentText = skipWhitespaceOrAsterisk();
                    var tag;
                    switch (tagName.escapedText) {
                        case "author":
                            tag = parseAuthorTag(start, tagName, margin, indentText);
                            break;
                        case "implements":
                            tag = parseImplementsTag(start, tagName, margin, indentText);
                            break;
                        case "augments":
                        case "extends":
                            tag = parseAugmentsTag(start, tagName, margin, indentText);
                            break;
                        case "class":
                        case "constructor":
                            tag = parseSimpleTag(start, factory.createJSDocClassTag, tagName, margin, indentText);
                            break;
                        case "public":
                            tag = parseSimpleTag(start, factory.createJSDocPublicTag, tagName, margin, indentText);
                            break;
                        case "private":
                            tag = parseSimpleTag(start, factory.createJSDocPrivateTag, tagName, margin, indentText);
                            break;
                        case "protected":
                            tag = parseSimpleTag(start, factory.createJSDocProtectedTag, tagName, margin, indentText);
                            break;
                        case "readonly":
                            tag = parseSimpleTag(start, factory.createJSDocReadonlyTag, tagName, margin, indentText);
                            break;
                        case "override":
                            tag = parseSimpleTag(start, factory.createJSDocOverrideTag, tagName, margin, indentText);
                            break;
                        case "deprecated":
                            hasDeprecatedTag = true;
                            tag = parseSimpleTag(start, factory.createJSDocDeprecatedTag, tagName, margin, indentText);
                            break;
                        case "this":
                            tag = parseThisTag(start, tagName, margin, indentText);
                            break;
                        case "enum":
                            tag = parseEnumTag(start, tagName, margin, indentText);
                            break;
                        case "arg":
                        case "argument":
                        case "param":
                            return parseParameterOrPropertyTag(start, tagName, 2, margin);
                        case "return":
                        case "returns":
                            tag = parseReturnTag(start, tagName, margin, indentText);
                            break;
                        case "template":
                            tag = parseTemplateTag(start, tagName, margin, indentText);
                            break;
                        case "type":
                            tag = parseTypeTag(start, tagName, margin, indentText);
                            break;
                        case "typedef":
                            tag = parseTypedefTag(start, tagName, margin, indentText);
                            break;
                        case "callback":
                            tag = parseCallbackTag(start, tagName, margin, indentText);
                            break;
                        case "see":
                            tag = parseSeeTag(start, tagName, margin, indentText);
                            break;
                        default:
                            tag = parseUnknownTag(start, tagName, margin, indentText);
                            break;
                    }
                    return tag;
                }
                function parseTrailingTagComments(pos, end, margin, indentText) {
                    if (!indentText) {
                        margin += end - pos;
                    }
                    return parseTagComments(margin, indentText.slice(margin));
                }
                function parseTagComments(indent, initialMargin) {
                    var commentsPos = getNodePos();
                    var comments = [];
                    var parts = [];
                    var linkEnd;
                    var state = 0;
                    var previousWhitespace = true;
                    var margin;
                    function pushComment(text) {
                        if (!margin) {
                            margin = indent;
                        }
                        comments.push(text);
                        indent += text.length;
                    }
                    if (initialMargin !== undefined) {
                        if (initialMargin !== "") {
                            pushComment(initialMargin);
                        }
                        state = 1;
                    }
                    var tok = token();
                    loop: while (true) {
                        switch (tok) {
                            case 4:
                                state = 0;
                                comments.push(scanner.getTokenText());
                                indent = 0;
                                break;
                            case 59:
                                if (state === 3
                                    || state === 2 && (!previousWhitespace || lookAhead(isNextJSDocTokenWhitespace))) {
                                    comments.push(scanner.getTokenText());
                                    break;
                                }
                                scanner.setTextPos(scanner.getTextPos() - 1);
                            case 1:
                                break loop;
                            case 5:
                                if (state === 2 || state === 3) {
                                    pushComment(scanner.getTokenText());
                                }
                                else {
                                    var whitespace = scanner.getTokenText();
                                    if (margin !== undefined && indent + whitespace.length > margin) {
                                        comments.push(whitespace.slice(margin - indent));
                                    }
                                    indent += whitespace.length;
                                }
                                break;
                            case 18:
                                state = 2;
                                var commentEnd = scanner.getStartPos();
                                var linkStart = scanner.getTextPos() - 1;
                                var link = parseJSDocLink(linkStart);
                                if (link) {
                                    parts.push(finishNode(factory.createJSDocText(comments.join("")), linkEnd !== null && linkEnd !== void 0 ? linkEnd : commentsPos, commentEnd));
                                    parts.push(link);
                                    comments = [];
                                    linkEnd = scanner.getTextPos();
                                }
                                else {
                                    pushComment(scanner.getTokenText());
                                }
                                break;
                            case 61:
                                if (state === 3) {
                                    state = 2;
                                }
                                else {
                                    state = 3;
                                }
                                pushComment(scanner.getTokenText());
                                break;
                            case 41:
                                if (state === 0) {
                                    state = 1;
                                    indent += 1;
                                    break;
                                }
                            default:
                                if (state !== 3) {
                                    state = 2;
                                }
                                pushComment(scanner.getTokenText());
                                break;
                        }
                        previousWhitespace = token() === 5;
                        tok = nextTokenJSDoc();
                    }
                    removeLeadingNewlines(comments);
                    removeTrailingWhitespace(comments);
                    if (parts.length) {
                        if (comments.length) {
                            parts.push(finishNode(factory.createJSDocText(comments.join("")), linkEnd !== null && linkEnd !== void 0 ? linkEnd : commentsPos));
                        }
                        return createNodeArray(parts, commentsPos, scanner.getTextPos());
                    }
                    else if (comments.length) {
                        return comments.join("");
                    }
                }
                function isNextJSDocTokenWhitespace() {
                    var next = nextTokenJSDoc();
                    return next === 5 || next === 4;
                }
                function parseJSDocLink(start) {
                    var linkType = tryParse(parseJSDocLinkPrefix);
                    if (!linkType) {
                        return undefined;
                    }
                    nextTokenJSDoc();
                    skipWhitespace();
                    var p2 = getNodePos();
                    var name = ts.tokenIsIdentifierOrKeyword(token())
                        ? parseEntityName(true)
                        : undefined;
                    if (name) {
                        while (token() === 80) {
                            reScanHashToken();
                            nextTokenJSDoc();
                            name = finishNode(factory.createJSDocMemberName(name, parseIdentifier()), p2);
                        }
                    }
                    var text = [];
                    while (token() !== 19 && token() !== 4 && token() !== 1) {
                        text.push(scanner.getTokenText());
                        nextTokenJSDoc();
                    }
                    var create = linkType === "link" ? factory.createJSDocLink
                        : linkType === "linkcode" ? factory.createJSDocLinkCode
                            : factory.createJSDocLinkPlain;
                    return finishNode(create(name, text.join("")), start, scanner.getTextPos());
                }
                function parseJSDocLinkPrefix() {
                    skipWhitespaceOrAsterisk();
                    if (token() === 18
                        && nextTokenJSDoc() === 59
                        && ts.tokenIsIdentifierOrKeyword(nextTokenJSDoc())) {
                        var kind = scanner.getTokenValue();
                        if (isJSDocLinkTag(kind))
                            return kind;
                    }
                }
                function isJSDocLinkTag(kind) {
                    return kind === "link" || kind === "linkcode" || kind === "linkplain";
                }
                function parseUnknownTag(start, tagName, indent, indentText) {
                    return finishNode(factory.createJSDocUnknownTag(tagName, parseTrailingTagComments(start, getNodePos(), indent, indentText)), start);
                }
                function addTag(tag) {
                    if (!tag) {
                        return;
                    }
                    if (!tags) {
                        tags = [tag];
                        tagsPos = tag.pos;
                    }
                    else {
                        tags.push(tag);
                    }
                    tagsEnd = tag.end;
                }
                function tryParseTypeExpression() {
                    skipWhitespaceOrAsterisk();
                    return token() === 18 ? parseJSDocTypeExpression() : undefined;
                }
                function parseBracketNameInPropertyAndParamTag() {
                    var isBracketed = parseOptionalJsdoc(22);
                    if (isBracketed) {
                        skipWhitespace();
                    }
                    var isBackquoted = parseOptionalJsdoc(61);
                    var name = parseJSDocEntityName();
                    if (isBackquoted) {
                        parseExpectedTokenJSDoc(61);
                    }
                    if (isBracketed) {
                        skipWhitespace();
                        if (parseOptionalToken(63)) {
                            parseExpression();
                        }
                        parseExpected(23);
                    }
                    return { name: name, isBracketed: isBracketed };
                }
                function isObjectOrObjectArrayTypeReference(node) {
                    switch (node.kind) {
                        case 148:
                            return true;
                        case 183:
                            return isObjectOrObjectArrayTypeReference(node.elementType);
                        default:
                            return ts.isTypeReferenceNode(node) && ts.isIdentifier(node.typeName) && node.typeName.escapedText === "Object" && !node.typeArguments;
                    }
                }
                function parseParameterOrPropertyTag(start, tagName, target, indent) {
                    var typeExpression = tryParseTypeExpression();
                    var isNameFirst = !typeExpression;
                    skipWhitespaceOrAsterisk();
                    var _a = parseBracketNameInPropertyAndParamTag(), name = _a.name, isBracketed = _a.isBracketed;
                    var indentText = skipWhitespaceOrAsterisk();
                    if (isNameFirst && !lookAhead(parseJSDocLinkPrefix)) {
                        typeExpression = tryParseTypeExpression();
                    }
                    var comment = parseTrailingTagComments(start, getNodePos(), indent, indentText);
                    var nestedTypeLiteral = target !== 4 && parseNestedTypeLiteral(typeExpression, name, target, indent);
                    if (nestedTypeLiteral) {
                        typeExpression = nestedTypeLiteral;
                        isNameFirst = true;
                    }
                    var result = target === 1
                        ? factory.createJSDocPropertyTag(tagName, name, isBracketed, typeExpression, isNameFirst, comment)
                        : factory.createJSDocParameterTag(tagName, name, isBracketed, typeExpression, isNameFirst, comment);
                    return finishNode(result, start);
                }
                function parseNestedTypeLiteral(typeExpression, name, target, indent) {
                    if (typeExpression && isObjectOrObjectArrayTypeReference(typeExpression.type)) {
                        var pos = getNodePos();
                        var child = void 0;
                        var children = void 0;
                        while (child = tryParse(function () { return parseChildParameterOrPropertyTag(target, indent, name); })) {
                            if (child.kind === 340 || child.kind === 347) {
                                children = ts.append(children, child);
                            }
                        }
                        if (children) {
                            var literal = finishNode(factory.createJSDocTypeLiteral(children, typeExpression.type.kind === 183), pos);
                            return finishNode(factory.createJSDocTypeExpression(literal), pos);
                        }
                    }
                }
                function parseReturnTag(start, tagName, indent, indentText) {
                    if (ts.some(tags, ts.isJSDocReturnTag)) {
                        parseErrorAt(tagName.pos, scanner.getTokenPos(), ts.Diagnostics._0_tag_already_specified, tagName.escapedText);
                    }
                    var typeExpression = tryParseTypeExpression();
                    return finishNode(factory.createJSDocReturnTag(tagName, typeExpression, parseTrailingTagComments(start, getNodePos(), indent, indentText)), start);
                }
                function parseTypeTag(start, tagName, indent, indentText) {
                    if (ts.some(tags, ts.isJSDocTypeTag)) {
                        parseErrorAt(tagName.pos, scanner.getTokenPos(), ts.Diagnostics._0_tag_already_specified, tagName.escapedText);
                    }
                    var typeExpression = parseJSDocTypeExpression(true);
                    var comments = indent !== undefined && indentText !== undefined ? parseTrailingTagComments(start, getNodePos(), indent, indentText) : undefined;
                    return finishNode(factory.createJSDocTypeTag(tagName, typeExpression, comments), start);
                }
                function parseSeeTag(start, tagName, indent, indentText) {
                    var isMarkdownOrJSDocLink = token() === 22
                        || lookAhead(function () { return nextTokenJSDoc() === 59 && ts.tokenIsIdentifierOrKeyword(nextTokenJSDoc()) && isJSDocLinkTag(scanner.getTokenValue()); });
                    var nameExpression = isMarkdownOrJSDocLink ? undefined : parseJSDocNameReference();
                    var comments = indent !== undefined && indentText !== undefined ? parseTrailingTagComments(start, getNodePos(), indent, indentText) : undefined;
                    return finishNode(factory.createJSDocSeeTag(tagName, nameExpression, comments), start);
                }
                function parseAuthorTag(start, tagName, indent, indentText) {
                    var commentStart = getNodePos();
                    var textOnly = parseAuthorNameAndEmail();
                    var commentEnd = scanner.getStartPos();
                    var comments = parseTrailingTagComments(start, commentEnd, indent, indentText);
                    if (!comments) {
                        commentEnd = scanner.getStartPos();
                    }
                    var allParts = typeof comments !== "string"
                        ? createNodeArray(ts.concatenate([finishNode(textOnly, commentStart, commentEnd)], comments), commentStart)
                        : textOnly.text + comments;
                    return finishNode(factory.createJSDocAuthorTag(tagName, allParts), start);
                }
                function parseAuthorNameAndEmail() {
                    var comments = [];
                    var inEmail = false;
                    var token = scanner.getToken();
                    while (token !== 1 && token !== 4) {
                        if (token === 29) {
                            inEmail = true;
                        }
                        else if (token === 59 && !inEmail) {
                            break;
                        }
                        else if (token === 31 && inEmail) {
                            comments.push(scanner.getTokenText());
                            scanner.setTextPos(scanner.getTokenPos() + 1);
                            break;
                        }
                        comments.push(scanner.getTokenText());
                        token = nextTokenJSDoc();
                    }
                    return factory.createJSDocText(comments.join(""));
                }
                function parseImplementsTag(start, tagName, margin, indentText) {
                    var className = parseExpressionWithTypeArgumentsForAugments();
                    return finishNode(factory.createJSDocImplementsTag(tagName, className, parseTrailingTagComments(start, getNodePos(), margin, indentText)), start);
                }
                function parseAugmentsTag(start, tagName, margin, indentText) {
                    var className = parseExpressionWithTypeArgumentsForAugments();
                    return finishNode(factory.createJSDocAugmentsTag(tagName, className, parseTrailingTagComments(start, getNodePos(), margin, indentText)), start);
                }
                function parseExpressionWithTypeArgumentsForAugments() {
                    var usedBrace = parseOptional(18);
                    var pos = getNodePos();
                    var expression = parsePropertyAccessEntityNameExpression();
                    var typeArguments = tryParseTypeArguments();
                    var node = factory.createExpressionWithTypeArguments(expression, typeArguments);
                    var res = finishNode(node, pos);
                    if (usedBrace) {
                        parseExpected(19);
                    }
                    return res;
                }
                function parsePropertyAccessEntityNameExpression() {
                    var pos = getNodePos();
                    var node = parseJSDocIdentifierName();
                    while (parseOptional(24)) {
                        var name = parseJSDocIdentifierName();
                        node = finishNode(factory.createPropertyAccessExpression(node, name), pos);
                    }
                    return node;
                }
                function parseSimpleTag(start, createTag, tagName, margin, indentText) {
                    return finishNode(createTag(tagName, parseTrailingTagComments(start, getNodePos(), margin, indentText)), start);
                }
                function parseThisTag(start, tagName, margin, indentText) {
                    var typeExpression = parseJSDocTypeExpression(true);
                    skipWhitespace();
                    return finishNode(factory.createJSDocThisTag(tagName, typeExpression, parseTrailingTagComments(start, getNodePos(), margin, indentText)), start);
                }
                function parseEnumTag(start, tagName, margin, indentText) {
                    var typeExpression = parseJSDocTypeExpression(true);
                    skipWhitespace();
                    return finishNode(factory.createJSDocEnumTag(tagName, typeExpression, parseTrailingTagComments(start, getNodePos(), margin, indentText)), start);
                }
                function parseTypedefTag(start, tagName, indent, indentText) {
                    var _a;
                    var typeExpression = tryParseTypeExpression();
                    skipWhitespaceOrAsterisk();
                    var fullName = parseJSDocTypeNameWithNamespace();
                    skipWhitespace();
                    var comment = parseTagComments(indent);
                    var end;
                    if (!typeExpression || isObjectOrObjectArrayTypeReference(typeExpression.type)) {
                        var child = void 0;
                        var childTypeTag = void 0;
                        var jsDocPropertyTags = void 0;
                        var hasChildren = false;
                        while (child = tryParse(function () { return parseChildPropertyTag(indent); })) {
                            hasChildren = true;
                            if (child.kind === 343) {
                                if (childTypeTag) {
                                    var lastError = parseErrorAtCurrentToken(ts.Diagnostics.A_JSDoc_typedef_comment_may_not_contain_multiple_type_tags);
                                    if (lastError) {
                                        ts.addRelatedInfo(lastError, ts.createDetachedDiagnostic(fileName, 0, 0, ts.Diagnostics.The_tag_was_first_specified_here));
                                    }
                                    break;
                                }
                                else {
                                    childTypeTag = child;
                                }
                            }
                            else {
                                jsDocPropertyTags = ts.append(jsDocPropertyTags, child);
                            }
                        }
                        if (hasChildren) {
                            var isArrayType = typeExpression && typeExpression.type.kind === 183;
                            var jsdocTypeLiteral = factory.createJSDocTypeLiteral(jsDocPropertyTags, isArrayType);
                            typeExpression = childTypeTag && childTypeTag.typeExpression && !isObjectOrObjectArrayTypeReference(childTypeTag.typeExpression.type) ?
                                childTypeTag.typeExpression :
                                finishNode(jsdocTypeLiteral, start);
                            end = typeExpression.end;
                        }
                    }
                    end = end || comment !== undefined ?
                        getNodePos() :
                        ((_a = fullName !== null && fullName !== void 0 ? fullName : typeExpression) !== null && _a !== void 0 ? _a : tagName).end;
                    if (!comment) {
                        comment = parseTrailingTagComments(start, end, indent, indentText);
                    }
                    var typedefTag = factory.createJSDocTypedefTag(tagName, typeExpression, fullName, comment);
                    return finishNode(typedefTag, start, end);
                }
                function parseJSDocTypeNameWithNamespace(nested) {
                    var pos = scanner.getTokenPos();
                    if (!ts.tokenIsIdentifierOrKeyword(token())) {
                        return undefined;
                    }
                    var typeNameOrNamespaceName = parseJSDocIdentifierName();
                    if (parseOptional(24)) {
                        var body = parseJSDocTypeNameWithNamespace(true);
                        var jsDocNamespaceNode = factory.createModuleDeclaration(undefined, undefined, typeNameOrNamespaceName, body, nested ? 4 : undefined);
                        return finishNode(jsDocNamespaceNode, pos);
                    }
                    if (nested) {
                        typeNameOrNamespaceName.isInJSDocNamespace = true;
                    }
                    return typeNameOrNamespaceName;
                }
                function parseCallbackTagParameters(indent) {
                    var pos = getNodePos();
                    var child;
                    var parameters;
                    while (child = tryParse(function () { return parseChildParameterOrPropertyTag(4, indent); })) {
                        parameters = ts.append(parameters, child);
                    }
                    return createNodeArray(parameters || [], pos);
                }
                function parseCallbackTag(start, tagName, indent, indentText) {
                    var fullName = parseJSDocTypeNameWithNamespace();
                    skipWhitespace();
                    var comment = parseTagComments(indent);
                    var parameters = parseCallbackTagParameters(indent);
                    var returnTag = tryParse(function () {
                        if (parseOptionalJsdoc(59)) {
                            var tag = parseTag(indent);
                            if (tag && tag.kind === 341) {
                                return tag;
                            }
                        }
                    });
                    var typeExpression = finishNode(factory.createJSDocSignature(undefined, parameters, returnTag), start);
                    if (!comment) {
                        comment = parseTrailingTagComments(start, getNodePos(), indent, indentText);
                    }
                    var end = comment !== undefined ? getNodePos() : typeExpression.end;
                    return finishNode(factory.createJSDocCallbackTag(tagName, typeExpression, fullName, comment), start, end);
                }
                function escapedTextsEqual(a, b) {
                    while (!ts.isIdentifier(a) || !ts.isIdentifier(b)) {
                        if (!ts.isIdentifier(a) && !ts.isIdentifier(b) && a.right.escapedText === b.right.escapedText) {
                            a = a.left;
                            b = b.left;
                        }
                        else {
                            return false;
                        }
                    }
                    return a.escapedText === b.escapedText;
                }
                function parseChildPropertyTag(indent) {
                    return parseChildParameterOrPropertyTag(1, indent);
                }
                function parseChildParameterOrPropertyTag(target, indent, name) {
                    var canParseTag = true;
                    var seenAsterisk = false;
                    while (true) {
                        switch (nextTokenJSDoc()) {
                            case 59:
                                if (canParseTag) {
                                    var child = tryParseChildTag(target, indent);
                                    if (child && (child.kind === 340 || child.kind === 347) &&
                                        target !== 4 &&
                                        name && (ts.isIdentifier(child.name) || !escapedTextsEqual(name, child.name.left))) {
                                        return false;
                                    }
                                    return child;
                                }
                                seenAsterisk = false;
                                break;
                            case 4:
                                canParseTag = true;
                                seenAsterisk = false;
                                break;
                            case 41:
                                if (seenAsterisk) {
                                    canParseTag = false;
                                }
                                seenAsterisk = true;
                                break;
                            case 79:
                                canParseTag = false;
                                break;
                            case 1:
                                return false;
                        }
                    }
                }
                function tryParseChildTag(target, indent) {
                    ts.Debug.assert(token() === 59);
                    var start = scanner.getStartPos();
                    nextTokenJSDoc();
                    var tagName = parseJSDocIdentifierName();
                    skipWhitespace();
                    var t;
                    switch (tagName.escapedText) {
                        case "type":
                            return target === 1 && parseTypeTag(start, tagName);
                        case "prop":
                        case "property":
                            t = 1;
                            break;
                        case "arg":
                        case "argument":
                        case "param":
                            t = 2 | 4;
                            break;
                        default:
                            return false;
                    }
                    if (!(target & t)) {
                        return false;
                    }
                    return parseParameterOrPropertyTag(start, tagName, target, indent);
                }
                function parseTemplateTagTypeParameter() {
                    var typeParameterPos = getNodePos();
                    var isBracketed = parseOptionalJsdoc(22);
                    if (isBracketed) {
                        skipWhitespace();
                    }
                    var name = parseJSDocIdentifierName(ts.Diagnostics.Unexpected_token_A_type_parameter_name_was_expected_without_curly_braces);
                    var defaultType;
                    if (isBracketed) {
                        skipWhitespace();
                        parseExpected(63);
                        defaultType = doInsideOfContext(8388608, parseJSDocType);
                        parseExpected(23);
                    }
                    if (ts.nodeIsMissing(name)) {
                        return undefined;
                    }
                    return finishNode(factory.createTypeParameterDeclaration(undefined, name, undefined, defaultType), typeParameterPos);
                }
                function parseTemplateTagTypeParameters() {
                    var pos = getNodePos();
                    var typeParameters = [];
                    do {
                        skipWhitespace();
                        var node = parseTemplateTagTypeParameter();
                        if (node !== undefined) {
                            typeParameters.push(node);
                        }
                        skipWhitespaceOrAsterisk();
                    } while (parseOptionalJsdoc(27));
                    return createNodeArray(typeParameters, pos);
                }
                function parseTemplateTag(start, tagName, indent, indentText) {
                    var constraint = token() === 18 ? parseJSDocTypeExpression() : undefined;
                    var typeParameters = parseTemplateTagTypeParameters();
                    return finishNode(factory.createJSDocTemplateTag(tagName, constraint, typeParameters, parseTrailingTagComments(start, getNodePos(), indent, indentText)), start);
                }
                function parseOptionalJsdoc(t) {
                    if (token() === t) {
                        nextTokenJSDoc();
                        return true;
                    }
                    return false;
                }
                function parseJSDocEntityName() {
                    var entity = parseJSDocIdentifierName();
                    if (parseOptional(22)) {
                        parseExpected(23);
                    }
                    while (parseOptional(24)) {
                        var name = parseJSDocIdentifierName();
                        if (parseOptional(22)) {
                            parseExpected(23);
                        }
                        entity = createQualifiedName(entity, name);
                    }
                    return entity;
                }
                function parseJSDocIdentifierName(message) {
                    if (!ts.tokenIsIdentifierOrKeyword(token())) {
                        return createMissingNode(79, !message, message || ts.Diagnostics.Identifier_expected);
                    }
                    identifierCount++;
                    var pos = scanner.getTokenPos();
                    var end = scanner.getTextPos();
                    var originalKeywordKind = token();
                    var text = internIdentifier(scanner.getTokenValue());
                    var result = finishNode(factory.createIdentifier(text, undefined, originalKeywordKind), pos, end);
                    nextTokenJSDoc();
                    return result;
                }
            }
        })(JSDocParser = Parser.JSDocParser || (Parser.JSDocParser = {}));
    })(Parser || (Parser = {}));
    var IncrementalParser;
    (function (IncrementalParser) {
        function updateSourceFile(sourceFile, newText, textChangeRange, aggressiveChecks) {
            aggressiveChecks = aggressiveChecks || ts.Debug.shouldAssert(2);
            checkChangeRange(sourceFile, newText, textChangeRange, aggressiveChecks);
            if (ts.textChangeRangeIsUnchanged(textChangeRange)) {
                return sourceFile;
            }
            if (sourceFile.statements.length === 0) {
                return Parser.parseSourceFile(sourceFile.fileName, newText, sourceFile.languageVersion, undefined, true, sourceFile.scriptKind, sourceFile.setExternalModuleIndicator);
            }
            var incrementalSourceFile = sourceFile;
            ts.Debug.assert(!incrementalSourceFile.hasBeenIncrementallyParsed);
            incrementalSourceFile.hasBeenIncrementallyParsed = true;
            Parser.fixupParentReferences(incrementalSourceFile);
            var oldText = sourceFile.text;
            var syntaxCursor = createSyntaxCursor(sourceFile);
            var changeRange = extendToAffectedRange(sourceFile, textChangeRange);
            checkChangeRange(sourceFile, newText, changeRange, aggressiveChecks);
            ts.Debug.assert(changeRange.span.start <= textChangeRange.span.start);
            ts.Debug.assert(ts.textSpanEnd(changeRange.span) === ts.textSpanEnd(textChangeRange.span));
            ts.Debug.assert(ts.textSpanEnd(ts.textChangeRangeNewSpan(changeRange)) === ts.textSpanEnd(ts.textChangeRangeNewSpan(textChangeRange)));
            var delta = ts.textChangeRangeNewSpan(changeRange).length - changeRange.span.length;
            updateTokenPositionsAndMarkElements(incrementalSourceFile, changeRange.span.start, ts.textSpanEnd(changeRange.span), ts.textSpanEnd(ts.textChangeRangeNewSpan(changeRange)), delta, oldText, newText, aggressiveChecks);
            var result = Parser.parseSourceFile(sourceFile.fileName, newText, sourceFile.languageVersion, syntaxCursor, true, sourceFile.scriptKind, sourceFile.setExternalModuleIndicator);
            result.commentDirectives = getNewCommentDirectives(sourceFile.commentDirectives, result.commentDirectives, changeRange.span.start, ts.textSpanEnd(changeRange.span), delta, oldText, newText, aggressiveChecks);
            result.impliedNodeFormat = sourceFile.impliedNodeFormat;
            return result;
        }
        IncrementalParser.updateSourceFile = updateSourceFile;
        function getNewCommentDirectives(oldDirectives, newDirectives, changeStart, changeRangeOldEnd, delta, oldText, newText, aggressiveChecks) {
            if (!oldDirectives)
                return newDirectives;
            var commentDirectives;
            var addedNewlyScannedDirectives = false;
            for (var _i = 0, oldDirectives_1 = oldDirectives; _i < oldDirectives_1.length; _i++) {
                var directive = oldDirectives_1[_i];
                var range = directive.range, type = directive.type;
                if (range.end < changeStart) {
                    commentDirectives = ts.append(commentDirectives, directive);
                }
                else if (range.pos > changeRangeOldEnd) {
                    addNewlyScannedDirectives();
                    var updatedDirective = {
                        range: { pos: range.pos + delta, end: range.end + delta },
                        type: type
                    };
                    commentDirectives = ts.append(commentDirectives, updatedDirective);
                    if (aggressiveChecks) {
                        ts.Debug.assert(oldText.substring(range.pos, range.end) === newText.substring(updatedDirective.range.pos, updatedDirective.range.end));
                    }
                }
            }
            addNewlyScannedDirectives();
            return commentDirectives;
            function addNewlyScannedDirectives() {
                if (addedNewlyScannedDirectives)
                    return;
                addedNewlyScannedDirectives = true;
                if (!commentDirectives) {
                    commentDirectives = newDirectives;
                }
                else if (newDirectives) {
                    commentDirectives.push.apply(commentDirectives, newDirectives);
                }
            }
        }
        function moveElementEntirelyPastChangeRange(element, isArray, delta, oldText, newText, aggressiveChecks) {
            if (isArray) {
                visitArray(element);
            }
            else {
                visitNode(element);
            }
            return;
            function visitNode(node) {
                var text = "";
                if (aggressiveChecks && shouldCheckNode(node)) {
                    text = oldText.substring(node.pos, node.end);
                }
                if (node._children) {
                    node._children = undefined;
                }
                ts.setTextRangePosEnd(node, node.pos + delta, node.end + delta);
                if (aggressiveChecks && shouldCheckNode(node)) {
                    ts.Debug.assert(text === newText.substring(node.pos, node.end));
                }
                forEachChild(node, visitNode, visitArray);
                if (ts.hasJSDocNodes(node)) {
                    for (var _i = 0, _a = node.jsDoc; _i < _a.length; _i++) {
                        var jsDocComment = _a[_i];
                        visitNode(jsDocComment);
                    }
                }
                checkNodePositions(node, aggressiveChecks);
            }
            function visitArray(array) {
                array._children = undefined;
                ts.setTextRangePosEnd(array, array.pos + delta, array.end + delta);
                for (var _i = 0, array_9 = array; _i < array_9.length; _i++) {
                    var node = array_9[_i];
                    visitNode(node);
                }
            }
        }
        function shouldCheckNode(node) {
            switch (node.kind) {
                case 10:
                case 8:
                case 79:
                    return true;
            }
            return false;
        }
        function adjustIntersectingElement(element, changeStart, changeRangeOldEnd, changeRangeNewEnd, delta) {
            ts.Debug.assert(element.end >= changeStart, "Adjusting an element that was entirely before the change range");
            ts.Debug.assert(element.pos <= changeRangeOldEnd, "Adjusting an element that was entirely after the change range");
            ts.Debug.assert(element.pos <= element.end);
            var pos = Math.min(element.pos, changeRangeNewEnd);
            var end = element.end >= changeRangeOldEnd ?
                element.end + delta :
                Math.min(element.end, changeRangeNewEnd);
            ts.Debug.assert(pos <= end);
            if (element.parent) {
                ts.Debug.assertGreaterThanOrEqual(pos, element.parent.pos);
                ts.Debug.assertLessThanOrEqual(end, element.parent.end);
            }
            ts.setTextRangePosEnd(element, pos, end);
        }
        function checkNodePositions(node, aggressiveChecks) {
            if (aggressiveChecks) {
                var pos_2 = node.pos;
                var visitNode_1 = function (child) {
                    ts.Debug.assert(child.pos >= pos_2);
                    pos_2 = child.end;
                };
                if (ts.hasJSDocNodes(node)) {
                    for (var _i = 0, _a = node.jsDoc; _i < _a.length; _i++) {
                        var jsDocComment = _a[_i];
                        visitNode_1(jsDocComment);
                    }
                }
                forEachChild(node, visitNode_1);
                ts.Debug.assert(pos_2 <= node.end);
            }
        }
        function updateTokenPositionsAndMarkElements(sourceFile, changeStart, changeRangeOldEnd, changeRangeNewEnd, delta, oldText, newText, aggressiveChecks) {
            visitNode(sourceFile);
            return;
            function visitNode(child) {
                ts.Debug.assert(child.pos <= child.end);
                if (child.pos > changeRangeOldEnd) {
                    moveElementEntirelyPastChangeRange(child, false, delta, oldText, newText, aggressiveChecks);
                    return;
                }
                var fullEnd = child.end;
                if (fullEnd >= changeStart) {
                    child.intersectsChange = true;
                    child._children = undefined;
                    adjustIntersectingElement(child, changeStart, changeRangeOldEnd, changeRangeNewEnd, delta);
                    forEachChild(child, visitNode, visitArray);
                    if (ts.hasJSDocNodes(child)) {
                        for (var _i = 0, _a = child.jsDoc; _i < _a.length; _i++) {
                            var jsDocComment = _a[_i];
                            visitNode(jsDocComment);
                        }
                    }
                    checkNodePositions(child, aggressiveChecks);
                    return;
                }
                ts.Debug.assert(fullEnd < changeStart);
            }
            function visitArray(array) {
                ts.Debug.assert(array.pos <= array.end);
                if (array.pos > changeRangeOldEnd) {
                    moveElementEntirelyPastChangeRange(array, true, delta, oldText, newText, aggressiveChecks);
                    return;
                }
                var fullEnd = array.end;
                if (fullEnd >= changeStart) {
                    array.intersectsChange = true;
                    array._children = undefined;
                    adjustIntersectingElement(array, changeStart, changeRangeOldEnd, changeRangeNewEnd, delta);
                    for (var _i = 0, array_10 = array; _i < array_10.length; _i++) {
                        var node = array_10[_i];
                        visitNode(node);
                    }
                    return;
                }
                ts.Debug.assert(fullEnd < changeStart);
            }
        }
        function extendToAffectedRange(sourceFile, changeRange) {
            var maxLookahead = 1;
            var start = changeRange.span.start;
            for (var i = 0; start > 0 && i <= maxLookahead; i++) {
                var nearestNode = findNearestNodeStartingBeforeOrAtPosition(sourceFile, start);
                ts.Debug.assert(nearestNode.pos <= start);
                var position = nearestNode.pos;
                start = Math.max(0, position - 1);
            }
            var finalSpan = ts.createTextSpanFromBounds(start, ts.textSpanEnd(changeRange.span));
            var finalLength = changeRange.newLength + (changeRange.span.start - start);
            return ts.createTextChangeRange(finalSpan, finalLength);
        }
        function findNearestNodeStartingBeforeOrAtPosition(sourceFile, position) {
            var bestResult = sourceFile;
            var lastNodeEntirelyBeforePosition;
            forEachChild(sourceFile, visit);
            if (lastNodeEntirelyBeforePosition) {
                var lastChildOfLastEntireNodeBeforePosition = getLastDescendant(lastNodeEntirelyBeforePosition);
                if (lastChildOfLastEntireNodeBeforePosition.pos > bestResult.pos) {
                    bestResult = lastChildOfLastEntireNodeBeforePosition;
                }
            }
            return bestResult;
            function getLastDescendant(node) {
                while (true) {
                    var lastChild = ts.getLastChild(node);
                    if (lastChild) {
                        node = lastChild;
                    }
                    else {
                        return node;
                    }
                }
            }
            function visit(child) {
                if (ts.nodeIsMissing(child)) {
                    return;
                }
                if (child.pos <= position) {
                    if (child.pos >= bestResult.pos) {
                        bestResult = child;
                    }
                    if (position < child.end) {
                        forEachChild(child, visit);
                        return true;
                    }
                    else {
                        ts.Debug.assert(child.end <= position);
                        lastNodeEntirelyBeforePosition = child;
                    }
                }
                else {
                    ts.Debug.assert(child.pos > position);
                    return true;
                }
            }
        }
        function checkChangeRange(sourceFile, newText, textChangeRange, aggressiveChecks) {
            var oldText = sourceFile.text;
            if (textChangeRange) {
                ts.Debug.assert((oldText.length - textChangeRange.span.length + textChangeRange.newLength) === newText.length);
                if (aggressiveChecks || ts.Debug.shouldAssert(3)) {
                    var oldTextPrefix = oldText.substr(0, textChangeRange.span.start);
                    var newTextPrefix = newText.substr(0, textChangeRange.span.start);
                    ts.Debug.assert(oldTextPrefix === newTextPrefix);
                    var oldTextSuffix = oldText.substring(ts.textSpanEnd(textChangeRange.span), oldText.length);
                    var newTextSuffix = newText.substring(ts.textSpanEnd(ts.textChangeRangeNewSpan(textChangeRange)), newText.length);
                    ts.Debug.assert(oldTextSuffix === newTextSuffix);
                }
            }
        }
        function createSyntaxCursor(sourceFile) {
            var currentArray = sourceFile.statements;
            var currentArrayIndex = 0;
            ts.Debug.assert(currentArrayIndex < currentArray.length);
            var current = currentArray[currentArrayIndex];
            var lastQueriedPosition = -1;
            return {
                currentNode: function (position) {
                    if (position !== lastQueriedPosition) {
                        if (current && current.end === position && currentArrayIndex < (currentArray.length - 1)) {
                            currentArrayIndex++;
                            current = currentArray[currentArrayIndex];
                        }
                        if (!current || current.pos !== position) {
                            findHighestListElementThatStartsAtPosition(position);
                        }
                    }
                    lastQueriedPosition = position;
                    ts.Debug.assert(!current || current.pos === position);
                    return current;
                }
            };
            function findHighestListElementThatStartsAtPosition(position) {
                currentArray = undefined;
                currentArrayIndex = -1;
                current = undefined;
                forEachChild(sourceFile, visitNode, visitArray);
                return;
                function visitNode(node) {
                    if (position >= node.pos && position < node.end) {
                        forEachChild(node, visitNode, visitArray);
                        return true;
                    }
                    return false;
                }
                function visitArray(array) {
                    if (position >= array.pos && position < array.end) {
                        for (var i = 0; i < array.length; i++) {
                            var child = array[i];
                            if (child) {
                                if (child.pos === position) {
                                    currentArray = array;
                                    currentArrayIndex = i;
                                    current = child;
                                    return true;
                                }
                                else {
                                    if (child.pos < position && position < child.end) {
                                        forEachChild(child, visitNode, visitArray);
                                        return true;
                                    }
                                }
                            }
                        }
                    }
                    return false;
                }
            }
        }
        IncrementalParser.createSyntaxCursor = createSyntaxCursor;
    })(IncrementalParser || (IncrementalParser = {}));
    function isDeclarationFileName(fileName) {
        return ts.fileExtensionIsOneOf(fileName, ts.supportedDeclarationExtensions);
    }
    ts.isDeclarationFileName = isDeclarationFileName;
    function parseResolutionMode(mode, pos, end, reportDiagnostic) {
        if (!mode) {
            return undefined;
        }
        if (mode === "import") {
            return ts.ModuleKind.ESNext;
        }
        if (mode === "require") {
            return ts.ModuleKind.CommonJS;
        }
        reportDiagnostic(pos, end - pos, ts.Diagnostics.resolution_mode_should_be_either_require_or_import);
        return undefined;
    }
    function processCommentPragmas(context, sourceText) {
        var pragmas = [];
        for (var _i = 0, _a = ts.getLeadingCommentRanges(sourceText, 0) || ts.emptyArray; _i < _a.length; _i++) {
            var range = _a[_i];
            var comment = sourceText.substring(range.pos, range.end);
            extractPragmas(pragmas, range, comment);
        }
        context.pragmas = new ts.Map();
        for (var _b = 0, pragmas_1 = pragmas; _b < pragmas_1.length; _b++) {
            var pragma = pragmas_1[_b];
            if (context.pragmas.has(pragma.name)) {
                var currentValue = context.pragmas.get(pragma.name);
                if (currentValue instanceof Array) {
                    currentValue.push(pragma.args);
                }
                else {
                    context.pragmas.set(pragma.name, [currentValue, pragma.args]);
                }
                continue;
            }
            context.pragmas.set(pragma.name, pragma.args);
        }
    }
    ts.processCommentPragmas = processCommentPragmas;
    function processPragmasIntoFields(context, reportDiagnostic) {
        context.checkJsDirective = undefined;
        context.referencedFiles = [];
        context.typeReferenceDirectives = [];
        context.libReferenceDirectives = [];
        context.amdDependencies = [];
        context.hasNoDefaultLib = false;
        context.pragmas.forEach(function (entryOrList, key) {
            switch (key) {
                case "reference": {
                    var referencedFiles_1 = context.referencedFiles;
                    var typeReferenceDirectives_1 = context.typeReferenceDirectives;
                    var libReferenceDirectives_1 = context.libReferenceDirectives;
                    ts.forEach(ts.toArray(entryOrList), function (arg) {
                        var _a = arg.arguments, types = _a.types, lib = _a.lib, path = _a.path, res = _a["resolution-mode"];
                        if (arg.arguments["no-default-lib"]) {
                            context.hasNoDefaultLib = true;
                        }
                        else if (types) {
                            var parsed = parseResolutionMode(res, types.pos, types.end, reportDiagnostic);
                            typeReferenceDirectives_1.push(__assign({ pos: types.pos, end: types.end, fileName: types.value }, (parsed ? { resolutionMode: parsed } : {})));
                        }
                        else if (lib) {
                            libReferenceDirectives_1.push({ pos: lib.pos, end: lib.end, fileName: lib.value });
                        }
                        else if (path) {
                            referencedFiles_1.push({ pos: path.pos, end: path.end, fileName: path.value });
                        }
                        else {
                            reportDiagnostic(arg.range.pos, arg.range.end - arg.range.pos, ts.Diagnostics.Invalid_reference_directive_syntax);
                        }
                    });
                    break;
                }
                case "amd-dependency": {
                    context.amdDependencies = ts.map(ts.toArray(entryOrList), function (x) { return ({ name: x.arguments.name, path: x.arguments.path }); });
                    break;
                }
                case "amd-module": {
                    if (entryOrList instanceof Array) {
                        for (var _i = 0, entryOrList_1 = entryOrList; _i < entryOrList_1.length; _i++) {
                            var entry = entryOrList_1[_i];
                            if (context.moduleName) {
                                reportDiagnostic(entry.range.pos, entry.range.end - entry.range.pos, ts.Diagnostics.An_AMD_module_cannot_have_multiple_name_assignments);
                            }
                            context.moduleName = entry.arguments.name;
                        }
                    }
                    else {
                        context.moduleName = entryOrList.arguments.name;
                    }
                    break;
                }
                case "ts-nocheck":
                case "ts-check": {
                    ts.forEach(ts.toArray(entryOrList), function (entry) {
                        if (!context.checkJsDirective || entry.range.pos > context.checkJsDirective.pos) {
                            context.checkJsDirective = {
                                enabled: key === "ts-check",
                                end: entry.range.end,
                                pos: entry.range.pos
                            };
                        }
                    });
                    break;
                }
                case "jsx":
                case "jsxfrag":
                case "jsximportsource":
                case "jsxruntime":
                    return;
                default: ts.Debug.fail("Unhandled pragma kind");
            }
        });
    }
    ts.processPragmasIntoFields = processPragmasIntoFields;
    var namedArgRegExCache = new ts.Map();
    function getNamedArgRegEx(name) {
        if (namedArgRegExCache.has(name)) {
            return namedArgRegExCache.get(name);
        }
        var result = new RegExp("(\\s".concat(name, "\\s*=\\s*)(?:(?:'([^']*)')|(?:\"([^\"]*)\"))"), "im");
        namedArgRegExCache.set(name, result);
        return result;
    }
    var tripleSlashXMLCommentStartRegEx = /^\/\/\/\s*<(\S+)\s.*?\/>/im;
    var singleLinePragmaRegEx = /^\/\/\/?\s*@(\S+)\s*(.*)\s*$/im;
    function extractPragmas(pragmas, range, text) {
        var tripleSlash = range.kind === 2 && tripleSlashXMLCommentStartRegEx.exec(text);
        if (tripleSlash) {
            var name = tripleSlash[1].toLowerCase();
            var pragma = ts.commentPragmas[name];
            if (!pragma || !(pragma.kind & 1)) {
                return;
            }
            if (pragma.args) {
                var argument = {};
                for (var _i = 0, _a = pragma.args; _i < _a.length; _i++) {
                    var arg = _a[_i];
                    var matcher = getNamedArgRegEx(arg.name);
                    var matchResult = matcher.exec(text);
                    if (!matchResult && !arg.optional) {
                        return;
                    }
                    else if (matchResult) {
                        var value = matchResult[2] || matchResult[3];
                        if (arg.captureSpan) {
                            var startPos = range.pos + matchResult.index + matchResult[1].length + 1;
                            argument[arg.name] = {
                                value: value,
                                pos: startPos,
                                end: startPos + value.length
                            };
                        }
                        else {
                            argument[arg.name] = value;
                        }
                    }
                }
                pragmas.push({ name: name, args: { arguments: argument, range: range } });
            }
            else {
                pragmas.push({ name: name, args: { arguments: {}, range: range } });
            }
            return;
        }
        var singleLine = range.kind === 2 && singleLinePragmaRegEx.exec(text);
        if (singleLine) {
            return addPragmaForMatch(pragmas, range, 2, singleLine);
        }
        if (range.kind === 3) {
            var multiLinePragmaRegEx = /@(\S+)(\s+.*)?$/gim;
            var multiLineMatch = void 0;
            while (multiLineMatch = multiLinePragmaRegEx.exec(text)) {
                addPragmaForMatch(pragmas, range, 4, multiLineMatch);
            }
        }
    }
    function addPragmaForMatch(pragmas, range, kind, match) {
        if (!match)
            return;
        var name = match[1].toLowerCase();
        var pragma = ts.commentPragmas[name];
        if (!pragma || !(pragma.kind & kind)) {
            return;
        }
        var args = match[2];
        var argument = getNamedPragmaArguments(pragma, args);
        if (argument === "fail")
            return;
        pragmas.push({ name: name, args: { arguments: argument, range: range } });
        return;
    }
    function getNamedPragmaArguments(pragma, text) {
        if (!text)
            return {};
        if (!pragma.args)
            return {};
        var args = ts.trimString(text).split(/\s+/);
        var argMap = {};
        for (var i = 0; i < pragma.args.length; i++) {
            var argument = pragma.args[i];
            if (!args[i] && !argument.optional) {
                return "fail";
            }
            if (argument.captureSpan) {
                return ts.Debug.fail("Capture spans not yet implemented for non-xml pragmas");
            }
            argMap[argument.name] = args[i];
        }
        return argMap;
    }
    function tagNamesAreEquivalent(lhs, rhs) {
        if (lhs.kind !== rhs.kind) {
            return false;
        }
        if (lhs.kind === 79) {
            return lhs.escapedText === rhs.escapedText;
        }
        if (lhs.kind === 108) {
            return true;
        }
        return lhs.name.escapedText === rhs.name.escapedText &&
            tagNamesAreEquivalent(lhs.expression, rhs.expression);
    }
    ts.tagNamesAreEquivalent = tagNamesAreEquivalent;
})(ts || (ts = {}));
var ts;
(function (ts) {
    ts.compileOnSaveCommandLineOption = {
        name: "compileOnSave",
        type: "boolean",
        defaultValueDescription: false,
    };
    var jsxOptionMap = new ts.Map(ts.getEntries({
        "preserve": 1,
        "react-native": 3,
        "react": 2,
        "react-jsx": 4,
        "react-jsxdev": 5,
    }));
    ts.inverseJsxOptionMap = new ts.Map(ts.arrayFrom(ts.mapIterator(jsxOptionMap.entries(), function (_a) {
        var key = _a[0], value = _a[1];
        return ["" + value, key];
    })));
    var libEntries = [
        ["es5", "lib.es5.d.ts"],
        ["es6", "lib.es2015.d.ts"],
        ["es2015", "lib.es2015.d.ts"],
        ["es7", "lib.es2016.d.ts"],
        ["es2016", "lib.es2016.d.ts"],
        ["es2017", "lib.es2017.d.ts"],
        ["es2018", "lib.es2018.d.ts"],
        ["es2019", "lib.es2019.d.ts"],
        ["es2020", "lib.es2020.d.ts"],
        ["es2021", "lib.es2021.d.ts"],
        ["es2022", "lib.es2022.d.ts"],
        ["esnext", "lib.esnext.d.ts"],
        ["dom", "lib.dom.d.ts"],
        ["dom.iterable", "lib.dom.iterable.d.ts"],
        ["webworker", "lib.webworker.d.ts"],
        ["webworker.importscripts", "lib.webworker.importscripts.d.ts"],
        ["webworker.iterable", "lib.webworker.iterable.d.ts"],
        ["scripthost", "lib.scripthost.d.ts"],
        ["es2015.core", "lib.es2015.core.d.ts"],
        ["es2015.collection", "lib.es2015.collection.d.ts"],
        ["es2015.generator", "lib.es2015.generator.d.ts"],
        ["es2015.iterable", "lib.es2015.iterable.d.ts"],
        ["es2015.promise", "lib.es2015.promise.d.ts"],
        ["es2015.proxy", "lib.es2015.proxy.d.ts"],
        ["es2015.reflect", "lib.es2015.reflect.d.ts"],
        ["es2015.symbol", "lib.es2015.symbol.d.ts"],
        ["es2015.symbol.wellknown", "lib.es2015.symbol.wellknown.d.ts"],
        ["es2016.array.include", "lib.es2016.array.include.d.ts"],
        ["es2017.object", "lib.es2017.object.d.ts"],
        ["es2017.sharedmemory", "lib.es2017.sharedmemory.d.ts"],
        ["es2017.string", "lib.es2017.string.d.ts"],
        ["es2017.intl", "lib.es2017.intl.d.ts"],
        ["es2017.typedarrays", "lib.es2017.typedarrays.d.ts"],
        ["es2018.asyncgenerator", "lib.es2018.asyncgenerator.d.ts"],
        ["es2018.asynciterable", "lib.es2018.asynciterable.d.ts"],
        ["es2018.intl", "lib.es2018.intl.d.ts"],
        ["es2018.promise", "lib.es2018.promise.d.ts"],
        ["es2018.regexp", "lib.es2018.regexp.d.ts"],
        ["es2019.array", "lib.es2019.array.d.ts"],
        ["es2019.object", "lib.es2019.object.d.ts"],
        ["es2019.string", "lib.es2019.string.d.ts"],
        ["es2019.symbol", "lib.es2019.symbol.d.ts"],
        ["es2020.bigint", "lib.es2020.bigint.d.ts"],
        ["es2020.date", "lib.es2020.date.d.ts"],
        ["es2020.promise", "lib.es2020.promise.d.ts"],
        ["es2020.sharedmemory", "lib.es2020.sharedmemory.d.ts"],
        ["es2020.string", "lib.es2020.string.d.ts"],
        ["es2020.symbol.wellknown", "lib.es2020.symbol.wellknown.d.ts"],
        ["es2020.intl", "lib.es2020.intl.d.ts"],
        ["es2020.number", "lib.es2020.number.d.ts"],
        ["es2021.promise", "lib.es2021.promise.d.ts"],
        ["es2021.string", "lib.es2021.string.d.ts"],
        ["es2021.weakref", "lib.es2021.weakref.d.ts"],
        ["es2021.intl", "lib.es2021.intl.d.ts"],
        ["es2022.array", "lib.es2022.array.d.ts"],
        ["es2022.error", "lib.es2022.error.d.ts"],
        ["es2022.intl", "lib.es2022.intl.d.ts"],
        ["es2022.object", "lib.es2022.object.d.ts"],
        ["es2022.string", "lib.es2022.string.d.ts"],
        ["esnext.array", "lib.es2022.array.d.ts"],
        ["esnext.symbol", "lib.es2019.symbol.d.ts"],
        ["esnext.asynciterable", "lib.es2018.asynciterable.d.ts"],
        ["esnext.intl", "lib.esnext.intl.d.ts"],
        ["esnext.bigint", "lib.es2020.bigint.d.ts"],
        ["esnext.string", "lib.es2022.string.d.ts"],
        ["esnext.promise", "lib.es2021.promise.d.ts"],
        ["esnext.weakref", "lib.es2021.weakref.d.ts"]
    ];
    ts.libs = libEntries.map(function (entry) { return entry[0]; });
    ts.libMap = new ts.Map(libEntries);
    ts.optionsForWatch = [
        {
            name: "watchFile",
            type: new ts.Map(ts.getEntries({
                fixedpollinginterval: ts.WatchFileKind.FixedPollingInterval,
                prioritypollinginterval: ts.WatchFileKind.PriorityPollingInterval,
                dynamicprioritypolling: ts.WatchFileKind.DynamicPriorityPolling,
                fixedchunksizepolling: ts.WatchFileKind.FixedChunkSizePolling,
                usefsevents: ts.WatchFileKind.UseFsEvents,
                usefseventsonparentdirectory: ts.WatchFileKind.UseFsEventsOnParentDirectory,
            })),
            category: ts.Diagnostics.Watch_and_Build_Modes,
            description: ts.Diagnostics.Specify_how_the_TypeScript_watch_mode_works,
            defaultValueDescription: ts.WatchFileKind.UseFsEvents,
        },
        {
            name: "watchDirectory",
            type: new ts.Map(ts.getEntries({
                usefsevents: ts.WatchDirectoryKind.UseFsEvents,
                fixedpollinginterval: ts.WatchDirectoryKind.FixedPollingInterval,
                dynamicprioritypolling: ts.WatchDirectoryKind.DynamicPriorityPolling,
                fixedchunksizepolling: ts.WatchDirectoryKind.FixedChunkSizePolling,
            })),
            category: ts.Diagnostics.Watch_and_Build_Modes,
            description: ts.Diagnostics.Specify_how_directories_are_watched_on_systems_that_lack_recursive_file_watching_functionality,
            defaultValueDescription: ts.WatchDirectoryKind.UseFsEvents,
        },
        {
            name: "fallbackPolling",
            type: new ts.Map(ts.getEntries({
                fixedinterval: ts.PollingWatchKind.FixedInterval,
                priorityinterval: ts.PollingWatchKind.PriorityInterval,
                dynamicpriority: ts.PollingWatchKind.DynamicPriority,
                fixedchunksize: ts.PollingWatchKind.FixedChunkSize,
            })),
            category: ts.Diagnostics.Watch_and_Build_Modes,
            description: ts.Diagnostics.Specify_what_approach_the_watcher_should_use_if_the_system_runs_out_of_native_file_watchers,
            defaultValueDescription: ts.PollingWatchKind.PriorityInterval,
        },
        {
            name: "synchronousWatchDirectory",
            type: "boolean",
            category: ts.Diagnostics.Watch_and_Build_Modes,
            description: ts.Diagnostics.Synchronously_call_callbacks_and_update_the_state_of_directory_watchers_on_platforms_that_don_t_support_recursive_watching_natively,
            defaultValueDescription: false,
        },
        {
            name: "excludeDirectories",
            type: "list",
            element: {
                name: "excludeDirectory",
                type: "string",
                isFilePath: true,
                extraValidation: specToDiagnostic
            },
            category: ts.Diagnostics.Watch_and_Build_Modes,
            description: ts.Diagnostics.Remove_a_list_of_directories_from_the_watch_process,
        },
        {
            name: "excludeFiles",
            type: "list",
            element: {
                name: "excludeFile",
                type: "string",
                isFilePath: true,
                extraValidation: specToDiagnostic
            },
            category: ts.Diagnostics.Watch_and_Build_Modes,
            description: ts.Diagnostics.Remove_a_list_of_files_from_the_watch_mode_s_processing,
        },
    ];
    ts.commonOptionsWithBuild = [
        {
            name: "help",
            shortName: "h",
            type: "boolean",
            showInSimplifiedHelpView: true,
            category: ts.Diagnostics.Command_line_Options,
            description: ts.Diagnostics.Print_this_message,
            defaultValueDescription: false,
        },
        {
            name: "help",
            shortName: "?",
            type: "boolean",
            defaultValueDescription: false,
        },
        {
            name: "watch",
            shortName: "w",
            type: "boolean",
            showInSimplifiedHelpView: true,
            isCommandLineOnly: true,
            category: ts.Diagnostics.Command_line_Options,
            description: ts.Diagnostics.Watch_input_files,
            defaultValueDescription: false,
        },
        {
            name: "preserveWatchOutput",
            type: "boolean",
            showInSimplifiedHelpView: false,
            category: ts.Diagnostics.Output_Formatting,
            description: ts.Diagnostics.Disable_wiping_the_console_in_watch_mode,
            defaultValueDescription: false,
        },
        {
            name: "listFiles",
            type: "boolean",
            category: ts.Diagnostics.Compiler_Diagnostics,
            description: ts.Diagnostics.Print_all_of_the_files_read_during_the_compilation,
            defaultValueDescription: false,
        },
        {
            name: "explainFiles",
            type: "boolean",
            category: ts.Diagnostics.Compiler_Diagnostics,
            description: ts.Diagnostics.Print_files_read_during_the_compilation_including_why_it_was_included,
            defaultValueDescription: false,
        },
        {
            name: "listEmittedFiles",
            type: "boolean",
            category: ts.Diagnostics.Compiler_Diagnostics,
            description: ts.Diagnostics.Print_the_names_of_emitted_files_after_a_compilation,
            defaultValueDescription: false,
        },
        {
            name: "pretty",
            type: "boolean",
            showInSimplifiedHelpView: true,
            category: ts.Diagnostics.Output_Formatting,
            description: ts.Diagnostics.Enable_color_and_formatting_in_TypeScript_s_output_to_make_compiler_errors_easier_to_read,
            defaultValueDescription: true,
        },
        {
            name: "traceResolution",
            type: "boolean",
            category: ts.Diagnostics.Compiler_Diagnostics,
            description: ts.Diagnostics.Log_paths_used_during_the_moduleResolution_process,
            defaultValueDescription: false,
        },
        {
            name: "diagnostics",
            type: "boolean",
            category: ts.Diagnostics.Compiler_Diagnostics,
            description: ts.Diagnostics.Output_compiler_performance_information_after_building,
            defaultValueDescription: false,
        },
        {
            name: "extendedDiagnostics",
            type: "boolean",
            category: ts.Diagnostics.Compiler_Diagnostics,
            description: ts.Diagnostics.Output_more_detailed_compiler_performance_information_after_building,
            defaultValueDescription: false,
        },
        {
            name: "generateCpuProfile",
            type: "string",
            isFilePath: true,
            paramType: ts.Diagnostics.FILE_OR_DIRECTORY,
            category: ts.Diagnostics.Compiler_Diagnostics,
            description: ts.Diagnostics.Emit_a_v8_CPU_profile_of_the_compiler_run_for_debugging,
            defaultValueDescription: "profile.cpuprofile"
        },
        {
            name: "generateTrace",
            type: "string",
            isFilePath: true,
            isCommandLineOnly: true,
            paramType: ts.Diagnostics.DIRECTORY,
            category: ts.Diagnostics.Compiler_Diagnostics,
            description: ts.Diagnostics.Generates_an_event_trace_and_a_list_of_types
        },
        {
            name: "incremental",
            shortName: "i",
            type: "boolean",
            category: ts.Diagnostics.Projects,
            description: ts.Diagnostics.Save_tsbuildinfo_files_to_allow_for_incremental_compilation_of_projects,
            transpileOptionValue: undefined,
            defaultValueDescription: ts.Diagnostics.false_unless_composite_is_set
        },
        {
            name: "assumeChangesOnlyAffectDirectDependencies",
            type: "boolean",
            affectsSemanticDiagnostics: true,
            affectsEmit: true,
            category: ts.Diagnostics.Watch_and_Build_Modes,
            description: ts.Diagnostics.Have_recompiles_in_projects_that_use_incremental_and_watch_mode_assume_that_changes_within_a_file_will_only_affect_files_directly_depending_on_it,
            defaultValueDescription: false,
        },
        {
            name: "locale",
            type: "string",
            category: ts.Diagnostics.Command_line_Options,
            isCommandLineOnly: true,
            description: ts.Diagnostics.Set_the_language_of_the_messaging_from_TypeScript_This_does_not_affect_emit,
            defaultValueDescription: ts.Diagnostics.Platform_specific
        },
    ];
    ts.targetOptionDeclaration = {
        name: "target",
        shortName: "t",
        type: new ts.Map(ts.getEntries({
            es3: 0,
            es5: 1,
            es6: 2,
            es2015: 2,
            es2016: 3,
            es2017: 4,
            es2018: 5,
            es2019: 6,
            es2020: 7,
            es2021: 8,
            es2022: 9,
            esnext: 99,
        })),
        affectsSourceFile: true,
        affectsModuleResolution: true,
        affectsEmit: true,
        paramType: ts.Diagnostics.VERSION,
        showInSimplifiedHelpView: true,
        category: ts.Diagnostics.Language_and_Environment,
        description: ts.Diagnostics.Set_the_JavaScript_language_version_for_emitted_JavaScript_and_include_compatible_library_declarations,
        defaultValueDescription: 0,
    };
    var commandOptionsWithoutBuild = [
        {
            name: "all",
            type: "boolean",
            showInSimplifiedHelpView: true,
            category: ts.Diagnostics.Command_line_Options,
            description: ts.Diagnostics.Show_all_compiler_options,
            defaultValueDescription: false,
        },
        {
            name: "version",
            shortName: "v",
            type: "boolean",
            showInSimplifiedHelpView: true,
            category: ts.Diagnostics.Command_line_Options,
            description: ts.Diagnostics.Print_the_compiler_s_version,
            defaultValueDescription: false,
        },
        {
            name: "init",
            type: "boolean",
            showInSimplifiedHelpView: true,
            category: ts.Diagnostics.Command_line_Options,
            description: ts.Diagnostics.Initializes_a_TypeScript_project_and_creates_a_tsconfig_json_file,
            defaultValueDescription: false,
        },
        {
            name: "project",
            shortName: "p",
            type: "string",
            isFilePath: true,
            showInSimplifiedHelpView: true,
            category: ts.Diagnostics.Command_line_Options,
            paramType: ts.Diagnostics.FILE_OR_DIRECTORY,
            description: ts.Diagnostics.Compile_the_project_given_the_path_to_its_configuration_file_or_to_a_folder_with_a_tsconfig_json,
        },
        {
            name: "build",
            type: "boolean",
            shortName: "b",
            showInSimplifiedHelpView: true,
            category: ts.Diagnostics.Command_line_Options,
            description: ts.Diagnostics.Build_one_or_more_projects_and_their_dependencies_if_out_of_date,
            defaultValueDescription: false,
        },
        {
            name: "showConfig",
            type: "boolean",
            showInSimplifiedHelpView: true,
            category: ts.Diagnostics.Command_line_Options,
            isCommandLineOnly: true,
            description: ts.Diagnostics.Print_the_final_configuration_instead_of_building,
            defaultValueDescription: false,
        },
        {
            name: "listFilesOnly",
            type: "boolean",
            category: ts.Diagnostics.Command_line_Options,
            affectsSemanticDiagnostics: true,
            affectsEmit: true,
            isCommandLineOnly: true,
            description: ts.Diagnostics.Print_names_of_files_that_are_part_of_the_compilation_and_then_stop_processing,
            defaultValueDescription: false,
        },
        ts.targetOptionDeclaration,
        {
            name: "module",
            shortName: "m",
            type: new ts.Map(ts.getEntries({
                none: ts.ModuleKind.None,
                commonjs: ts.ModuleKind.CommonJS,
                amd: ts.ModuleKind.AMD,
                system: ts.ModuleKind.System,
                umd: ts.ModuleKind.UMD,
                es6: ts.ModuleKind.ES2015,
                es2015: ts.ModuleKind.ES2015,
                es2020: ts.ModuleKind.ES2020,
                es2022: ts.ModuleKind.ES2022,
                esnext: ts.ModuleKind.ESNext,
                node16: ts.ModuleKind.Node16,
                nodenext: ts.ModuleKind.NodeNext,
            })),
            affectsModuleResolution: true,
            affectsEmit: true,
            paramType: ts.Diagnostics.KIND,
            showInSimplifiedHelpView: true,
            category: ts.Diagnostics.Modules,
            description: ts.Diagnostics.Specify_what_module_code_is_generated,
            defaultValueDescription: undefined,
        },
        {
            name: "lib",
            type: "list",
            element: {
                name: "lib",
                type: ts.libMap,
                defaultValueDescription: undefined,
            },
            affectsProgramStructure: true,
            showInSimplifiedHelpView: true,
            category: ts.Diagnostics.Language_and_Environment,
            description: ts.Diagnostics.Specify_a_set_of_bundled_library_declaration_files_that_describe_the_target_runtime_environment,
            transpileOptionValue: undefined
        },
        {
            name: "allowJs",
            type: "boolean",
            affectsModuleResolution: true,
            showInSimplifiedHelpView: true,
            category: ts.Diagnostics.JavaScript_Support,
            description: ts.Diagnostics.Allow_JavaScript_files_to_be_a_part_of_your_program_Use_the_checkJS_option_to_get_errors_from_these_files,
            defaultValueDescription: false,
        },
        {
            name: "checkJs",
            type: "boolean",
            showInSimplifiedHelpView: true,
            category: ts.Diagnostics.JavaScript_Support,
            description: ts.Diagnostics.Enable_error_reporting_in_type_checked_JavaScript_files,
            defaultValueDescription: false,
        },
        {
            name: "jsx",
            type: jsxOptionMap,
            affectsSourceFile: true,
            affectsEmit: true,
            affectsModuleResolution: true,
            paramType: ts.Diagnostics.KIND,
            showInSimplifiedHelpView: true,
            category: ts.Diagnostics.Language_and_Environment,
            description: ts.Diagnostics.Specify_what_JSX_code_is_generated,
            defaultValueDescription: undefined,
        },
        {
            name: "declaration",
            shortName: "d",
            type: "boolean",
            affectsEmit: true,
            showInSimplifiedHelpView: true,
            category: ts.Diagnostics.Emit,
            transpileOptionValue: undefined,
            description: ts.Diagnostics.Generate_d_ts_files_from_TypeScript_and_JavaScript_files_in_your_project,
            defaultValueDescription: ts.Diagnostics.false_unless_composite_is_set,
        },
        {
            name: "declarationMap",
            type: "boolean",
            affectsEmit: true,
            showInSimplifiedHelpView: true,
            category: ts.Diagnostics.Emit,
            transpileOptionValue: undefined,
            defaultValueDescription: false,
            description: ts.Diagnostics.Create_sourcemaps_for_d_ts_files
        },
        {
            name: "emitDeclarationOnly",
            type: "boolean",
            affectsEmit: true,
            showInSimplifiedHelpView: true,
            category: ts.Diagnostics.Emit,
            description: ts.Diagnostics.Only_output_d_ts_files_and_not_JavaScript_files,
            transpileOptionValue: undefined,
            defaultValueDescription: false,
        },
        {
            name: "sourceMap",
            type: "boolean",
            affectsEmit: true,
            showInSimplifiedHelpView: true,
            category: ts.Diagnostics.Emit,
            defaultValueDescription: false,
            description: ts.Diagnostics.Create_source_map_files_for_emitted_JavaScript_files,
        },
        {
            name: "outFile",
            type: "string",
            affectsEmit: true,
            isFilePath: true,
            paramType: ts.Diagnostics.FILE,
            showInSimplifiedHelpView: true,
            category: ts.Diagnostics.Emit,
            description: ts.Diagnostics.Specify_a_file_that_bundles_all_outputs_into_one_JavaScript_file_If_declaration_is_true_also_designates_a_file_that_bundles_all_d_ts_output,
            transpileOptionValue: undefined,
        },
        {
            name: "outDir",
            type: "string",
            affectsEmit: true,
            isFilePath: true,
            paramType: ts.Diagnostics.DIRECTORY,
            showInSimplifiedHelpView: true,
            category: ts.Diagnostics.Emit,
            description: ts.Diagnostics.Specify_an_output_folder_for_all_emitted_files,
        },
        {
            name: "rootDir",
            type: "string",
            affectsEmit: true,
            isFilePath: true,
            paramType: ts.Diagnostics.LOCATION,
            category: ts.Diagnostics.Modules,
            description: ts.Diagnostics.Specify_the_root_folder_within_your_source_files,
            defaultValueDescription: ts.Diagnostics.Computed_from_the_list_of_input_files
        },
        {
            name: "composite",
            type: "boolean",
            affectsEmit: true,
            isTSConfigOnly: true,
            category: ts.Diagnostics.Projects,
            transpileOptionValue: undefined,
            defaultValueDescription: false,
            description: ts.Diagnostics.Enable_constraints_that_allow_a_TypeScript_project_to_be_used_with_project_references,
        },
        {
            name: "tsBuildInfoFile",
            type: "string",
            affectsEmit: true,
            isFilePath: true,
            paramType: ts.Diagnostics.FILE,
            category: ts.Diagnostics.Projects,
            transpileOptionValue: undefined,
            defaultValueDescription: ".tsbuildinfo",
            description: ts.Diagnostics.Specify_the_path_to_tsbuildinfo_incremental_compilation_file,
        },
        {
            name: "removeComments",
            type: "boolean",
            affectsEmit: true,
            showInSimplifiedHelpView: true,
            category: ts.Diagnostics.Emit,
            defaultValueDescription: false,
            description: ts.Diagnostics.Disable_emitting_comments,
        },
        {
            name: "noEmit",
            type: "boolean",
            showInSimplifiedHelpView: true,
            category: ts.Diagnostics.Emit,
            description: ts.Diagnostics.Disable_emitting_files_from_a_compilation,
            transpileOptionValue: undefined,
            defaultValueDescription: false,
        },
        {
            name: "importHelpers",
            type: "boolean",
            affectsEmit: true,
            category: ts.Diagnostics.Emit,
            description: ts.Diagnostics.Allow_importing_helper_functions_from_tslib_once_per_project_instead_of_including_them_per_file,
            defaultValueDescription: false,
        },
        {
            name: "importsNotUsedAsValues",
            type: new ts.Map(ts.getEntries({
                remove: 0,
                preserve: 1,
                error: 2,
            })),
            affectsEmit: true,
            affectsSemanticDiagnostics: true,
            category: ts.Diagnostics.Emit,
            description: ts.Diagnostics.Specify_emit_Slashchecking_behavior_for_imports_that_are_only_used_for_types,
            defaultValueDescription: 0,
        },
        {
            name: "downlevelIteration",
            type: "boolean",
            affectsEmit: true,
            category: ts.Diagnostics.Emit,
            description: ts.Diagnostics.Emit_more_compliant_but_verbose_and_less_performant_JavaScript_for_iteration,
            defaultValueDescription: false,
        },
        {
            name: "isolatedModules",
            type: "boolean",
            category: ts.Diagnostics.Interop_Constraints,
            description: ts.Diagnostics.Ensure_that_each_file_can_be_safely_transpiled_without_relying_on_other_imports,
            transpileOptionValue: true,
            defaultValueDescription: false,
        },
        {
            name: "strict",
            type: "boolean",
            showInSimplifiedHelpView: true,
            category: ts.Diagnostics.Type_Checking,
            description: ts.Diagnostics.Enable_all_strict_type_checking_options,
            defaultValueDescription: false,
        },
        {
            name: "noImplicitAny",
            type: "boolean",
            affectsSemanticDiagnostics: true,
            strictFlag: true,
            category: ts.Diagnostics.Type_Checking,
            description: ts.Diagnostics.Enable_error_reporting_for_expressions_and_declarations_with_an_implied_any_type,
            defaultValueDescription: ts.Diagnostics.false_unless_strict_is_set
        },
        {
            name: "strictNullChecks",
            type: "boolean",
            affectsSemanticDiagnostics: true,
            strictFlag: true,
            category: ts.Diagnostics.Type_Checking,
            description: ts.Diagnostics.When_type_checking_take_into_account_null_and_undefined,
            defaultValueDescription: ts.Diagnostics.false_unless_strict_is_set
        },
        {
            name: "strictFunctionTypes",
            type: "boolean",
            strictFlag: true,
            category: ts.Diagnostics.Type_Checking,
            description: ts.Diagnostics.When_assigning_functions_check_to_ensure_parameters_and_the_return_values_are_subtype_compatible,
            defaultValueDescription: ts.Diagnostics.false_unless_strict_is_set
        },
        {
            name: "strictBindCallApply",
            type: "boolean",
            strictFlag: true,
            category: ts.Diagnostics.Type_Checking,
            description: ts.Diagnostics.Check_that_the_arguments_for_bind_call_and_apply_methods_match_the_original_function,
            defaultValueDescription: ts.Diagnostics.false_unless_strict_is_set
        },
        {
            name: "strictPropertyInitialization",
            type: "boolean",
            affectsSemanticDiagnostics: true,
            strictFlag: true,
            category: ts.Diagnostics.Type_Checking,
            description: ts.Diagnostics.Check_for_class_properties_that_are_declared_but_not_set_in_the_constructor,
            defaultValueDescription: ts.Diagnostics.false_unless_strict_is_set
        },
        {
            name: "noImplicitThis",
            type: "boolean",
            affectsSemanticDiagnostics: true,
            strictFlag: true,
            category: ts.Diagnostics.Type_Checking,
            description: ts.Diagnostics.Enable_error_reporting_when_this_is_given_the_type_any,
            defaultValueDescription: ts.Diagnostics.false_unless_strict_is_set
        },
        {
            name: "useUnknownInCatchVariables",
            type: "boolean",
            affectsSemanticDiagnostics: true,
            strictFlag: true,
            category: ts.Diagnostics.Type_Checking,
            description: ts.Diagnostics.Default_catch_clause_variables_as_unknown_instead_of_any,
            defaultValueDescription: false,
        },
        {
            name: "alwaysStrict",
            type: "boolean",
            affectsSourceFile: true,
            strictFlag: true,
            category: ts.Diagnostics.Type_Checking,
            description: ts.Diagnostics.Ensure_use_strict_is_always_emitted,
            defaultValueDescription: ts.Diagnostics.false_unless_strict_is_set
        },
        {
            name: "noUnusedLocals",
            type: "boolean",
            affectsSemanticDiagnostics: true,
            category: ts.Diagnostics.Type_Checking,
            description: ts.Diagnostics.Enable_error_reporting_when_local_variables_aren_t_read,
            defaultValueDescription: false,
        },
        {
            name: "noUnusedParameters",
            type: "boolean",
            affectsSemanticDiagnostics: true,
            category: ts.Diagnostics.Type_Checking,
            description: ts.Diagnostics.Raise_an_error_when_a_function_parameter_isn_t_read,
            defaultValueDescription: false,
        },
        {
            name: "exactOptionalPropertyTypes",
            type: "boolean",
            affectsSemanticDiagnostics: true,
            category: ts.Diagnostics.Type_Checking,
            description: ts.Diagnostics.Interpret_optional_property_types_as_written_rather_than_adding_undefined,
            defaultValueDescription: false,
        },
        {
            name: "noImplicitReturns",
            type: "boolean",
            affectsSemanticDiagnostics: true,
            category: ts.Diagnostics.Type_Checking,
            description: ts.Diagnostics.Enable_error_reporting_for_codepaths_that_do_not_explicitly_return_in_a_function,
            defaultValueDescription: false,
        },
        {
            name: "noFallthroughCasesInSwitch",
            type: "boolean",
            affectsBindDiagnostics: true,
            affectsSemanticDiagnostics: true,
            category: ts.Diagnostics.Type_Checking,
            description: ts.Diagnostics.Enable_error_reporting_for_fallthrough_cases_in_switch_statements,
            defaultValueDescription: false,
        },
        {
            name: "noUncheckedIndexedAccess",
            type: "boolean",
            affectsSemanticDiagnostics: true,
            category: ts.Diagnostics.Type_Checking,
            description: ts.Diagnostics.Add_undefined_to_a_type_when_accessed_using_an_index,
            defaultValueDescription: false,
        },
        {
            name: "noImplicitOverride",
            type: "boolean",
            affectsSemanticDiagnostics: true,
            category: ts.Diagnostics.Type_Checking,
            description: ts.Diagnostics.Ensure_overriding_members_in_derived_classes_are_marked_with_an_override_modifier,
            defaultValueDescription: false,
        },
        {
            name: "noPropertyAccessFromIndexSignature",
            type: "boolean",
            showInSimplifiedHelpView: false,
            category: ts.Diagnostics.Type_Checking,
            description: ts.Diagnostics.Enforces_using_indexed_accessors_for_keys_declared_using_an_indexed_type,
            defaultValueDescription: false,
        },
        {
            name: "moduleResolution",
            type: new ts.Map(ts.getEntries({
                node: ts.ModuleResolutionKind.NodeJs,
                classic: ts.ModuleResolutionKind.Classic,
                node16: ts.ModuleResolutionKind.Node16,
                nodenext: ts.ModuleResolutionKind.NodeNext,
            })),
            affectsModuleResolution: true,
            paramType: ts.Diagnostics.STRATEGY,
            category: ts.Diagnostics.Modules,
            description: ts.Diagnostics.Specify_how_TypeScript_looks_up_a_file_from_a_given_module_specifier,
            defaultValueDescription: ts.Diagnostics.module_AMD_or_UMD_or_System_or_ES6_then_Classic_Otherwise_Node
        },
        {
            name: "baseUrl",
            type: "string",
            affectsModuleResolution: true,
            isFilePath: true,
            category: ts.Diagnostics.Modules,
            description: ts.Diagnostics.Specify_the_base_directory_to_resolve_non_relative_module_names
        },
        {
            name: "paths",
            type: "object",
            affectsModuleResolution: true,
            isTSConfigOnly: true,
            category: ts.Diagnostics.Modules,
            description: ts.Diagnostics.Specify_a_set_of_entries_that_re_map_imports_to_additional_lookup_locations,
            transpileOptionValue: undefined
        },
        {
            name: "rootDirs",
            type: "list",
            isTSConfigOnly: true,
            element: {
                name: "rootDirs",
                type: "string",
                isFilePath: true
            },
            affectsModuleResolution: true,
            category: ts.Diagnostics.Modules,
            description: ts.Diagnostics.Allow_multiple_folders_to_be_treated_as_one_when_resolving_modules,
            transpileOptionValue: undefined,
            defaultValueDescription: ts.Diagnostics.Computed_from_the_list_of_input_files
        },
        {
            name: "typeRoots",
            type: "list",
            element: {
                name: "typeRoots",
                type: "string",
                isFilePath: true
            },
            affectsModuleResolution: true,
            category: ts.Diagnostics.Modules,
            description: ts.Diagnostics.Specify_multiple_folders_that_act_like_Slashnode_modules_Slash_types
        },
        {
            name: "types",
            type: "list",
            element: {
                name: "types",
                type: "string"
            },
            affectsProgramStructure: true,
            showInSimplifiedHelpView: true,
            category: ts.Diagnostics.Modules,
            description: ts.Diagnostics.Specify_type_package_names_to_be_included_without_being_referenced_in_a_source_file,
            transpileOptionValue: undefined
        },
        {
            name: "allowSyntheticDefaultImports",
            type: "boolean",
            affectsSemanticDiagnostics: true,
            category: ts.Diagnostics.Interop_Constraints,
            description: ts.Diagnostics.Allow_import_x_from_y_when_a_module_doesn_t_have_a_default_export,
            defaultValueDescription: ts.Diagnostics.module_system_or_esModuleInterop
        },
        {
            name: "esModuleInterop",
            type: "boolean",
            affectsSemanticDiagnostics: true,
            affectsEmit: true,
            showInSimplifiedHelpView: true,
            category: ts.Diagnostics.Interop_Constraints,
            description: ts.Diagnostics.Emit_additional_JavaScript_to_ease_support_for_importing_CommonJS_modules_This_enables_allowSyntheticDefaultImports_for_type_compatibility,
            defaultValueDescription: false,
        },
        {
            name: "preserveSymlinks",
            type: "boolean",
            category: ts.Diagnostics.Interop_Constraints,
            description: ts.Diagnostics.Disable_resolving_symlinks_to_their_realpath_This_correlates_to_the_same_flag_in_node,
            defaultValueDescription: false,
        },
        {
            name: "allowUmdGlobalAccess",
            type: "boolean",
            affectsSemanticDiagnostics: true,
            category: ts.Diagnostics.Modules,
            description: ts.Diagnostics.Allow_accessing_UMD_globals_from_modules,
            defaultValueDescription: false,
        },
        {
            name: "moduleSuffixes",
            type: "list",
            element: {
                name: "suffix",
                type: "string",
            },
            listPreserveFalsyValues: true,
            affectsModuleResolution: true,
            category: ts.Diagnostics.Modules,
            description: ts.Diagnostics.List_of_file_name_suffixes_to_search_when_resolving_a_module,
        },
        {
            name: "sourceRoot",
            type: "string",
            affectsEmit: true,
            paramType: ts.Diagnostics.LOCATION,
            category: ts.Diagnostics.Emit,
            description: ts.Diagnostics.Specify_the_root_path_for_debuggers_to_find_the_reference_source_code,
        },
        {
            name: "mapRoot",
            type: "string",
            affectsEmit: true,
            paramType: ts.Diagnostics.LOCATION,
            category: ts.Diagnostics.Emit,
            description: ts.Diagnostics.Specify_the_location_where_debugger_should_locate_map_files_instead_of_generated_locations,
        },
        {
            name: "inlineSourceMap",
            type: "boolean",
            affectsEmit: true,
            category: ts.Diagnostics.Emit,
            description: ts.Diagnostics.Include_sourcemap_files_inside_the_emitted_JavaScript,
            defaultValueDescription: false,
        },
        {
            name: "inlineSources",
            type: "boolean",
            affectsEmit: true,
            category: ts.Diagnostics.Emit,
            description: ts.Diagnostics.Include_source_code_in_the_sourcemaps_inside_the_emitted_JavaScript,
            defaultValueDescription: false,
        },
        {
            name: "experimentalDecorators",
            type: "boolean",
            affectsSemanticDiagnostics: true,
            category: ts.Diagnostics.Language_and_Environment,
            description: ts.Diagnostics.Enable_experimental_support_for_TC39_stage_2_draft_decorators,
            defaultValueDescription: false,
        },
        {
            name: "emitDecoratorMetadata",
            type: "boolean",
            affectsSemanticDiagnostics: true,
            affectsEmit: true,
            category: ts.Diagnostics.Language_and_Environment,
            description: ts.Diagnostics.Emit_design_type_metadata_for_decorated_declarations_in_source_files,
            defaultValueDescription: false,
        },
        {
            name: "jsxFactory",
            type: "string",
            category: ts.Diagnostics.Language_and_Environment,
            description: ts.Diagnostics.Specify_the_JSX_factory_function_used_when_targeting_React_JSX_emit_e_g_React_createElement_or_h,
            defaultValueDescription: "`React.createElement`"
        },
        {
            name: "jsxFragmentFactory",
            type: "string",
            category: ts.Diagnostics.Language_and_Environment,
            description: ts.Diagnostics.Specify_the_JSX_Fragment_reference_used_for_fragments_when_targeting_React_JSX_emit_e_g_React_Fragment_or_Fragment,
            defaultValueDescription: "React.Fragment",
        },
        {
            name: "jsxImportSource",
            type: "string",
            affectsSemanticDiagnostics: true,
            affectsEmit: true,
            affectsModuleResolution: true,
            category: ts.Diagnostics.Language_and_Environment,
            description: ts.Diagnostics.Specify_module_specifier_used_to_import_the_JSX_factory_functions_when_using_jsx_Colon_react_jsx_Asterisk,
            defaultValueDescription: "react"
        },
        {
            name: "resolveJsonModule",
            type: "boolean",
            affectsModuleResolution: true,
            category: ts.Diagnostics.Modules,
            description: ts.Diagnostics.Enable_importing_json_files,
            defaultValueDescription: false,
        },
        {
            name: "out",
            type: "string",
            affectsEmit: true,
            isFilePath: false,
            category: ts.Diagnostics.Backwards_Compatibility,
            paramType: ts.Diagnostics.FILE,
            transpileOptionValue: undefined,
            description: ts.Diagnostics.Deprecated_setting_Use_outFile_instead,
        },
        {
            name: "reactNamespace",
            type: "string",
            affectsEmit: true,
            category: ts.Diagnostics.Language_and_Environment,
            description: ts.Diagnostics.Specify_the_object_invoked_for_createElement_This_only_applies_when_targeting_react_JSX_emit,
            defaultValueDescription: "`React`",
        },
        {
            name: "skipDefaultLibCheck",
            type: "boolean",
            category: ts.Diagnostics.Completeness,
            description: ts.Diagnostics.Skip_type_checking_d_ts_files_that_are_included_with_TypeScript,
            defaultValueDescription: false,
        },
        {
            name: "charset",
            type: "string",
            category: ts.Diagnostics.Backwards_Compatibility,
            description: ts.Diagnostics.No_longer_supported_In_early_versions_manually_set_the_text_encoding_for_reading_files,
            defaultValueDescription: "utf8"
        },
        {
            name: "emitBOM",
            type: "boolean",
            affectsEmit: true,
            category: ts.Diagnostics.Emit,
            description: ts.Diagnostics.Emit_a_UTF_8_Byte_Order_Mark_BOM_in_the_beginning_of_output_files,
            defaultValueDescription: false,
        },
        {
            name: "newLine",
            type: new ts.Map(ts.getEntries({
                crlf: 0,
                lf: 1
            })),
            affectsEmit: true,
            paramType: ts.Diagnostics.NEWLINE,
            category: ts.Diagnostics.Emit,
            description: ts.Diagnostics.Set_the_newline_character_for_emitting_files,
            defaultValueDescription: ts.Diagnostics.Platform_specific
        },
        {
            name: "noErrorTruncation",
            type: "boolean",
            affectsSemanticDiagnostics: true,
            category: ts.Diagnostics.Output_Formatting,
            description: ts.Diagnostics.Disable_truncating_types_in_error_messages,
            defaultValueDescription: false,
        },
        {
            name: "noLib",
            type: "boolean",
            category: ts.Diagnostics.Language_and_Environment,
            affectsProgramStructure: true,
            description: ts.Diagnostics.Disable_including_any_library_files_including_the_default_lib_d_ts,
            transpileOptionValue: true,
            defaultValueDescription: false,
        },
        {
            name: "noResolve",
            type: "boolean",
            affectsModuleResolution: true,
            category: ts.Diagnostics.Modules,
            description: ts.Diagnostics.Disallow_import_s_require_s_or_reference_s_from_expanding_the_number_of_files_TypeScript_should_add_to_a_project,
            transpileOptionValue: true,
            defaultValueDescription: false,
        },
        {
            name: "stripInternal",
            type: "boolean",
            affectsEmit: true,
            category: ts.Diagnostics.Emit,
            description: ts.Diagnostics.Disable_emitting_declarations_that_have_internal_in_their_JSDoc_comments,
            defaultValueDescription: false,
        },
        {
            name: "disableSizeLimit",
            type: "boolean",
            affectsProgramStructure: true,
            category: ts.Diagnostics.Editor_Support,
            description: ts.Diagnostics.Remove_the_20mb_cap_on_total_source_code_size_for_JavaScript_files_in_the_TypeScript_language_server,
            defaultValueDescription: false,
        },
        {
            name: "disableSourceOfProjectReferenceRedirect",
            type: "boolean",
            isTSConfigOnly: true,
            category: ts.Diagnostics.Projects,
            description: ts.Diagnostics.Disable_preferring_source_files_instead_of_declaration_files_when_referencing_composite_projects,
            defaultValueDescription: false,
        },
        {
            name: "disableSolutionSearching",
            type: "boolean",
            isTSConfigOnly: true,
            category: ts.Diagnostics.Projects,
            description: ts.Diagnostics.Opt_a_project_out_of_multi_project_reference_checking_when_editing,
            defaultValueDescription: false,
        },
        {
            name: "disableReferencedProjectLoad",
            type: "boolean",
            isTSConfigOnly: true,
            category: ts.Diagnostics.Projects,
            description: ts.Diagnostics.Reduce_the_number_of_projects_loaded_automatically_by_TypeScript,
            defaultValueDescription: false,
        },
        {
            name: "noImplicitUseStrict",
            type: "boolean",
            affectsSemanticDiagnostics: true,
            category: ts.Diagnostics.Backwards_Compatibility,
            description: ts.Diagnostics.Disable_adding_use_strict_directives_in_emitted_JavaScript_files,
            defaultValueDescription: false,
        },
        {
            name: "noEmitHelpers",
            type: "boolean",
            affectsEmit: true,
            category: ts.Diagnostics.Emit,
            description: ts.Diagnostics.Disable_generating_custom_helper_functions_like_extends_in_compiled_output,
            defaultValueDescription: false,
        },
        {
            name: "noEmitOnError",
            type: "boolean",
            affectsEmit: true,
            category: ts.Diagnostics.Emit,
            transpileOptionValue: undefined,
            description: ts.Diagnostics.Disable_emitting_files_if_any_type_checking_errors_are_reported,
            defaultValueDescription: false,
        },
        {
            name: "preserveConstEnums",
            type: "boolean",
            affectsEmit: true,
            category: ts.Diagnostics.Emit,
            description: ts.Diagnostics.Disable_erasing_const_enum_declarations_in_generated_code,
            defaultValueDescription: false,
        },
        {
            name: "declarationDir",
            type: "string",
            affectsEmit: true,
            isFilePath: true,
            paramType: ts.Diagnostics.DIRECTORY,
            category: ts.Diagnostics.Emit,
            transpileOptionValue: undefined,
            description: ts.Diagnostics.Specify_the_output_directory_for_generated_declaration_files,
        },
        {
            name: "skipLibCheck",
            type: "boolean",
            category: ts.Diagnostics.Completeness,
            description: ts.Diagnostics.Skip_type_checking_all_d_ts_files,
            defaultValueDescription: false,
        },
        {
            name: "allowUnusedLabels",
            type: "boolean",
            affectsBindDiagnostics: true,
            affectsSemanticDiagnostics: true,
            category: ts.Diagnostics.Type_Checking,
            description: ts.Diagnostics.Disable_error_reporting_for_unused_labels,
            defaultValueDescription: undefined,
        },
        {
            name: "allowUnreachableCode",
            type: "boolean",
            affectsBindDiagnostics: true,
            affectsSemanticDiagnostics: true,
            category: ts.Diagnostics.Type_Checking,
            description: ts.Diagnostics.Disable_error_reporting_for_unreachable_code,
            defaultValueDescription: undefined,
        },
        {
            name: "suppressExcessPropertyErrors",
            type: "boolean",
            affectsSemanticDiagnostics: true,
            category: ts.Diagnostics.Backwards_Compatibility,
            description: ts.Diagnostics.Disable_reporting_of_excess_property_errors_during_the_creation_of_object_literals,
            defaultValueDescription: false,
        },
        {
            name: "suppressImplicitAnyIndexErrors",
            type: "boolean",
            affectsSemanticDiagnostics: true,
            category: ts.Diagnostics.Backwards_Compatibility,
            description: ts.Diagnostics.Suppress_noImplicitAny_errors_when_indexing_objects_that_lack_index_signatures,
            defaultValueDescription: false,
        },
        {
            name: "forceConsistentCasingInFileNames",
            type: "boolean",
            affectsModuleResolution: true,
            category: ts.Diagnostics.Interop_Constraints,
            description: ts.Diagnostics.Ensure_that_casing_is_correct_in_imports,
            defaultValueDescription: false,
        },
        {
            name: "maxNodeModuleJsDepth",
            type: "number",
            affectsModuleResolution: true,
            category: ts.Diagnostics.JavaScript_Support,
            description: ts.Diagnostics.Specify_the_maximum_folder_depth_used_for_checking_JavaScript_files_from_node_modules_Only_applicable_with_allowJs,
            defaultValueDescription: 0,
        },
        {
            name: "noStrictGenericChecks",
            type: "boolean",
            affectsSemanticDiagnostics: true,
            category: ts.Diagnostics.Backwards_Compatibility,
            description: ts.Diagnostics.Disable_strict_checking_of_generic_signatures_in_function_types,
            defaultValueDescription: false,
        },
        {
            name: "useDefineForClassFields",
            type: "boolean",
            affectsSemanticDiagnostics: true,
            affectsEmit: true,
            category: ts.Diagnostics.Language_and_Environment,
            description: ts.Diagnostics.Emit_ECMAScript_standard_compliant_class_fields,
            defaultValueDescription: ts.Diagnostics.true_for_ES2022_and_above_including_ESNext
        },
        {
            name: "preserveValueImports",
            type: "boolean",
            affectsEmit: true,
            category: ts.Diagnostics.Emit,
            description: ts.Diagnostics.Preserve_unused_imported_values_in_the_JavaScript_output_that_would_otherwise_be_removed,
            defaultValueDescription: false,
        },
        {
            name: "keyofStringsOnly",
            type: "boolean",
            category: ts.Diagnostics.Backwards_Compatibility,
            description: ts.Diagnostics.Make_keyof_only_return_strings_instead_of_string_numbers_or_symbols_Legacy_option,
            defaultValueDescription: false,
        },
        {
            name: "plugins",
            type: "list",
            isTSConfigOnly: true,
            element: {
                name: "plugin",
                type: "object"
            },
            description: ts.Diagnostics.Specify_a_list_of_language_service_plugins_to_include,
            category: ts.Diagnostics.Editor_Support,
        },
        {
            name: "moduleDetection",
            type: new ts.Map(ts.getEntries({
                auto: ts.ModuleDetectionKind.Auto,
                legacy: ts.ModuleDetectionKind.Legacy,
                force: ts.ModuleDetectionKind.Force,
            })),
            affectsModuleResolution: true,
            description: ts.Diagnostics.Control_what_method_is_used_to_detect_module_format_JS_files,
            category: ts.Diagnostics.Language_and_Environment,
            defaultValueDescription: ts.Diagnostics.auto_Colon_Treat_files_with_imports_exports_import_meta_jsx_with_jsx_Colon_react_jsx_or_esm_format_with_module_Colon_node16_as_modules,
        }
    ];
    ts.optionDeclarations = __spreadArray(__spreadArray([], ts.commonOptionsWithBuild, true), commandOptionsWithoutBuild, true);
    ts.semanticDiagnosticsOptionDeclarations = ts.optionDeclarations.filter(function (option) { return !!option.affectsSemanticDiagnostics; });
    ts.affectsEmitOptionDeclarations = ts.optionDeclarations.filter(function (option) { return !!option.affectsEmit; });
    ts.moduleResolutionOptionDeclarations = ts.optionDeclarations.filter(function (option) { return !!option.affectsModuleResolution; });
    ts.sourceFileAffectingCompilerOptions = ts.optionDeclarations.filter(function (option) {
        return !!option.affectsSourceFile || !!option.affectsModuleResolution || !!option.affectsBindDiagnostics;
    });
    ts.optionsAffectingProgramStructure = ts.optionDeclarations.filter(function (option) { return !!option.affectsProgramStructure; });
    ts.transpileOptionValueCompilerOptions = ts.optionDeclarations.filter(function (option) {
        return ts.hasProperty(option, "transpileOptionValue");
    });
    ts.optionsForBuild = [
        {
            name: "verbose",
            shortName: "v",
            category: ts.Diagnostics.Command_line_Options,
            description: ts.Diagnostics.Enable_verbose_logging,
            type: "boolean",
            defaultValueDescription: false,
        },
        {
            name: "dry",
            shortName: "d",
            category: ts.Diagnostics.Command_line_Options,
            description: ts.Diagnostics.Show_what_would_be_built_or_deleted_if_specified_with_clean,
            type: "boolean",
            defaultValueDescription: false,
        },
        {
            name: "force",
            shortName: "f",
            category: ts.Diagnostics.Command_line_Options,
            description: ts.Diagnostics.Build_all_projects_including_those_that_appear_to_be_up_to_date,
            type: "boolean",
            defaultValueDescription: false,
        },
        {
            name: "clean",
            category: ts.Diagnostics.Command_line_Options,
            description: ts.Diagnostics.Delete_the_outputs_of_all_projects,
            type: "boolean",
            defaultValueDescription: false,
        }
    ];
    ts.buildOpts = __spreadArray(__spreadArray([], ts.commonOptionsWithBuild, true), ts.optionsForBuild, true);
    ts.typeAcquisitionDeclarations = [
        {
            name: "enableAutoDiscovery",
            type: "boolean",
            defaultValueDescription: false,
        },
        {
            name: "enable",
            type: "boolean",
            defaultValueDescription: false,
        },
        {
            name: "include",
            type: "list",
            element: {
                name: "include",
                type: "string"
            }
        },
        {
            name: "exclude",
            type: "list",
            element: {
                name: "exclude",
                type: "string"
            }
        },
        {
            name: "disableFilenameBasedTypeAcquisition",
            type: "boolean",
            defaultValueDescription: false,
        },
    ];
    function createOptionNameMap(optionDeclarations) {
        var optionsNameMap = new ts.Map();
        var shortOptionNames = new ts.Map();
        ts.forEach(optionDeclarations, function (option) {
            optionsNameMap.set(option.name.toLowerCase(), option);
            if (option.shortName) {
                shortOptionNames.set(option.shortName, option.name);
            }
        });
        return { optionsNameMap: optionsNameMap, shortOptionNames: shortOptionNames };
    }
    ts.createOptionNameMap = createOptionNameMap;
    var optionsNameMapCache;
    function getOptionsNameMap() {
        return optionsNameMapCache || (optionsNameMapCache = createOptionNameMap(ts.optionDeclarations));
    }
    ts.getOptionsNameMap = getOptionsNameMap;
    var compilerOptionsAlternateMode = {
        diagnostic: ts.Diagnostics.Compiler_option_0_may_only_be_used_with_build,
        getOptionsNameMap: getBuildOptionsNameMap
    };
    ts.defaultInitCompilerOptions = {
        module: ts.ModuleKind.CommonJS,
        target: 3,
        strict: true,
        esModuleInterop: true,
        forceConsistentCasingInFileNames: true,
        skipLibCheck: true
    };
    function convertEnableAutoDiscoveryToEnable(typeAcquisition) {
        if (typeAcquisition && typeAcquisition.enableAutoDiscovery !== undefined && typeAcquisition.enable === undefined) {
            return {
                enable: typeAcquisition.enableAutoDiscovery,
                include: typeAcquisition.include || [],
                exclude: typeAcquisition.exclude || []
            };
        }
        return typeAcquisition;
    }
    ts.convertEnableAutoDiscoveryToEnable = convertEnableAutoDiscoveryToEnable;
    function createCompilerDiagnosticForInvalidCustomType(opt) {
        return createDiagnosticForInvalidCustomType(opt, ts.createCompilerDiagnostic);
    }
    ts.createCompilerDiagnosticForInvalidCustomType = createCompilerDiagnosticForInvalidCustomType;
    function createDiagnosticForInvalidCustomType(opt, createDiagnostic) {
        var namesOfType = ts.arrayFrom(opt.type.keys()).map(function (key) { return "'".concat(key, "'"); }).join(", ");
        return createDiagnostic(ts.Diagnostics.Argument_for_0_option_must_be_Colon_1, "--".concat(opt.name), namesOfType);
    }
    function parseCustomTypeOption(opt, value, errors) {
        return convertJsonOptionOfCustomType(opt, ts.trimString(value || ""), errors);
    }
    ts.parseCustomTypeOption = parseCustomTypeOption;
    function parseListTypeOption(opt, value, errors) {
        if (value === void 0) { value = ""; }
        value = ts.trimString(value);
        if (ts.startsWith(value, "-")) {
            return undefined;
        }
        if (value === "") {
            return [];
        }
        var values = value.split(",");
        switch (opt.element.type) {
            case "number":
                return ts.mapDefined(values, function (v) { return validateJsonOptionValue(opt.element, parseInt(v), errors); });
            case "string":
                return ts.mapDefined(values, function (v) { return validateJsonOptionValue(opt.element, v || "", errors); });
            default:
                return ts.mapDefined(values, function (v) { return parseCustomTypeOption(opt.element, v, errors); });
        }
    }
    ts.parseListTypeOption = parseListTypeOption;
    function getOptionName(option) {
        return option.name;
    }
    function createUnknownOptionError(unknownOption, diagnostics, createDiagnostics, unknownOptionErrorText) {
        var _a;
        if ((_a = diagnostics.alternateMode) === null || _a === void 0 ? void 0 : _a.getOptionsNameMap().optionsNameMap.has(unknownOption.toLowerCase())) {
            return createDiagnostics(diagnostics.alternateMode.diagnostic, unknownOption);
        }
        var possibleOption = ts.getSpellingSuggestion(unknownOption, diagnostics.optionDeclarations, getOptionName);
        return possibleOption ?
            createDiagnostics(diagnostics.unknownDidYouMeanDiagnostic, unknownOptionErrorText || unknownOption, possibleOption.name) :
            createDiagnostics(diagnostics.unknownOptionDiagnostic, unknownOptionErrorText || unknownOption);
    }
    function parseCommandLineWorker(diagnostics, commandLine, readFile) {
        var options = {};
        var watchOptions;
        var fileNames = [];
        var errors = [];
        parseStrings(commandLine);
        return {
            options: options,
            watchOptions: watchOptions,
            fileNames: fileNames,
            errors: errors
        };
        function parseStrings(args) {
            var i = 0;
            while (i < args.length) {
                var s = args[i];
                i++;
                if (s.charCodeAt(0) === 64) {
                    parseResponseFile(s.slice(1));
                }
                else if (s.charCodeAt(0) === 45) {
                    var inputOptionName = s.slice(s.charCodeAt(1) === 45 ? 2 : 1);
                    var opt = getOptionDeclarationFromName(diagnostics.getOptionsNameMap, inputOptionName, true);
                    if (opt) {
                        i = parseOptionValue(args, i, diagnostics, opt, options, errors);
                    }
                    else {
                        var watchOpt = getOptionDeclarationFromName(watchOptionsDidYouMeanDiagnostics.getOptionsNameMap, inputOptionName, true);
                        if (watchOpt) {
                            i = parseOptionValue(args, i, watchOptionsDidYouMeanDiagnostics, watchOpt, watchOptions || (watchOptions = {}), errors);
                        }
                        else {
                            errors.push(createUnknownOptionError(inputOptionName, diagnostics, ts.createCompilerDiagnostic, s));
                        }
                    }
                }
                else {
                    fileNames.push(s);
                }
            }
        }
        function parseResponseFile(fileName) {
            var text = tryReadFile(fileName, readFile || (function (fileName) { return ts.sys.readFile(fileName); }));
            if (!ts.isString(text)) {
                errors.push(text);
                return;
            }
            var args = [];
            var pos = 0;
            while (true) {
                while (pos < text.length && text.charCodeAt(pos) <= 32)
                    pos++;
                if (pos >= text.length)
                    break;
                var start = pos;
                if (text.charCodeAt(start) === 34) {
                    pos++;
                    while (pos < text.length && text.charCodeAt(pos) !== 34)
                        pos++;
                    if (pos < text.length) {
                        args.push(text.substring(start + 1, pos));
                        pos++;
                    }
                    else {
                        errors.push(ts.createCompilerDiagnostic(ts.Diagnostics.Unterminated_quoted_string_in_response_file_0, fileName));
                    }
                }
                else {
                    while (text.charCodeAt(pos) > 32)
                        pos++;
                    args.push(text.substring(start, pos));
                }
            }
            parseStrings(args);
        }
    }
    ts.parseCommandLineWorker = parseCommandLineWorker;
    function parseOptionValue(args, i, diagnostics, opt, options, errors) {
        if (opt.isTSConfigOnly) {
            var optValue = args[i];
            if (optValue === "null") {
                options[opt.name] = undefined;
                i++;
            }
            else if (opt.type === "boolean") {
                if (optValue === "false") {
                    options[opt.name] = validateJsonOptionValue(opt, false, errors);
                    i++;
                }
                else {
                    if (optValue === "true")
                        i++;
                    errors.push(ts.createCompilerDiagnostic(ts.Diagnostics.Option_0_can_only_be_specified_in_tsconfig_json_file_or_set_to_false_or_null_on_command_line, opt.name));
                }
            }
            else {
                errors.push(ts.createCompilerDiagnostic(ts.Diagnostics.Option_0_can_only_be_specified_in_tsconfig_json_file_or_set_to_null_on_command_line, opt.name));
                if (optValue && !ts.startsWith(optValue, "-"))
                    i++;
            }
        }
        else {
            if (!args[i] && opt.type !== "boolean") {
                errors.push(ts.createCompilerDiagnostic(diagnostics.optionTypeMismatchDiagnostic, opt.name, getCompilerOptionValueTypeString(opt)));
            }
            if (args[i] !== "null") {
                switch (opt.type) {
                    case "number":
                        options[opt.name] = validateJsonOptionValue(opt, parseInt(args[i]), errors);
                        i++;
                        break;
                    case "boolean":
                        var optValue = args[i];
                        options[opt.name] = validateJsonOptionValue(opt, optValue !== "false", errors);
                        if (optValue === "false" || optValue === "true") {
                            i++;
                        }
                        break;
                    case "string":
                        options[opt.name] = validateJsonOptionValue(opt, args[i] || "", errors);
                        i++;
                        break;
                    case "list":
                        var result = parseListTypeOption(opt, args[i], errors);
                        options[opt.name] = result || [];
                        if (result) {
                            i++;
                        }
                        break;
                    default:
                        options[opt.name] = parseCustomTypeOption(opt, args[i], errors);
                        i++;
                        break;
                }
            }
            else {
                options[opt.name] = undefined;
                i++;
            }
        }
        return i;
    }
    ts.compilerOptionsDidYouMeanDiagnostics = {
        alternateMode: compilerOptionsAlternateMode,
        getOptionsNameMap: getOptionsNameMap,
        optionDeclarations: ts.optionDeclarations,
        unknownOptionDiagnostic: ts.Diagnostics.Unknown_compiler_option_0,
        unknownDidYouMeanDiagnostic: ts.Diagnostics.Unknown_compiler_option_0_Did_you_mean_1,
        optionTypeMismatchDiagnostic: ts.Diagnostics.Compiler_option_0_expects_an_argument
    };
    function parseCommandLine(commandLine, readFile) {
        return parseCommandLineWorker(ts.compilerOptionsDidYouMeanDiagnostics, commandLine, readFile);
    }
    ts.parseCommandLine = parseCommandLine;
    function getOptionFromName(optionName, allowShort) {
        return getOptionDeclarationFromName(getOptionsNameMap, optionName, allowShort);
    }
    ts.getOptionFromName = getOptionFromName;
    function getOptionDeclarationFromName(getOptionNameMap, optionName, allowShort) {
        if (allowShort === void 0) { allowShort = false; }
        optionName = optionName.toLowerCase();
        var _a = getOptionNameMap(), optionsNameMap = _a.optionsNameMap, shortOptionNames = _a.shortOptionNames;
        if (allowShort) {
            var short = shortOptionNames.get(optionName);
            if (short !== undefined) {
                optionName = short;
            }
        }
        return optionsNameMap.get(optionName);
    }
    var buildOptionsNameMapCache;
    function getBuildOptionsNameMap() {
        return buildOptionsNameMapCache || (buildOptionsNameMapCache = createOptionNameMap(ts.buildOpts));
    }
    var buildOptionsAlternateMode = {
        diagnostic: ts.Diagnostics.Compiler_option_0_may_not_be_used_with_build,
        getOptionsNameMap: getOptionsNameMap
    };
    var buildOptionsDidYouMeanDiagnostics = {
        alternateMode: buildOptionsAlternateMode,
        getOptionsNameMap: getBuildOptionsNameMap,
        optionDeclarations: ts.buildOpts,
        unknownOptionDiagnostic: ts.Diagnostics.Unknown_build_option_0,
        unknownDidYouMeanDiagnostic: ts.Diagnostics.Unknown_build_option_0_Did_you_mean_1,
        optionTypeMismatchDiagnostic: ts.Diagnostics.Build_option_0_requires_a_value_of_type_1
    };
    function parseBuildCommand(args) {
        var _a = parseCommandLineWorker(buildOptionsDidYouMeanDiagnostics, args), options = _a.options, watchOptions = _a.watchOptions, projects = _a.fileNames, errors = _a.errors;
        var buildOptions = options;
        if (projects.length === 0) {
            projects.push(".");
        }
        if (buildOptions.clean && buildOptions.force) {
            errors.push(ts.createCompilerDiagnostic(ts.Diagnostics.Options_0_and_1_cannot_be_combined, "clean", "force"));
        }
        if (buildOptions.clean && buildOptions.verbose) {
            errors.push(ts.createCompilerDiagnostic(ts.Diagnostics.Options_0_and_1_cannot_be_combined, "clean", "verbose"));
        }
        if (buildOptions.clean && buildOptions.watch) {
            errors.push(ts.createCompilerDiagnostic(ts.Diagnostics.Options_0_and_1_cannot_be_combined, "clean", "watch"));
        }
        if (buildOptions.watch && buildOptions.dry) {
            errors.push(ts.createCompilerDiagnostic(ts.Diagnostics.Options_0_and_1_cannot_be_combined, "watch", "dry"));
        }
        return { buildOptions: buildOptions, watchOptions: watchOptions, projects: projects, errors: errors };
    }
    ts.parseBuildCommand = parseBuildCommand;
    function getDiagnosticText(_message) {
        var _args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            _args[_i - 1] = arguments[_i];
        }
        var diagnostic = ts.createCompilerDiagnostic.apply(undefined, arguments);
        return diagnostic.messageText;
    }
    ts.getDiagnosticText = getDiagnosticText;
    function getParsedCommandLineOfConfigFile(configFileName, optionsToExtend, host, extendedConfigCache, watchOptionsToExtend, extraFileExtensions) {
        var configFileText = tryReadFile(configFileName, function (fileName) { return host.readFile(fileName); });
        if (!ts.isString(configFileText)) {
            host.onUnRecoverableConfigFileDiagnostic(configFileText);
            return undefined;
        }
        var result = ts.parseJsonText(configFileName, configFileText);
        var cwd = host.getCurrentDirectory();
        result.path = ts.toPath(configFileName, cwd, ts.createGetCanonicalFileName(host.useCaseSensitiveFileNames));
        result.resolvedPath = result.path;
        result.originalFileName = result.fileName;
        return parseJsonSourceFileConfigFileContent(result, host, ts.getNormalizedAbsolutePath(ts.getDirectoryPath(configFileName), cwd), optionsToExtend, ts.getNormalizedAbsolutePath(configFileName, cwd), undefined, extraFileExtensions, extendedConfigCache, watchOptionsToExtend);
    }
    ts.getParsedCommandLineOfConfigFile = getParsedCommandLineOfConfigFile;
    function readConfigFile(fileName, readFile) {
        var textOrDiagnostic = tryReadFile(fileName, readFile);
        return ts.isString(textOrDiagnostic) ? parseConfigFileTextToJson(fileName, textOrDiagnostic) : { config: {}, error: textOrDiagnostic };
    }
    ts.readConfigFile = readConfigFile;
    function parseConfigFileTextToJson(fileName, jsonText) {
        var jsonSourceFile = ts.parseJsonText(fileName, jsonText);
        return {
            config: convertConfigFileToObject(jsonSourceFile, jsonSourceFile.parseDiagnostics, false, undefined),
            error: jsonSourceFile.parseDiagnostics.length ? jsonSourceFile.parseDiagnostics[0] : undefined
        };
    }
    ts.parseConfigFileTextToJson = parseConfigFileTextToJson;
    function readJsonConfigFile(fileName, readFile) {
        var textOrDiagnostic = tryReadFile(fileName, readFile);
        return ts.isString(textOrDiagnostic) ? ts.parseJsonText(fileName, textOrDiagnostic) : { fileName: fileName, parseDiagnostics: [textOrDiagnostic] };
    }
    ts.readJsonConfigFile = readJsonConfigFile;
    function tryReadFile(fileName, readFile) {
        var text;
        try {
            text = readFile(fileName);
        }
        catch (e) {
            return ts.createCompilerDiagnostic(ts.Diagnostics.Cannot_read_file_0_Colon_1, fileName, e.message);
        }
        return text === undefined ? ts.createCompilerDiagnostic(ts.Diagnostics.Cannot_read_file_0, fileName) : text;
    }
    ts.tryReadFile = tryReadFile;
    function commandLineOptionsToMap(options) {
        return ts.arrayToMap(options, getOptionName);
    }
    var typeAcquisitionDidYouMeanDiagnostics = {
        optionDeclarations: ts.typeAcquisitionDeclarations,
        unknownOptionDiagnostic: ts.Diagnostics.Unknown_type_acquisition_option_0,
        unknownDidYouMeanDiagnostic: ts.Diagnostics.Unknown_type_acquisition_option_0_Did_you_mean_1,
    };
    var watchOptionsNameMapCache;
    function getWatchOptionsNameMap() {
        return watchOptionsNameMapCache || (watchOptionsNameMapCache = createOptionNameMap(ts.optionsForWatch));
    }
    var watchOptionsDidYouMeanDiagnostics = {
        getOptionsNameMap: getWatchOptionsNameMap,
        optionDeclarations: ts.optionsForWatch,
        unknownOptionDiagnostic: ts.Diagnostics.Unknown_watch_option_0,
        unknownDidYouMeanDiagnostic: ts.Diagnostics.Unknown_watch_option_0_Did_you_mean_1,
        optionTypeMismatchDiagnostic: ts.Diagnostics.Watch_option_0_requires_a_value_of_type_1
    };
    var commandLineCompilerOptionsMapCache;
    function getCommandLineCompilerOptionsMap() {
        return commandLineCompilerOptionsMapCache || (commandLineCompilerOptionsMapCache = commandLineOptionsToMap(ts.optionDeclarations));
    }
    var commandLineWatchOptionsMapCache;
    function getCommandLineWatchOptionsMap() {
        return commandLineWatchOptionsMapCache || (commandLineWatchOptionsMapCache = commandLineOptionsToMap(ts.optionsForWatch));
    }
    var commandLineTypeAcquisitionMapCache;
    function getCommandLineTypeAcquisitionMap() {
        return commandLineTypeAcquisitionMapCache || (commandLineTypeAcquisitionMapCache = commandLineOptionsToMap(ts.typeAcquisitionDeclarations));
    }
    var _tsconfigRootOptions;
    function getTsconfigRootOptionsMap() {
        if (_tsconfigRootOptions === undefined) {
            _tsconfigRootOptions = {
                name: undefined,
                type: "object",
                elementOptions: commandLineOptionsToMap([
                    {
                        name: "compilerOptions",
                        type: "object",
                        elementOptions: getCommandLineCompilerOptionsMap(),
                        extraKeyDiagnostics: ts.compilerOptionsDidYouMeanDiagnostics,
                    },
                    {
                        name: "watchOptions",
                        type: "object",
                        elementOptions: getCommandLineWatchOptionsMap(),
                        extraKeyDiagnostics: watchOptionsDidYouMeanDiagnostics,
                    },
                    {
                        name: "typingOptions",
                        type: "object",
                        elementOptions: getCommandLineTypeAcquisitionMap(),
                        extraKeyDiagnostics: typeAcquisitionDidYouMeanDiagnostics,
                    },
                    {
                        name: "typeAcquisition",
                        type: "object",
                        elementOptions: getCommandLineTypeAcquisitionMap(),
                        extraKeyDiagnostics: typeAcquisitionDidYouMeanDiagnostics
                    },
                    {
                        name: "extends",
                        type: "string",
                        category: ts.Diagnostics.File_Management,
                    },
                    {
                        name: "references",
                        type: "list",
                        element: {
                            name: "references",
                            type: "object"
                        },
                        category: ts.Diagnostics.Projects,
                    },
                    {
                        name: "files",
                        type: "list",
                        element: {
                            name: "files",
                            type: "string"
                        },
                        category: ts.Diagnostics.File_Management,
                    },
                    {
                        name: "include",
                        type: "list",
                        element: {
                            name: "include",
                            type: "string"
                        },
                        category: ts.Diagnostics.File_Management,
                        defaultValueDescription: ts.Diagnostics.if_files_is_specified_otherwise_Asterisk_Asterisk_Slash_Asterisk
                    },
                    {
                        name: "exclude",
                        type: "list",
                        element: {
                            name: "exclude",
                            type: "string"
                        },
                        category: ts.Diagnostics.File_Management,
                        defaultValueDescription: ts.Diagnostics.node_modules_bower_components_jspm_packages_plus_the_value_of_outDir_if_one_is_specified
                    },
                    ts.compileOnSaveCommandLineOption
                ])
            };
        }
        return _tsconfigRootOptions;
    }
    function convertConfigFileToObject(sourceFile, errors, reportOptionsErrors, optionsIterator) {
        var _a;
        var rootExpression = (_a = sourceFile.statements[0]) === null || _a === void 0 ? void 0 : _a.expression;
        var knownRootOptions = reportOptionsErrors ? getTsconfigRootOptionsMap() : undefined;
        if (rootExpression && rootExpression.kind !== 205) {
            errors.push(ts.createDiagnosticForNodeInSourceFile(sourceFile, rootExpression, ts.Diagnostics.The_root_value_of_a_0_file_must_be_an_object, ts.getBaseFileName(sourceFile.fileName) === "jsconfig.json" ? "jsconfig.json" : "tsconfig.json"));
            if (ts.isArrayLiteralExpression(rootExpression)) {
                var firstObject = ts.find(rootExpression.elements, ts.isObjectLiteralExpression);
                if (firstObject) {
                    return convertToObjectWorker(sourceFile, firstObject, errors, true, knownRootOptions, optionsIterator);
                }
            }
            return {};
        }
        return convertToObjectWorker(sourceFile, rootExpression, errors, true, knownRootOptions, optionsIterator);
    }
    function convertToObject(sourceFile, errors) {
        var _a;
        return convertToObjectWorker(sourceFile, (_a = sourceFile.statements[0]) === null || _a === void 0 ? void 0 : _a.expression, errors, true, undefined, undefined);
    }
    ts.convertToObject = convertToObject;
    function convertToObjectWorker(sourceFile, rootExpression, errors, returnValue, knownRootOptions, jsonConversionNotifier) {
        if (!rootExpression) {
            return returnValue ? {} : undefined;
        }
        return convertPropertyValueToJson(rootExpression, knownRootOptions);
        function isRootOptionMap(knownOptions) {
            return knownRootOptions && knownRootOptions.elementOptions === knownOptions;
        }
        function convertObjectLiteralExpressionToJson(node, knownOptions, extraKeyDiagnostics, parentOption) {
            var result = returnValue ? {} : undefined;
            var _loop_4 = function (element) {
                if (element.kind !== 296) {
                    errors.push(ts.createDiagnosticForNodeInSourceFile(sourceFile, element, ts.Diagnostics.Property_assignment_expected));
                    return "continue";
                }
                if (element.questionToken) {
                    errors.push(ts.createDiagnosticForNodeInSourceFile(sourceFile, element.questionToken, ts.Diagnostics.The_0_modifier_can_only_be_used_in_TypeScript_files, "?"));
                }
                if (!isDoubleQuotedString(element.name)) {
                    errors.push(ts.createDiagnosticForNodeInSourceFile(sourceFile, element.name, ts.Diagnostics.String_literal_with_double_quotes_expected));
                }
                var textOfKey = ts.isComputedNonLiteralName(element.name) ? undefined : ts.getTextOfPropertyName(element.name);
                var keyText = textOfKey && ts.unescapeLeadingUnderscores(textOfKey);
                var option = keyText && knownOptions ? knownOptions.get(keyText) : undefined;
                if (keyText && extraKeyDiagnostics && !option) {
                    if (knownOptions) {
                        errors.push(createUnknownOptionError(keyText, extraKeyDiagnostics, function (message, arg0, arg1) { return ts.createDiagnosticForNodeInSourceFile(sourceFile, element.name, message, arg0, arg1); }));
                    }
                    else {
                        errors.push(ts.createDiagnosticForNodeInSourceFile(sourceFile, element.name, extraKeyDiagnostics.unknownOptionDiagnostic, keyText));
                    }
                }
                var value = convertPropertyValueToJson(element.initializer, option);
                if (typeof keyText !== "undefined") {
                    if (returnValue) {
                        result[keyText] = value;
                    }
                    if (jsonConversionNotifier &&
                        (parentOption || isRootOptionMap(knownOptions))) {
                        var isValidOptionValue = isCompilerOptionsValue(option, value);
                        if (parentOption) {
                            if (isValidOptionValue) {
                                jsonConversionNotifier.onSetValidOptionKeyValueInParent(parentOption, option, value);
                            }
                        }
                        else if (isRootOptionMap(knownOptions)) {
                            if (isValidOptionValue) {
                                jsonConversionNotifier.onSetValidOptionKeyValueInRoot(keyText, element.name, value, element.initializer);
                            }
                            else if (!option) {
                                jsonConversionNotifier.onSetUnknownOptionKeyValueInRoot(keyText, element.name, value, element.initializer);
                            }
                        }
                    }
                }
            };
            for (var _i = 0, _a = node.properties; _i < _a.length; _i++) {
                var element = _a[_i];
                _loop_4(element);
            }
            return result;
        }
        function convertArrayLiteralExpressionToJson(elements, elementOption) {
            if (!returnValue) {
                elements.forEach(function (element) { return convertPropertyValueToJson(element, elementOption); });
                return undefined;
            }
            return ts.filter(elements.map(function (element) { return convertPropertyValueToJson(element, elementOption); }), function (v) { return v !== undefined; });
        }
        function convertPropertyValueToJson(valueExpression, option) {
            var invalidReported;
            switch (valueExpression.kind) {
                case 110:
                    reportInvalidOptionValue(option && option.type !== "boolean");
                    return validateValue(true);
                case 95:
                    reportInvalidOptionValue(option && option.type !== "boolean");
                    return validateValue(false);
                case 104:
                    reportInvalidOptionValue(option && option.name === "extends");
                    return validateValue(null);
                case 10:
                    if (!isDoubleQuotedString(valueExpression)) {
                        errors.push(ts.createDiagnosticForNodeInSourceFile(sourceFile, valueExpression, ts.Diagnostics.String_literal_with_double_quotes_expected));
                    }
                    reportInvalidOptionValue(option && (ts.isString(option.type) && option.type !== "string"));
                    var text = valueExpression.text;
                    if (option && !ts.isString(option.type)) {
                        var customOption = option;
                        if (!customOption.type.has(text.toLowerCase())) {
                            errors.push(createDiagnosticForInvalidCustomType(customOption, function (message, arg0, arg1) { return ts.createDiagnosticForNodeInSourceFile(sourceFile, valueExpression, message, arg0, arg1); }));
                            invalidReported = true;
                        }
                    }
                    return validateValue(text);
                case 8:
                    reportInvalidOptionValue(option && option.type !== "number");
                    return validateValue(Number(valueExpression.text));
                case 219:
                    if (valueExpression.operator !== 40 || valueExpression.operand.kind !== 8) {
                        break;
                    }
                    reportInvalidOptionValue(option && option.type !== "number");
                    return validateValue(-Number(valueExpression.operand.text));
                case 205:
                    reportInvalidOptionValue(option && option.type !== "object");
                    var objectLiteralExpression = valueExpression;
                    if (option) {
                        var _a = option, elementOptions = _a.elementOptions, extraKeyDiagnostics = _a.extraKeyDiagnostics, optionName = _a.name;
                        return validateValue(convertObjectLiteralExpressionToJson(objectLiteralExpression, elementOptions, extraKeyDiagnostics, optionName));
                    }
                    else {
                        return validateValue(convertObjectLiteralExpressionToJson(objectLiteralExpression, undefined, undefined, undefined));
                    }
                case 204:
                    reportInvalidOptionValue(option && option.type !== "list");
                    return validateValue(convertArrayLiteralExpressionToJson(valueExpression.elements, option && option.element));
            }
            if (option) {
                reportInvalidOptionValue(true);
            }
            else {
                errors.push(ts.createDiagnosticForNodeInSourceFile(sourceFile, valueExpression, ts.Diagnostics.Property_value_can_only_be_string_literal_numeric_literal_true_false_null_object_literal_or_array_literal));
            }
            return undefined;
            function validateValue(value) {
                var _a;
                if (!invalidReported) {
                    var diagnostic = (_a = option === null || option === void 0 ? void 0 : option.extraValidation) === null || _a === void 0 ? void 0 : _a.call(option, value);
                    if (diagnostic) {
                        errors.push(ts.createDiagnosticForNodeInSourceFile.apply(void 0, __spreadArray([sourceFile, valueExpression], diagnostic, false)));
                        return undefined;
                    }
                }
                return value;
            }
            function reportInvalidOptionValue(isError) {
                if (isError) {
                    errors.push(ts.createDiagnosticForNodeInSourceFile(sourceFile, valueExpression, ts.Diagnostics.Compiler_option_0_requires_a_value_of_type_1, option.name, getCompilerOptionValueTypeString(option)));
                    invalidReported = true;
                }
            }
        }
        function isDoubleQuotedString(node) {
            return ts.isStringLiteral(node) && ts.isStringDoubleQuoted(node, sourceFile);
        }
    }
    ts.convertToObjectWorker = convertToObjectWorker;
    function getCompilerOptionValueTypeString(option) {
        return option.type === "list" ?
            "Array" :
            ts.isString(option.type) ? option.type : "string";
    }
    function isCompilerOptionsValue(option, value) {
        if (option) {
            if (isNullOrUndefined(value))
                return true;
            if (option.type === "list") {
                return ts.isArray(value);
            }
            var expectedType = ts.isString(option.type) ? option.type : "string";
            return typeof value === expectedType;
        }
        return false;
    }
    function convertToTSConfig(configParseResult, configFileName, host) {
        var _a, _b, _c;
        var getCanonicalFileName = ts.createGetCanonicalFileName(host.useCaseSensitiveFileNames);
        var files = ts.map(ts.filter(configParseResult.fileNames, !((_b = (_a = configParseResult.options.configFile) === null || _a === void 0 ? void 0 : _a.configFileSpecs) === null || _b === void 0 ? void 0 : _b.validatedIncludeSpecs) ? ts.returnTrue : matchesSpecs(configFileName, configParseResult.options.configFile.configFileSpecs.validatedIncludeSpecs, configParseResult.options.configFile.configFileSpecs.validatedExcludeSpecs, host)), function (f) { return ts.getRelativePathFromFile(ts.getNormalizedAbsolutePath(configFileName, host.getCurrentDirectory()), ts.getNormalizedAbsolutePath(f, host.getCurrentDirectory()), getCanonicalFileName); });
        var optionMap = serializeCompilerOptions(configParseResult.options, { configFilePath: ts.getNormalizedAbsolutePath(configFileName, host.getCurrentDirectory()), useCaseSensitiveFileNames: host.useCaseSensitiveFileNames });
        var watchOptionMap = configParseResult.watchOptions && serializeWatchOptions(configParseResult.watchOptions);
        var config = __assign(__assign({ compilerOptions: __assign(__assign({}, optionMapToObject(optionMap)), { showConfig: undefined, configFile: undefined, configFilePath: undefined, help: undefined, init: undefined, listFiles: undefined, listEmittedFiles: undefined, project: undefined, build: undefined, version: undefined }), watchOptions: watchOptionMap && optionMapToObject(watchOptionMap), references: ts.map(configParseResult.projectReferences, function (r) { return (__assign(__assign({}, r), { path: r.originalPath ? r.originalPath : "", originalPath: undefined })); }), files: ts.length(files) ? files : undefined }, (((_c = configParseResult.options.configFile) === null || _c === void 0 ? void 0 : _c.configFileSpecs) ? {
            include: filterSameAsDefaultInclude(configParseResult.options.configFile.configFileSpecs.validatedIncludeSpecs),
            exclude: configParseResult.options.configFile.configFileSpecs.validatedExcludeSpecs
        } : {})), { compileOnSave: !!configParseResult.compileOnSave ? true : undefined });
        return config;
    }
    ts.convertToTSConfig = convertToTSConfig;
    function optionMapToObject(optionMap) {
        return __assign({}, ts.arrayFrom(optionMap.entries()).reduce(function (prev, cur) {
            var _a;
            return (__assign(__assign({}, prev), (_a = {}, _a[cur[0]] = cur[1], _a)));
        }, {}));
    }
    function filterSameAsDefaultInclude(specs) {
        if (!ts.length(specs))
            return undefined;
        if (ts.length(specs) !== 1)
            return specs;
        if (specs[0] === "**/*")
            return undefined;
        return specs;
    }
    function matchesSpecs(path, includeSpecs, excludeSpecs, host) {
        if (!includeSpecs)
            return ts.returnTrue;
        var patterns = ts.getFileMatcherPatterns(path, excludeSpecs, includeSpecs, host.useCaseSensitiveFileNames, host.getCurrentDirectory());
        var excludeRe = patterns.excludePattern && ts.getRegexFromPattern(patterns.excludePattern, host.useCaseSensitiveFileNames);
        var includeRe = patterns.includeFilePattern && ts.getRegexFromPattern(patterns.includeFilePattern, host.useCaseSensitiveFileNames);
        if (includeRe) {
            if (excludeRe) {
                return function (path) { return !(includeRe.test(path) && !excludeRe.test(path)); };
            }
            return function (path) { return !includeRe.test(path); };
        }
        if (excludeRe) {
            return function (path) { return excludeRe.test(path); };
        }
        return ts.returnTrue;
    }
    function getCustomTypeMapOfCommandLineOption(optionDefinition) {
        if (optionDefinition.type === "string" || optionDefinition.type === "number" || optionDefinition.type === "boolean" || optionDefinition.type === "object") {
            return undefined;
        }
        else if (optionDefinition.type === "list") {
            return getCustomTypeMapOfCommandLineOption(optionDefinition.element);
        }
        else {
            return optionDefinition.type;
        }
    }
    function getNameOfCompilerOptionValue(value, customTypeMap) {
        return ts.forEachEntry(customTypeMap, function (mapValue, key) {
            if (mapValue === value) {
                return key;
            }
        });
    }
    function serializeCompilerOptions(options, pathOptions) {
        return serializeOptionBaseObject(options, getOptionsNameMap(), pathOptions);
    }
    function serializeWatchOptions(options) {
        return serializeOptionBaseObject(options, getWatchOptionsNameMap());
    }
    function serializeOptionBaseObject(options, _a, pathOptions) {
        var optionsNameMap = _a.optionsNameMap;
        var result = new ts.Map();
        var getCanonicalFileName = pathOptions && ts.createGetCanonicalFileName(pathOptions.useCaseSensitiveFileNames);
        var _loop_5 = function (name) {
            if (ts.hasProperty(options, name)) {
                if (optionsNameMap.has(name) && (optionsNameMap.get(name).category === ts.Diagnostics.Command_line_Options || optionsNameMap.get(name).category === ts.Diagnostics.Output_Formatting)) {
                    return "continue";
                }
                var value = options[name];
                var optionDefinition = optionsNameMap.get(name.toLowerCase());
                if (optionDefinition) {
                    var customTypeMap_1 = getCustomTypeMapOfCommandLineOption(optionDefinition);
                    if (!customTypeMap_1) {
                        if (pathOptions && optionDefinition.isFilePath) {
                            result.set(name, ts.getRelativePathFromFile(pathOptions.configFilePath, ts.getNormalizedAbsolutePath(value, ts.getDirectoryPath(pathOptions.configFilePath)), getCanonicalFileName));
                        }
                        else {
                            result.set(name, value);
                        }
                    }
                    else {
                        if (optionDefinition.type === "list") {
                            result.set(name, value.map(function (element) { return getNameOfCompilerOptionValue(element, customTypeMap_1); }));
                        }
                        else {
                            result.set(name, getNameOfCompilerOptionValue(value, customTypeMap_1));
                        }
                    }
                }
            }
        };
        for (var name in options) {
            _loop_5(name);
        }
        return result;
    }
    function getCompilerOptionsDiffValue(options, newLine) {
        var compilerOptionsMap = getSerializedCompilerOption(options);
        return getOverwrittenDefaultOptions();
        function makePadding(paddingLength) {
            return Array(paddingLength + 1).join(" ");
        }
        function getOverwrittenDefaultOptions() {
            var result = [];
            var tab = makePadding(2);
            commandOptionsWithoutBuild.forEach(function (cmd) {
                if (!compilerOptionsMap.has(cmd.name)) {
                    return;
                }
                var newValue = compilerOptionsMap.get(cmd.name);
                var defaultValue = getDefaultValueForOption(cmd);
                if (newValue !== defaultValue) {
                    result.push("".concat(tab).concat(cmd.name, ": ").concat(newValue));
                }
                else if (ts.hasProperty(ts.defaultInitCompilerOptions, cmd.name)) {
                    result.push("".concat(tab).concat(cmd.name, ": ").concat(defaultValue));
                }
            });
            return result.join(newLine) + newLine;
        }
    }
    ts.getCompilerOptionsDiffValue = getCompilerOptionsDiffValue;
    function getSerializedCompilerOption(options) {
        var compilerOptions = ts.extend(options, ts.defaultInitCompilerOptions);
        return serializeCompilerOptions(compilerOptions);
    }
    function generateTSConfig(options, fileNames, newLine) {
        var compilerOptionsMap = getSerializedCompilerOption(options);
        return writeConfigurations();
        function makePadding(paddingLength) {
            return Array(paddingLength + 1).join(" ");
        }
        function isAllowedOptionForOutput(_a) {
            var category = _a.category, name = _a.name, isCommandLineOnly = _a.isCommandLineOnly;
            var categoriesToSkip = [ts.Diagnostics.Command_line_Options, ts.Diagnostics.Editor_Support, ts.Diagnostics.Compiler_Diagnostics, ts.Diagnostics.Backwards_Compatibility, ts.Diagnostics.Watch_and_Build_Modes, ts.Diagnostics.Output_Formatting];
            return !isCommandLineOnly && category !== undefined && (!categoriesToSkip.includes(category) || compilerOptionsMap.has(name));
        }
        function writeConfigurations() {
            var categorizedOptions = ts.createMultiMap();
            for (var _i = 0, optionDeclarations_1 = ts.optionDeclarations; _i < optionDeclarations_1.length; _i++) {
                var option = optionDeclarations_1[_i];
                var category = option.category;
                if (isAllowedOptionForOutput(option)) {
                    categorizedOptions.add(ts.getLocaleSpecificMessage(category), option);
                }
            }
            var marginLength = 0;
            var seenKnownKeys = 0;
            var entries = [];
            categorizedOptions.forEach(function (options, category) {
                if (entries.length !== 0) {
                    entries.push({ value: "" });
                }
                entries.push({ value: "/* ".concat(category, " */") });
                for (var _i = 0, options_1 = options; _i < options_1.length; _i++) {
                    var option = options_1[_i];
                    var optionName = void 0;
                    if (compilerOptionsMap.has(option.name)) {
                        optionName = "\"".concat(option.name, "\": ").concat(JSON.stringify(compilerOptionsMap.get(option.name))).concat((seenKnownKeys += 1) === compilerOptionsMap.size ? "" : ",");
                    }
                    else {
                        optionName = "// \"".concat(option.name, "\": ").concat(JSON.stringify(getDefaultValueForOption(option)), ",");
                    }
                    entries.push({
                        value: optionName,
                        description: "/* ".concat(option.description && ts.getLocaleSpecificMessage(option.description) || option.name, " */")
                    });
                    marginLength = Math.max(optionName.length, marginLength);
                }
            });
            var tab = makePadding(2);
            var result = [];
            result.push("{");
            result.push("".concat(tab, "\"compilerOptions\": {"));
            result.push("".concat(tab).concat(tab, "/* ").concat(ts.getLocaleSpecificMessage(ts.Diagnostics.Visit_https_Colon_Slash_Slashaka_ms_Slashtsconfig_to_read_more_about_this_file), " */"));
            result.push("");
            for (var _a = 0, entries_2 = entries; _a < entries_2.length; _a++) {
                var entry = entries_2[_a];
                var value = entry.value, _b = entry.description, description = _b === void 0 ? "" : _b;
                result.push(value && "".concat(tab).concat(tab).concat(value).concat(description && (makePadding(marginLength - value.length + 2) + description)));
            }
            if (fileNames.length) {
                result.push("".concat(tab, "},"));
                result.push("".concat(tab, "\"files\": ["));
                for (var i = 0; i < fileNames.length; i++) {
                    result.push("".concat(tab).concat(tab).concat(JSON.stringify(fileNames[i])).concat(i === fileNames.length - 1 ? "" : ","));
                }
                result.push("".concat(tab, "]"));
            }
            else {
                result.push("".concat(tab, "}"));
            }
            result.push("}");
            return result.join(newLine) + newLine;
        }
    }
    ts.generateTSConfig = generateTSConfig;
    function convertToOptionsWithAbsolutePaths(options, toAbsolutePath) {
        var result = {};
        var optionsNameMap = getOptionsNameMap().optionsNameMap;
        for (var name in options) {
            if (ts.hasProperty(options, name)) {
                result[name] = convertToOptionValueWithAbsolutePaths(optionsNameMap.get(name.toLowerCase()), options[name], toAbsolutePath);
            }
        }
        if (result.configFilePath) {
            result.configFilePath = toAbsolutePath(result.configFilePath);
        }
        return result;
    }
    ts.convertToOptionsWithAbsolutePaths = convertToOptionsWithAbsolutePaths;
    function convertToOptionValueWithAbsolutePaths(option, value, toAbsolutePath) {
        if (option && !isNullOrUndefined(value)) {
            if (option.type === "list") {
                var values = value;
                if (option.element.isFilePath && values.length) {
                    return values.map(toAbsolutePath);
                }
            }
            else if (option.isFilePath) {
                return toAbsolutePath(value);
            }
        }
        return value;
    }
    function parseJsonConfigFileContent(json, host, basePath, existingOptions, configFileName, resolutionStack, extraFileExtensions, extendedConfigCache, existingWatchOptions) {
        return parseJsonConfigFileContentWorker(json, undefined, host, basePath, existingOptions, existingWatchOptions, configFileName, resolutionStack, extraFileExtensions, extendedConfigCache);
    }
    ts.parseJsonConfigFileContent = parseJsonConfigFileContent;
    function parseJsonSourceFileConfigFileContent(sourceFile, host, basePath, existingOptions, configFileName, resolutionStack, extraFileExtensions, extendedConfigCache, existingWatchOptions) {
        ts.tracing === null || ts.tracing === void 0 ? void 0 : ts.tracing.push("parse", "parseJsonSourceFileConfigFileContent", { path: sourceFile.fileName });
        var result = parseJsonConfigFileContentWorker(undefined, sourceFile, host, basePath, existingOptions, existingWatchOptions, configFileName, resolutionStack, extraFileExtensions, extendedConfigCache);
        ts.tracing === null || ts.tracing === void 0 ? void 0 : ts.tracing.pop();
        return result;
    }
    ts.parseJsonSourceFileConfigFileContent = parseJsonSourceFileConfigFileContent;
    function setConfigFileInOptions(options, configFile) {
        if (configFile) {
            Object.defineProperty(options, "configFile", { enumerable: false, writable: false, value: configFile });
        }
    }
    ts.setConfigFileInOptions = setConfigFileInOptions;
    function isNullOrUndefined(x) {
        return x === undefined || x === null;
    }
    function directoryOfCombinedPath(fileName, basePath) {
        return ts.getDirectoryPath(ts.getNormalizedAbsolutePath(fileName, basePath));
    }
    function parseJsonConfigFileContentWorker(json, sourceFile, host, basePath, existingOptions, existingWatchOptions, configFileName, resolutionStack, extraFileExtensions, extendedConfigCache) {
        if (existingOptions === void 0) { existingOptions = {}; }
        if (resolutionStack === void 0) { resolutionStack = []; }
        if (extraFileExtensions === void 0) { extraFileExtensions = []; }
        ts.Debug.assert((json === undefined && sourceFile !== undefined) || (json !== undefined && sourceFile === undefined));
        var errors = [];
        var parsedConfig = parseConfig(json, sourceFile, host, basePath, configFileName, resolutionStack, errors, extendedConfigCache);
        var raw = parsedConfig.raw;
        var options = ts.extend(existingOptions, parsedConfig.options || {});
        var watchOptions = existingWatchOptions && parsedConfig.watchOptions ?
            ts.extend(existingWatchOptions, parsedConfig.watchOptions) :
            parsedConfig.watchOptions || existingWatchOptions;
        options.configFilePath = configFileName && ts.normalizeSlashes(configFileName);
        var configFileSpecs = getConfigFileSpecs();
        if (sourceFile)
            sourceFile.configFileSpecs = configFileSpecs;
        setConfigFileInOptions(options, sourceFile);
        var basePathForFileNames = ts.normalizePath(configFileName ? directoryOfCombinedPath(configFileName, basePath) : basePath);
        return {
            options: options,
            watchOptions: watchOptions,
            fileNames: getFileNames(basePathForFileNames),
            projectReferences: getProjectReferences(basePathForFileNames),
            typeAcquisition: parsedConfig.typeAcquisition || getDefaultTypeAcquisition(),
            raw: raw,
            errors: errors,
            wildcardDirectories: getWildcardDirectories(configFileSpecs, basePathForFileNames, host.useCaseSensitiveFileNames),
            compileOnSave: !!raw.compileOnSave,
        };
        function getConfigFileSpecs() {
            var referencesOfRaw = getPropFromRaw("references", function (element) { return typeof element === "object"; }, "object");
            var filesSpecs = toPropValue(getSpecsFromRaw("files"));
            if (filesSpecs) {
                var hasZeroOrNoReferences = referencesOfRaw === "no-prop" || ts.isArray(referencesOfRaw) && referencesOfRaw.length === 0;
                var hasExtends = ts.hasProperty(raw, "extends");
                if (filesSpecs.length === 0 && hasZeroOrNoReferences && !hasExtends) {
                    if (sourceFile) {
                        var fileName = configFileName || "tsconfig.json";
                        var diagnosticMessage = ts.Diagnostics.The_files_list_in_config_file_0_is_empty;
                        var nodeValue = ts.firstDefined(ts.getTsConfigPropArray(sourceFile, "files"), function (property) { return property.initializer; });
                        var error = nodeValue
                            ? ts.createDiagnosticForNodeInSourceFile(sourceFile, nodeValue, diagnosticMessage, fileName)
                            : ts.createCompilerDiagnostic(diagnosticMessage, fileName);
                        errors.push(error);
                    }
                    else {
                        createCompilerDiagnosticOnlyIfJson(ts.Diagnostics.The_files_list_in_config_file_0_is_empty, configFileName || "tsconfig.json");
                    }
                }
            }
            var includeSpecs = toPropValue(getSpecsFromRaw("include"));
            var excludeOfRaw = getSpecsFromRaw("exclude");
            var excludeSpecs = toPropValue(excludeOfRaw);
            if (excludeOfRaw === "no-prop" && raw.compilerOptions) {
                var outDir = raw.compilerOptions.outDir;
                var declarationDir = raw.compilerOptions.declarationDir;
                if (outDir || declarationDir) {
                    excludeSpecs = [outDir, declarationDir].filter(function (d) { return !!d; });
                }
            }
            if (filesSpecs === undefined && includeSpecs === undefined) {
                includeSpecs = ["**/*"];
            }
            var validatedIncludeSpecs, validatedExcludeSpecs;
            if (includeSpecs) {
                validatedIncludeSpecs = validateSpecs(includeSpecs, errors, true, sourceFile, "include");
            }
            if (excludeSpecs) {
                validatedExcludeSpecs = validateSpecs(excludeSpecs, errors, false, sourceFile, "exclude");
            }
            return {
                filesSpecs: filesSpecs,
                includeSpecs: includeSpecs,
                excludeSpecs: excludeSpecs,
                validatedFilesSpec: ts.filter(filesSpecs, ts.isString),
                validatedIncludeSpecs: validatedIncludeSpecs,
                validatedExcludeSpecs: validatedExcludeSpecs,
                pathPatterns: undefined,
            };
        }
        function getFileNames(basePath) {
            var fileNames = getFileNamesFromConfigSpecs(configFileSpecs, basePath, options, host, extraFileExtensions);
            if (shouldReportNoInputFiles(fileNames, canJsonReportNoInputFiles(raw), resolutionStack)) {
                errors.push(getErrorForNoInputFiles(configFileSpecs, configFileName));
            }
            return fileNames;
        }
        function getProjectReferences(basePath) {
            var projectReferences;
            var referencesOfRaw = getPropFromRaw("references", function (element) { return typeof element === "object"; }, "object");
            if (ts.isArray(referencesOfRaw)) {
                for (var _i = 0, referencesOfRaw_1 = referencesOfRaw; _i < referencesOfRaw_1.length; _i++) {
                    var ref = referencesOfRaw_1[_i];
                    if (typeof ref.path !== "string") {
                        createCompilerDiagnosticOnlyIfJson(ts.Diagnostics.Compiler_option_0_requires_a_value_of_type_1, "reference.path", "string");
                    }
                    else {
                        (projectReferences || (projectReferences = [])).push({
                            path: ts.getNormalizedAbsolutePath(ref.path, basePath),
                            originalPath: ref.path,
                            prepend: ref.prepend,
                            circular: ref.circular
                        });
                    }
                }
            }
            return projectReferences;
        }
        function toPropValue(specResult) {
            return ts.isArray(specResult) ? specResult : undefined;
        }
        function getSpecsFromRaw(prop) {
            return getPropFromRaw(prop, ts.isString, "string");
        }
        function getPropFromRaw(prop, validateElement, elementTypeName) {
            if (ts.hasProperty(raw, prop) && !isNullOrUndefined(raw[prop])) {
                if (ts.isArray(raw[prop])) {
                    var result = raw[prop];
                    if (!sourceFile && !ts.every(result, validateElement)) {
                        errors.push(ts.createCompilerDiagnostic(ts.Diagnostics.Compiler_option_0_requires_a_value_of_type_1, prop, elementTypeName));
                    }
                    return result;
                }
                else {
                    createCompilerDiagnosticOnlyIfJson(ts.Diagnostics.Compiler_option_0_requires_a_value_of_type_1, prop, "Array");
                    return "not-array";
                }
            }
            return "no-prop";
        }
        function createCompilerDiagnosticOnlyIfJson(message, arg0, arg1) {
            if (!sourceFile) {
                errors.push(ts.createCompilerDiagnostic(message, arg0, arg1));
            }
        }
    }
    function isErrorNoInputFiles(error) {
        return error.code === ts.Diagnostics.No_inputs_were_found_in_config_file_0_Specified_include_paths_were_1_and_exclude_paths_were_2.code;
    }
    function getErrorForNoInputFiles(_a, configFileName) {
        var includeSpecs = _a.includeSpecs, excludeSpecs = _a.excludeSpecs;
        return ts.createCompilerDiagnostic(ts.Diagnostics.No_inputs_were_found_in_config_file_0_Specified_include_paths_were_1_and_exclude_paths_were_2, configFileName || "tsconfig.json", JSON.stringify(includeSpecs || []), JSON.stringify(excludeSpecs || []));
    }
    function shouldReportNoInputFiles(fileNames, canJsonReportNoInutFiles, resolutionStack) {
        return fileNames.length === 0 && canJsonReportNoInutFiles && (!resolutionStack || resolutionStack.length === 0);
    }
    function canJsonReportNoInputFiles(raw) {
        return !ts.hasProperty(raw, "files") && !ts.hasProperty(raw, "references");
    }
    ts.canJsonReportNoInputFiles = canJsonReportNoInputFiles;
    function updateErrorForNoInputFiles(fileNames, configFileName, configFileSpecs, configParseDiagnostics, canJsonReportNoInutFiles) {
        var existingErrors = configParseDiagnostics.length;
        if (shouldReportNoInputFiles(fileNames, canJsonReportNoInutFiles)) {
            configParseDiagnostics.push(getErrorForNoInputFiles(configFileSpecs, configFileName));
        }
        else {
            ts.filterMutate(configParseDiagnostics, function (error) { return !isErrorNoInputFiles(error); });
        }
        return existingErrors !== configParseDiagnostics.length;
    }
    ts.updateErrorForNoInputFiles = updateErrorForNoInputFiles;
    function isSuccessfulParsedTsconfig(value) {
        return !!value.options;
    }
    function parseConfig(json, sourceFile, host, basePath, configFileName, resolutionStack, errors, extendedConfigCache) {
        var _a;
        basePath = ts.normalizeSlashes(basePath);
        var resolvedPath = ts.getNormalizedAbsolutePath(configFileName || "", basePath);
        if (resolutionStack.indexOf(resolvedPath) >= 0) {
            errors.push(ts.createCompilerDiagnostic(ts.Diagnostics.Circularity_detected_while_resolving_configuration_Colon_0, __spreadArray(__spreadArray([], resolutionStack, true), [resolvedPath], false).join(" -> ")));
            return { raw: json || convertToObject(sourceFile, errors) };
        }
        var ownConfig = json ?
            parseOwnConfigOfJson(json, host, basePath, configFileName, errors) :
            parseOwnConfigOfJsonSourceFile(sourceFile, host, basePath, configFileName, errors);
        if ((_a = ownConfig.options) === null || _a === void 0 ? void 0 : _a.paths) {
            ownConfig.options.pathsBasePath = basePath;
        }
        if (ownConfig.extendedConfigPath) {
            resolutionStack = resolutionStack.concat([resolvedPath]);
            var extendedConfig = getExtendedConfig(sourceFile, ownConfig.extendedConfigPath, host, resolutionStack, errors, extendedConfigCache);
            if (extendedConfig && isSuccessfulParsedTsconfig(extendedConfig)) {
                var baseRaw_1 = extendedConfig.raw;
                var raw_1 = ownConfig.raw;
                var relativeDifference_1;
                var setPropertyInRawIfNotUndefined = function (propertyName) {
                    if (!raw_1[propertyName] && baseRaw_1[propertyName]) {
                        raw_1[propertyName] = ts.map(baseRaw_1[propertyName], function (path) { return ts.isRootedDiskPath(path) ? path : ts.combinePaths(relativeDifference_1 || (relativeDifference_1 = ts.convertToRelativePath(ts.getDirectoryPath(ownConfig.extendedConfigPath), basePath, ts.createGetCanonicalFileName(host.useCaseSensitiveFileNames))), path); });
                    }
                };
                setPropertyInRawIfNotUndefined("include");
                setPropertyInRawIfNotUndefined("exclude");
                setPropertyInRawIfNotUndefined("files");
                if (raw_1.compileOnSave === undefined) {
                    raw_1.compileOnSave = baseRaw_1.compileOnSave;
                }
                ownConfig.options = ts.assign({}, extendedConfig.options, ownConfig.options);
                ownConfig.watchOptions = ownConfig.watchOptions && extendedConfig.watchOptions ?
                    ts.assign({}, extendedConfig.watchOptions, ownConfig.watchOptions) :
                    ownConfig.watchOptions || extendedConfig.watchOptions;
            }
        }
        return ownConfig;
    }
    function parseOwnConfigOfJson(json, host, basePath, configFileName, errors) {
        if (ts.hasProperty(json, "excludes")) {
            errors.push(ts.createCompilerDiagnostic(ts.Diagnostics.Unknown_option_excludes_Did_you_mean_exclude));
        }
        var options = convertCompilerOptionsFromJsonWorker(json.compilerOptions, basePath, errors, configFileName);
        var typeAcquisition = convertTypeAcquisitionFromJsonWorker(json.typeAcquisition || json.typingOptions, basePath, errors, configFileName);
        var watchOptions = convertWatchOptionsFromJsonWorker(json.watchOptions, basePath, errors);
        json.compileOnSave = convertCompileOnSaveOptionFromJson(json, basePath, errors);
        var extendedConfigPath;
        if (json.extends) {
            if (!ts.isString(json.extends)) {
                errors.push(ts.createCompilerDiagnostic(ts.Diagnostics.Compiler_option_0_requires_a_value_of_type_1, "extends", "string"));
            }
            else {
                var newBase = configFileName ? directoryOfCombinedPath(configFileName, basePath) : basePath;
                extendedConfigPath = getExtendsConfigPath(json.extends, host, newBase, errors, ts.createCompilerDiagnostic);
            }
        }
        return { raw: json, options: options, watchOptions: watchOptions, typeAcquisition: typeAcquisition, extendedConfigPath: extendedConfigPath };
    }
    function parseOwnConfigOfJsonSourceFile(sourceFile, host, basePath, configFileName, errors) {
        var options = getDefaultCompilerOptions(configFileName);
        var typeAcquisition, typingOptionstypeAcquisition;
        var watchOptions;
        var extendedConfigPath;
        var rootCompilerOptions;
        var optionsIterator = {
            onSetValidOptionKeyValueInParent: function (parentOption, option, value) {
                var currentOption;
                switch (parentOption) {
                    case "compilerOptions":
                        currentOption = options;
                        break;
                    case "watchOptions":
                        currentOption = (watchOptions || (watchOptions = {}));
                        break;
                    case "typeAcquisition":
                        currentOption = (typeAcquisition || (typeAcquisition = getDefaultTypeAcquisition(configFileName)));
                        break;
                    case "typingOptions":
                        currentOption = (typingOptionstypeAcquisition || (typingOptionstypeAcquisition = getDefaultTypeAcquisition(configFileName)));
                        break;
                    default:
                        ts.Debug.fail("Unknown option");
                }
                currentOption[option.name] = normalizeOptionValue(option, basePath, value);
            },
            onSetValidOptionKeyValueInRoot: function (key, _keyNode, value, valueNode) {
                switch (key) {
                    case "extends":
                        var newBase = configFileName ? directoryOfCombinedPath(configFileName, basePath) : basePath;
                        extendedConfigPath = getExtendsConfigPath(value, host, newBase, errors, function (message, arg0) {
                            return ts.createDiagnosticForNodeInSourceFile(sourceFile, valueNode, message, arg0);
                        });
                        return;
                }
            },
            onSetUnknownOptionKeyValueInRoot: function (key, keyNode, _value, _valueNode) {
                if (key === "excludes") {
                    errors.push(ts.createDiagnosticForNodeInSourceFile(sourceFile, keyNode, ts.Diagnostics.Unknown_option_excludes_Did_you_mean_exclude));
                }
                if (ts.find(commandOptionsWithoutBuild, function (opt) { return opt.name === key; })) {
                    rootCompilerOptions = ts.append(rootCompilerOptions, keyNode);
                }
            }
        };
        var json = convertConfigFileToObject(sourceFile, errors, true, optionsIterator);
        if (!typeAcquisition) {
            if (typingOptionstypeAcquisition) {
                typeAcquisition = (typingOptionstypeAcquisition.enableAutoDiscovery !== undefined) ?
                    {
                        enable: typingOptionstypeAcquisition.enableAutoDiscovery,
                        include: typingOptionstypeAcquisition.include,
                        exclude: typingOptionstypeAcquisition.exclude
                    } :
                    typingOptionstypeAcquisition;
            }
            else {
                typeAcquisition = getDefaultTypeAcquisition(configFileName);
            }
        }
        if (rootCompilerOptions && json && json.compilerOptions === undefined) {
            errors.push(ts.createDiagnosticForNodeInSourceFile(sourceFile, rootCompilerOptions[0], ts.Diagnostics._0_should_be_set_inside_the_compilerOptions_object_of_the_config_json_file, ts.getTextOfPropertyName(rootCompilerOptions[0])));
        }
        return { raw: json, options: options, watchOptions: watchOptions, typeAcquisition: typeAcquisition, extendedConfigPath: extendedConfigPath };
    }
    function getExtendsConfigPath(extendedConfig, host, basePath, errors, createDiagnostic) {
        extendedConfig = ts.normalizeSlashes(extendedConfig);
        if (ts.isRootedDiskPath(extendedConfig) || ts.startsWith(extendedConfig, "./") || ts.startsWith(extendedConfig, "../")) {
            var extendedConfigPath = ts.getNormalizedAbsolutePath(extendedConfig, basePath);
            if (!host.fileExists(extendedConfigPath) && !ts.endsWith(extendedConfigPath, ".json")) {
                extendedConfigPath = "".concat(extendedConfigPath, ".json");
                if (!host.fileExists(extendedConfigPath)) {
                    errors.push(createDiagnostic(ts.Diagnostics.File_0_not_found, extendedConfig));
                    return undefined;
                }
            }
            return extendedConfigPath;
        }
        var resolved = ts.nodeModuleNameResolver(extendedConfig, ts.combinePaths(basePath, "tsconfig.json"), { moduleResolution: ts.ModuleResolutionKind.NodeJs }, host, undefined, undefined, true);
        if (resolved.resolvedModule) {
            return resolved.resolvedModule.resolvedFileName;
        }
        errors.push(createDiagnostic(ts.Diagnostics.File_0_not_found, extendedConfig));
        return undefined;
    }
    function getExtendedConfig(sourceFile, extendedConfigPath, host, resolutionStack, errors, extendedConfigCache) {
        var _a;
        var path = host.useCaseSensitiveFileNames ? extendedConfigPath : ts.toFileNameLowerCase(extendedConfigPath);
        var value;
        var extendedResult;
        var extendedConfig;
        if (extendedConfigCache && (value = extendedConfigCache.get(path))) {
            (extendedResult = value.extendedResult, extendedConfig = value.extendedConfig);
        }
        else {
            extendedResult = readJsonConfigFile(extendedConfigPath, function (path) { return host.readFile(path); });
            if (!extendedResult.parseDiagnostics.length) {
                extendedConfig = parseConfig(undefined, extendedResult, host, ts.getDirectoryPath(extendedConfigPath), ts.getBaseFileName(extendedConfigPath), resolutionStack, errors, extendedConfigCache);
            }
            if (extendedConfigCache) {
                extendedConfigCache.set(path, { extendedResult: extendedResult, extendedConfig: extendedConfig });
            }
        }
        if (sourceFile) {
            sourceFile.extendedSourceFiles = [extendedResult.fileName];
            if (extendedResult.extendedSourceFiles) {
                (_a = sourceFile.extendedSourceFiles).push.apply(_a, extendedResult.extendedSourceFiles);
            }
        }
        if (extendedResult.parseDiagnostics.length) {
            errors.push.apply(errors, extendedResult.parseDiagnostics);
            return undefined;
        }
        return extendedConfig;
    }
    function convertCompileOnSaveOptionFromJson(jsonOption, basePath, errors) {
        if (!ts.hasProperty(jsonOption, ts.compileOnSaveCommandLineOption.name)) {
            return false;
        }
        var result = convertJsonOption(ts.compileOnSaveCommandLineOption, jsonOption.compileOnSave, basePath, errors);
        return typeof result === "boolean" && result;
    }
    function convertCompilerOptionsFromJson(jsonOptions, basePath, configFileName) {
        var errors = [];
        var options = convertCompilerOptionsFromJsonWorker(jsonOptions, basePath, errors, configFileName);
        return { options: options, errors: errors };
    }
    ts.convertCompilerOptionsFromJson = convertCompilerOptionsFromJson;
    function convertTypeAcquisitionFromJson(jsonOptions, basePath, configFileName) {
        var errors = [];
        var options = convertTypeAcquisitionFromJsonWorker(jsonOptions, basePath, errors, configFileName);
        return { options: options, errors: errors };
    }
    ts.convertTypeAcquisitionFromJson = convertTypeAcquisitionFromJson;
    function getDefaultCompilerOptions(configFileName) {
        var options = configFileName && ts.getBaseFileName(configFileName) === "jsconfig.json"
            ? { allowJs: true, maxNodeModuleJsDepth: 2, allowSyntheticDefaultImports: true, skipLibCheck: true, noEmit: true }
            : {};
        return options;
    }
    function convertCompilerOptionsFromJsonWorker(jsonOptions, basePath, errors, configFileName) {
        var options = getDefaultCompilerOptions(configFileName);
        convertOptionsFromJson(getCommandLineCompilerOptionsMap(), jsonOptions, basePath, options, ts.compilerOptionsDidYouMeanDiagnostics, errors);
        if (configFileName) {
            options.configFilePath = ts.normalizeSlashes(configFileName);
        }
        return options;
    }
    function getDefaultTypeAcquisition(configFileName) {
        return { enable: !!configFileName && ts.getBaseFileName(configFileName) === "jsconfig.json", include: [], exclude: [] };
    }
    function convertTypeAcquisitionFromJsonWorker(jsonOptions, basePath, errors, configFileName) {
        var options = getDefaultTypeAcquisition(configFileName);
        var typeAcquisition = convertEnableAutoDiscoveryToEnable(jsonOptions);
        convertOptionsFromJson(getCommandLineTypeAcquisitionMap(), typeAcquisition, basePath, options, typeAcquisitionDidYouMeanDiagnostics, errors);
        return options;
    }
    function convertWatchOptionsFromJsonWorker(jsonOptions, basePath, errors) {
        return convertOptionsFromJson(getCommandLineWatchOptionsMap(), jsonOptions, basePath, undefined, watchOptionsDidYouMeanDiagnostics, errors);
    }
    function convertOptionsFromJson(optionsNameMap, jsonOptions, basePath, defaultOptions, diagnostics, errors) {
        if (!jsonOptions) {
            return;
        }
        for (var id in jsonOptions) {
            var opt = optionsNameMap.get(id);
            if (opt) {
                (defaultOptions || (defaultOptions = {}))[opt.name] = convertJsonOption(opt, jsonOptions[id], basePath, errors);
            }
            else {
                errors.push(createUnknownOptionError(id, diagnostics, ts.createCompilerDiagnostic));
            }
        }
        return defaultOptions;
    }
    function convertJsonOption(opt, value, basePath, errors) {
        if (isCompilerOptionsValue(opt, value)) {
            var optType = opt.type;
            if (optType === "list" && ts.isArray(value)) {
                return convertJsonOptionOfListType(opt, value, basePath, errors);
            }
            else if (!ts.isString(optType)) {
                return convertJsonOptionOfCustomType(opt, value, errors);
            }
            var validatedValue = validateJsonOptionValue(opt, value, errors);
            return isNullOrUndefined(validatedValue) ? validatedValue : normalizeNonListOptionValue(opt, basePath, validatedValue);
        }
        else {
            errors.push(ts.createCompilerDiagnostic(ts.Diagnostics.Compiler_option_0_requires_a_value_of_type_1, opt.name, getCompilerOptionValueTypeString(opt)));
        }
    }
    ts.convertJsonOption = convertJsonOption;
    function normalizeOptionValue(option, basePath, value) {
        if (isNullOrUndefined(value))
            return undefined;
        if (option.type === "list") {
            var listOption_1 = option;
            if (listOption_1.element.isFilePath || !ts.isString(listOption_1.element.type)) {
                return ts.filter(ts.map(value, function (v) { return normalizeOptionValue(listOption_1.element, basePath, v); }), function (v) { return listOption_1.listPreserveFalsyValues ? true : !!v; });
            }
            return value;
        }
        else if (!ts.isString(option.type)) {
            return option.type.get(ts.isString(value) ? value.toLowerCase() : value);
        }
        return normalizeNonListOptionValue(option, basePath, value);
    }
    function normalizeNonListOptionValue(option, basePath, value) {
        if (option.isFilePath) {
            value = ts.getNormalizedAbsolutePath(value, basePath);
            if (value === "") {
                value = ".";
            }
        }
        return value;
    }
    function validateJsonOptionValue(opt, value, errors) {
        var _a;
        if (isNullOrUndefined(value))
            return undefined;
        var d = (_a = opt.extraValidation) === null || _a === void 0 ? void 0 : _a.call(opt, value);
        if (!d)
            return value;
        errors.push(ts.createCompilerDiagnostic.apply(void 0, d));
        return undefined;
    }
    function convertJsonOptionOfCustomType(opt, value, errors) {
        if (isNullOrUndefined(value))
            return undefined;
        var key = value.toLowerCase();
        var val = opt.type.get(key);
        if (val !== undefined) {
            return validateJsonOptionValue(opt, val, errors);
        }
        else {
            errors.push(createCompilerDiagnosticForInvalidCustomType(opt));
        }
    }
    function convertJsonOptionOfListType(option, values, basePath, errors) {
        return ts.filter(ts.map(values, function (v) { return convertJsonOption(option.element, v, basePath, errors); }), function (v) { return option.listPreserveFalsyValues ? true : !!v; });
    }
    var invalidTrailingRecursionPattern = /(^|\/)\*\*\/?$/;
    var wildcardDirectoryPattern = /^[^*?]*(?=\/[^/]*[*?])/;
    function getFileNamesFromConfigSpecs(configFileSpecs, basePath, options, host, extraFileExtensions) {
        if (extraFileExtensions === void 0) { extraFileExtensions = ts.emptyArray; }
        basePath = ts.normalizePath(basePath);
        var keyMapper = ts.createGetCanonicalFileName(host.useCaseSensitiveFileNames);
        var literalFileMap = new ts.Map();
        var wildcardFileMap = new ts.Map();
        var wildCardJsonFileMap = new ts.Map();
        var validatedFilesSpec = configFileSpecs.validatedFilesSpec, validatedIncludeSpecs = configFileSpecs.validatedIncludeSpecs, validatedExcludeSpecs = configFileSpecs.validatedExcludeSpecs;
        var supportedExtensions = ts.getSupportedExtensions(options, extraFileExtensions);
        var supportedExtensionsWithJsonIfResolveJsonModule = ts.getSupportedExtensionsWithJsonIfResolveJsonModule(options, supportedExtensions);
        if (validatedFilesSpec) {
            for (var _i = 0, validatedFilesSpec_1 = validatedFilesSpec; _i < validatedFilesSpec_1.length; _i++) {
                var fileName = validatedFilesSpec_1[_i];
                var file = ts.getNormalizedAbsolutePath(fileName, basePath);
                literalFileMap.set(keyMapper(file), file);
            }
        }
        var jsonOnlyIncludeRegexes;
        if (validatedIncludeSpecs && validatedIncludeSpecs.length > 0) {
            var _loop_6 = function (file) {
                if (ts.fileExtensionIs(file, ".json")) {
                    if (!jsonOnlyIncludeRegexes) {
                        var includes = validatedIncludeSpecs.filter(function (s) { return ts.endsWith(s, ".json"); });
                        var includeFilePatterns = ts.map(ts.getRegularExpressionsForWildcards(includes, basePath, "files"), function (pattern) { return "^".concat(pattern, "$"); });
                        jsonOnlyIncludeRegexes = includeFilePatterns ? includeFilePatterns.map(function (pattern) { return ts.getRegexFromPattern(pattern, host.useCaseSensitiveFileNames); }) : ts.emptyArray;
                    }
                    var includeIndex = ts.findIndex(jsonOnlyIncludeRegexes, function (re) { return re.test(file); });
                    if (includeIndex !== -1) {
                        var key_1 = keyMapper(file);
                        if (!literalFileMap.has(key_1) && !wildCardJsonFileMap.has(key_1)) {
                            wildCardJsonFileMap.set(key_1, file);
                        }
                    }
                    return "continue";
                }
                if (hasFileWithHigherPriorityExtension(file, literalFileMap, wildcardFileMap, supportedExtensions, keyMapper)) {
                    return "continue";
                }
                removeWildcardFilesWithLowerPriorityExtension(file, wildcardFileMap, supportedExtensions, keyMapper);
                var key = keyMapper(file);
                if (!literalFileMap.has(key) && !wildcardFileMap.has(key)) {
                    wildcardFileMap.set(key, file);
                }
            };
            for (var _a = 0, _b = host.readDirectory(basePath, ts.flatten(supportedExtensionsWithJsonIfResolveJsonModule), validatedExcludeSpecs, validatedIncludeSpecs, undefined); _a < _b.length; _a++) {
                var file = _b[_a];
                _loop_6(file);
            }
        }
        var literalFiles = ts.arrayFrom(literalFileMap.values());
        var wildcardFiles = ts.arrayFrom(wildcardFileMap.values());
        return literalFiles.concat(wildcardFiles, ts.arrayFrom(wildCardJsonFileMap.values()));
    }
    ts.getFileNamesFromConfigSpecs = getFileNamesFromConfigSpecs;
    function isExcludedFile(pathToCheck, spec, basePath, useCaseSensitiveFileNames, currentDirectory) {
        var validatedFilesSpec = spec.validatedFilesSpec, validatedIncludeSpecs = spec.validatedIncludeSpecs, validatedExcludeSpecs = spec.validatedExcludeSpecs;
        if (!ts.length(validatedIncludeSpecs) || !ts.length(validatedExcludeSpecs))
            return false;
        basePath = ts.normalizePath(basePath);
        var keyMapper = ts.createGetCanonicalFileName(useCaseSensitiveFileNames);
        if (validatedFilesSpec) {
            for (var _i = 0, validatedFilesSpec_2 = validatedFilesSpec; _i < validatedFilesSpec_2.length; _i++) {
                var fileName = validatedFilesSpec_2[_i];
                if (keyMapper(ts.getNormalizedAbsolutePath(fileName, basePath)) === pathToCheck)
                    return false;
            }
        }
        return matchesExcludeWorker(pathToCheck, validatedExcludeSpecs, useCaseSensitiveFileNames, currentDirectory, basePath);
    }
    ts.isExcludedFile = isExcludedFile;
    function invalidDotDotAfterRecursiveWildcard(s) {
        var wildcardIndex = ts.startsWith(s, "**/") ? 0 : s.indexOf("/**/");
        if (wildcardIndex === -1) {
            return false;
        }
        var lastDotIndex = ts.endsWith(s, "/..") ? s.length : s.lastIndexOf("/../");
        return lastDotIndex > wildcardIndex;
    }
    function matchesExclude(pathToCheck, excludeSpecs, useCaseSensitiveFileNames, currentDirectory) {
        return matchesExcludeWorker(pathToCheck, ts.filter(excludeSpecs, function (spec) { return !invalidDotDotAfterRecursiveWildcard(spec); }), useCaseSensitiveFileNames, currentDirectory);
    }
    ts.matchesExclude = matchesExclude;
    function matchesExcludeWorker(pathToCheck, excludeSpecs, useCaseSensitiveFileNames, currentDirectory, basePath) {
        var excludePattern = ts.getRegularExpressionForWildcard(excludeSpecs, ts.combinePaths(ts.normalizePath(currentDirectory), basePath), "exclude");
        var excludeRegex = excludePattern && ts.getRegexFromPattern(excludePattern, useCaseSensitiveFileNames);
        if (!excludeRegex)
            return false;
        if (excludeRegex.test(pathToCheck))
            return true;
        return !ts.hasExtension(pathToCheck) && excludeRegex.test(ts.ensureTrailingDirectorySeparator(pathToCheck));
    }
    function validateSpecs(specs, errors, disallowTrailingRecursion, jsonSourceFile, specKey) {
        return specs.filter(function (spec) {
            if (!ts.isString(spec))
                return false;
            var diag = specToDiagnostic(spec, disallowTrailingRecursion);
            if (diag !== undefined) {
                errors.push(createDiagnostic.apply(void 0, diag));
            }
            return diag === undefined;
        });
        function createDiagnostic(message, spec) {
            var element = ts.getTsConfigPropArrayElementValue(jsonSourceFile, specKey, spec);
            return element ?
                ts.createDiagnosticForNodeInSourceFile(jsonSourceFile, element, message, spec) :
                ts.createCompilerDiagnostic(message, spec);
        }
    }
    function specToDiagnostic(spec, disallowTrailingRecursion) {
        if (disallowTrailingRecursion && invalidTrailingRecursionPattern.test(spec)) {
            return [ts.Diagnostics.File_specification_cannot_end_in_a_recursive_directory_wildcard_Asterisk_Asterisk_Colon_0, spec];
        }
        else if (invalidDotDotAfterRecursiveWildcard(spec)) {
            return [ts.Diagnostics.File_specification_cannot_contain_a_parent_directory_that_appears_after_a_recursive_directory_wildcard_Asterisk_Asterisk_Colon_0, spec];
        }
    }
    function getWildcardDirectories(_a, path, useCaseSensitiveFileNames) {
        var include = _a.validatedIncludeSpecs, exclude = _a.validatedExcludeSpecs;
        var rawExcludeRegex = ts.getRegularExpressionForWildcard(exclude, path, "exclude");
        var excludeRegex = rawExcludeRegex && new RegExp(rawExcludeRegex, useCaseSensitiveFileNames ? "" : "i");
        var wildcardDirectories = {};
        if (include !== undefined) {
            var recursiveKeys = [];
            for (var _i = 0, include_1 = include; _i < include_1.length; _i++) {
                var file = include_1[_i];
                var spec = ts.normalizePath(ts.combinePaths(path, file));
                if (excludeRegex && excludeRegex.test(spec)) {
                    continue;
                }
                var match = getWildcardDirectoryFromSpec(spec, useCaseSensitiveFileNames);
                if (match) {
                    var key = match.key, flags = match.flags;
                    var existingFlags = wildcardDirectories[key];
                    if (existingFlags === undefined || existingFlags < flags) {
                        wildcardDirectories[key] = flags;
                        if (flags === 1) {
                            recursiveKeys.push(key);
                        }
                    }
                }
            }
            for (var key in wildcardDirectories) {
                if (ts.hasProperty(wildcardDirectories, key)) {
                    for (var _b = 0, recursiveKeys_1 = recursiveKeys; _b < recursiveKeys_1.length; _b++) {
                        var recursiveKey = recursiveKeys_1[_b];
                        if (key !== recursiveKey && ts.containsPath(recursiveKey, key, path, !useCaseSensitiveFileNames)) {
                            delete wildcardDirectories[key];
                        }
                    }
                }
            }
        }
        return wildcardDirectories;
    }
    function getWildcardDirectoryFromSpec(spec, useCaseSensitiveFileNames) {
        var match = wildcardDirectoryPattern.exec(spec);
        if (match) {
            var questionWildcardIndex = spec.indexOf("?");
            var starWildcardIndex = spec.indexOf("*");
            var lastDirectorySeperatorIndex = spec.lastIndexOf(ts.directorySeparator);
            return {
                key: useCaseSensitiveFileNames ? match[0] : ts.toFileNameLowerCase(match[0]),
                flags: (questionWildcardIndex !== -1 && questionWildcardIndex < lastDirectorySeperatorIndex)
                    || (starWildcardIndex !== -1 && starWildcardIndex < lastDirectorySeperatorIndex)
                    ? 1 : 0
            };
        }
        if (ts.isImplicitGlob(spec.substring(spec.lastIndexOf(ts.directorySeparator) + 1))) {
            return {
                key: ts.removeTrailingDirectorySeparator(useCaseSensitiveFileNames ? spec : ts.toFileNameLowerCase(spec)),
                flags: 1
            };
        }
        return undefined;
    }
    function hasFileWithHigherPriorityExtension(file, literalFiles, wildcardFiles, extensions, keyMapper) {
        var extensionGroup = ts.forEach(extensions, function (group) { return ts.fileExtensionIsOneOf(file, group) ? group : undefined; });
        if (!extensionGroup) {
            return false;
        }
        for (var _i = 0, extensionGroup_1 = extensionGroup; _i < extensionGroup_1.length; _i++) {
            var ext = extensionGroup_1[_i];
            if (ts.fileExtensionIs(file, ext)) {
                return false;
            }
            var higherPriorityPath = keyMapper(ts.changeExtension(file, ext));
            if (literalFiles.has(higherPriorityPath) || wildcardFiles.has(higherPriorityPath)) {
                if (ext === ".d.ts" && (ts.fileExtensionIs(file, ".js") || ts.fileExtensionIs(file, ".jsx"))) {
                    continue;
                }
                return true;
            }
        }
        return false;
    }
    function removeWildcardFilesWithLowerPriorityExtension(file, wildcardFiles, extensions, keyMapper) {
        var extensionGroup = ts.forEach(extensions, function (group) { return ts.fileExtensionIsOneOf(file, group) ? group : undefined; });
        if (!extensionGroup) {
            return;
        }
        for (var i = extensionGroup.length - 1; i >= 0; i--) {
            var ext = extensionGroup[i];
            if (ts.fileExtensionIs(file, ext)) {
                return;
            }
            var lowerPriorityPath = keyMapper(ts.changeExtension(file, ext));
            wildcardFiles.delete(lowerPriorityPath);
        }
    }
    function convertCompilerOptionsForTelemetry(opts) {
        var out = {};
        for (var key in opts) {
            if (opts.hasOwnProperty(key)) {
                var type = getOptionFromName(key);
                if (type !== undefined) {
                    out[key] = getOptionValueWithEmptyStrings(opts[key], type);
                }
            }
        }
        return out;
    }
    ts.convertCompilerOptionsForTelemetry = convertCompilerOptionsForTelemetry;
    function getOptionValueWithEmptyStrings(value, option) {
        switch (option.type) {
            case "object":
                return "";
            case "string":
                return "";
            case "number":
                return typeof value === "number" ? value : "";
            case "boolean":
                return typeof value === "boolean" ? value : "";
            case "list":
                var elementType_1 = option.element;
                return ts.isArray(value) ? value.map(function (v) { return getOptionValueWithEmptyStrings(v, elementType_1); }) : "";
            default:
                return ts.forEachEntry(option.type, function (optionEnumValue, optionStringValue) {
                    if (optionEnumValue === value) {
                        return optionStringValue;
                    }
                });
        }
    }
    function getDefaultValueForOption(option) {
        switch (option.type) {
            case "number":
                return 1;
            case "boolean":
                return true;
            case "string":
                var defaultValue = option.defaultValueDescription;
                return option.isFilePath ? "./".concat(defaultValue && typeof defaultValue === "string" ? defaultValue : "") : "";
            case "list":
                return [];
            case "object":
                return {};
            default:
                var iterResult = option.type.keys().next();
                if (!iterResult.done)
                    return iterResult.value;
                return ts.Debug.fail("Expected 'option.type' to have entries.");
        }
    }
})(ts || (ts = {}));
var ts;
(function (ts) {
    function trace(host) {
        host.trace(ts.formatMessage.apply(undefined, arguments));
    }
    ts.trace = trace;
    function isTraceEnabled(compilerOptions, host) {
        return !!compilerOptions.traceResolution && host.trace !== undefined;
    }
    ts.isTraceEnabled = isTraceEnabled;
    function withPackageId(packageInfo, r) {
        var packageId;
        if (r && packageInfo) {
            var packageJsonContent = packageInfo.packageJsonContent;
            if (typeof packageJsonContent.name === "string" && typeof packageJsonContent.version === "string") {
                packageId = {
                    name: packageJsonContent.name,
                    subModuleName: r.path.slice(packageInfo.packageDirectory.length + ts.directorySeparator.length),
                    version: packageJsonContent.version
                };
            }
        }
        return r && { path: r.path, extension: r.ext, packageId: packageId };
    }
    function noPackageId(r) {
        return withPackageId(undefined, r);
    }
    function removeIgnoredPackageId(r) {
        if (r) {
            ts.Debug.assert(r.packageId === undefined);
            return { path: r.path, ext: r.extension };
        }
    }
    var Extensions;
    (function (Extensions) {
        Extensions[Extensions["TypeScript"] = 0] = "TypeScript";
        Extensions[Extensions["JavaScript"] = 1] = "JavaScript";
        Extensions[Extensions["Json"] = 2] = "Json";
        Extensions[Extensions["TSConfig"] = 3] = "TSConfig";
        Extensions[Extensions["DtsOnly"] = 4] = "DtsOnly";
        Extensions[Extensions["TsOnly"] = 5] = "TsOnly";
    })(Extensions || (Extensions = {}));
    function resolvedTypeScriptOnly(resolved) {
        if (!resolved) {
            return undefined;
        }
        ts.Debug.assert(ts.extensionIsTS(resolved.extension));
        return { fileName: resolved.path, packageId: resolved.packageId };
    }
    function createResolvedModuleWithFailedLookupLocations(resolved, isExternalLibraryImport, failedLookupLocations, diagnostics, resultFromCache) {
        var _a;
        if (resultFromCache) {
            (_a = resultFromCache.failedLookupLocations).push.apply(_a, failedLookupLocations);
            return resultFromCache;
        }
        return {
            resolvedModule: resolved && { resolvedFileName: resolved.path, originalPath: resolved.originalPath === true ? undefined : resolved.originalPath, extension: resolved.extension, isExternalLibraryImport: isExternalLibraryImport, packageId: resolved.packageId },
            failedLookupLocations: failedLookupLocations,
            resolutionDiagnostics: diagnostics
        };
    }
    function readPackageJsonField(jsonContent, fieldName, typeOfTag, state) {
        if (!ts.hasProperty(jsonContent, fieldName)) {
            if (state.traceEnabled) {
                trace(state.host, ts.Diagnostics.package_json_does_not_have_a_0_field, fieldName);
            }
            return;
        }
        var value = jsonContent[fieldName];
        if (typeof value !== typeOfTag || value === null) {
            if (state.traceEnabled) {
                trace(state.host, ts.Diagnostics.Expected_type_of_0_field_in_package_json_to_be_1_got_2, fieldName, typeOfTag, value === null ? "null" : typeof value);
            }
            return;
        }
        return value;
    }
    function readPackageJsonPathField(jsonContent, fieldName, baseDirectory, state) {
        var fileName = readPackageJsonField(jsonContent, fieldName, "string", state);
        if (fileName === undefined) {
            return;
        }
        if (!fileName) {
            if (state.traceEnabled) {
                trace(state.host, ts.Diagnostics.package_json_had_a_falsy_0_field, fieldName);
            }
            return;
        }
        var path = ts.normalizePath(ts.combinePaths(baseDirectory, fileName));
        if (state.traceEnabled) {
            trace(state.host, ts.Diagnostics.package_json_has_0_field_1_that_references_2, fieldName, fileName, path);
        }
        return path;
    }
    function readPackageJsonTypesFields(jsonContent, baseDirectory, state) {
        return readPackageJsonPathField(jsonContent, "typings", baseDirectory, state)
            || readPackageJsonPathField(jsonContent, "types", baseDirectory, state);
    }
    function readPackageJsonTSConfigField(jsonContent, baseDirectory, state) {
        return readPackageJsonPathField(jsonContent, "tsconfig", baseDirectory, state);
    }
    function readPackageJsonMainField(jsonContent, baseDirectory, state) {
        return readPackageJsonPathField(jsonContent, "main", baseDirectory, state);
    }
    function readPackageJsonTypesVersionsField(jsonContent, state) {
        var typesVersions = readPackageJsonField(jsonContent, "typesVersions", "object", state);
        if (typesVersions === undefined)
            return;
        if (state.traceEnabled) {
            trace(state.host, ts.Diagnostics.package_json_has_a_typesVersions_field_with_version_specific_path_mappings);
        }
        return typesVersions;
    }
    function readPackageJsonTypesVersionPaths(jsonContent, state) {
        var typesVersions = readPackageJsonTypesVersionsField(jsonContent, state);
        if (typesVersions === undefined)
            return;
        if (state.traceEnabled) {
            for (var key in typesVersions) {
                if (ts.hasProperty(typesVersions, key) && !ts.VersionRange.tryParse(key)) {
                    trace(state.host, ts.Diagnostics.package_json_has_a_typesVersions_entry_0_that_is_not_a_valid_semver_range, key);
                }
            }
        }
        var result = getPackageJsonTypesVersionsPaths(typesVersions);
        if (!result) {
            if (state.traceEnabled) {
                trace(state.host, ts.Diagnostics.package_json_does_not_have_a_typesVersions_entry_that_matches_version_0, ts.versionMajorMinor);
            }
            return;
        }
        var bestVersionKey = result.version, bestVersionPaths = result.paths;
        if (typeof bestVersionPaths !== "object") {
            if (state.traceEnabled) {
                trace(state.host, ts.Diagnostics.Expected_type_of_0_field_in_package_json_to_be_1_got_2, "typesVersions['".concat(bestVersionKey, "']"), "object", typeof bestVersionPaths);
            }
            return;
        }
        return result;
    }
    var typeScriptVersion;
    function getPackageJsonTypesVersionsPaths(typesVersions) {
        if (!typeScriptVersion)
            typeScriptVersion = new ts.Version(ts.version);
        for (var key in typesVersions) {
            if (!ts.hasProperty(typesVersions, key))
                continue;
            var keyRange = ts.VersionRange.tryParse(key);
            if (keyRange === undefined) {
                continue;
            }
            if (keyRange.test(typeScriptVersion)) {
                return { version: key, paths: typesVersions[key] };
            }
        }
    }
    ts.getPackageJsonTypesVersionsPaths = getPackageJsonTypesVersionsPaths;
    function getEffectiveTypeRoots(options, host) {
        if (options.typeRoots) {
            return options.typeRoots;
        }
        var currentDirectory;
        if (options.configFilePath) {
            currentDirectory = ts.getDirectoryPath(options.configFilePath);
        }
        else if (host.getCurrentDirectory) {
            currentDirectory = host.getCurrentDirectory();
        }
        if (currentDirectory !== undefined) {
            return getDefaultTypeRoots(currentDirectory, host);
        }
    }
    ts.getEffectiveTypeRoots = getEffectiveTypeRoots;
    function getDefaultTypeRoots(currentDirectory, host) {
        if (!host.directoryExists) {
            return [ts.combinePaths(currentDirectory, nodeModulesAtTypes)];
        }
        var typeRoots;
        ts.forEachAncestorDirectory(ts.normalizePath(currentDirectory), function (directory) {
            var atTypes = ts.combinePaths(directory, nodeModulesAtTypes);
            if (host.directoryExists(atTypes)) {
                (typeRoots || (typeRoots = [])).push(atTypes);
            }
            return undefined;
        });
        return typeRoots;
    }
    var nodeModulesAtTypes = ts.combinePaths("node_modules", "@types");
    function arePathsEqual(path1, path2, host) {
        var useCaseSensitiveFileNames = typeof host.useCaseSensitiveFileNames === "function" ? host.useCaseSensitiveFileNames() : host.useCaseSensitiveFileNames;
        return ts.comparePaths(path1, path2, !useCaseSensitiveFileNames) === 0;
    }
    function resolveTypeReferenceDirective(typeReferenceDirectiveName, containingFile, options, host, redirectedReference, cache, resolutionMode) {
        ts.Debug.assert(typeof typeReferenceDirectiveName === "string", "Non-string value passed to `ts.resolveTypeReferenceDirective`, likely by a wrapping package working with an outdated `resolveTypeReferenceDirectives` signature. This is probably not a problem in TS itself.");
        var traceEnabled = isTraceEnabled(options, host);
        if (redirectedReference) {
            options = redirectedReference.commandLine.options;
        }
        var containingDirectory = containingFile ? ts.getDirectoryPath(containingFile) : undefined;
        var perFolderCache = containingDirectory ? cache && cache.getOrCreateCacheForDirectory(containingDirectory, redirectedReference) : undefined;
        var result = perFolderCache && perFolderCache.get(typeReferenceDirectiveName, resolutionMode);
        if (result) {
            if (traceEnabled) {
                trace(host, ts.Diagnostics.Resolving_type_reference_directive_0_containing_file_1, typeReferenceDirectiveName, containingFile);
                if (redirectedReference)
                    trace(host, ts.Diagnostics.Using_compiler_options_of_project_reference_redirect_0, redirectedReference.sourceFile.fileName);
                trace(host, ts.Diagnostics.Resolution_for_type_reference_directive_0_was_found_in_cache_from_location_1, typeReferenceDirectiveName, containingDirectory);
                traceResult(result);
            }
            return result;
        }
        var typeRoots = getEffectiveTypeRoots(options, host);
        if (traceEnabled) {
            if (containingFile === undefined) {
                if (typeRoots === undefined) {
                    trace(host, ts.Diagnostics.Resolving_type_reference_directive_0_containing_file_not_set_root_directory_not_set, typeReferenceDirectiveName);
                }
                else {
                    trace(host, ts.Diagnostics.Resolving_type_reference_directive_0_containing_file_not_set_root_directory_1, typeReferenceDirectiveName, typeRoots);
                }
            }
            else {
                if (typeRoots === undefined) {
                    trace(host, ts.Diagnostics.Resolving_type_reference_directive_0_containing_file_1_root_directory_not_set, typeReferenceDirectiveName, containingFile);
                }
                else {
                    trace(host, ts.Diagnostics.Resolving_type_reference_directive_0_containing_file_1_root_directory_2, typeReferenceDirectiveName, containingFile, typeRoots);
                }
            }
            if (redirectedReference) {
                trace(host, ts.Diagnostics.Using_compiler_options_of_project_reference_redirect_0, redirectedReference.sourceFile.fileName);
            }
        }
        var failedLookupLocations = [];
        var features = getDefaultNodeResolutionFeatures(options);
        if (resolutionMode === ts.ModuleKind.ESNext && (ts.getEmitModuleResolutionKind(options) === ts.ModuleResolutionKind.Node16 || ts.getEmitModuleResolutionKind(options) === ts.ModuleResolutionKind.NodeNext)) {
            features |= NodeResolutionFeatures.EsmMode;
        }
        var conditions = features & NodeResolutionFeatures.Exports ? features & NodeResolutionFeatures.EsmMode ? ["node", "import", "types"] : ["node", "require", "types"] : [];
        var diagnostics = [];
        var moduleResolutionState = {
            compilerOptions: options,
            host: host,
            traceEnabled: traceEnabled,
            failedLookupLocations: failedLookupLocations,
            packageJsonInfoCache: cache,
            features: features,
            conditions: conditions,
            requestContainingDirectory: containingDirectory,
            reportDiagnostic: function (diag) { return void diagnostics.push(diag); },
        };
        var resolved = primaryLookup();
        var primary = true;
        if (!resolved) {
            resolved = secondaryLookup();
            primary = false;
        }
        var resolvedTypeReferenceDirective;
        if (resolved) {
            var fileName = resolved.fileName, packageId = resolved.packageId;
            var resolvedFileName = options.preserveSymlinks ? fileName : realPath(fileName, host, traceEnabled);
            resolvedTypeReferenceDirective = {
                primary: primary,
                resolvedFileName: resolvedFileName,
                originalPath: arePathsEqual(fileName, resolvedFileName, host) ? undefined : fileName,
                packageId: packageId,
                isExternalLibraryImport: pathContainsNodeModules(fileName),
            };
        }
        result = { resolvedTypeReferenceDirective: resolvedTypeReferenceDirective, failedLookupLocations: failedLookupLocations, resolutionDiagnostics: diagnostics };
        perFolderCache === null || perFolderCache === void 0 ? void 0 : perFolderCache.set(typeReferenceDirectiveName, resolutionMode, result);
        if (traceEnabled)
            traceResult(result);
        return result;
        function traceResult(result) {
            var _a;
            if (!((_a = result.resolvedTypeReferenceDirective) === null || _a === void 0 ? void 0 : _a.resolvedFileName)) {
                trace(host, ts.Diagnostics.Type_reference_directive_0_was_not_resolved, typeReferenceDirectiveName);
            }
            else if (result.resolvedTypeReferenceDirective.packageId) {
                trace(host, ts.Diagnostics.Type_reference_directive_0_was_successfully_resolved_to_1_with_Package_ID_2_primary_Colon_3, typeReferenceDirectiveName, result.resolvedTypeReferenceDirective.resolvedFileName, ts.packageIdToString(result.resolvedTypeReferenceDirective.packageId), result.resolvedTypeReferenceDirective.primary);
            }
            else {
                trace(host, ts.Diagnostics.Type_reference_directive_0_was_successfully_resolved_to_1_primary_Colon_2, typeReferenceDirectiveName, result.resolvedTypeReferenceDirective.resolvedFileName, result.resolvedTypeReferenceDirective.primary);
            }
        }
        function primaryLookup() {
            if (typeRoots && typeRoots.length) {
                if (traceEnabled) {
                    trace(host, ts.Diagnostics.Resolving_with_primary_search_path_0, typeRoots.join(", "));
                }
                return ts.firstDefined(typeRoots, function (typeRoot) {
                    var candidate = ts.combinePaths(typeRoot, typeReferenceDirectiveName);
                    var candidateDirectory = ts.getDirectoryPath(candidate);
                    var directoryExists = ts.directoryProbablyExists(candidateDirectory, host);
                    if (!directoryExists && traceEnabled) {
                        trace(host, ts.Diagnostics.Directory_0_does_not_exist_skipping_all_lookups_in_it, candidateDirectory);
                    }
                    return resolvedTypeScriptOnly(loadNodeModuleFromDirectory(Extensions.DtsOnly, candidate, !directoryExists, moduleResolutionState));
                });
            }
            else {
                if (traceEnabled) {
                    trace(host, ts.Diagnostics.Root_directory_cannot_be_determined_skipping_primary_search_paths);
                }
            }
        }
        function secondaryLookup() {
            var initialLocationForSecondaryLookup = containingFile && ts.getDirectoryPath(containingFile);
            if (initialLocationForSecondaryLookup !== undefined) {
                if (traceEnabled) {
                    trace(host, ts.Diagnostics.Looking_up_in_node_modules_folder_initial_location_0, initialLocationForSecondaryLookup);
                }
                var result_4;
                if (!ts.isExternalModuleNameRelative(typeReferenceDirectiveName)) {
                    var searchResult = loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, undefined, undefined);
                    result_4 = searchResult && searchResult.value;
                }
                else {
                    var candidate = normalizePathForCJSResolution(initialLocationForSecondaryLookup, typeReferenceDirectiveName).path;
                    result_4 = nodeLoadModuleByRelativeName(Extensions.DtsOnly, candidate, false, moduleResolutionState, true);
                }
                return resolvedTypeScriptOnly(result_4);
            }
            else {
                if (traceEnabled) {
                    trace(host, ts.Diagnostics.Containing_file_is_not_specified_and_root_directory_cannot_be_determined_skipping_lookup_in_node_modules_folder);
                }
            }
        }
    }
    ts.resolveTypeReferenceDirective = resolveTypeReferenceDirective;
    function getDefaultNodeResolutionFeatures(options) {
        return ts.getEmitModuleResolutionKind(options) === ts.ModuleResolutionKind.Node16 ? NodeResolutionFeatures.Node16Default :
            ts.getEmitModuleResolutionKind(options) === ts.ModuleResolutionKind.NodeNext ? NodeResolutionFeatures.NodeNextDefault :
                NodeResolutionFeatures.None;
    }
    function resolvePackageNameToPackageJson(packageName, containingDirectory, options, host, cache) {
        var moduleResolutionState = {
            compilerOptions: options,
            host: host,
            traceEnabled: isTraceEnabled(options, host),
            failedLookupLocations: [],
            packageJsonInfoCache: cache === null || cache === void 0 ? void 0 : cache.getPackageJsonInfoCache(),
            conditions: ts.emptyArray,
            features: NodeResolutionFeatures.None,
            requestContainingDirectory: containingDirectory,
            reportDiagnostic: ts.noop
        };
        return ts.forEachAncestorDirectory(containingDirectory, function (ancestorDirectory) {
            if (ts.getBaseFileName(ancestorDirectory) !== "node_modules") {
                var nodeModulesFolder = ts.combinePaths(ancestorDirectory, "node_modules");
                var candidate = ts.combinePaths(nodeModulesFolder, packageName);
                return getPackageJsonInfo(candidate, false, moduleResolutionState);
            }
        });
    }
    ts.resolvePackageNameToPackageJson = resolvePackageNameToPackageJson;
    function getAutomaticTypeDirectiveNames(options, host) {
        if (options.types) {
            return options.types;
        }
        var result = [];
        if (host.directoryExists && host.getDirectories) {
            var typeRoots = getEffectiveTypeRoots(options, host);
            if (typeRoots) {
                for (var _i = 0, typeRoots_1 = typeRoots; _i < typeRoots_1.length; _i++) {
                    var root = typeRoots_1[_i];
                    if (host.directoryExists(root)) {
                        for (var _a = 0, _b = host.getDirectories(root); _a < _b.length; _a++) {
                            var typeDirectivePath = _b[_a];
                            var normalized = ts.normalizePath(typeDirectivePath);
                            var packageJsonPath = ts.combinePaths(root, normalized, "package.json");
                            var isNotNeededPackage = host.fileExists(packageJsonPath) && ts.readJson(packageJsonPath, host).typings === null;
                            if (!isNotNeededPackage) {
                                var baseFileName = ts.getBaseFileName(normalized);
                                if (baseFileName.charCodeAt(0) !== 46) {
                                    result.push(baseFileName);
                                }
                            }
                        }
                    }
                }
            }
        }
        return result;
    }
    ts.getAutomaticTypeDirectiveNames = getAutomaticTypeDirectiveNames;
    function createCacheWithRedirects(options) {
        var ownMap = new ts.Map();
        var redirectsMap = new ts.Map();
        return {
            getOwnMap: getOwnMap,
            redirectsMap: redirectsMap,
            getOrCreateMapOfCacheRedirects: getOrCreateMapOfCacheRedirects,
            clear: clear,
            setOwnOptions: setOwnOptions,
            setOwnMap: setOwnMap
        };
        function getOwnMap() {
            return ownMap;
        }
        function setOwnOptions(newOptions) {
            options = newOptions;
        }
        function setOwnMap(newOwnMap) {
            ownMap = newOwnMap;
        }
        function getOrCreateMapOfCacheRedirects(redirectedReference) {
            if (!redirectedReference) {
                return ownMap;
            }
            var path = redirectedReference.sourceFile.path;
            var redirects = redirectsMap.get(path);
            if (!redirects) {
                redirects = !options || ts.optionsHaveModuleResolutionChanges(options, redirectedReference.commandLine.options) ? new ts.Map() : ownMap;
                redirectsMap.set(path, redirects);
            }
            return redirects;
        }
        function clear() {
            ownMap.clear();
            redirectsMap.clear();
        }
    }
    ts.createCacheWithRedirects = createCacheWithRedirects;
    function createPackageJsonInfoCache(currentDirectory, getCanonicalFileName) {
        var cache;
        return { getPackageJsonInfo: getPackageJsonInfo, setPackageJsonInfo: setPackageJsonInfo, clear: clear, entries: entries };
        function getPackageJsonInfo(packageJsonPath) {
            return cache === null || cache === void 0 ? void 0 : cache.get(ts.toPath(packageJsonPath, currentDirectory, getCanonicalFileName));
        }
        function setPackageJsonInfo(packageJsonPath, info) {
            (cache || (cache = new ts.Map())).set(ts.toPath(packageJsonPath, currentDirectory, getCanonicalFileName), info);
        }
        function clear() {
            cache = undefined;
        }
        function entries() {
            var iter = cache === null || cache === void 0 ? void 0 : cache.entries();
            return iter ? ts.arrayFrom(iter) : [];
        }
    }
    function getOrCreateCache(cacheWithRedirects, redirectedReference, key, create) {
        var cache = cacheWithRedirects.getOrCreateMapOfCacheRedirects(redirectedReference);
        var result = cache.get(key);
        if (!result) {
            result = create();
            cache.set(key, result);
        }
        return result;
    }
    function updateRedirectsMap(options, directoryToModuleNameMap, moduleNameToDirectoryMap) {
        if (!options.configFile)
            return;
        if (directoryToModuleNameMap.redirectsMap.size === 0) {
            ts.Debug.assert(!moduleNameToDirectoryMap || moduleNameToDirectoryMap.redirectsMap.size === 0);
            ts.Debug.assert(directoryToModuleNameMap.getOwnMap().size === 0);
            ts.Debug.assert(!moduleNameToDirectoryMap || moduleNameToDirectoryMap.getOwnMap().size === 0);
            directoryToModuleNameMap.redirectsMap.set(options.configFile.path, directoryToModuleNameMap.getOwnMap());
            moduleNameToDirectoryMap === null || moduleNameToDirectoryMap === void 0 ? void 0 : moduleNameToDirectoryMap.redirectsMap.set(options.configFile.path, moduleNameToDirectoryMap.getOwnMap());
        }
        else {
            ts.Debug.assert(!moduleNameToDirectoryMap || moduleNameToDirectoryMap.redirectsMap.size > 0);
            var ref = {
                sourceFile: options.configFile,
                commandLine: { options: options }
            };
            directoryToModuleNameMap.setOwnMap(directoryToModuleNameMap.getOrCreateMapOfCacheRedirects(ref));
            moduleNameToDirectoryMap === null || moduleNameToDirectoryMap === void 0 ? void 0 : moduleNameToDirectoryMap.setOwnMap(moduleNameToDirectoryMap.getOrCreateMapOfCacheRedirects(ref));
        }
        directoryToModuleNameMap.setOwnOptions(options);
        moduleNameToDirectoryMap === null || moduleNameToDirectoryMap === void 0 ? void 0 : moduleNameToDirectoryMap.setOwnOptions(options);
    }
    function createPerDirectoryResolutionCache(currentDirectory, getCanonicalFileName, directoryToModuleNameMap) {
        return {
            getOrCreateCacheForDirectory: getOrCreateCacheForDirectory,
            clear: clear,
            update: update,
        };
        function clear() {
            directoryToModuleNameMap.clear();
        }
        function update(options) {
            updateRedirectsMap(options, directoryToModuleNameMap);
        }
        function getOrCreateCacheForDirectory(directoryName, redirectedReference) {
            var path = ts.toPath(directoryName, currentDirectory, getCanonicalFileName);
            return getOrCreateCache(directoryToModuleNameMap, redirectedReference, path, function () { return createModeAwareCache(); });
        }
    }
    function createModeAwareCache() {
        var underlying = new ts.Map();
        var memoizedReverseKeys = new ts.Map();
        var cache = {
            get: function (specifier, mode) {
                return underlying.get(getUnderlyingCacheKey(specifier, mode));
            },
            set: function (specifier, mode, value) {
                underlying.set(getUnderlyingCacheKey(specifier, mode), value);
                return cache;
            },
            delete: function (specifier, mode) {
                underlying.delete(getUnderlyingCacheKey(specifier, mode));
                return cache;
            },
            has: function (specifier, mode) {
                return underlying.has(getUnderlyingCacheKey(specifier, mode));
            },
            forEach: function (cb) {
                return underlying.forEach(function (elem, key) {
                    var _a = memoizedReverseKeys.get(key), specifier = _a[0], mode = _a[1];
                    return cb(elem, specifier, mode);
                });
            },
            size: function () {
                return underlying.size;
            }
        };
        return cache;
        function getUnderlyingCacheKey(specifier, mode) {
            var result = mode === undefined ? specifier : "".concat(mode, "|").concat(specifier);
            memoizedReverseKeys.set(result, [specifier, mode]);
            return result;
        }
    }
    ts.createModeAwareCache = createModeAwareCache;
    function zipToModeAwareCache(file, keys, values) {
        ts.Debug.assert(keys.length === values.length);
        var map = createModeAwareCache();
        for (var i = 0; i < keys.length; ++i) {
            var entry = keys[i];
            var name = !ts.isString(entry) ? entry.fileName.toLowerCase() : entry;
            var mode = !ts.isString(entry) ? entry.resolutionMode || file.impliedNodeFormat : ts.getModeForResolutionAtIndex(file, i);
            map.set(name, mode, values[i]);
        }
        return map;
    }
    ts.zipToModeAwareCache = zipToModeAwareCache;
    function createModuleResolutionCache(currentDirectory, getCanonicalFileName, options, directoryToModuleNameMap, moduleNameToDirectoryMap) {
        var preDirectoryResolutionCache = createPerDirectoryResolutionCache(currentDirectory, getCanonicalFileName, directoryToModuleNameMap || (directoryToModuleNameMap = createCacheWithRedirects(options)));
        moduleNameToDirectoryMap || (moduleNameToDirectoryMap = createCacheWithRedirects(options));
        var packageJsonInfoCache = createPackageJsonInfoCache(currentDirectory, getCanonicalFileName);
        return __assign(__assign(__assign({}, packageJsonInfoCache), preDirectoryResolutionCache), { getOrCreateCacheForModuleName: getOrCreateCacheForModuleName, clear: clear, update: update, getPackageJsonInfoCache: function () { return packageJsonInfoCache; } });
        function clear() {
            preDirectoryResolutionCache.clear();
            moduleNameToDirectoryMap.clear();
            packageJsonInfoCache.clear();
        }
        function update(options) {
            updateRedirectsMap(options, directoryToModuleNameMap, moduleNameToDirectoryMap);
        }
        function getOrCreateCacheForModuleName(nonRelativeModuleName, mode, redirectedReference) {
            ts.Debug.assert(!ts.isExternalModuleNameRelative(nonRelativeModuleName));
            return getOrCreateCache(moduleNameToDirectoryMap, redirectedReference, mode === undefined ? nonRelativeModuleName : "".concat(mode, "|").concat(nonRelativeModuleName), createPerModuleNameCache);
        }
        function createPerModuleNameCache() {
            var directoryPathMap = new ts.Map();
            return { get: get, set: set };
            function get(directory) {
                return directoryPathMap.get(ts.toPath(directory, currentDirectory, getCanonicalFileName));
            }
            function set(directory, result) {
                var path = ts.toPath(directory, currentDirectory, getCanonicalFileName);
                if (directoryPathMap.has(path)) {
                    return;
                }
                directoryPathMap.set(path, result);
                var resolvedFileName = result.resolvedModule &&
                    (result.resolvedModule.originalPath || result.resolvedModule.resolvedFileName);
                var commonPrefix = resolvedFileName && getCommonPrefix(path, resolvedFileName);
                var current = path;
                while (current !== commonPrefix) {
                    var parent = ts.getDirectoryPath(current);
                    if (parent === current || directoryPathMap.has(parent)) {
                        break;
                    }
                    directoryPathMap.set(parent, result);
                    current = parent;
                }
            }
            function getCommonPrefix(directory, resolution) {
                var resolutionDirectory = ts.toPath(ts.getDirectoryPath(resolution), currentDirectory, getCanonicalFileName);
                var i = 0;
                var limit = Math.min(directory.length, resolutionDirectory.length);
                while (i < limit && directory.charCodeAt(i) === resolutionDirectory.charCodeAt(i)) {
                    i++;
                }
                if (i === directory.length && (resolutionDirectory.length === i || resolutionDirectory[i] === ts.directorySeparator)) {
                    return directory;
                }
                var rootLength = ts.getRootLength(directory);
                if (i < rootLength) {
                    return undefined;
                }
                var sep = directory.lastIndexOf(ts.directorySeparator, i - 1);
                if (sep === -1) {
                    return undefined;
                }
                return directory.substr(0, Math.max(sep, rootLength));
            }
        }
    }
    ts.createModuleResolutionCache = createModuleResolutionCache;
    function createTypeReferenceDirectiveResolutionCache(currentDirectory, getCanonicalFileName, options, packageJsonInfoCache, directoryToModuleNameMap) {
        var preDirectoryResolutionCache = createPerDirectoryResolutionCache(currentDirectory, getCanonicalFileName, directoryToModuleNameMap || (directoryToModuleNameMap = createCacheWithRedirects(options)));
        packageJsonInfoCache || (packageJsonInfoCache = createPackageJsonInfoCache(currentDirectory, getCanonicalFileName));
        return __assign(__assign(__assign({}, packageJsonInfoCache), preDirectoryResolutionCache), { clear: clear });
        function clear() {
            preDirectoryResolutionCache.clear();
            packageJsonInfoCache.clear();
        }
    }
    ts.createTypeReferenceDirectiveResolutionCache = createTypeReferenceDirectiveResolutionCache;
    function resolveModuleNameFromCache(moduleName, containingFile, cache, mode) {
        var containingDirectory = ts.getDirectoryPath(containingFile);
        var perFolderCache = cache && cache.getOrCreateCacheForDirectory(containingDirectory);
        if (!perFolderCache)
            return undefined;
        return perFolderCache.get(moduleName, mode);
    }
    ts.resolveModuleNameFromCache = resolveModuleNameFromCache;
    function resolveModuleName(moduleName, containingFile, compilerOptions, host, cache, redirectedReference, resolutionMode) {
        var traceEnabled = isTraceEnabled(compilerOptions, host);
        if (redirectedReference) {
            compilerOptions = redirectedReference.commandLine.options;
        }
        if (traceEnabled) {
            trace(host, ts.Diagnostics.Resolving_module_0_from_1, moduleName, containingFile);
            if (redirectedReference) {
                trace(host, ts.Diagnostics.Using_compiler_options_of_project_reference_redirect_0, redirectedReference.sourceFile.fileName);
            }
        }
        var containingDirectory = ts.getDirectoryPath(containingFile);
        var perFolderCache = cache && cache.getOrCreateCacheForDirectory(containingDirectory, redirectedReference);
        var result = perFolderCache && perFolderCache.get(moduleName, resolutionMode);
        if (result) {
            if (traceEnabled) {
                trace(host, ts.Diagnostics.Resolution_for_module_0_was_found_in_cache_from_location_1, moduleName, containingDirectory);
            }
        }
        else {
            var moduleResolution = compilerOptions.moduleResolution;
            if (moduleResolution === undefined) {
                switch (ts.getEmitModuleKind(compilerOptions)) {
                    case ts.ModuleKind.CommonJS:
                        moduleResolution = ts.ModuleResolutionKind.NodeJs;
                        break;
                    case ts.ModuleKind.Node16:
                        moduleResolution = ts.ModuleResolutionKind.Node16;
                        break;
                    case ts.ModuleKind.NodeNext:
                        moduleResolution = ts.ModuleResolutionKind.NodeNext;
                        break;
                    default:
                        moduleResolution = ts.ModuleResolutionKind.Classic;
                        break;
                }
                if (traceEnabled) {
                    trace(host, ts.Diagnostics.Module_resolution_kind_is_not_specified_using_0, ts.ModuleResolutionKind[moduleResolution]);
                }
            }
            else {
                if (traceEnabled) {
                    trace(host, ts.Diagnostics.Explicitly_specified_module_resolution_kind_Colon_0, ts.ModuleResolutionKind[moduleResolution]);
                }
            }
            ts.perfLogger.logStartResolveModule(moduleName);
            switch (moduleResolution) {
                case ts.ModuleResolutionKind.Node16:
                    result = node16ModuleNameResolver(moduleName, containingFile, compilerOptions, host, cache, redirectedReference, resolutionMode);
                    break;
                case ts.ModuleResolutionKind.NodeNext:
                    result = nodeNextModuleNameResolver(moduleName, containingFile, compilerOptions, host, cache, redirectedReference, resolutionMode);
                    break;
                case ts.ModuleResolutionKind.NodeJs:
                    result = nodeModuleNameResolver(moduleName, containingFile, compilerOptions, host, cache, redirectedReference);
                    break;
                case ts.ModuleResolutionKind.Classic:
                    result = classicNameResolver(moduleName, containingFile, compilerOptions, host, cache, redirectedReference);
                    break;
                default:
                    return ts.Debug.fail("Unexpected moduleResolution: ".concat(moduleResolution));
            }
            if (result && result.resolvedModule)
                ts.perfLogger.logInfoEvent("Module \"".concat(moduleName, "\" resolved to \"").concat(result.resolvedModule.resolvedFileName, "\""));
            ts.perfLogger.logStopResolveModule((result && result.resolvedModule) ? "" + result.resolvedModule.resolvedFileName : "null");
            if (perFolderCache) {
                perFolderCache.set(moduleName, resolutionMode, result);
                if (!ts.isExternalModuleNameRelative(moduleName)) {
                    cache.getOrCreateCacheForModuleName(moduleName, resolutionMode, redirectedReference).set(containingDirectory, result);
                }
            }
        }
        if (traceEnabled) {
            if (result.resolvedModule) {
                if (result.resolvedModule.packageId) {
                    trace(host, ts.Diagnostics.Module_name_0_was_successfully_resolved_to_1_with_Package_ID_2, moduleName, result.resolvedModule.resolvedFileName, ts.packageIdToString(result.resolvedModule.packageId));
                }
                else {
                    trace(host, ts.Diagnostics.Module_name_0_was_successfully_resolved_to_1, moduleName, result.resolvedModule.resolvedFileName);
                }
            }
            else {
                trace(host, ts.Diagnostics.Module_name_0_was_not_resolved, moduleName);
            }
        }
        return result;
    }
    ts.resolveModuleName = resolveModuleName;
    function tryLoadModuleUsingOptionalResolutionSettings(extensions, moduleName, containingDirectory, loader, state) {
        var resolved = tryLoadModuleUsingPathsIfEligible(extensions, moduleName, loader, state);
        if (resolved)
            return resolved.value;
        if (!ts.isExternalModuleNameRelative(moduleName)) {
            return tryLoadModuleUsingBaseUrl(extensions, moduleName, loader, state);
        }
        else {
            return tryLoadModuleUsingRootDirs(extensions, moduleName, containingDirectory, loader, state);
        }
    }
    function tryLoadModuleUsingPathsIfEligible(extensions, moduleName, loader, state) {
        var _a;
        var _b = state.compilerOptions, baseUrl = _b.baseUrl, paths = _b.paths, configFile = _b.configFile;
        if (paths && !ts.pathIsRelative(moduleName)) {
            if (state.traceEnabled) {
                if (baseUrl) {
                    trace(state.host, ts.Diagnostics.baseUrl_option_is_set_to_0_using_this_value_to_resolve_non_relative_module_name_1, baseUrl, moduleName);
                }
                trace(state.host, ts.Diagnostics.paths_option_is_specified_looking_for_a_pattern_to_match_module_name_0, moduleName);
            }
            var baseDirectory = ts.getPathsBasePath(state.compilerOptions, state.host);
            var pathPatterns = (configFile === null || configFile === void 0 ? void 0 : configFile.configFileSpecs) ? (_a = configFile.configFileSpecs).pathPatterns || (_a.pathPatterns = ts.tryParsePatterns(paths)) : undefined;
            return tryLoadModuleUsingPaths(extensions, moduleName, baseDirectory, paths, pathPatterns, loader, false, state);
        }
    }
    function tryLoadModuleUsingRootDirs(extensions, moduleName, containingDirectory, loader, state) {
        if (!state.compilerOptions.rootDirs) {
            return undefined;
        }
        if (state.traceEnabled) {
            trace(state.host, ts.Diagnostics.rootDirs_option_is_set_using_it_to_resolve_relative_module_name_0, moduleName);
        }
        var candidate = ts.normalizePath(ts.combinePaths(containingDirectory, moduleName));
        var matchedRootDir;
        var matchedNormalizedPrefix;
        for (var _i = 0, _a = state.compilerOptions.rootDirs; _i < _a.length; _i++) {
            var rootDir = _a[_i];
            var normalizedRoot = ts.normalizePath(rootDir);
            if (!ts.endsWith(normalizedRoot, ts.directorySeparator)) {
                normalizedRoot += ts.directorySeparator;
            }
            var isLongestMatchingPrefix = ts.startsWith(candidate, normalizedRoot) &&
                (matchedNormalizedPrefix === undefined || matchedNormalizedPrefix.length < normalizedRoot.length);
            if (state.traceEnabled) {
                trace(state.host, ts.Diagnostics.Checking_if_0_is_the_longest_matching_prefix_for_1_2, normalizedRoot, candidate, isLongestMatchingPrefix);
            }
            if (isLongestMatchingPrefix) {
                matchedNormalizedPrefix = normalizedRoot;
                matchedRootDir = rootDir;
            }
        }
        if (matchedNormalizedPrefix) {
            if (state.traceEnabled) {
                trace(state.host, ts.Diagnostics.Longest_matching_prefix_for_0_is_1, candidate, matchedNormalizedPrefix);
            }
            var suffix = candidate.substr(matchedNormalizedPrefix.length);
            if (state.traceEnabled) {
                trace(state.host, ts.Diagnostics.Loading_0_from_the_root_dir_1_candidate_location_2, suffix, matchedNormalizedPrefix, candidate);
            }
            var resolvedFileName = loader(extensions, candidate, !ts.directoryProbablyExists(containingDirectory, state.host), state);
            if (resolvedFileName) {
                return resolvedFileName;
            }
            if (state.traceEnabled) {
                trace(state.host, ts.Diagnostics.Trying_other_entries_in_rootDirs);
            }
            for (var _b = 0, _c = state.compilerOptions.rootDirs; _b < _c.length; _b++) {
                var rootDir = _c[_b];
                if (rootDir === matchedRootDir) {
                    continue;
                }
                var candidate_1 = ts.combinePaths(ts.normalizePath(rootDir), suffix);
                if (state.traceEnabled) {
                    trace(state.host, ts.Diagnostics.Loading_0_from_the_root_dir_1_candidate_location_2, suffix, rootDir, candidate_1);
                }
                var baseDirectory = ts.getDirectoryPath(candidate_1);
                var resolvedFileName_1 = loader(extensions, candidate_1, !ts.directoryProbablyExists(baseDirectory, state.host), state);
                if (resolvedFileName_1) {
                    return resolvedFileName_1;
                }
            }
            if (state.traceEnabled) {
                trace(state.host, ts.Diagnostics.Module_resolution_using_rootDirs_has_failed);
            }
        }
        return undefined;
    }
    function tryLoadModuleUsingBaseUrl(extensions, moduleName, loader, state) {
        var baseUrl = state.compilerOptions.baseUrl;
        if (!baseUrl) {
            return undefined;
        }
        if (state.traceEnabled) {
            trace(state.host, ts.Diagnostics.baseUrl_option_is_set_to_0_using_this_value_to_resolve_non_relative_module_name_1, baseUrl, moduleName);
        }
        var candidate = ts.normalizePath(ts.combinePaths(baseUrl, moduleName));
        if (state.traceEnabled) {
            trace(state.host, ts.Diagnostics.Resolving_module_name_0_relative_to_base_url_1_2, moduleName, baseUrl, candidate);
        }
        return loader(extensions, candidate, !ts.directoryProbablyExists(ts.getDirectoryPath(candidate), state.host), state);
    }
    function resolveJSModule(moduleName, initialDir, host) {
        var _a = tryResolveJSModuleWorker(moduleName, initialDir, host), resolvedModule = _a.resolvedModule, failedLookupLocations = _a.failedLookupLocations;
        if (!resolvedModule) {
            throw new Error("Could not resolve JS module '".concat(moduleName, "' starting at '").concat(initialDir, "'. Looked in: ").concat(failedLookupLocations.join(", ")));
        }
        return resolvedModule.resolvedFileName;
    }
    ts.resolveJSModule = resolveJSModule;
    var NodeResolutionFeatures;
    (function (NodeResolutionFeatures) {
        NodeResolutionFeatures[NodeResolutionFeatures["None"] = 0] = "None";
        NodeResolutionFeatures[NodeResolutionFeatures["Imports"] = 2] = "Imports";
        NodeResolutionFeatures[NodeResolutionFeatures["SelfName"] = 4] = "SelfName";
        NodeResolutionFeatures[NodeResolutionFeatures["Exports"] = 8] = "Exports";
        NodeResolutionFeatures[NodeResolutionFeatures["ExportsPatternTrailers"] = 16] = "ExportsPatternTrailers";
        NodeResolutionFeatures[NodeResolutionFeatures["AllFeatures"] = 30] = "AllFeatures";
        NodeResolutionFeatures[NodeResolutionFeatures["Node16Default"] = 30] = "Node16Default";
        NodeResolutionFeatures[NodeResolutionFeatures["NodeNextDefault"] = 30] = "NodeNextDefault";
        NodeResolutionFeatures[NodeResolutionFeatures["EsmMode"] = 32] = "EsmMode";
    })(NodeResolutionFeatures || (NodeResolutionFeatures = {}));
    function node16ModuleNameResolver(moduleName, containingFile, compilerOptions, host, cache, redirectedReference, resolutionMode) {
        return nodeNextModuleNameResolverWorker(NodeResolutionFeatures.Node16Default, moduleName, containingFile, compilerOptions, host, cache, redirectedReference, resolutionMode);
    }
    function nodeNextModuleNameResolver(moduleName, containingFile, compilerOptions, host, cache, redirectedReference, resolutionMode) {
        return nodeNextModuleNameResolverWorker(NodeResolutionFeatures.NodeNextDefault, moduleName, containingFile, compilerOptions, host, cache, redirectedReference, resolutionMode);
    }
    var jsOnlyExtensions = [Extensions.JavaScript];
    var tsExtensions = [Extensions.TypeScript, Extensions.JavaScript];
    var tsPlusJsonExtensions = __spreadArray(__spreadArray([], tsExtensions, true), [Extensions.Json], false);
    var tsconfigExtensions = [Extensions.TSConfig];
    function nodeNextModuleNameResolverWorker(features, moduleName, containingFile, compilerOptions, host, cache, redirectedReference, resolutionMode) {
        var containingDirectory = ts.getDirectoryPath(containingFile);
        var esmMode = resolutionMode === ts.ModuleKind.ESNext ? NodeResolutionFeatures.EsmMode : 0;
        var extensions = compilerOptions.noDtsResolution ? [Extensions.TsOnly, Extensions.JavaScript] : tsExtensions;
        if (compilerOptions.resolveJsonModule) {
            extensions = __spreadArray(__spreadArray([], extensions, true), [Extensions.Json], false);
        }
        return nodeModuleNameResolverWorker(features | esmMode, moduleName, containingDirectory, compilerOptions, host, cache, extensions, redirectedReference);
    }
    function tryResolveJSModuleWorker(moduleName, initialDir, host) {
        return nodeModuleNameResolverWorker(NodeResolutionFeatures.None, moduleName, initialDir, { moduleResolution: ts.ModuleResolutionKind.NodeJs, allowJs: true }, host, undefined, jsOnlyExtensions, undefined);
    }
    function nodeModuleNameResolver(moduleName, containingFile, compilerOptions, host, cache, redirectedReference, lookupConfig) {
        var extensions;
        if (lookupConfig) {
            extensions = tsconfigExtensions;
        }
        else if (compilerOptions.noDtsResolution) {
            extensions = [Extensions.TsOnly];
            if (compilerOptions.allowJs)
                extensions.push(Extensions.JavaScript);
            if (compilerOptions.resolveJsonModule)
                extensions.push(Extensions.Json);
        }
        else {
            extensions = compilerOptions.resolveJsonModule ? tsPlusJsonExtensions : tsExtensions;
        }
        return nodeModuleNameResolverWorker(NodeResolutionFeatures.None, moduleName, ts.getDirectoryPath(containingFile), compilerOptions, host, cache, extensions, redirectedReference);
    }
    ts.nodeModuleNameResolver = nodeModuleNameResolver;
    function nodeModuleNameResolverWorker(features, moduleName, containingDirectory, compilerOptions, host, cache, extensions, redirectedReference) {
        var _a, _b;
        var traceEnabled = isTraceEnabled(compilerOptions, host);
        var failedLookupLocations = [];
        var conditions = features & NodeResolutionFeatures.EsmMode ? ["node", "import", "types"] : ["node", "require", "types"];
        if (compilerOptions.noDtsResolution) {
            conditions.pop();
        }
        var diagnostics = [];
        var state = {
            compilerOptions: compilerOptions,
            host: host,
            traceEnabled: traceEnabled,
            failedLookupLocations: failedLookupLocations,
            packageJsonInfoCache: cache,
            features: features,
            conditions: conditions,
            requestContainingDirectory: containingDirectory,
            reportDiagnostic: function (diag) { return void diagnostics.push(diag); },
        };
        var result = ts.forEach(extensions, function (ext) { return tryResolve(ext); });
        return createResolvedModuleWithFailedLookupLocations((_a = result === null || result === void 0 ? void 0 : result.value) === null || _a === void 0 ? void 0 : _a.resolved, (_b = result === null || result === void 0 ? void 0 : result.value) === null || _b === void 0 ? void 0 : _b.isExternalLibraryImport, failedLookupLocations, diagnostics, state.resultFromCache);
        function tryResolve(extensions) {
            var loader = function (extensions, candidate, onlyRecordFailures, state) { return nodeLoadModuleByRelativeName(extensions, candidate, onlyRecordFailures, state, true); };
            var resolved = tryLoadModuleUsingOptionalResolutionSettings(extensions, moduleName, containingDirectory, loader, state);
            if (resolved) {
                return toSearchResult({ resolved: resolved, isExternalLibraryImport: pathContainsNodeModules(resolved.path) });
            }
            if (!ts.isExternalModuleNameRelative(moduleName)) {
                var resolved_1;
                if (features & NodeResolutionFeatures.Imports && ts.startsWith(moduleName, "#")) {
                    resolved_1 = loadModuleFromImports(extensions, moduleName, containingDirectory, state, cache, redirectedReference);
                }
                if (!resolved_1 && features & NodeResolutionFeatures.SelfName) {
                    resolved_1 = loadModuleFromSelfNameReference(extensions, moduleName, containingDirectory, state, cache, redirectedReference);
                }
                if (!resolved_1) {
                    if (traceEnabled) {
                        trace(host, ts.Diagnostics.Loading_module_0_from_node_modules_folder_target_file_type_1, moduleName, Extensions[extensions]);
                    }
                    resolved_1 = loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);
                }
                if (!resolved_1)
                    return undefined;
                var resolvedValue = resolved_1.value;
                if (!compilerOptions.preserveSymlinks && resolvedValue && !resolvedValue.originalPath) {
                    var path = realPath(resolvedValue.path, host, traceEnabled);
                    var originalPath = arePathsEqual(path, resolvedValue.path, host) ? undefined : resolvedValue.path;
                    resolvedValue = __assign(__assign({}, resolvedValue), { path: path, originalPath: originalPath });
                }
                return { value: resolvedValue && { resolved: resolvedValue, isExternalLibraryImport: true } };
            }
            else {
                var _a = normalizePathForCJSResolution(containingDirectory, moduleName), candidate = _a.path, parts = _a.parts;
                var resolved_2 = nodeLoadModuleByRelativeName(extensions, candidate, false, state, true);
                return resolved_2 && toSearchResult({ resolved: resolved_2, isExternalLibraryImport: ts.contains(parts, "node_modules") });
            }
        }
    }
    function normalizePathForCJSResolution(containingDirectory, moduleName) {
        var combined = ts.combinePaths(containingDirectory, moduleName);
        var parts = ts.getPathComponents(combined);
        var lastPart = ts.lastOrUndefined(parts);
        var path = lastPart === "." || lastPart === ".." ? ts.ensureTrailingDirectorySeparator(ts.normalizePath(combined)) : ts.normalizePath(combined);
        return { path: path, parts: parts };
    }
    function realPath(path, host, traceEnabled) {
        if (!host.realpath) {
            return path;
        }
        var real = ts.normalizePath(host.realpath(path));
        if (traceEnabled) {
            trace(host, ts.Diagnostics.Resolving_real_path_for_0_result_1, path, real);
        }
        ts.Debug.assert(host.fileExists(real), "".concat(path, " linked to nonexistent file ").concat(real));
        return real;
    }
    function nodeLoadModuleByRelativeName(extensions, candidate, onlyRecordFailures, state, considerPackageJson) {
        if (state.traceEnabled) {
            trace(state.host, ts.Diagnostics.Loading_module_as_file_Slash_folder_candidate_module_location_0_target_file_type_1, candidate, Extensions[extensions]);
        }
        if (!ts.hasTrailingDirectorySeparator(candidate)) {
            if (!onlyRecordFailures) {
                var parentOfCandidate = ts.getDirectoryPath(candidate);
                if (!ts.directoryProbablyExists(parentOfCandidate, state.host)) {
                    if (state.traceEnabled) {
                        trace(state.host, ts.Diagnostics.Directory_0_does_not_exist_skipping_all_lookups_in_it, parentOfCandidate);
                    }
                    onlyRecordFailures = true;
                }
            }
            var resolvedFromFile = loadModuleFromFile(extensions, candidate, onlyRecordFailures, state);
            if (resolvedFromFile) {
                var packageDirectory = considerPackageJson ? parseNodeModuleFromPath(resolvedFromFile.path) : undefined;
                var packageInfo = packageDirectory ? getPackageJsonInfo(packageDirectory, false, state) : undefined;
                return withPackageId(packageInfo, resolvedFromFile);
            }
        }
        if (!onlyRecordFailures) {
            var candidateExists = ts.directoryProbablyExists(candidate, state.host);
            if (!candidateExists) {
                if (state.traceEnabled) {
                    trace(state.host, ts.Diagnostics.Directory_0_does_not_exist_skipping_all_lookups_in_it, candidate);
                }
                onlyRecordFailures = true;
            }
        }
        if (!(state.features & NodeResolutionFeatures.EsmMode)) {
            return loadNodeModuleFromDirectory(extensions, candidate, onlyRecordFailures, state, considerPackageJson);
        }
        return undefined;
    }
    ts.nodeModulesPathPart = "/node_modules/";
    function pathContainsNodeModules(path) {
        return ts.stringContains(path, ts.nodeModulesPathPart);
    }
    ts.pathContainsNodeModules = pathContainsNodeModules;
    function parseNodeModuleFromPath(resolved) {
        var path = ts.normalizePath(resolved);
        var idx = path.lastIndexOf(ts.nodeModulesPathPart);
        if (idx === -1) {
            return undefined;
        }
        var indexAfterNodeModules = idx + ts.nodeModulesPathPart.length;
        var indexAfterPackageName = moveToNextDirectorySeparatorIfAvailable(path, indexAfterNodeModules);
        if (path.charCodeAt(indexAfterNodeModules) === 64) {
            indexAfterPackageName = moveToNextDirectorySeparatorIfAvailable(path, indexAfterPackageName);
        }
        return path.slice(0, indexAfterPackageName);
    }
    ts.parseNodeModuleFromPath = parseNodeModuleFromPath;
    function moveToNextDirectorySeparatorIfAvailable(path, prevSeparatorIndex) {
        var nextSeparatorIndex = path.indexOf(ts.directorySeparator, prevSeparatorIndex + 1);
        return nextSeparatorIndex === -1 ? prevSeparatorIndex : nextSeparatorIndex;
    }
    function loadModuleFromFileNoPackageId(extensions, candidate, onlyRecordFailures, state) {
        return noPackageId(loadModuleFromFile(extensions, candidate, onlyRecordFailures, state));
    }
    function loadModuleFromFile(extensions, candidate, onlyRecordFailures, state) {
        if (extensions === Extensions.Json || extensions === Extensions.TSConfig) {
            var extensionLess = ts.tryRemoveExtension(candidate, ".json");
            var extension = extensionLess ? candidate.substring(extensionLess.length) : "";
            return (extensionLess === undefined && extensions === Extensions.Json) ? undefined : tryAddingExtensions(extensionLess || candidate, extensions, extension, onlyRecordFailures, state);
        }
        if (!(state.features & NodeResolutionFeatures.EsmMode)) {
            var resolvedByAddingExtension = tryAddingExtensions(candidate, extensions, "", onlyRecordFailures, state);
            if (resolvedByAddingExtension) {
                return resolvedByAddingExtension;
            }
        }
        return loadModuleFromFileNoImplicitExtensions(extensions, candidate, onlyRecordFailures, state);
    }
    function loadModuleFromFileNoImplicitExtensions(extensions, candidate, onlyRecordFailures, state) {
        if (ts.hasJSFileExtension(candidate) || (ts.fileExtensionIs(candidate, ".json") && state.compilerOptions.resolveJsonModule)) {
            var extensionless = ts.removeFileExtension(candidate);
            var extension = candidate.substring(extensionless.length);
            if (state.traceEnabled) {
                trace(state.host, ts.Diagnostics.File_name_0_has_a_1_extension_stripping_it, candidate, extension);
            }
            return tryAddingExtensions(extensionless, extensions, extension, onlyRecordFailures, state);
        }
    }
    function loadJSOrExactTSFileName(extensions, candidate, onlyRecordFailures, state) {
        if ((extensions === Extensions.TypeScript || extensions === Extensions.DtsOnly) && ts.fileExtensionIsOneOf(candidate, ts.supportedTSExtensionsFlat)) {
            var result = tryFile(candidate, onlyRecordFailures, state);
            return result !== undefined ? { path: candidate, ext: ts.tryExtractTSExtension(candidate) } : undefined;
        }
        return loadModuleFromFileNoImplicitExtensions(extensions, candidate, onlyRecordFailures, state);
    }
    function tryAddingExtensions(candidate, extensions, originalExtension, onlyRecordFailures, state) {
        if (!onlyRecordFailures) {
            var directory = ts.getDirectoryPath(candidate);
            if (directory) {
                onlyRecordFailures = !ts.directoryProbablyExists(directory, state.host);
            }
        }
        switch (extensions) {
            case Extensions.DtsOnly:
                switch (originalExtension) {
                    case ".mjs":
                    case ".mts":
                    case ".d.mts":
                        return tryExtension(".d.mts");
                    case ".cjs":
                    case ".cts":
                    case ".d.cts":
                        return tryExtension(".d.cts");
                    case ".json":
                        candidate += ".json";
                        return tryExtension(".d.ts");
                    default: return tryExtension(".d.ts");
                }
            case Extensions.TypeScript:
            case Extensions.TsOnly:
                var useDts = extensions === Extensions.TypeScript;
                switch (originalExtension) {
                    case ".mjs":
                    case ".mts":
                    case ".d.mts":
                        return tryExtension(".mts") || (useDts ? tryExtension(".d.mts") : undefined);
                    case ".cjs":
                    case ".cts":
                    case ".d.cts":
                        return tryExtension(".cts") || (useDts ? tryExtension(".d.cts") : undefined);
                    case ".json":
                        candidate += ".json";
                        return useDts ? tryExtension(".d.ts") : undefined;
                    default:
                        return tryExtension(".ts") || tryExtension(".tsx") || (useDts ? tryExtension(".d.ts") : undefined);
                }
            case Extensions.JavaScript:
                switch (originalExtension) {
                    case ".mjs":
                    case ".mts":
                    case ".d.mts":
                        return tryExtension(".mjs");
                    case ".cjs":
                    case ".cts":
                    case ".d.cts":
                        return tryExtension(".cjs");
                    case ".json":
                        return tryExtension(".json");
                    default:
                        return tryExtension(".js") || tryExtension(".jsx");
                }
            case Extensions.TSConfig:
            case Extensions.Json:
                return tryExtension(".json");
        }
        function tryExtension(ext) {
            var path = tryFile(candidate + ext, onlyRecordFailures, state);
            return path === undefined ? undefined : { path: path, ext: ext };
        }
    }
    function tryFile(fileName, onlyRecordFailures, state) {
        var _a, _b;
        if (!((_a = state.compilerOptions.moduleSuffixes) === null || _a === void 0 ? void 0 : _a.length)) {
            return tryFileLookup(fileName, onlyRecordFailures, state);
        }
        var ext = (_b = ts.tryGetExtensionFromPath(fileName)) !== null && _b !== void 0 ? _b : "";
        var fileNameNoExtension = ext ? ts.removeExtension(fileName, ext) : fileName;
        return ts.forEach(state.compilerOptions.moduleSuffixes, function (suffix) { return tryFileLookup(fileNameNoExtension + suffix + ext, onlyRecordFailures, state); });
    }
    function tryFileLookup(fileName, onlyRecordFailures, state) {
        if (!onlyRecordFailures) {
            if (state.host.fileExists(fileName)) {
                if (state.traceEnabled) {
                    trace(state.host, ts.Diagnostics.File_0_exist_use_it_as_a_name_resolution_result, fileName);
                }
                return fileName;
            }
            else {
                if (state.traceEnabled) {
                    trace(state.host, ts.Diagnostics.File_0_does_not_exist, fileName);
                }
            }
        }
        state.failedLookupLocations.push(fileName);
        return undefined;
    }
    function loadNodeModuleFromDirectory(extensions, candidate, onlyRecordFailures, state, considerPackageJson) {
        if (considerPackageJson === void 0) { considerPackageJson = true; }
        var packageInfo = considerPackageJson ? getPackageJsonInfo(candidate, onlyRecordFailures, state) : undefined;
        var packageJsonContent = packageInfo && packageInfo.packageJsonContent;
        var versionPaths = packageInfo && packageInfo.versionPaths;
        return withPackageId(packageInfo, loadNodeModuleFromDirectoryWorker(extensions, candidate, onlyRecordFailures, state, packageJsonContent, versionPaths));
    }
    function getEntrypointsFromPackageJsonInfo(packageJsonInfo, options, host, cache, resolveJs) {
        if (!resolveJs && packageJsonInfo.resolvedEntrypoints !== undefined) {
            return packageJsonInfo.resolvedEntrypoints;
        }
        var entrypoints;
        var extensions = resolveJs ? Extensions.JavaScript : Extensions.TypeScript;
        var features = getDefaultNodeResolutionFeatures(options);
        var requireState = {
            compilerOptions: options,
            host: host,
            traceEnabled: isTraceEnabled(options, host),
            failedLookupLocations: [],
            packageJsonInfoCache: cache === null || cache === void 0 ? void 0 : cache.getPackageJsonInfoCache(),
            conditions: ["node", "require", "types"],
            features: features,
            requestContainingDirectory: packageJsonInfo.packageDirectory,
            reportDiagnostic: ts.noop
        };
        var requireResolution = loadNodeModuleFromDirectoryWorker(extensions, packageJsonInfo.packageDirectory, false, requireState, packageJsonInfo.packageJsonContent, packageJsonInfo.versionPaths);
        entrypoints = ts.append(entrypoints, requireResolution === null || requireResolution === void 0 ? void 0 : requireResolution.path);
        if (features & NodeResolutionFeatures.Exports && packageJsonInfo.packageJsonContent.exports) {
            for (var _i = 0, _a = [["node", "import", "types"], ["node", "require", "types"]]; _i < _a.length; _i++) {
                var conditions = _a[_i];
                var exportState = __assign(__assign({}, requireState), { failedLookupLocations: [], conditions: conditions });
                var exportResolutions = loadEntrypointsFromExportMap(packageJsonInfo, packageJsonInfo.packageJsonContent.exports, exportState, extensions);
                if (exportResolutions) {
                    for (var _b = 0, exportResolutions_1 = exportResolutions; _b < exportResolutions_1.length; _b++) {
                        var resolution = exportResolutions_1[_b];
                        entrypoints = ts.appendIfUnique(entrypoints, resolution.path);
                    }
                }
            }
        }
        return packageJsonInfo.resolvedEntrypoints = entrypoints || false;
    }
    ts.getEntrypointsFromPackageJsonInfo = getEntrypointsFromPackageJsonInfo;
    function loadEntrypointsFromExportMap(scope, exports, state, extensions) {
        var entrypoints;
        if (ts.isArray(exports)) {
            for (var _i = 0, exports_1 = exports; _i < exports_1.length; _i++) {
                var target = exports_1[_i];
                loadEntrypointsFromTargetExports(target);
            }
        }
        else if (typeof exports === "object" && exports !== null && allKeysStartWithDot(exports)) {
            for (var key in exports) {
                loadEntrypointsFromTargetExports(exports[key]);
            }
        }
        else {
            loadEntrypointsFromTargetExports(exports);
        }
        return entrypoints;
        function loadEntrypointsFromTargetExports(target) {
            var _a, _b;
            if (typeof target === "string" && ts.startsWith(target, "./") && target.indexOf("*") === -1) {
                var partsAfterFirst = ts.getPathComponents(target).slice(2);
                if (partsAfterFirst.indexOf("..") >= 0 || partsAfterFirst.indexOf(".") >= 0 || partsAfterFirst.indexOf("node_modules") >= 0) {
                    return false;
                }
                var resolvedTarget = ts.combinePaths(scope.packageDirectory, target);
                var finalPath = ts.getNormalizedAbsolutePath(resolvedTarget, (_b = (_a = state.host).getCurrentDirectory) === null || _b === void 0 ? void 0 : _b.call(_a));
                var result = loadJSOrExactTSFileName(extensions, finalPath, false, state);
                if (result) {
                    entrypoints = ts.appendIfUnique(entrypoints, result, function (a, b) { return a.path === b.path; });
                    return true;
                }
            }
            else if (Array.isArray(target)) {
                for (var _i = 0, target_1 = target; _i < target_1.length; _i++) {
                    var t = target_1[_i];
                    var success = loadEntrypointsFromTargetExports(t);
                    if (success) {
                        return true;
                    }
                }
            }
            else if (typeof target === "object" && target !== null) {
                return ts.forEach(ts.getOwnKeys(target), function (key) {
                    if (key === "default" || ts.contains(state.conditions, key) || isApplicableVersionedTypesKey(state.conditions, key)) {
                        loadEntrypointsFromTargetExports(target[key]);
                        return true;
                    }
                });
            }
        }
    }
    function getPackageScopeForPath(fileName, packageJsonInfoCache, host, options) {
        var state = {
            host: host,
            compilerOptions: options,
            traceEnabled: isTraceEnabled(options, host),
            failedLookupLocations: [],
            packageJsonInfoCache: packageJsonInfoCache,
            features: 0,
            conditions: [],
            requestContainingDirectory: undefined,
            reportDiagnostic: ts.noop
        };
        var parts = ts.getPathComponents(fileName);
        parts.pop();
        while (parts.length > 0) {
            var pkg = getPackageJsonInfo(ts.getPathFromPathComponents(parts), false, state);
            if (pkg) {
                return pkg;
            }
            parts.pop();
        }
        return undefined;
    }
    ts.getPackageScopeForPath = getPackageScopeForPath;
    function getPackageJsonInfo(packageDirectory, onlyRecordFailures, state) {
        var _a, _b, _c;
        var host = state.host, traceEnabled = state.traceEnabled;
        var packageJsonPath = ts.combinePaths(packageDirectory, "package.json");
        if (onlyRecordFailures) {
            state.failedLookupLocations.push(packageJsonPath);
            return undefined;
        }
        var existing = (_a = state.packageJsonInfoCache) === null || _a === void 0 ? void 0 : _a.getPackageJsonInfo(packageJsonPath);
        if (existing !== undefined) {
            if (typeof existing !== "boolean") {
                if (traceEnabled)
                    trace(host, ts.Diagnostics.File_0_exists_according_to_earlier_cached_lookups, packageJsonPath);
                return existing;
            }
            else {
                if (existing && traceEnabled)
                    trace(host, ts.Diagnostics.File_0_does_not_exist_according_to_earlier_cached_lookups, packageJsonPath);
                state.failedLookupLocations.push(packageJsonPath);
                return undefined;
            }
        }
        var directoryExists = ts.directoryProbablyExists(packageDirectory, host);
        if (directoryExists && host.fileExists(packageJsonPath)) {
            var packageJsonContent = ts.readJson(packageJsonPath, host);
            if (traceEnabled) {
                trace(host, ts.Diagnostics.Found_package_json_at_0, packageJsonPath);
            }
            var versionPaths = readPackageJsonTypesVersionPaths(packageJsonContent, state);
            var result = { packageDirectory: packageDirectory, packageJsonContent: packageJsonContent, versionPaths: versionPaths, resolvedEntrypoints: undefined };
            (_b = state.packageJsonInfoCache) === null || _b === void 0 ? void 0 : _b.setPackageJsonInfo(packageJsonPath, result);
            return result;
        }
        else {
            if (directoryExists && traceEnabled) {
                trace(host, ts.Diagnostics.File_0_does_not_exist, packageJsonPath);
            }
            (_c = state.packageJsonInfoCache) === null || _c === void 0 ? void 0 : _c.setPackageJsonInfo(packageJsonPath, directoryExists);
            state.failedLookupLocations.push(packageJsonPath);
        }
    }
    ts.getPackageJsonInfo = getPackageJsonInfo;
    function loadNodeModuleFromDirectoryWorker(extensions, candidate, onlyRecordFailures, state, jsonContent, versionPaths) {
        var packageFile;
        if (jsonContent) {
            switch (extensions) {
                case Extensions.JavaScript:
                case Extensions.Json:
                case Extensions.TsOnly:
                    packageFile = readPackageJsonMainField(jsonContent, candidate, state);
                    break;
                case Extensions.TypeScript:
                    packageFile = readPackageJsonTypesFields(jsonContent, candidate, state) || readPackageJsonMainField(jsonContent, candidate, state);
                    break;
                case Extensions.DtsOnly:
                    packageFile = readPackageJsonTypesFields(jsonContent, candidate, state);
                    break;
                case Extensions.TSConfig:
                    packageFile = readPackageJsonTSConfigField(jsonContent, candidate, state);
                    break;
                default:
                    return ts.Debug.assertNever(extensions);
            }
        }
        var loader = function (extensions, candidate, onlyRecordFailures, state) {
            var fromFile = tryFile(candidate, onlyRecordFailures, state);
            if (fromFile) {
                var resolved = resolvedIfExtensionMatches(extensions, fromFile);
                if (resolved) {
                    return noPackageId(resolved);
                }
                if (state.traceEnabled) {
                    trace(state.host, ts.Diagnostics.File_0_has_an_unsupported_extension_so_skipping_it, fromFile);
                }
            }
            var nextExtensions = extensions === Extensions.DtsOnly ? Extensions.TypeScript : extensions;
            var features = state.features;
            if ((jsonContent === null || jsonContent === void 0 ? void 0 : jsonContent.type) !== "module") {
                state.features &= ~NodeResolutionFeatures.EsmMode;
            }
            var result = nodeLoadModuleByRelativeName(nextExtensions, candidate, onlyRecordFailures, state, false);
            state.features = features;
            return result;
        };
        var onlyRecordFailuresForPackageFile = packageFile ? !ts.directoryProbablyExists(ts.getDirectoryPath(packageFile), state.host) : undefined;
        var onlyRecordFailuresForIndex = onlyRecordFailures || !ts.directoryProbablyExists(candidate, state.host);
        var indexPath = ts.combinePaths(candidate, extensions === Extensions.TSConfig ? "tsconfig" : "index");
        if (versionPaths && (!packageFile || ts.containsPath(candidate, packageFile))) {
            var moduleName = ts.getRelativePathFromDirectory(candidate, packageFile || indexPath, false);
            if (state.traceEnabled) {
                trace(state.host, ts.Diagnostics.package_json_has_a_typesVersions_entry_0_that_matches_compiler_version_1_looking_for_a_pattern_to_match_module_name_2, versionPaths.version, ts.version, moduleName);
            }
            var result = tryLoadModuleUsingPaths(extensions, moduleName, candidate, versionPaths.paths, undefined, loader, onlyRecordFailuresForPackageFile || onlyRecordFailuresForIndex, state);
            if (result) {
                return removeIgnoredPackageId(result.value);
            }
        }
        var packageFileResult = packageFile && removeIgnoredPackageId(loader(extensions, packageFile, onlyRecordFailuresForPackageFile, state));
        if (packageFileResult)
            return packageFileResult;
        if (!(state.features & NodeResolutionFeatures.EsmMode)) {
            return loadModuleFromFile(extensions, indexPath, onlyRecordFailuresForIndex, state);
        }
    }
    function resolvedIfExtensionMatches(extensions, path) {
        var ext = ts.tryGetExtensionFromPath(path);
        return ext !== undefined && extensionIsOk(extensions, ext) ? { path: path, ext: ext } : undefined;
    }
    function extensionIsOk(extensions, extension) {
        switch (extensions) {
            case Extensions.JavaScript:
                return extension === ".js" || extension === ".jsx" || extension === ".mjs" || extension === ".cjs";
            case Extensions.TSConfig:
            case Extensions.Json:
                return extension === ".json";
            case Extensions.TypeScript:
                return extension === ".ts" || extension === ".tsx" || extension === ".mts" || extension === ".cts" || extension === ".d.ts" || extension === ".d.mts" || extension === ".d.cts";
            case Extensions.TsOnly:
                return extension === ".ts" || extension === ".tsx" || extension === ".mts" || extension === ".cts";
            case Extensions.DtsOnly:
                return extension === ".d.ts" || extension === ".d.mts" || extension === ".d.cts";
        }
    }
    function parsePackageName(moduleName) {
        var idx = moduleName.indexOf(ts.directorySeparator);
        if (moduleName[0] === "@") {
            idx = moduleName.indexOf(ts.directorySeparator, idx + 1);
        }
        return idx === -1 ? { packageName: moduleName, rest: "" } : { packageName: moduleName.slice(0, idx), rest: moduleName.slice(idx + 1) };
    }
    ts.parsePackageName = parsePackageName;
    function allKeysStartWithDot(obj) {
        return ts.every(ts.getOwnKeys(obj), function (k) { return ts.startsWith(k, "."); });
    }
    ts.allKeysStartWithDot = allKeysStartWithDot;
    function noKeyStartsWithDot(obj) {
        return !ts.some(ts.getOwnKeys(obj), function (k) { return ts.startsWith(k, "."); });
    }
    function loadModuleFromSelfNameReference(extensions, moduleName, directory, state, cache, redirectedReference) {
        var _a, _b;
        var useCaseSensitiveFileNames = typeof state.host.useCaseSensitiveFileNames === "function" ? state.host.useCaseSensitiveFileNames() : state.host.useCaseSensitiveFileNames;
        var directoryPath = ts.toPath(ts.combinePaths(directory, "dummy"), (_b = (_a = state.host).getCurrentDirectory) === null || _b === void 0 ? void 0 : _b.call(_a), ts.createGetCanonicalFileName(useCaseSensitiveFileNames === undefined ? true : useCaseSensitiveFileNames));
        var scope = getPackageScopeForPath(directoryPath, state.packageJsonInfoCache, state.host, state.compilerOptions);
        if (!scope || !scope.packageJsonContent.exports) {
            return undefined;
        }
        if (typeof scope.packageJsonContent.name !== "string") {
            return undefined;
        }
        var parts = ts.getPathComponents(moduleName);
        var nameParts = ts.getPathComponents(scope.packageJsonContent.name);
        if (!ts.every(nameParts, function (p, i) { return parts[i] === p; })) {
            return undefined;
        }
        var trailingParts = parts.slice(nameParts.length);
        return loadModuleFromExports(scope, extensions, !ts.length(trailingParts) ? "." : ".".concat(ts.directorySeparator).concat(trailingParts.join(ts.directorySeparator)), state, cache, redirectedReference);
    }
    function loadModuleFromExports(scope, extensions, subpath, state, cache, redirectedReference) {
        if (!scope.packageJsonContent.exports) {
            return undefined;
        }
        if (subpath === ".") {
            var mainExport = void 0;
            if (typeof scope.packageJsonContent.exports === "string" || Array.isArray(scope.packageJsonContent.exports) || (typeof scope.packageJsonContent.exports === "object" && noKeyStartsWithDot(scope.packageJsonContent.exports))) {
                mainExport = scope.packageJsonContent.exports;
            }
            else if (ts.hasProperty(scope.packageJsonContent.exports, ".")) {
                mainExport = scope.packageJsonContent.exports["."];
            }
            if (mainExport) {
                var loadModuleFromTargetImportOrExport = getLoadModuleFromTargetImportOrExport(extensions, state, cache, redirectedReference, subpath, scope, false);
                return loadModuleFromTargetImportOrExport(mainExport, "", false);
            }
        }
        else if (allKeysStartWithDot(scope.packageJsonContent.exports)) {
            if (typeof scope.packageJsonContent.exports !== "object") {
                if (state.traceEnabled) {
                    trace(state.host, ts.Diagnostics.Export_specifier_0_does_not_exist_in_package_json_scope_at_path_1, subpath, scope.packageDirectory);
                }
                return toSearchResult(undefined);
            }
            var result = loadModuleFromImportsOrExports(extensions, state, cache, redirectedReference, subpath, scope.packageJsonContent.exports, scope, false);
            if (result) {
                return result;
            }
        }
        if (state.traceEnabled) {
            trace(state.host, ts.Diagnostics.Export_specifier_0_does_not_exist_in_package_json_scope_at_path_1, subpath, scope.packageDirectory);
        }
        return toSearchResult(undefined);
    }
    function loadModuleFromImports(extensions, moduleName, directory, state, cache, redirectedReference) {
        var _a, _b;
        if (moduleName === "#" || ts.startsWith(moduleName, "#/")) {
            if (state.traceEnabled) {
                trace(state.host, ts.Diagnostics.Invalid_import_specifier_0_has_no_possible_resolutions, moduleName);
            }
            return toSearchResult(undefined);
        }
        var useCaseSensitiveFileNames = typeof state.host.useCaseSensitiveFileNames === "function" ? state.host.useCaseSensitiveFileNames() : state.host.useCaseSensitiveFileNames;
        var directoryPath = ts.toPath(ts.combinePaths(directory, "dummy"), (_b = (_a = state.host).getCurrentDirectory) === null || _b === void 0 ? void 0 : _b.call(_a), ts.createGetCanonicalFileName(useCaseSensitiveFileNames === undefined ? true : useCaseSensitiveFileNames));
        var scope = getPackageScopeForPath(directoryPath, state.packageJsonInfoCache, state.host, state.compilerOptions);
        if (!scope) {
            if (state.traceEnabled) {
                trace(state.host, ts.Diagnostics.Directory_0_has_no_containing_package_json_scope_Imports_will_not_resolve, directoryPath);
            }
            return toSearchResult(undefined);
        }
        if (!scope.packageJsonContent.imports) {
            if (state.traceEnabled) {
                trace(state.host, ts.Diagnostics.package_json_scope_0_has_no_imports_defined, scope.packageDirectory);
            }
            return toSearchResult(undefined);
        }
        var result = loadModuleFromImportsOrExports(extensions, state, cache, redirectedReference, moduleName, scope.packageJsonContent.imports, scope, true);
        if (result) {
            return result;
        }
        if (state.traceEnabled) {
            trace(state.host, ts.Diagnostics.Import_specifier_0_does_not_exist_in_package_json_scope_at_path_1, moduleName, scope.packageDirectory);
        }
        return toSearchResult(undefined);
    }
    function comparePatternKeys(a, b) {
        var aPatternIndex = a.indexOf("*");
        var bPatternIndex = b.indexOf("*");
        var baseLenA = aPatternIndex === -1 ? a.length : aPatternIndex + 1;
        var baseLenB = bPatternIndex === -1 ? b.length : bPatternIndex + 1;
        if (baseLenA > baseLenB)
            return -1;
        if (baseLenB > baseLenA)
            return 1;
        if (aPatternIndex === -1)
            return 1;
        if (bPatternIndex === -1)
            return -1;
        if (a.length > b.length)
            return -1;
        if (b.length > a.length)
            return 1;
        return 0;
    }
    function loadModuleFromImportsOrExports(extensions, state, cache, redirectedReference, moduleName, lookupTable, scope, isImports) {
        var loadModuleFromTargetImportOrExport = getLoadModuleFromTargetImportOrExport(extensions, state, cache, redirectedReference, moduleName, scope, isImports);
        if (!ts.endsWith(moduleName, ts.directorySeparator) && moduleName.indexOf("*") === -1 && ts.hasProperty(lookupTable, moduleName)) {
            var target = lookupTable[moduleName];
            return loadModuleFromTargetImportOrExport(target, "", false);
        }
        var expandingKeys = ts.sort(ts.filter(ts.getOwnKeys(lookupTable), function (k) { return k.indexOf("*") !== -1 || ts.endsWith(k, "/"); }), comparePatternKeys);
        for (var _i = 0, expandingKeys_1 = expandingKeys; _i < expandingKeys_1.length; _i++) {
            var potentialTarget = expandingKeys_1[_i];
            if (state.features & NodeResolutionFeatures.ExportsPatternTrailers && matchesPatternWithTrailer(potentialTarget, moduleName)) {
                var target = lookupTable[potentialTarget];
                var starPos = potentialTarget.indexOf("*");
                var subpath = moduleName.substring(potentialTarget.substring(0, starPos).length, moduleName.length - (potentialTarget.length - 1 - starPos));
                return loadModuleFromTargetImportOrExport(target, subpath, true);
            }
            else if (ts.endsWith(potentialTarget, "*") && ts.startsWith(moduleName, potentialTarget.substring(0, potentialTarget.length - 1))) {
                var target = lookupTable[potentialTarget];
                var subpath = moduleName.substring(potentialTarget.length - 1);
                return loadModuleFromTargetImportOrExport(target, subpath, true);
            }
            else if (ts.startsWith(moduleName, potentialTarget)) {
                var target = lookupTable[potentialTarget];
                var subpath = moduleName.substring(potentialTarget.length);
                return loadModuleFromTargetImportOrExport(target, subpath, false);
            }
        }
        function matchesPatternWithTrailer(target, name) {
            if (ts.endsWith(target, "*"))
                return false;
            var starPos = target.indexOf("*");
            if (starPos === -1)
                return false;
            return ts.startsWith(name, target.substring(0, starPos)) && ts.endsWith(name, target.substring(starPos + 1));
        }
    }
    function getLoadModuleFromTargetImportOrExport(extensions, state, cache, redirectedReference, moduleName, scope, isImports) {
        return loadModuleFromTargetImportOrExport;
        function loadModuleFromTargetImportOrExport(target, subpath, pattern) {
            if (typeof target === "string") {
                if (!pattern && subpath.length > 0 && !ts.endsWith(target, "/")) {
                    if (state.traceEnabled) {
                        trace(state.host, ts.Diagnostics.package_json_scope_0_has_invalid_type_for_target_of_specifier_1, scope.packageDirectory, moduleName);
                    }
                    return toSearchResult(undefined);
                }
                if (!ts.startsWith(target, "./")) {
                    if (isImports && !ts.startsWith(target, "../") && !ts.startsWith(target, "/") && !ts.isRootedDiskPath(target)) {
                        var combinedLookup = pattern ? target.replace(/\*/g, subpath) : target + subpath;
                        var result = nodeModuleNameResolverWorker(state.features, combinedLookup, scope.packageDirectory + "/", state.compilerOptions, state.host, cache, [extensions], redirectedReference);
                        return toSearchResult(result.resolvedModule ? { path: result.resolvedModule.resolvedFileName, extension: result.resolvedModule.extension, packageId: result.resolvedModule.packageId, originalPath: result.resolvedModule.originalPath } : undefined);
                    }
                    if (state.traceEnabled) {
                        trace(state.host, ts.Diagnostics.package_json_scope_0_has_invalid_type_for_target_of_specifier_1, scope.packageDirectory, moduleName);
                    }
                    return toSearchResult(undefined);
                }
                var parts = ts.pathIsRelative(target) ? ts.getPathComponents(target).slice(1) : ts.getPathComponents(target);
                var partsAfterFirst = parts.slice(1);
                if (partsAfterFirst.indexOf("..") >= 0 || partsAfterFirst.indexOf(".") >= 0 || partsAfterFirst.indexOf("node_modules") >= 0) {
                    if (state.traceEnabled) {
                        trace(state.host, ts.Diagnostics.package_json_scope_0_has_invalid_type_for_target_of_specifier_1, scope.packageDirectory, moduleName);
                    }
                    return toSearchResult(undefined);
                }
                var resolvedTarget = ts.combinePaths(scope.packageDirectory, target);
                var subpathParts = ts.getPathComponents(subpath);
                if (subpathParts.indexOf("..") >= 0 || subpathParts.indexOf(".") >= 0 || subpathParts.indexOf("node_modules") >= 0) {
                    if (state.traceEnabled) {
                        trace(state.host, ts.Diagnostics.package_json_scope_0_has_invalid_type_for_target_of_specifier_1, scope.packageDirectory, moduleName);
                    }
                    return toSearchResult(undefined);
                }
                var finalPath = toAbsolutePath(pattern ? resolvedTarget.replace(/\*/g, subpath) : resolvedTarget + subpath);
                var inputLink = tryLoadInputFileForPath(finalPath, subpath, ts.combinePaths(scope.packageDirectory, "package.json"), isImports);
                if (inputLink)
                    return inputLink;
                return toSearchResult(withPackageId(scope, loadJSOrExactTSFileName(extensions, finalPath, false, state)));
            }
            else if (typeof target === "object" && target !== null) {
                if (!Array.isArray(target)) {
                    for (var _i = 0, _a = ts.getOwnKeys(target); _i < _a.length; _i++) {
                        var key = _a[_i];
                        if (key === "default" || state.conditions.indexOf(key) >= 0 || isApplicableVersionedTypesKey(state.conditions, key)) {
                            var subTarget = target[key];
                            var result = loadModuleFromTargetImportOrExport(subTarget, subpath, pattern);
                            if (result) {
                                return result;
                            }
                        }
                    }
                    return undefined;
                }
                else {
                    if (!ts.length(target)) {
                        if (state.traceEnabled) {
                            trace(state.host, ts.Diagnostics.package_json_scope_0_has_invalid_type_for_target_of_specifier_1, scope.packageDirectory, moduleName);
                        }
                        return toSearchResult(undefined);
                    }
                    for (var _b = 0, target_2 = target; _b < target_2.length; _b++) {
                        var elem = target_2[_b];
                        var result = loadModuleFromTargetImportOrExport(elem, subpath, pattern);
                        if (result) {
                            return result;
                        }
                    }
                }
            }
            else if (target === null) {
                if (state.traceEnabled) {
                    trace(state.host, ts.Diagnostics.package_json_scope_0_explicitly_maps_specifier_1_to_null, scope.packageDirectory, moduleName);
                }
                return toSearchResult(undefined);
            }
            if (state.traceEnabled) {
                trace(state.host, ts.Diagnostics.package_json_scope_0_has_invalid_type_for_target_of_specifier_1, scope.packageDirectory, moduleName);
            }
            return toSearchResult(undefined);
            function toAbsolutePath(path) {
                var _a, _b;
                if (path === undefined)
                    return path;
                return ts.hostGetCanonicalFileName({ useCaseSensitiveFileNames: useCaseSensitiveFileNames })(ts.getNormalizedAbsolutePath(path, (_b = (_a = state.host).getCurrentDirectory) === null || _b === void 0 ? void 0 : _b.call(_a)));
            }
            function combineDirectoryPath(root, dir) {
                return ts.ensureTrailingDirectorySeparator(ts.combinePaths(root, dir));
            }
            function useCaseSensitiveFileNames() {
                return !state.host.useCaseSensitiveFileNames ? true :
                    typeof state.host.useCaseSensitiveFileNames === "boolean" ? state.host.useCaseSensitiveFileNames :
                        state.host.useCaseSensitiveFileNames();
            }
            function tryLoadInputFileForPath(finalPath, entry, packagePath, isImports) {
                var _a, _b, _c, _d;
                if ((extensions === Extensions.TypeScript || extensions === Extensions.JavaScript || extensions === Extensions.Json)
                    && (state.compilerOptions.declarationDir || state.compilerOptions.outDir)
                    && finalPath.indexOf("/node_modules/") === -1
                    && (state.compilerOptions.configFile ? ts.startsWith(toAbsolutePath(state.compilerOptions.configFile.fileName), scope.packageDirectory) : true)) {
                    var getCanonicalFileName = ts.hostGetCanonicalFileName({ useCaseSensitiveFileNames: useCaseSensitiveFileNames });
                    var commonSourceDirGuesses = [];
                    if (state.compilerOptions.rootDir || (state.compilerOptions.composite && state.compilerOptions.configFilePath)) {
                        var commonDir = toAbsolutePath(ts.getCommonSourceDirectory(state.compilerOptions, function () { return []; }, ((_b = (_a = state.host).getCurrentDirectory) === null || _b === void 0 ? void 0 : _b.call(_a)) || "", getCanonicalFileName));
                        commonSourceDirGuesses.push(commonDir);
                    }
                    else if (state.requestContainingDirectory) {
                        var requestingFile_1 = toAbsolutePath(ts.combinePaths(state.requestContainingDirectory, "index.ts"));
                        var commonDir = toAbsolutePath(ts.getCommonSourceDirectory(state.compilerOptions, function () { return [requestingFile_1, toAbsolutePath(packagePath)]; }, ((_d = (_c = state.host).getCurrentDirectory) === null || _d === void 0 ? void 0 : _d.call(_c)) || "", getCanonicalFileName));
                        commonSourceDirGuesses.push(commonDir);
                        var fragment = ts.ensureTrailingDirectorySeparator(commonDir);
                        while (fragment && fragment.length > 1) {
                            var parts = ts.getPathComponents(fragment);
                            parts.pop();
                            var commonDir_1 = ts.getPathFromPathComponents(parts);
                            commonSourceDirGuesses.unshift(commonDir_1);
                            fragment = ts.ensureTrailingDirectorySeparator(commonDir_1);
                        }
                    }
                    if (commonSourceDirGuesses.length > 1) {
                        state.reportDiagnostic(ts.createCompilerDiagnostic(isImports
                            ? ts.Diagnostics.The_project_root_is_ambiguous_but_is_required_to_resolve_import_map_entry_0_in_file_1_Supply_the_rootDir_compiler_option_to_disambiguate
                            : ts.Diagnostics.The_project_root_is_ambiguous_but_is_required_to_resolve_export_map_entry_0_in_file_1_Supply_the_rootDir_compiler_option_to_disambiguate, entry === "" ? "." : entry, packagePath));
                    }
                    for (var _i = 0, commonSourceDirGuesses_1 = commonSourceDirGuesses; _i < commonSourceDirGuesses_1.length; _i++) {
                        var commonSourceDirGuess = commonSourceDirGuesses_1[_i];
                        var candidateDirectories = getOutputDirectoriesForBaseDirectory(commonSourceDirGuess);
                        for (var _e = 0, candidateDirectories_1 = candidateDirectories; _e < candidateDirectories_1.length; _e++) {
                            var candidateDir = candidateDirectories_1[_e];
                            if (ts.startsWith(finalPath, candidateDir)) {
                                var pathFragment = finalPath.slice(candidateDir.length + 1);
                                var possibleInputBase = ts.combinePaths(commonSourceDirGuess, pathFragment);
                                var jsAndDtsExtensions = [".mjs", ".cjs", ".js", ".json", ".d.mts", ".d.cts", ".d.ts"];
                                for (var _f = 0, jsAndDtsExtensions_1 = jsAndDtsExtensions; _f < jsAndDtsExtensions_1.length; _f++) {
                                    var ext = jsAndDtsExtensions_1[_f];
                                    if (ts.fileExtensionIs(possibleInputBase, ext)) {
                                        var inputExts = ts.getPossibleOriginalInputExtensionForExtension(possibleInputBase);
                                        for (var _g = 0, inputExts_1 = inputExts; _g < inputExts_1.length; _g++) {
                                            var possibleExt = inputExts_1[_g];
                                            var possibleInputWithInputExtension = ts.changeAnyExtension(possibleInputBase, possibleExt, ext, !useCaseSensitiveFileNames());
                                            if ((extensions === Extensions.TypeScript && ts.hasJSFileExtension(possibleInputWithInputExtension)) ||
                                                (extensions === Extensions.JavaScript && ts.hasTSFileExtension(possibleInputWithInputExtension))) {
                                                continue;
                                            }
                                            if (state.host.fileExists(possibleInputWithInputExtension)) {
                                                return toSearchResult(withPackageId(scope, loadJSOrExactTSFileName(extensions, possibleInputWithInputExtension, false, state)));
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                return undefined;
                function getOutputDirectoriesForBaseDirectory(commonSourceDirGuess) {
                    var _a, _b;
                    var currentDir = state.compilerOptions.configFile ? ((_b = (_a = state.host).getCurrentDirectory) === null || _b === void 0 ? void 0 : _b.call(_a)) || "" : commonSourceDirGuess;
                    var candidateDirectories = [];
                    if (state.compilerOptions.declarationDir) {
                        candidateDirectories.push(toAbsolutePath(combineDirectoryPath(currentDir, state.compilerOptions.declarationDir)));
                    }
                    if (state.compilerOptions.outDir && state.compilerOptions.outDir !== state.compilerOptions.declarationDir) {
                        candidateDirectories.push(toAbsolutePath(combineDirectoryPath(currentDir, state.compilerOptions.outDir)));
                    }
                    return candidateDirectories;
                }
            }
        }
    }
    function isApplicableVersionedTypesKey(conditions, key) {
        if (conditions.indexOf("types") === -1)
            return false;
        if (!ts.startsWith(key, "types@"))
            return false;
        var range = ts.VersionRange.tryParse(key.substring("types@".length));
        if (!range)
            return false;
        return range.test(ts.version);
    }
    ts.isApplicableVersionedTypesKey = isApplicableVersionedTypesKey;
    function loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, directory, state, cache, redirectedReference) {
        return loadModuleFromNearestNodeModulesDirectoryWorker(extensions, moduleName, directory, state, false, cache, redirectedReference);
    }
    function loadModuleFromNearestNodeModulesDirectoryTypesScope(moduleName, directory, state) {
        return loadModuleFromNearestNodeModulesDirectoryWorker(Extensions.DtsOnly, moduleName, directory, state, true, undefined, undefined);
    }
    function loadModuleFromNearestNodeModulesDirectoryWorker(extensions, moduleName, directory, state, typesScopeOnly, cache, redirectedReference) {
        var perModuleNameCache = cache && cache.getOrCreateCacheForModuleName(moduleName, state.features === 0 ? undefined : state.features & NodeResolutionFeatures.EsmMode ? ts.ModuleKind.ESNext : ts.ModuleKind.CommonJS, redirectedReference);
        return ts.forEachAncestorDirectory(ts.normalizeSlashes(directory), function (ancestorDirectory) {
            if (ts.getBaseFileName(ancestorDirectory) !== "node_modules") {
                var resolutionFromCache = tryFindNonRelativeModuleNameInCache(perModuleNameCache, moduleName, ancestorDirectory, state);
                if (resolutionFromCache) {
                    return resolutionFromCache;
                }
                return toSearchResult(loadModuleFromImmediateNodeModulesDirectory(extensions, moduleName, ancestorDirectory, state, typesScopeOnly, cache, redirectedReference));
            }
        });
    }
    function loadModuleFromImmediateNodeModulesDirectory(extensions, moduleName, directory, state, typesScopeOnly, cache, redirectedReference) {
        var nodeModulesFolder = ts.combinePaths(directory, "node_modules");
        var nodeModulesFolderExists = ts.directoryProbablyExists(nodeModulesFolder, state.host);
        if (!nodeModulesFolderExists && state.traceEnabled) {
            trace(state.host, ts.Diagnostics.Directory_0_does_not_exist_skipping_all_lookups_in_it, nodeModulesFolder);
        }
        var packageResult = typesScopeOnly ? undefined : loadModuleFromSpecificNodeModulesDirectory(extensions, moduleName, nodeModulesFolder, nodeModulesFolderExists, state, cache, redirectedReference);
        if (packageResult) {
            return packageResult;
        }
        if (extensions === Extensions.TypeScript || extensions === Extensions.DtsOnly) {
            var nodeModulesAtTypes_1 = ts.combinePaths(nodeModulesFolder, "@types");
            var nodeModulesAtTypesExists = nodeModulesFolderExists;
            if (nodeModulesFolderExists && !ts.directoryProbablyExists(nodeModulesAtTypes_1, state.host)) {
                if (state.traceEnabled) {
                    trace(state.host, ts.Diagnostics.Directory_0_does_not_exist_skipping_all_lookups_in_it, nodeModulesAtTypes_1);
                }
                nodeModulesAtTypesExists = false;
            }
            return loadModuleFromSpecificNodeModulesDirectory(Extensions.DtsOnly, mangleScopedPackageNameWithTrace(moduleName, state), nodeModulesAtTypes_1, nodeModulesAtTypesExists, state, cache, redirectedReference);
        }
    }
    function loadModuleFromSpecificNodeModulesDirectory(extensions, moduleName, nodeModulesDirectory, nodeModulesDirectoryExists, state, cache, redirectedReference) {
        var candidate = ts.normalizePath(ts.combinePaths(nodeModulesDirectory, moduleName));
        var packageInfo = getPackageJsonInfo(candidate, !nodeModulesDirectoryExists, state);
        if (!(state.features & NodeResolutionFeatures.Exports)) {
            if (packageInfo) {
                var fromFile = loadModuleFromFile(extensions, candidate, !nodeModulesDirectoryExists, state);
                if (fromFile) {
                    return noPackageId(fromFile);
                }
                var fromDirectory = loadNodeModuleFromDirectoryWorker(extensions, candidate, !nodeModulesDirectoryExists, state, packageInfo.packageJsonContent, packageInfo.versionPaths);
                return withPackageId(packageInfo, fromDirectory);
            }
        }
        var _a = parsePackageName(moduleName), packageName = _a.packageName, rest = _a.rest;
        var loader = function (extensions, candidate, onlyRecordFailures, state) {
            var _a;
            if (packageInfo && packageInfo.packageJsonContent.exports && state.features & NodeResolutionFeatures.Exports) {
                return (_a = loadModuleFromExports(packageInfo, extensions, ts.combinePaths(".", rest), state, cache, redirectedReference)) === null || _a === void 0 ? void 0 : _a.value;
            }
            var pathAndExtension = loadModuleFromFile(extensions, candidate, onlyRecordFailures, state) ||
                loadNodeModuleFromDirectoryWorker(extensions, candidate, onlyRecordFailures, state, packageInfo && packageInfo.packageJsonContent, packageInfo && packageInfo.versionPaths);
            if (!pathAndExtension && packageInfo
                && (packageInfo.packageJsonContent.exports === undefined || packageInfo.packageJsonContent.exports === null)
                && state.features & NodeResolutionFeatures.EsmMode) {
                pathAndExtension = loadModuleFromFile(extensions, ts.combinePaths(candidate, "index.js"), onlyRecordFailures, state);
            }
            return withPackageId(packageInfo, pathAndExtension);
        };
        if (rest !== "") {
            var packageDirectory = ts.combinePaths(nodeModulesDirectory, packageName);
            packageInfo = getPackageJsonInfo(packageDirectory, !nodeModulesDirectoryExists, state);
            if (packageInfo && packageInfo.versionPaths) {
                if (state.traceEnabled) {
                    trace(state.host, ts.Diagnostics.package_json_has_a_typesVersions_entry_0_that_matches_compiler_version_1_looking_for_a_pattern_to_match_module_name_2, packageInfo.versionPaths.version, ts.version, rest);
                }
                var packageDirectoryExists = nodeModulesDirectoryExists && ts.directoryProbablyExists(packageDirectory, state.host);
                var fromPaths = tryLoadModuleUsingPaths(extensions, rest, packageDirectory, packageInfo.versionPaths.paths, undefined, loader, !packageDirectoryExists, state);
                if (fromPaths) {
                    return fromPaths.value;
                }
            }
        }
        return loader(extensions, candidate, !nodeModulesDirectoryExists, state);
    }
    function tryLoadModuleUsingPaths(extensions, moduleName, baseDirectory, paths, pathPatterns, loader, onlyRecordFailures, state) {
        pathPatterns || (pathPatterns = ts.tryParsePatterns(paths));
        var matchedPattern = ts.matchPatternOrExact(pathPatterns, moduleName);
        if (matchedPattern) {
            var matchedStar_1 = ts.isString(matchedPattern) ? undefined : ts.matchedText(matchedPattern, moduleName);
            var matchedPatternText = ts.isString(matchedPattern) ? matchedPattern : ts.patternText(matchedPattern);
            if (state.traceEnabled) {
                trace(state.host, ts.Diagnostics.Module_name_0_matched_pattern_1, moduleName, matchedPatternText);
            }
            var resolved = ts.forEach(paths[matchedPatternText], function (subst) {
                var path = matchedStar_1 ? subst.replace("*", matchedStar_1) : subst;
                var candidate = ts.normalizePath(ts.combinePaths(baseDirectory, path));
                if (state.traceEnabled) {
                    trace(state.host, ts.Diagnostics.Trying_substitution_0_candidate_module_location_Colon_1, subst, path);
                }
                var extension = ts.tryGetExtensionFromPath(subst);
                if (extension !== undefined) {
                    var path_1 = tryFile(candidate, onlyRecordFailures, state);
                    if (path_1 !== undefined) {
                        return noPackageId({ path: path_1, ext: extension });
                    }
                }
                return loader(extensions, candidate, onlyRecordFailures || !ts.directoryProbablyExists(ts.getDirectoryPath(candidate), state.host), state);
            });
            return { value: resolved };
        }
    }
    var mangledScopedPackageSeparator = "__";
    function mangleScopedPackageNameWithTrace(packageName, state) {
        var mangled = mangleScopedPackageName(packageName);
        if (state.traceEnabled && mangled !== packageName) {
            trace(state.host, ts.Diagnostics.Scoped_package_detected_looking_in_0, mangled);
        }
        return mangled;
    }
    function getTypesPackageName(packageName) {
        return "@types/".concat(mangleScopedPackageName(packageName));
    }
    ts.getTypesPackageName = getTypesPackageName;
    function mangleScopedPackageName(packageName) {
        if (ts.startsWith(packageName, "@")) {
            var replaceSlash = packageName.replace(ts.directorySeparator, mangledScopedPackageSeparator);
            if (replaceSlash !== packageName) {
                return replaceSlash.slice(1);
            }
        }
        return packageName;
    }
    ts.mangleScopedPackageName = mangleScopedPackageName;
    function getPackageNameFromTypesPackageName(mangledName) {
        var withoutAtTypePrefix = ts.removePrefix(mangledName, "@types/");
        if (withoutAtTypePrefix !== mangledName) {
            return unmangleScopedPackageName(withoutAtTypePrefix);
        }
        return mangledName;
    }
    ts.getPackageNameFromTypesPackageName = getPackageNameFromTypesPackageName;
    function unmangleScopedPackageName(typesPackageName) {
        return ts.stringContains(typesPackageName, mangledScopedPackageSeparator) ?
            "@" + typesPackageName.replace(mangledScopedPackageSeparator, ts.directorySeparator) :
            typesPackageName;
    }
    ts.unmangleScopedPackageName = unmangleScopedPackageName;
    function tryFindNonRelativeModuleNameInCache(cache, moduleName, containingDirectory, state) {
        var result = cache && cache.get(containingDirectory);
        if (result) {
            if (state.traceEnabled) {
                trace(state.host, ts.Diagnostics.Resolution_for_module_0_was_found_in_cache_from_location_1, moduleName, containingDirectory);
            }
            state.resultFromCache = result;
            return { value: result.resolvedModule && { path: result.resolvedModule.resolvedFileName, originalPath: result.resolvedModule.originalPath || true, extension: result.resolvedModule.extension, packageId: result.resolvedModule.packageId } };
        }
    }
    function classicNameResolver(moduleName, containingFile, compilerOptions, host, cache, redirectedReference) {
        var traceEnabled = isTraceEnabled(compilerOptions, host);
        var failedLookupLocations = [];
        var containingDirectory = ts.getDirectoryPath(containingFile);
        var diagnostics = [];
        var state = { compilerOptions: compilerOptions, host: host, traceEnabled: traceEnabled, failedLookupLocations: failedLookupLocations, packageJsonInfoCache: cache, features: NodeResolutionFeatures.None, conditions: [], requestContainingDirectory: containingDirectory, reportDiagnostic: function (diag) { return void diagnostics.push(diag); } };
        var resolved = tryResolve(Extensions.TypeScript) || tryResolve(Extensions.JavaScript);
        return createResolvedModuleWithFailedLookupLocations(resolved && resolved.value, false, failedLookupLocations, diagnostics, state.resultFromCache);
        function tryResolve(extensions) {
            var resolvedUsingSettings = tryLoadModuleUsingOptionalResolutionSettings(extensions, moduleName, containingDirectory, loadModuleFromFileNoPackageId, state);
            if (resolvedUsingSettings) {
                return { value: resolvedUsingSettings };
            }
            if (!ts.isExternalModuleNameRelative(moduleName)) {
                var perModuleNameCache_1 = cache && cache.getOrCreateCacheForModuleName(moduleName, undefined, redirectedReference);
                var resolved_3 = ts.forEachAncestorDirectory(containingDirectory, function (directory) {
                    var resolutionFromCache = tryFindNonRelativeModuleNameInCache(perModuleNameCache_1, moduleName, directory, state);
                    if (resolutionFromCache) {
                        return resolutionFromCache;
                    }
                    var searchName = ts.normalizePath(ts.combinePaths(directory, moduleName));
                    return toSearchResult(loadModuleFromFileNoPackageId(extensions, searchName, false, state));
                });
                if (resolved_3) {
                    return resolved_3;
                }
                if (extensions === Extensions.TypeScript) {
                    return loadModuleFromNearestNodeModulesDirectoryTypesScope(moduleName, containingDirectory, state);
                }
            }
            else {
                var candidate = ts.normalizePath(ts.combinePaths(containingDirectory, moduleName));
                return toSearchResult(loadModuleFromFileNoPackageId(extensions, candidate, false, state));
            }
        }
    }
    ts.classicNameResolver = classicNameResolver;
    function loadModuleFromGlobalCache(moduleName, projectName, compilerOptions, host, globalCache, packageJsonInfoCache) {
        var traceEnabled = isTraceEnabled(compilerOptions, host);
        if (traceEnabled) {
            trace(host, ts.Diagnostics.Auto_discovery_for_typings_is_enabled_in_project_0_Running_extra_resolution_pass_for_module_1_using_cache_location_2, projectName, moduleName, globalCache);
        }
        var failedLookupLocations = [];
        var diagnostics = [];
        var state = { compilerOptions: compilerOptions, host: host, traceEnabled: traceEnabled, failedLookupLocations: failedLookupLocations, packageJsonInfoCache: packageJsonInfoCache, features: NodeResolutionFeatures.None, conditions: [], requestContainingDirectory: undefined, reportDiagnostic: function (diag) { return void diagnostics.push(diag); } };
        var resolved = loadModuleFromImmediateNodeModulesDirectory(Extensions.DtsOnly, moduleName, globalCache, state, false, undefined, undefined);
        return createResolvedModuleWithFailedLookupLocations(resolved, true, failedLookupLocations, diagnostics, state.resultFromCache);
    }
    ts.loadModuleFromGlobalCache = loadModuleFromGlobalCache;
    function toSearchResult(value) {
        return value !== undefined ? { value: value } : undefined;
    }
})(ts || (ts = {}));
var ts;
(function (ts) {
    function getModuleInstanceState(node, visited) {
        if (node.body && !node.body.parent) {
            ts.setParent(node.body, node);
            ts.setParentRecursive(node.body, false);
        }
        return node.body ? getModuleInstanceStateCached(node.body, visited) : 1;
    }
    ts.getModuleInstanceState = getModuleInstanceState;
    function getModuleInstanceStateCached(node, visited) {
        if (visited === void 0) { visited = new ts.Map(); }
        var nodeId = ts.getNodeId(node);
        if (visited.has(nodeId)) {
            return visited.get(nodeId) || 0;
        }
        visited.set(nodeId, undefined);
        var result = getModuleInstanceStateWorker(node, visited);
        visited.set(nodeId, result);
        return result;
    }
    function getModuleInstanceStateWorker(node, visited) {
        switch (node.kind) {
            case 258:
            case 259:
                return 0;
            case 260:
                if (ts.isEnumConst(node)) {
                    return 2;
                }
                break;
            case 266:
            case 265:
                if (!(ts.hasSyntacticModifier(node, 1))) {
                    return 0;
                }
                break;
            case 272:
                var exportDeclaration = node;
                if (!exportDeclaration.moduleSpecifier && exportDeclaration.exportClause && exportDeclaration.exportClause.kind === 273) {
                    var state = 0;
                    for (var _i = 0, _a = exportDeclaration.exportClause.elements; _i < _a.length; _i++) {
                        var specifier = _a[_i];
                        var specifierState = getModuleInstanceStateForAliasTarget(specifier, visited);
                        if (specifierState > state) {
                            state = specifierState;
                        }
                        if (state === 1) {
                            return state;
                        }
                    }
                    return state;
                }
                break;
            case 262: {
                var state_1 = 0;
                ts.forEachChild(node, function (n) {
                    var childState = getModuleInstanceStateCached(n, visited);
                    switch (childState) {
                        case 0:
                            return;
                        case 2:
                            state_1 = 2;
                            return;
                        case 1:
                            state_1 = 1;
                            return true;
                        default:
                            ts.Debug.assertNever(childState);
                    }
                });
                return state_1;
            }
            case 261:
                return getModuleInstanceState(node, visited);
            case 79:
                if (node.isInJSDocNamespace) {
                    return 0;
                }
        }
        return 1;
    }
    function getModuleInstanceStateForAliasTarget(specifier, visited) {
        var name = specifier.propertyName || specifier.name;
        var p = specifier.parent;
        while (p) {
            if (ts.isBlock(p) || ts.isModuleBlock(p) || ts.isSourceFile(p)) {
                var statements = p.statements;
                var found = void 0;
                for (var _i = 0, statements_2 = statements; _i < statements_2.length; _i++) {
                    var statement = statements_2[_i];
                    if (ts.nodeHasName(statement, name)) {
                        if (!statement.parent) {
                            ts.setParent(statement, p);
                            ts.setParentRecursive(statement, false);
                        }
                        var state = getModuleInstanceStateCached(statement, visited);
                        if (found === undefined || state > found) {
                            found = state;
                        }
                        if (found === 1) {
                            return found;
                        }
                    }
                }
                if (found !== undefined) {
                    return found;
                }
            }
            p = p.parent;
        }
        return 1;
    }
    function initFlowNode(node) {
        ts.Debug.attachFlowNodeDebugInfo(node);
        return node;
    }
    var binder = createBinder();
    function bindSourceFile(file, options) {
        ts.performance.mark("beforeBind");
        ts.perfLogger.logStartBindFile("" + file.fileName);
        binder(file, options);
        ts.perfLogger.logStopBindFile();
        ts.performance.mark("afterBind");
        ts.performance.measure("Bind", "beforeBind", "afterBind");
    }
    ts.bindSourceFile = bindSourceFile;
    function createBinder() {
        var file;
        var options;
        var languageVersion;
        var parent;
        var container;
        var thisParentContainer;
        var blockScopeContainer;
        var lastContainer;
        var delayedTypeAliases;
        var seenThisKeyword;
        var currentFlow;
        var currentBreakTarget;
        var currentContinueTarget;
        var currentReturnTarget;
        var currentTrueTarget;
        var currentFalseTarget;
        var currentExceptionTarget;
        var preSwitchCaseFlow;
        var activeLabelList;
        var hasExplicitReturn;
        var emitFlags;
        var inStrictMode;
        var inAssignmentPattern = false;
        var symbolCount = 0;
        var Symbol;
        var classifiableNames;
        var unreachableFlow = { flags: 1 };
        var reportedUnreachableFlow = { flags: 1 };
        var bindBinaryExpressionFlow = createBindBinaryExpressionFlow();
        function createDiagnosticForNode(node, message, arg0, arg1, arg2) {
            return ts.createDiagnosticForNodeInSourceFile(ts.getSourceFileOfNode(node) || file, node, message, arg0, arg1, arg2);
        }
        function bindSourceFile(f, opts) {
            file = f;
            options = opts;
            languageVersion = ts.getEmitScriptTarget(options);
            inStrictMode = bindInStrictMode(file, opts);
            classifiableNames = new ts.Set();
            symbolCount = 0;
            Symbol = ts.objectAllocator.getSymbolConstructor();
            ts.Debug.attachFlowNodeDebugInfo(unreachableFlow);
            ts.Debug.attachFlowNodeDebugInfo(reportedUnreachableFlow);
            if (!file.locals) {
                ts.tracing === null || ts.tracing === void 0 ? void 0 : ts.tracing.push("bind", "bindSourceFile", { path: file.path }, true);
                bind(file);
                ts.tracing === null || ts.tracing === void 0 ? void 0 : ts.tracing.pop();
                file.symbolCount = symbolCount;
                file.classifiableNames = classifiableNames;
                delayedBindJSDocTypedefTag();
            }
            file = undefined;
            options = undefined;
            languageVersion = undefined;
            parent = undefined;
            container = undefined;
            thisParentContainer = undefined;
            blockScopeContainer = undefined;
            lastContainer = undefined;
            delayedTypeAliases = undefined;
            seenThisKeyword = false;
            currentFlow = undefined;
            currentBreakTarget = undefined;
            currentContinueTarget = undefined;
            currentReturnTarget = undefined;
            currentTrueTarget = undefined;
            currentFalseTarget = undefined;
            currentExceptionTarget = undefined;
            activeLabelList = undefined;
            hasExplicitReturn = false;
            inAssignmentPattern = false;
            emitFlags = 0;
        }
        return bindSourceFile;
        function bindInStrictMode(file, opts) {
            if (ts.getStrictOptionValue(opts, "alwaysStrict") && !file.isDeclarationFile) {
                return true;
            }
            else {
                return !!file.externalModuleIndicator;
            }
        }
        function createSymbol(flags, name) {
            symbolCount++;
            return new Symbol(flags, name);
        }
        function addDeclarationToSymbol(symbol, node, symbolFlags) {
            symbol.flags |= symbolFlags;
            node.symbol = symbol;
            symbol.declarations = ts.appendIfUnique(symbol.declarations, node);
            if (symbolFlags & (32 | 384 | 1536 | 3) && !symbol.exports) {
                symbol.exports = ts.createSymbolTable();
            }
            if (symbolFlags & (32 | 64 | 2048 | 4096) && !symbol.members) {
                symbol.members = ts.createSymbolTable();
            }
            if (symbol.constEnumOnlyModule && (symbol.flags & (16 | 32 | 256))) {
                symbol.constEnumOnlyModule = false;
            }
            if (symbolFlags & 111551) {
                ts.setValueDeclaration(symbol, node);
            }
        }
        function getDeclarationName(node) {
            if (node.kind === 271) {
                return node.isExportEquals ? "export=" : "default";
            }
            var name = ts.getNameOfDeclaration(node);
            if (name) {
                if (ts.isAmbientModule(node)) {
                    var moduleName = ts.getTextOfIdentifierOrLiteral(name);
                    return (ts.isGlobalScopeAugmentation(node) ? "__global" : "\"".concat(moduleName, "\""));
                }
                if (name.kind === 162) {
                    var nameExpression = name.expression;
                    if (ts.isStringOrNumericLiteralLike(nameExpression)) {
                        return ts.escapeLeadingUnderscores(nameExpression.text);
                    }
                    if (ts.isSignedNumericLiteral(nameExpression)) {
                        return ts.tokenToString(nameExpression.operator) + nameExpression.operand.text;
                    }
                    else {
                        ts.Debug.fail("Only computed properties with literal names have declaration names");
                    }
                }
                if (ts.isPrivateIdentifier(name)) {
                    var containingClass = ts.getContainingClass(node);
                    if (!containingClass) {
                        return undefined;
                    }
                    var containingClassSymbol = containingClass.symbol;
                    return ts.getSymbolNameForPrivateIdentifier(containingClassSymbol, name.escapedText);
                }
                return ts.isPropertyNameLiteral(name) ? ts.getEscapedTextOfIdentifierOrLiteral(name) : undefined;
            }
            switch (node.kind) {
                case 171:
                    return "__constructor";
                case 179:
                case 174:
                case 323:
                    return "__call";
                case 180:
                case 175:
                    return "__new";
                case 176:
                    return "__index";
                case 272:
                    return "__export";
                case 305:
                    return "export=";
                case 221:
                    if (ts.getAssignmentDeclarationKind(node) === 2) {
                        return "export=";
                    }
                    ts.Debug.fail("Unknown binary declaration kind");
                    break;
                case 317:
                    return (ts.isJSDocConstructSignature(node) ? "__new" : "__call");
                case 164:
                    ts.Debug.assert(node.parent.kind === 317, "Impossible parameter parent kind", function () { return "parent is: ".concat(ts.SyntaxKind ? ts.SyntaxKind[node.parent.kind] : node.parent.kind, ", expected JSDocFunctionType"); });
                    var functionType = node.parent;
                    var index = functionType.parameters.indexOf(node);
                    return "arg" + index;
            }
        }
        function getDisplayName(node) {
            return ts.isNamedDeclaration(node) ? ts.declarationNameToString(node.name) : ts.unescapeLeadingUnderscores(ts.Debug.checkDefined(getDeclarationName(node)));
        }
        function declareSymbol(symbolTable, parent, node, includes, excludes, isReplaceableByMethod, isComputedName) {
            ts.Debug.assert(isComputedName || !ts.hasDynamicName(node));
            var isDefaultExport = ts.hasSyntacticModifier(node, 512) || ts.isExportSpecifier(node) && node.name.escapedText === "default";
            var name = isComputedName ? "__computed"
                : isDefaultExport && parent ? "default"
                    : getDeclarationName(node);
            var symbol;
            if (name === undefined) {
                symbol = createSymbol(0, "__missing");
            }
            else {
                symbol = symbolTable.get(name);
                if (includes & 2885600) {
                    classifiableNames.add(name);
                }
                if (!symbol) {
                    symbolTable.set(name, symbol = createSymbol(0, name));
                    if (isReplaceableByMethod)
                        symbol.isReplaceableByMethod = true;
                }
                else if (isReplaceableByMethod && !symbol.isReplaceableByMethod) {
                    return symbol;
                }
                else if (symbol.flags & excludes) {
                    if (symbol.isReplaceableByMethod) {
                        symbolTable.set(name, symbol = createSymbol(0, name));
                    }
                    else if (!(includes & 3 && symbol.flags & 67108864)) {
                        if (ts.isNamedDeclaration(node)) {
                            ts.setParent(node.name, node);
                        }
                        var message_1 = symbol.flags & 2
                            ? ts.Diagnostics.Cannot_redeclare_block_scoped_variable_0
                            : ts.Diagnostics.Duplicate_identifier_0;
                        var messageNeedsName_1 = true;
                        if (symbol.flags & 384 || includes & 384) {
                            message_1 = ts.Diagnostics.Enum_declarations_can_only_merge_with_namespace_or_other_enum_declarations;
                            messageNeedsName_1 = false;
                        }
                        var multipleDefaultExports_1 = false;
                        if (ts.length(symbol.declarations)) {
                            if (isDefaultExport) {
                                message_1 = ts.Diagnostics.A_module_cannot_have_multiple_default_exports;
                                messageNeedsName_1 = false;
                                multipleDefaultExports_1 = true;
                            }
                            else {
                                if (symbol.declarations && symbol.declarations.length &&
                                    (node.kind === 271 && !node.isExportEquals)) {
                                    message_1 = ts.Diagnostics.A_module_cannot_have_multiple_default_exports;
                                    messageNeedsName_1 = false;
                                    multipleDefaultExports_1 = true;
                                }
                            }
                        }
                        var relatedInformation_1 = [];
                        if (ts.isTypeAliasDeclaration(node) && ts.nodeIsMissing(node.type) && ts.hasSyntacticModifier(node, 1) && symbol.flags & (2097152 | 788968 | 1920)) {
                            relatedInformation_1.push(createDiagnosticForNode(node, ts.Diagnostics.Did_you_mean_0, "export type { ".concat(ts.unescapeLeadingUnderscores(node.name.escapedText), " }")));
                        }
                        var declarationName_1 = ts.getNameOfDeclaration(node) || node;
                        ts.forEach(symbol.declarations, function (declaration, index) {
                            var decl = ts.getNameOfDeclaration(declaration) || declaration;
                            var diag = createDiagnosticForNode(decl, message_1, messageNeedsName_1 ? getDisplayName(declaration) : undefined);
                            file.bindDiagnostics.push(multipleDefaultExports_1 ? ts.addRelatedInfo(diag, createDiagnosticForNode(declarationName_1, index === 0 ? ts.Diagnostics.Another_export_default_is_here : ts.Diagnostics.and_here)) : diag);
                            if (multipleDefaultExports_1) {
                                relatedInformation_1.push(createDiagnosticForNode(decl, ts.Diagnostics.The_first_export_default_is_here));
                            }
                        });
                        var diag = createDiagnosticForNode(declarationName_1, message_1, messageNeedsName_1 ? getDisplayName(node) : undefined);
                        file.bindDiagnostics.push(ts.addRelatedInfo.apply(void 0, __spreadArray([diag], relatedInformation_1, false)));
                        symbol = createSymbol(0, name);
                    }
                }
            }
            addDeclarationToSymbol(symbol, node, includes);
            if (symbol.parent) {
                ts.Debug.assert(symbol.parent === parent, "Existing symbol parent should match new one");
            }
            else {
                symbol.parent = parent;
            }
            return symbol;
        }
        function declareModuleMember(node, symbolFlags, symbolExcludes) {
            var hasExportModifier = !!(ts.getCombinedModifierFlags(node) & 1) || jsdocTreatAsExported(node);
            if (symbolFlags & 2097152) {
                if (node.kind === 275 || (node.kind === 265 && hasExportModifier)) {
                    return declareSymbol(container.symbol.exports, container.symbol, node, symbolFlags, symbolExcludes);
                }
                else {
                    return declareSymbol(container.locals, undefined, node, symbolFlags, symbolExcludes);
                }
            }
            else {
                if (ts.isJSDocTypeAlias(node))
                    ts.Debug.assert(ts.isInJSFile(node));
                if (!ts.isAmbientModule(node) && (hasExportModifier || container.flags & 64)) {
                    if (!container.locals || (ts.hasSyntacticModifier(node, 512) && !getDeclarationName(node))) {
                        return declareSymbol(container.symbol.exports, container.symbol, node, symbolFlags, symbolExcludes);
                    }
                    var exportKind = symbolFlags & 111551 ? 1048576 : 0;
                    var local = declareSymbol(container.locals, undefined, node, exportKind, symbolExcludes);
                    local.exportSymbol = declareSymbol(container.symbol.exports, container.symbol, node, symbolFlags, symbolExcludes);
                    node.localSymbol = local;
                    return local;
                }
                else {
                    return declareSymbol(container.locals, undefined, node, symbolFlags, symbolExcludes);
                }
            }
        }
        function jsdocTreatAsExported(node) {
            if (node.parent && ts.isModuleDeclaration(node)) {
                node = node.parent;
            }
            if (!ts.isJSDocTypeAlias(node))
                return false;
            if (!ts.isJSDocEnumTag(node) && !!node.fullName)
                return true;
            var declName = ts.getNameOfDeclaration(node);
            if (!declName)
                return false;
            if (ts.isPropertyAccessEntityNameExpression(declName.parent) && isTopLevelNamespaceAssignment(declName.parent))
                return true;
            if (ts.isDeclaration(declName.parent) && ts.getCombinedModifierFlags(declName.parent) & 1)
                return true;
            return false;
        }
        function bindContainer(node, containerFlags) {
            var saveContainer = container;
            var saveThisParentContainer = thisParentContainer;
            var savedBlockScopeContainer = blockScopeContainer;
            if (containerFlags & 1) {
                if (node.kind !== 214) {
                    thisParentContainer = container;
                }
                container = blockScopeContainer = node;
                if (containerFlags & 32) {
                    container.locals = ts.createSymbolTable();
                }
                addToContainerChain(container);
            }
            else if (containerFlags & 2) {
                blockScopeContainer = node;
                blockScopeContainer.locals = undefined;
            }
            if (containerFlags & 4) {
                var saveCurrentFlow = currentFlow;
                var saveBreakTarget = currentBreakTarget;
                var saveContinueTarget = currentContinueTarget;
                var saveReturnTarget = currentReturnTarget;
                var saveExceptionTarget = currentExceptionTarget;
                var saveActiveLabelList = activeLabelList;
                var saveHasExplicitReturn = hasExplicitReturn;
                var isImmediatelyInvoked = (containerFlags & 16 &&
                    !ts.hasSyntacticModifier(node, 256) &&
                    !node.asteriskToken &&
                    !!ts.getImmediatelyInvokedFunctionExpression(node)) ||
                    node.kind === 170;
                if (!isImmediatelyInvoked) {
                    currentFlow = initFlowNode({ flags: 2 });
                    if (containerFlags & (16 | 128)) {
                        currentFlow.node = node;
                    }
                }
                currentReturnTarget = isImmediatelyInvoked || node.kind === 171 || (ts.isInJSFile(node) && (node.kind === 256 || node.kind === 213)) ? createBranchLabel() : undefined;
                currentExceptionTarget = undefined;
                currentBreakTarget = undefined;
                currentContinueTarget = undefined;
                activeLabelList = undefined;
                hasExplicitReturn = false;
                bindChildren(node);
                node.flags &= ~2816;
                if (!(currentFlow.flags & 1) && containerFlags & 8 && ts.nodeIsPresent(node.body)) {
                    node.flags |= 256;
                    if (hasExplicitReturn)
                        node.flags |= 512;
                    node.endFlowNode = currentFlow;
                }
                if (node.kind === 305) {
                    node.flags |= emitFlags;
                    node.endFlowNode = currentFlow;
                }
                if (currentReturnTarget) {
                    addAntecedent(currentReturnTarget, currentFlow);
                    currentFlow = finishFlowLabel(currentReturnTarget);
                    if (node.kind === 171 || node.kind === 170 || (ts.isInJSFile(node) && (node.kind === 256 || node.kind === 213))) {
                        node.returnFlowNode = currentFlow;
                    }
                }
                if (!isImmediatelyInvoked) {
                    currentFlow = saveCurrentFlow;
                }
                currentBreakTarget = saveBreakTarget;
                currentContinueTarget = saveContinueTarget;
                currentReturnTarget = saveReturnTarget;
                currentExceptionTarget = saveExceptionTarget;
                activeLabelList = saveActiveLabelList;
                hasExplicitReturn = saveHasExplicitReturn;
            }
            else if (containerFlags & 64) {
                seenThisKeyword = false;
                bindChildren(node);
                node.flags = seenThisKeyword ? node.flags | 128 : node.flags & ~128;
            }
            else {
                bindChildren(node);
            }
            container = saveContainer;
            thisParentContainer = saveThisParentContainer;
            blockScopeContainer = savedBlockScopeContainer;
        }
        function bindEachFunctionsFirst(nodes) {
            bindEach(nodes, function (n) { return n.kind === 256 ? bind(n) : undefined; });
            bindEach(nodes, function (n) { return n.kind !== 256 ? bind(n) : undefined; });
        }
        function bindEach(nodes, bindFunction) {
            if (bindFunction === void 0) { bindFunction = bind; }
            if (nodes === undefined) {
                return;
            }
            ts.forEach(nodes, bindFunction);
        }
        function bindEachChild(node) {
            ts.forEachChild(node, bind, bindEach);
        }
        function bindChildren(node) {
            var saveInAssignmentPattern = inAssignmentPattern;
            inAssignmentPattern = false;
            if (checkUnreachable(node)) {
                bindEachChild(node);
                bindJSDoc(node);
                inAssignmentPattern = saveInAssignmentPattern;
                return;
            }
            if (node.kind >= 237 && node.kind <= 253 && !options.allowUnreachableCode) {
                node.flowNode = currentFlow;
            }
            switch (node.kind) {
                case 241:
                    bindWhileStatement(node);
                    break;
                case 240:
                    bindDoStatement(node);
                    break;
                case 242:
                    bindForStatement(node);
                    break;
                case 243:
                case 244:
                    bindForInOrForOfStatement(node);
                    break;
                case 239:
                    bindIfStatement(node);
                    break;
                case 247:
                case 251:
                    bindReturnOrThrow(node);
                    break;
                case 246:
                case 245:
                    bindBreakOrContinueStatement(node);
                    break;
                case 252:
                    bindTryStatement(node);
                    break;
                case 249:
                    bindSwitchStatement(node);
                    break;
                case 263:
                    bindCaseBlock(node);
                    break;
                case 289:
                    bindCaseClause(node);
                    break;
                case 238:
                    bindExpressionStatement(node);
                    break;
                case 250:
                    bindLabeledStatement(node);
                    break;
                case 219:
                    bindPrefixUnaryExpressionFlow(node);
                    break;
                case 220:
                    bindPostfixUnaryExpressionFlow(node);
                    break;
                case 221:
                    if (ts.isDestructuringAssignment(node)) {
                        inAssignmentPattern = saveInAssignmentPattern;
                        bindDestructuringAssignmentFlow(node);
                        return;
                    }
                    bindBinaryExpressionFlow(node);
                    break;
                case 215:
                    bindDeleteExpressionFlow(node);
                    break;
                case 222:
                    bindConditionalExpressionFlow(node);
                    break;
                case 254:
                    bindVariableDeclarationFlow(node);
                    break;
                case 206:
                case 207:
                    bindAccessExpressionFlow(node);
                    break;
                case 208:
                    bindCallExpressionFlow(node);
                    break;
                case 230:
                    bindNonNullExpressionFlow(node);
                    break;
                case 345:
                case 338:
                case 339:
                    bindJSDocTypeAlias(node);
                    break;
                case 305: {
                    bindEachFunctionsFirst(node.statements);
                    bind(node.endOfFileToken);
                    break;
                }
                case 235:
                case 262:
                    bindEachFunctionsFirst(node.statements);
                    break;
                case 203:
                    bindBindingElementFlow(node);
                    break;
                case 205:
                case 204:
                case 296:
                case 225:
                    inAssignmentPattern = saveInAssignmentPattern;
                default:
                    bindEachChild(node);
                    break;
            }
            bindJSDoc(node);
            inAssignmentPattern = saveInAssignmentPattern;
        }
        function isNarrowingExpression(expr) {
            switch (expr.kind) {
                case 79:
                case 80:
                case 108:
                case 206:
                case 207:
                    return containsNarrowableReference(expr);
                case 208:
                    return hasNarrowableArgument(expr);
                case 212:
                case 230:
                    return isNarrowingExpression(expr.expression);
                case 221:
                    return isNarrowingBinaryExpression(expr);
                case 219:
                    return expr.operator === 53 && isNarrowingExpression(expr.operand);
                case 216:
                    return isNarrowingExpression(expr.expression);
            }
            return false;
        }
        function isNarrowableReference(expr) {
            return ts.isDottedName(expr)
                || (ts.isPropertyAccessExpression(expr) || ts.isNonNullExpression(expr) || ts.isParenthesizedExpression(expr)) && isNarrowableReference(expr.expression)
                || ts.isBinaryExpression(expr) && expr.operatorToken.kind === 27 && isNarrowableReference(expr.right)
                || ts.isElementAccessExpression(expr) && (ts.isStringOrNumericLiteralLike(expr.argumentExpression) || ts.isEntityNameExpression(expr.argumentExpression)) && isNarrowableReference(expr.expression)
                || ts.isAssignmentExpression(expr) && isNarrowableReference(expr.left);
        }
        function containsNarrowableReference(expr) {
            return isNarrowableReference(expr) || ts.isOptionalChain(expr) && containsNarrowableReference(expr.expression);
        }
        function hasNarrowableArgument(expr) {
            if (expr.arguments) {
                for (var _i = 0, _a = expr.arguments; _i < _a.length; _i++) {
                    var argument = _a[_i];
                    if (containsNarrowableReference(argument)) {
                        return true;
                    }
                }
            }
            if (expr.expression.kind === 206 &&
                containsNarrowableReference(expr.expression.expression)) {
                return true;
            }
            return false;
        }
        function isNarrowingTypeofOperands(expr1, expr2) {
            return ts.isTypeOfExpression(expr1) && isNarrowableOperand(expr1.expression) && ts.isStringLiteralLike(expr2);
        }
        function isNarrowingBinaryExpression(expr) {
            switch (expr.operatorToken.kind) {
                case 63:
                case 75:
                case 76:
                case 77:
                    return containsNarrowableReference(expr.left);
                case 34:
                case 35:
                case 36:
                case 37:
                    return isNarrowableOperand(expr.left) || isNarrowableOperand(expr.right) ||
                        isNarrowingTypeofOperands(expr.right, expr.left) || isNarrowingTypeofOperands(expr.left, expr.right);
                case 102:
                    return isNarrowableOperand(expr.left);
                case 101:
                    return isNarrowingExpression(expr.right);
                case 27:
                    return isNarrowingExpression(expr.right);
            }
            return false;
        }
        function isNarrowableOperand(expr) {
            switch (expr.kind) {
                case 212:
                    return isNarrowableOperand(expr.expression);
                case 221:
                    switch (expr.operatorToken.kind) {
                        case 63:
                            return isNarrowableOperand(expr.left);
                        case 27:
                            return isNarrowableOperand(expr.right);
                    }
            }
            return containsNarrowableReference(expr);
        }
        function createBranchLabel() {
            return initFlowNode({ flags: 4, antecedents: undefined });
        }
        function createLoopLabel() {
            return initFlowNode({ flags: 8, antecedents: undefined });
        }
        function createReduceLabel(target, antecedents, antecedent) {
            return initFlowNode({ flags: 1024, target: target, antecedents: antecedents, antecedent: antecedent });
        }
        function setFlowNodeReferenced(flow) {
            flow.flags |= flow.flags & 2048 ? 4096 : 2048;
        }
        function addAntecedent(label, antecedent) {
            if (!(antecedent.flags & 1) && !ts.contains(label.antecedents, antecedent)) {
                (label.antecedents || (label.antecedents = [])).push(antecedent);
                setFlowNodeReferenced(antecedent);
            }
        }
        function createFlowCondition(flags, antecedent, expression) {
            if (antecedent.flags & 1) {
                return antecedent;
            }
            if (!expression) {
                return flags & 32 ? antecedent : unreachableFlow;
            }
            if ((expression.kind === 110 && flags & 64 ||
                expression.kind === 95 && flags & 32) &&
                !ts.isExpressionOfOptionalChainRoot(expression) && !ts.isNullishCoalesce(expression.parent)) {
                return unreachableFlow;
            }
            if (!isNarrowingExpression(expression)) {
                return antecedent;
            }
            setFlowNodeReferenced(antecedent);
            return initFlowNode({ flags: flags, antecedent: antecedent, node: expression });
        }
        function createFlowSwitchClause(antecedent, switchStatement, clauseStart, clauseEnd) {
            setFlowNodeReferenced(antecedent);
            return initFlowNode({ flags: 128, antecedent: antecedent, switchStatement: switchStatement, clauseStart: clauseStart, clauseEnd: clauseEnd });
        }
        function createFlowMutation(flags, antecedent, node) {
            setFlowNodeReferenced(antecedent);
            var result = initFlowNode({ flags: flags, antecedent: antecedent, node: node });
            if (currentExceptionTarget) {
                addAntecedent(currentExceptionTarget, result);
            }
            return result;
        }
        function createFlowCall(antecedent, node) {
            setFlowNodeReferenced(antecedent);
            return initFlowNode({ flags: 512, antecedent: antecedent, node: node });
        }
        function finishFlowLabel(flow) {
            var antecedents = flow.antecedents;
            if (!antecedents) {
                return unreachableFlow;
            }
            if (antecedents.length === 1) {
                return antecedents[0];
            }
            return flow;
        }
        function isStatementCondition(node) {
            var parent = node.parent;
            switch (parent.kind) {
                case 239:
                case 241:
                case 240:
                    return parent.expression === node;
                case 242:
                case 222:
                    return parent.condition === node;
            }
            return false;
        }
        function isLogicalExpression(node) {
            while (true) {
                if (node.kind === 212) {
                    node = node.expression;
                }
                else if (node.kind === 219 && node.operator === 53) {
                    node = node.operand;
                }
                else {
                    return node.kind === 221 && (node.operatorToken.kind === 55 ||
                        node.operatorToken.kind === 56 ||
                        node.operatorToken.kind === 60);
                }
            }
        }
        function isLogicalAssignmentExpression(node) {
            node = ts.skipParentheses(node);
            return ts.isBinaryExpression(node) && ts.isLogicalOrCoalescingAssignmentOperator(node.operatorToken.kind);
        }
        function isTopLevelLogicalExpression(node) {
            while (ts.isParenthesizedExpression(node.parent) ||
                ts.isPrefixUnaryExpression(node.parent) && node.parent.operator === 53) {
                node = node.parent;
            }
            return !isStatementCondition(node) &&
                !isLogicalExpression(node.parent) &&
                !(ts.isOptionalChain(node.parent) && node.parent.expression === node);
        }
        function doWithConditionalBranches(action, value, trueTarget, falseTarget) {
            var savedTrueTarget = currentTrueTarget;
            var savedFalseTarget = currentFalseTarget;
            currentTrueTarget = trueTarget;
            currentFalseTarget = falseTarget;
            action(value);
            currentTrueTarget = savedTrueTarget;
            currentFalseTarget = savedFalseTarget;
        }
        function bindCondition(node, trueTarget, falseTarget) {
            doWithConditionalBranches(bind, node, trueTarget, falseTarget);
            if (!node || !isLogicalAssignmentExpression(node) && !isLogicalExpression(node) && !(ts.isOptionalChain(node) && ts.isOutermostOptionalChain(node))) {
                addAntecedent(trueTarget, createFlowCondition(32, currentFlow, node));
                addAntecedent(falseTarget, createFlowCondition(64, currentFlow, node));
            }
        }
        function bindIterativeStatement(node, breakTarget, continueTarget) {
            var saveBreakTarget = currentBreakTarget;
            var saveContinueTarget = currentContinueTarget;
            currentBreakTarget = breakTarget;
            currentContinueTarget = continueTarget;
            bind(node);
            currentBreakTarget = saveBreakTarget;
            currentContinueTarget = saveContinueTarget;
        }
        function setContinueTarget(node, target) {
            var label = activeLabelList;
            while (label && node.parent.kind === 250) {
                label.continueTarget = target;
                label = label.next;
                node = node.parent;
            }
            return target;
        }
        function bindWhileStatement(node) {
            var preWhileLabel = setContinueTarget(node, createLoopLabel());
            var preBodyLabel = createBranchLabel();
            var postWhileLabel = createBranchLabel();
            addAntecedent(preWhileLabel, currentFlow);
            currentFlow = preWhileLabel;
            bindCondition(node.expression, preBodyLabel, postWhileLabel);
            currentFlow = finishFlowLabel(preBodyLabel);
            bindIterativeStatement(node.statement, postWhileLabel, preWhileLabel);
            addAntecedent(preWhileLabel, currentFlow);
            currentFlow = finishFlowLabel(postWhileLabel);
        }
        function bindDoStatement(node) {
            var preDoLabel = createLoopLabel();
            var preConditionLabel = setContinueTarget(node, createBranchLabel());
            var postDoLabel = createBranchLabel();
            addAntecedent(preDoLabel, currentFlow);
            currentFlow = preDoLabel;
            bindIterativeStatement(node.statement, postDoLabel, preConditionLabel);
            addAntecedent(preConditionLabel, currentFlow);
            currentFlow = finishFlowLabel(preConditionLabel);
            bindCondition(node.expression, preDoLabel, postDoLabel);
            currentFlow = finishFlowLabel(postDoLabel);
        }
        function bindForStatement(node) {
            var preLoopLabel = setContinueTarget(node, createLoopLabel());
            var preBodyLabel = createBranchLabel();
            var postLoopLabel = createBranchLabel();
            bind(node.initializer);
            addAntecedent(preLoopLabel, currentFlow);
            currentFlow = preLoopLabel;
            bindCondition(node.condition, preBodyLabel, postLoopLabel);
            currentFlow = finishFlowLabel(preBodyLabel);
            bindIterativeStatement(node.statement, postLoopLabel, preLoopLabel);
            bind(node.incrementor);
            addAntecedent(preLoopLabel, currentFlow);
            currentFlow = finishFlowLabel(postLoopLabel);
        }
        function bindForInOrForOfStatement(node) {
            var preLoopLabel = setContinueTarget(node, createLoopLabel());
            var postLoopLabel = createBranchLabel();
            bind(node.expression);
            addAntecedent(preLoopLabel, currentFlow);
            currentFlow = preLoopLabel;
            if (node.kind === 244) {
                bind(node.awaitModifier);
            }
            addAntecedent(postLoopLabel, currentFlow);
            bind(node.initializer);
            if (node.initializer.kind !== 255) {
                bindAssignmentTargetFlow(node.initializer);
            }
            bindIterativeStatement(node.statement, postLoopLabel, preLoopLabel);
            addAntecedent(preLoopLabel, currentFlow);
            currentFlow = finishFlowLabel(postLoopLabel);
        }
        function bindIfStatement(node) {
            var thenLabel = createBranchLabel();
            var elseLabel = createBranchLabel();
            var postIfLabel = createBranchLabel();
            bindCondition(node.expression, thenLabel, elseLabel);
            currentFlow = finishFlowLabel(thenLabel);
            bind(node.thenStatement);
            addAntecedent(postIfLabel, currentFlow);
            currentFlow = finishFlowLabel(elseLabel);
            bind(node.elseStatement);
            addAntecedent(postIfLabel, currentFlow);
            currentFlow = finishFlowLabel(postIfLabel);
        }
        function bindReturnOrThrow(node) {
            bind(node.expression);
            if (node.kind === 247) {
                hasExplicitReturn = true;
                if (currentReturnTarget) {
                    addAntecedent(currentReturnTarget, currentFlow);
                }
            }
            currentFlow = unreachableFlow;
        }
        function findActiveLabel(name) {
            for (var label = activeLabelList; label; label = label.next) {
                if (label.name === name) {
                    return label;
                }
            }
            return undefined;
        }
        function bindBreakOrContinueFlow(node, breakTarget, continueTarget) {
            var flowLabel = node.kind === 246 ? breakTarget : continueTarget;
            if (flowLabel) {
                addAntecedent(flowLabel, currentFlow);
                currentFlow = unreachableFlow;
            }
        }
        function bindBreakOrContinueStatement(node) {
            bind(node.label);
            if (node.label) {
                var activeLabel = findActiveLabel(node.label.escapedText);
                if (activeLabel) {
                    activeLabel.referenced = true;
                    bindBreakOrContinueFlow(node, activeLabel.breakTarget, activeLabel.continueTarget);
                }
            }
            else {
                bindBreakOrContinueFlow(node, currentBreakTarget, currentContinueTarget);
            }
        }
        function bindTryStatement(node) {
            var saveReturnTarget = currentReturnTarget;
            var saveExceptionTarget = currentExceptionTarget;
            var normalExitLabel = createBranchLabel();
            var returnLabel = createBranchLabel();
            var exceptionLabel = createBranchLabel();
            if (node.finallyBlock) {
                currentReturnTarget = returnLabel;
            }
            addAntecedent(exceptionLabel, currentFlow);
            currentExceptionTarget = exceptionLabel;
            bind(node.tryBlock);
            addAntecedent(normalExitLabel, currentFlow);
            if (node.catchClause) {
                currentFlow = finishFlowLabel(exceptionLabel);
                exceptionLabel = createBranchLabel();
                addAntecedent(exceptionLabel, currentFlow);
                currentExceptionTarget = exceptionLabel;
                bind(node.catchClause);
                addAntecedent(normalExitLabel, currentFlow);
            }
            currentReturnTarget = saveReturnTarget;
            currentExceptionTarget = saveExceptionTarget;
            if (node.finallyBlock) {
                var finallyLabel = createBranchLabel();
                finallyLabel.antecedents = ts.concatenate(ts.concatenate(normalExitLabel.antecedents, exceptionLabel.antecedents), returnLabel.antecedents);
                currentFlow = finallyLabel;
                bind(node.finallyBlock);
                if (currentFlow.flags & 1) {
                    currentFlow = unreachableFlow;
                }
                else {
                    if (currentReturnTarget && returnLabel.antecedents) {
                        addAntecedent(currentReturnTarget, createReduceLabel(finallyLabel, returnLabel.antecedents, currentFlow));
                    }
                    if (currentExceptionTarget && exceptionLabel.antecedents) {
                        addAntecedent(currentExceptionTarget, createReduceLabel(finallyLabel, exceptionLabel.antecedents, currentFlow));
                    }
                    currentFlow = normalExitLabel.antecedents ? createReduceLabel(finallyLabel, normalExitLabel.antecedents, currentFlow) : unreachableFlow;
                }
            }
            else {
                currentFlow = finishFlowLabel(normalExitLabel);
            }
        }
        function bindSwitchStatement(node) {
            var postSwitchLabel = createBranchLabel();
            bind(node.expression);
            var saveBreakTarget = currentBreakTarget;
            var savePreSwitchCaseFlow = preSwitchCaseFlow;
            currentBreakTarget = postSwitchLabel;
            preSwitchCaseFlow = currentFlow;
            bind(node.caseBlock);
            addAntecedent(postSwitchLabel, currentFlow);
            var hasDefault = ts.forEach(node.caseBlock.clauses, function (c) { return c.kind === 290; });
            node.possiblyExhaustive = !hasDefault && !postSwitchLabel.antecedents;
            if (!hasDefault) {
                addAntecedent(postSwitchLabel, createFlowSwitchClause(preSwitchCaseFlow, node, 0, 0));
            }
            currentBreakTarget = saveBreakTarget;
            preSwitchCaseFlow = savePreSwitchCaseFlow;
            currentFlow = finishFlowLabel(postSwitchLabel);
        }
        function bindCaseBlock(node) {
            var clauses = node.clauses;
            var isNarrowingSwitch = isNarrowingExpression(node.parent.expression);
            var fallthroughFlow = unreachableFlow;
            for (var i = 0; i < clauses.length; i++) {
                var clauseStart = i;
                while (!clauses[i].statements.length && i + 1 < clauses.length) {
                    bind(clauses[i]);
                    i++;
                }
                var preCaseLabel = createBranchLabel();
                addAntecedent(preCaseLabel, isNarrowingSwitch ? createFlowSwitchClause(preSwitchCaseFlow, node.parent, clauseStart, i + 1) : preSwitchCaseFlow);
                addAntecedent(preCaseLabel, fallthroughFlow);
                currentFlow = finishFlowLabel(preCaseLabel);
                var clause = clauses[i];
                bind(clause);
                fallthroughFlow = currentFlow;
                if (!(currentFlow.flags & 1) && i !== clauses.length - 1 && options.noFallthroughCasesInSwitch) {
                    clause.fallthroughFlowNode = currentFlow;
                }
            }
        }
        function bindCaseClause(node) {
            var saveCurrentFlow = currentFlow;
            currentFlow = preSwitchCaseFlow;
            bind(node.expression);
            currentFlow = saveCurrentFlow;
            bindEach(node.statements);
        }
        function bindExpressionStatement(node) {
            bind(node.expression);
            maybeBindExpressionFlowIfCall(node.expression);
        }
        function maybeBindExpressionFlowIfCall(node) {
            if (node.kind === 208) {
                var call = node;
                if (call.expression.kind !== 106 && ts.isDottedName(call.expression)) {
                    currentFlow = createFlowCall(currentFlow, call);
                }
            }
        }
        function bindLabeledStatement(node) {
            var postStatementLabel = createBranchLabel();
            activeLabelList = {
                next: activeLabelList,
                name: node.label.escapedText,
                breakTarget: postStatementLabel,
                continueTarget: undefined,
                referenced: false
            };
            bind(node.label);
            bind(node.statement);
            if (!activeLabelList.referenced && !options.allowUnusedLabels) {
                errorOrSuggestionOnNode(ts.unusedLabelIsError(options), node.label, ts.Diagnostics.Unused_label);
            }
            activeLabelList = activeLabelList.next;
            addAntecedent(postStatementLabel, currentFlow);
            currentFlow = finishFlowLabel(postStatementLabel);
        }
        function bindDestructuringTargetFlow(node) {
            if (node.kind === 221 && node.operatorToken.kind === 63) {
                bindAssignmentTargetFlow(node.left);
            }
            else {
                bindAssignmentTargetFlow(node);
            }
        }
        function bindAssignmentTargetFlow(node) {
            if (isNarrowableReference(node)) {
                currentFlow = createFlowMutation(16, currentFlow, node);
            }
            else if (node.kind === 204) {
                for (var _i = 0, _a = node.elements; _i < _a.length; _i++) {
                    var e = _a[_i];
                    if (e.kind === 225) {
                        bindAssignmentTargetFlow(e.expression);
                    }
                    else {
                        bindDestructuringTargetFlow(e);
                    }
                }
            }
            else if (node.kind === 205) {
                for (var _b = 0, _c = node.properties; _b < _c.length; _b++) {
                    var p = _c[_b];
                    if (p.kind === 296) {
                        bindDestructuringTargetFlow(p.initializer);
                    }
                    else if (p.kind === 297) {
                        bindAssignmentTargetFlow(p.name);
                    }
                    else if (p.kind === 298) {
                        bindAssignmentTargetFlow(p.expression);
                    }
                }
            }
        }
        function bindLogicalLikeExpression(node, trueTarget, falseTarget) {
            var preRightLabel = createBranchLabel();
            if (node.operatorToken.kind === 55 || node.operatorToken.kind === 76) {
                bindCondition(node.left, preRightLabel, falseTarget);
            }
            else {
                bindCondition(node.left, trueTarget, preRightLabel);
            }
            currentFlow = finishFlowLabel(preRightLabel);
            bind(node.operatorToken);
            if (ts.isLogicalOrCoalescingAssignmentOperator(node.operatorToken.kind)) {
                doWithConditionalBranches(bind, node.right, trueTarget, falseTarget);
                bindAssignmentTargetFlow(node.left);
                addAntecedent(trueTarget, createFlowCondition(32, currentFlow, node));
                addAntecedent(falseTarget, createFlowCondition(64, currentFlow, node));
            }
            else {
                bindCondition(node.right, trueTarget, falseTarget);
            }
        }
        function bindPrefixUnaryExpressionFlow(node) {
            if (node.operator === 53) {
                var saveTrueTarget = currentTrueTarget;
                currentTrueTarget = currentFalseTarget;
                currentFalseTarget = saveTrueTarget;
                bindEachChild(node);
                currentFalseTarget = currentTrueTarget;
                currentTrueTarget = saveTrueTarget;
            }
            else {
                bindEachChild(node);
                if (node.operator === 45 || node.operator === 46) {
                    bindAssignmentTargetFlow(node.operand);
                }
            }
        }
        function bindPostfixUnaryExpressionFlow(node) {
            bindEachChild(node);
            if (node.operator === 45 || node.operator === 46) {
                bindAssignmentTargetFlow(node.operand);
            }
        }
        function bindDestructuringAssignmentFlow(node) {
            if (inAssignmentPattern) {
                inAssignmentPattern = false;
                bind(node.operatorToken);
                bind(node.right);
                inAssignmentPattern = true;
                bind(node.left);
            }
            else {
                inAssignmentPattern = true;
                bind(node.left);
                inAssignmentPattern = false;
                bind(node.operatorToken);
                bind(node.right);
            }
            bindAssignmentTargetFlow(node.left);
        }
        function createBindBinaryExpressionFlow() {
            return ts.createBinaryExpressionTrampoline(onEnter, onLeft, onOperator, onRight, onExit, undefined);
            function onEnter(node, state) {
                if (state) {
                    state.stackIndex++;
                    ts.setParent(node, parent);
                    var saveInStrictMode = inStrictMode;
                    bindWorker(node);
                    var saveParent = parent;
                    parent = node;
                    state.skip = false;
                    state.inStrictModeStack[state.stackIndex] = saveInStrictMode;
                    state.parentStack[state.stackIndex] = saveParent;
                }
                else {
                    state = {
                        stackIndex: 0,
                        skip: false,
                        inStrictModeStack: [undefined],
                        parentStack: [undefined]
                    };
                }
                var operator = node.operatorToken.kind;
                if (operator === 55 ||
                    operator === 56 ||
                    operator === 60 ||
                    ts.isLogicalOrCoalescingAssignmentOperator(operator)) {
                    if (isTopLevelLogicalExpression(node)) {
                        var postExpressionLabel = createBranchLabel();
                        bindLogicalLikeExpression(node, postExpressionLabel, postExpressionLabel);
                        currentFlow = finishFlowLabel(postExpressionLabel);
                    }
                    else {
                        bindLogicalLikeExpression(node, currentTrueTarget, currentFalseTarget);
                    }
                    state.skip = true;
                }
                return state;
            }
            function onLeft(left, state, node) {
                if (!state.skip) {
                    var maybeBound = maybeBind(left);
                    if (node.operatorToken.kind === 27) {
                        maybeBindExpressionFlowIfCall(left);
                    }
                    return maybeBound;
                }
            }
            function onOperator(operatorToken, state, _node) {
                if (!state.skip) {
                    bind(operatorToken);
                }
            }
            function onRight(right, state, node) {
                if (!state.skip) {
                    var maybeBound = maybeBind(right);
                    if (node.operatorToken.kind === 27) {
                        maybeBindExpressionFlowIfCall(right);
                    }
                    return maybeBound;
                }
            }
            function onExit(node, state) {
                if (!state.skip) {
                    var operator = node.operatorToken.kind;
                    if (ts.isAssignmentOperator(operator) && !ts.isAssignmentTarget(node)) {
                        bindAssignmentTargetFlow(node.left);
                        if (operator === 63 && node.left.kind === 207) {
                            var elementAccess = node.left;
                            if (isNarrowableOperand(elementAccess.expression)) {
                                currentFlow = createFlowMutation(256, currentFlow, node);
                            }
                        }
                    }
                }
                var savedInStrictMode = state.inStrictModeStack[state.stackIndex];
                var savedParent = state.parentStack[state.stackIndex];
                if (savedInStrictMode !== undefined) {
                    inStrictMode = savedInStrictMode;
                }
                if (savedParent !== undefined) {
                    parent = savedParent;
                }
                state.skip = false;
                state.stackIndex--;
            }
            function maybeBind(node) {
                if (node && ts.isBinaryExpression(node) && !ts.isDestructuringAssignment(node)) {
                    return node;
                }
                bind(node);
            }
        }
        function bindDeleteExpressionFlow(node) {
            bindEachChild(node);
            if (node.expression.kind === 206) {
                bindAssignmentTargetFlow(node.expression);
            }
        }
        function bindConditionalExpressionFlow(node) {
            var trueLabel = createBranchLabel();
            var falseLabel = createBranchLabel();
            var postExpressionLabel = createBranchLabel();
            bindCondition(node.condition, trueLabel, falseLabel);
            currentFlow = finishFlowLabel(trueLabel);
            bind(node.questionToken);
            bind(node.whenTrue);
            addAntecedent(postExpressionLabel, currentFlow);
            currentFlow = finishFlowLabel(falseLabel);
            bind(node.colonToken);
            bind(node.whenFalse);
            addAntecedent(postExpressionLabel, currentFlow);
            currentFlow = finishFlowLabel(postExpressionLabel);
        }
        function bindInitializedVariableFlow(node) {
            var name = !ts.isOmittedExpression(node) ? node.name : undefined;
            if (ts.isBindingPattern(name)) {
                for (var _i = 0, _a = name.elements; _i < _a.length; _i++) {
                    var child = _a[_i];
                    bindInitializedVariableFlow(child);
                }
            }
            else {
                currentFlow = createFlowMutation(16, currentFlow, node);
            }
        }
        function bindVariableDeclarationFlow(node) {
            bindEachChild(node);
            if (node.initializer || ts.isForInOrOfStatement(node.parent.parent)) {
                bindInitializedVariableFlow(node);
            }
        }
        function bindBindingElementFlow(node) {
            if (ts.isBindingPattern(node.name)) {
                bindEach(node.decorators);
                bindEach(node.modifiers);
                bind(node.dotDotDotToken);
                bind(node.propertyName);
                bind(node.initializer);
                bind(node.name);
            }
            else {
                bindEachChild(node);
            }
        }
        function bindJSDocTypeAlias(node) {
            bind(node.tagName);
            if (node.kind !== 339 && node.fullName) {
                ts.setParent(node.fullName, node);
                ts.setParentRecursive(node.fullName, false);
            }
            if (typeof node.comment !== "string") {
                bindEach(node.comment);
            }
        }
        function bindJSDocClassTag(node) {
            bindEachChild(node);
            var host = ts.getHostSignatureFromJSDoc(node);
            if (host && host.kind !== 169) {
                addDeclarationToSymbol(host.symbol, host, 32);
            }
        }
        function bindOptionalExpression(node, trueTarget, falseTarget) {
            doWithConditionalBranches(bind, node, trueTarget, falseTarget);
            if (!ts.isOptionalChain(node) || ts.isOutermostOptionalChain(node)) {
                addAntecedent(trueTarget, createFlowCondition(32, currentFlow, node));
                addAntecedent(falseTarget, createFlowCondition(64, currentFlow, node));
            }
        }
        function bindOptionalChainRest(node) {
            switch (node.kind) {
                case 206:
                    bind(node.questionDotToken);
                    bind(node.name);
                    break;
                case 207:
                    bind(node.questionDotToken);
                    bind(node.argumentExpression);
                    break;
                case 208:
                    bind(node.questionDotToken);
                    bindEach(node.typeArguments);
                    bindEach(node.arguments);
                    break;
            }
        }
        function bindOptionalChain(node, trueTarget, falseTarget) {
            var preChainLabel = ts.isOptionalChainRoot(node) ? createBranchLabel() : undefined;
            bindOptionalExpression(node.expression, preChainLabel || trueTarget, falseTarget);
            if (preChainLabel) {
                currentFlow = finishFlowLabel(preChainLabel);
            }
            doWithConditionalBranches(bindOptionalChainRest, node, trueTarget, falseTarget);
            if (ts.isOutermostOptionalChain(node)) {
                addAntecedent(trueTarget, createFlowCondition(32, currentFlow, node));
                addAntecedent(falseTarget, createFlowCondition(64, currentFlow, node));
            }
        }
        function bindOptionalChainFlow(node) {
            if (isTopLevelLogicalExpression(node)) {
                var postExpressionLabel = createBranchLabel();
                bindOptionalChain(node, postExpressionLabel, postExpressionLabel);
                currentFlow = finishFlowLabel(postExpressionLabel);
            }
            else {
                bindOptionalChain(node, currentTrueTarget, currentFalseTarget);
            }
        }
        function bindNonNullExpressionFlow(node) {
            if (ts.isOptionalChain(node)) {
                bindOptionalChainFlow(node);
            }
            else {
                bindEachChild(node);
            }
        }
        function bindAccessExpressionFlow(node) {
            if (ts.isOptionalChain(node)) {
                bindOptionalChainFlow(node);
            }
            else {
                bindEachChild(node);
            }
        }
        function bindCallExpressionFlow(node) {
            if (ts.isOptionalChain(node)) {
                bindOptionalChainFlow(node);
            }
            else {
                var expr = ts.skipParentheses(node.expression);
                if (expr.kind === 213 || expr.kind === 214) {
                    bindEach(node.typeArguments);
                    bindEach(node.arguments);
                    bind(node.expression);
                }
                else {
                    bindEachChild(node);
                    if (node.expression.kind === 106) {
                        currentFlow = createFlowCall(currentFlow, node);
                    }
                }
            }
            if (node.expression.kind === 206) {
                var propertyAccess = node.expression;
                if (ts.isIdentifier(propertyAccess.name) && isNarrowableOperand(propertyAccess.expression) && ts.isPushOrUnshiftIdentifier(propertyAccess.name)) {
                    currentFlow = createFlowMutation(256, currentFlow, node);
                }
            }
        }
        function getContainerFlags(node) {
            switch (node.kind) {
                case 226:
                case 257:
                case 260:
                case 205:
                case 182:
                case 322:
                case 286:
                    return 1;
                case 258:
                    return 1 | 64;
                case 261:
                case 259:
                case 195:
                case 176:
                    return 1 | 32;
                case 305:
                    return 1 | 4 | 32;
                case 172:
                case 173:
                case 169:
                    if (ts.isObjectLiteralOrClassExpressionMethodOrAccessor(node)) {
                        return 1 | 4 | 32 | 8 | 128;
                    }
                case 171:
                case 256:
                case 168:
                case 174:
                case 323:
                case 317:
                case 179:
                case 175:
                case 180:
                case 170:
                    return 1 | 4 | 32 | 8;
                case 213:
                case 214:
                    return 1 | 4 | 32 | 8 | 16;
                case 262:
                    return 4;
                case 167:
                    return node.initializer ? 4 : 0;
                case 292:
                case 242:
                case 243:
                case 244:
                case 263:
                    return 2;
                case 235:
                    return ts.isFunctionLike(node.parent) || ts.isClassStaticBlockDeclaration(node.parent) ? 0 : 2;
            }
            return 0;
        }
        function addToContainerChain(next) {
            if (lastContainer) {
                lastContainer.nextContainer = next;
            }
            lastContainer = next;
        }
        function declareSymbolAndAddToSymbolTable(node, symbolFlags, symbolExcludes) {
            switch (container.kind) {
                case 261:
                    return declareModuleMember(node, symbolFlags, symbolExcludes);
                case 305:
                    return declareSourceFileMember(node, symbolFlags, symbolExcludes);
                case 226:
                case 257:
                    return declareClassMember(node, symbolFlags, symbolExcludes);
                case 260:
                    return declareSymbol(container.symbol.exports, container.symbol, node, symbolFlags, symbolExcludes);
                case 182:
                case 322:
                case 205:
                case 258:
                case 286:
                    return declareSymbol(container.symbol.members, container.symbol, node, symbolFlags, symbolExcludes);
                case 179:
                case 180:
                case 174:
                case 175:
                case 323:
                case 176:
                case 169:
                case 168:
                case 171:
                case 172:
                case 173:
                case 256:
                case 213:
                case 214:
                case 317:
                case 345:
                case 338:
                case 170:
                case 259:
                case 195:
                    return declareSymbol(container.locals, undefined, node, symbolFlags, symbolExcludes);
            }
        }
        function declareClassMember(node, symbolFlags, symbolExcludes) {
            return ts.isStatic(node)
                ? declareSymbol(container.symbol.exports, container.symbol, node, symbolFlags, symbolExcludes)
                : declareSymbol(container.symbol.members, container.symbol, node, symbolFlags, symbolExcludes);
        }
        function declareSourceFileMember(node, symbolFlags, symbolExcludes) {
            return ts.isExternalModule(file)
                ? declareModuleMember(node, symbolFlags, symbolExcludes)
                : declareSymbol(file.locals, undefined, node, symbolFlags, symbolExcludes);
        }
        function hasExportDeclarations(node) {
            var body = ts.isSourceFile(node) ? node : ts.tryCast(node.body, ts.isModuleBlock);
            return !!body && body.statements.some(function (s) { return ts.isExportDeclaration(s) || ts.isExportAssignment(s); });
        }
        function setExportContextFlag(node) {
            if (node.flags & 16777216 && !hasExportDeclarations(node)) {
                node.flags |= 64;
            }
            else {
                node.flags &= ~64;
            }
        }
        function bindModuleDeclaration(node) {
            setExportContextFlag(node);
            if (ts.isAmbientModule(node)) {
                if (ts.hasSyntacticModifier(node, 1)) {
                    errorOnFirstToken(node, ts.Diagnostics.export_modifier_cannot_be_applied_to_ambient_modules_and_module_augmentations_since_they_are_always_visible);
                }
                if (ts.isModuleAugmentationExternal(node)) {
                    declareModuleSymbol(node);
                }
                else {
                    var pattern = void 0;
                    if (node.name.kind === 10) {
                        var text = node.name.text;
                        pattern = ts.tryParsePattern(text);
                        if (pattern === undefined) {
                            errorOnFirstToken(node.name, ts.Diagnostics.Pattern_0_can_have_at_most_one_Asterisk_character, text);
                        }
                    }
                    var symbol = declareSymbolAndAddToSymbolTable(node, 512, 110735);
                    file.patternAmbientModules = ts.append(file.patternAmbientModules, pattern && !ts.isString(pattern) ? { pattern: pattern, symbol: symbol } : undefined);
                }
            }
            else {
                var state = declareModuleSymbol(node);
                if (state !== 0) {
                    var symbol = node.symbol;
                    symbol.constEnumOnlyModule = (!(symbol.flags & (16 | 32 | 256)))
                        && state === 2
                        && symbol.constEnumOnlyModule !== false;
                }
            }
        }
        function declareModuleSymbol(node) {
            var state = getModuleInstanceState(node);
            var instantiated = state !== 0;
            declareSymbolAndAddToSymbolTable(node, instantiated ? 512 : 1024, instantiated ? 110735 : 0);
            return state;
        }
        function bindFunctionOrConstructorType(node) {
            var symbol = createSymbol(131072, getDeclarationName(node));
            addDeclarationToSymbol(symbol, node, 131072);
            var typeLiteralSymbol = createSymbol(2048, "__type");
            addDeclarationToSymbol(typeLiteralSymbol, node, 2048);
            typeLiteralSymbol.members = ts.createSymbolTable();
            typeLiteralSymbol.members.set(symbol.escapedName, symbol);
        }
        function bindObjectLiteralExpression(node) {
            if (inStrictMode && !ts.isAssignmentTarget(node)) {
                var seen = new ts.Map();
                for (var _i = 0, _a = node.properties; _i < _a.length; _i++) {
                    var prop = _a[_i];
                    if (prop.kind === 298 || prop.name.kind !== 79) {
                        continue;
                    }
                    var identifier = prop.name;
                    var currentKind = prop.kind === 296 || prop.kind === 297 || prop.kind === 169
                        ? 1
                        : 2;
                    var existingKind = seen.get(identifier.escapedText);
                    if (!existingKind) {
                        seen.set(identifier.escapedText, currentKind);
                        continue;
                    }
                }
            }
            return bindAnonymousDeclaration(node, 4096, "__object");
        }
        function bindJsxAttributes(node) {
            return bindAnonymousDeclaration(node, 4096, "__jsxAttributes");
        }
        function bindJsxAttribute(node, symbolFlags, symbolExcludes) {
            return declareSymbolAndAddToSymbolTable(node, symbolFlags, symbolExcludes);
        }
        function bindAnonymousDeclaration(node, symbolFlags, name) {
            var symbol = createSymbol(symbolFlags, name);
            if (symbolFlags & (8 | 106500)) {
                symbol.parent = container.symbol;
            }
            addDeclarationToSymbol(symbol, node, symbolFlags);
            return symbol;
        }
        function bindBlockScopedDeclaration(node, symbolFlags, symbolExcludes) {
            switch (blockScopeContainer.kind) {
                case 261:
                    declareModuleMember(node, symbolFlags, symbolExcludes);
                    break;
                case 305:
                    if (ts.isExternalOrCommonJsModule(container)) {
                        declareModuleMember(node, symbolFlags, symbolExcludes);
                        break;
                    }
                default:
                    if (!blockScopeContainer.locals) {
                        blockScopeContainer.locals = ts.createSymbolTable();
                        addToContainerChain(blockScopeContainer);
                    }
                    declareSymbol(blockScopeContainer.locals, undefined, node, symbolFlags, symbolExcludes);
            }
        }
        function delayedBindJSDocTypedefTag() {
            if (!delayedTypeAliases) {
                return;
            }
            var saveContainer = container;
            var saveLastContainer = lastContainer;
            var saveBlockScopeContainer = blockScopeContainer;
            var saveParent = parent;
            var saveCurrentFlow = currentFlow;
            for (var _i = 0, delayedTypeAliases_1 = delayedTypeAliases; _i < delayedTypeAliases_1.length; _i++) {
                var typeAlias = delayedTypeAliases_1[_i];
                var host = typeAlias.parent.parent;
                container = ts.findAncestor(host.parent, function (n) { return !!(getContainerFlags(n) & 1); }) || file;
                blockScopeContainer = ts.getEnclosingBlockScopeContainer(host) || file;
                currentFlow = initFlowNode({ flags: 2 });
                parent = typeAlias;
                bind(typeAlias.typeExpression);
                var declName = ts.getNameOfDeclaration(typeAlias);
                if ((ts.isJSDocEnumTag(typeAlias) || !typeAlias.fullName) && declName && ts.isPropertyAccessEntityNameExpression(declName.parent)) {
                    var isTopLevel = isTopLevelNamespaceAssignment(declName.parent);
                    if (isTopLevel) {
                        bindPotentiallyMissingNamespaces(file.symbol, declName.parent, isTopLevel, !!ts.findAncestor(declName, function (d) { return ts.isPropertyAccessExpression(d) && d.name.escapedText === "prototype"; }), false);
                        var oldContainer = container;
                        switch (ts.getAssignmentDeclarationPropertyAccessKind(declName.parent)) {
                            case 1:
                            case 2:
                                if (!ts.isExternalOrCommonJsModule(file)) {
                                    container = undefined;
                                }
                                else {
                                    container = file;
                                }
                                break;
                            case 4:
                                container = declName.parent.expression;
                                break;
                            case 3:
                                container = declName.parent.expression.name;
                                break;
                            case 5:
                                container = isExportsOrModuleExportsOrAlias(file, declName.parent.expression) ? file
                                    : ts.isPropertyAccessExpression(declName.parent.expression) ? declName.parent.expression.name
                                        : declName.parent.expression;
                                break;
                            case 0:
                                return ts.Debug.fail("Shouldn't have detected typedef or enum on non-assignment declaration");
                        }
                        if (container) {
                            declareModuleMember(typeAlias, 524288, 788968);
                        }
                        container = oldContainer;
                    }
                }
                else if (ts.isJSDocEnumTag(typeAlias) || !typeAlias.fullName || typeAlias.fullName.kind === 79) {
                    parent = typeAlias.parent;
                    bindBlockScopedDeclaration(typeAlias, 524288, 788968);
                }
                else {
                    bind(typeAlias.fullName);
                }
            }
            container = saveContainer;
            lastContainer = saveLastContainer;
            blockScopeContainer = saveBlockScopeContainer;
            parent = saveParent;
            currentFlow = saveCurrentFlow;
        }
        function checkContextualIdentifier(node) {
            if (!file.parseDiagnostics.length &&
                !(node.flags & 16777216) &&
                !(node.flags & 8388608) &&
                !ts.isIdentifierName(node)) {
                if (inStrictMode &&
                    node.originalKeywordKind >= 117 &&
                    node.originalKeywordKind <= 125) {
                    file.bindDiagnostics.push(createDiagnosticForNode(node, getStrictModeIdentifierMessage(node), ts.declarationNameToString(node)));
                }
                else if (node.originalKeywordKind === 132) {
                    if (ts.isExternalModule(file) && ts.isInTopLevelContext(node)) {
                        file.bindDiagnostics.push(createDiagnosticForNode(node, ts.Diagnostics.Identifier_expected_0_is_a_reserved_word_at_the_top_level_of_a_module, ts.declarationNameToString(node)));
                    }
                    else if (node.flags & 32768) {
                        file.bindDiagnostics.push(createDiagnosticForNode(node, ts.Diagnostics.Identifier_expected_0_is_a_reserved_word_that_cannot_be_used_here, ts.declarationNameToString(node)));
                    }
                }
                else if (node.originalKeywordKind === 125 && node.flags & 8192) {
                    file.bindDiagnostics.push(createDiagnosticForNode(node, ts.Diagnostics.Identifier_expected_0_is_a_reserved_word_that_cannot_be_used_here, ts.declarationNameToString(node)));
                }
            }
        }
        function getStrictModeIdentifierMessage(node) {
            if (ts.getContainingClass(node)) {
                return ts.Diagnostics.Identifier_expected_0_is_a_reserved_word_in_strict_mode_Class_definitions_are_automatically_in_strict_mode;
            }
            if (file.externalModuleIndicator) {
                return ts.Diagnostics.Identifier_expected_0_is_a_reserved_word_in_strict_mode_Modules_are_automatically_in_strict_mode;
            }
            return ts.Diagnostics.Identifier_expected_0_is_a_reserved_word_in_strict_mode;
        }
        function checkPrivateIdentifier(node) {
            if (node.escapedText === "#constructor") {
                if (!file.parseDiagnostics.length) {
                    file.bindDiagnostics.push(createDiagnosticForNode(node, ts.Diagnostics.constructor_is_a_reserved_word, ts.declarationNameToString(node)));
                }
            }
        }
        function checkStrictModeBinaryExpression(node) {
            if (inStrictMode && ts.isLeftHandSideExpression(node.left) && ts.isAssignmentOperator(node.operatorToken.kind)) {
                checkStrictModeEvalOrArguments(node, node.left);
            }
        }
        function checkStrictModeCatchClause(node) {
            if (inStrictMode && node.variableDeclaration) {
                checkStrictModeEvalOrArguments(node, node.variableDeclaration.name);
            }
        }
        function checkStrictModeDeleteExpression(node) {
            if (inStrictMode && node.expression.kind === 79) {
                var span = ts.getErrorSpanForNode(file, node.expression);
                file.bindDiagnostics.push(ts.createFileDiagnostic(file, span.start, span.length, ts.Diagnostics.delete_cannot_be_called_on_an_identifier_in_strict_mode));
            }
        }
        function isEvalOrArgumentsIdentifier(node) {
            return ts.isIdentifier(node) && (node.escapedText === "eval" || node.escapedText === "arguments");
        }
        function checkStrictModeEvalOrArguments(contextNode, name) {
            if (name && name.kind === 79) {
                var identifier = name;
                if (isEvalOrArgumentsIdentifier(identifier)) {
                    var span = ts.getErrorSpanForNode(file, name);
                    file.bindDiagnostics.push(ts.createFileDiagnostic(file, span.start, span.length, getStrictModeEvalOrArgumentsMessage(contextNode), ts.idText(identifier)));
                }
            }
        }
        function getStrictModeEvalOrArgumentsMessage(node) {
            if (ts.getContainingClass(node)) {
                return ts.Diagnostics.Code_contained_in_a_class_is_evaluated_in_JavaScript_s_strict_mode_which_does_not_allow_this_use_of_0_For_more_information_see_https_Colon_Slash_Slashdeveloper_mozilla_org_Slashen_US_Slashdocs_SlashWeb_SlashJavaScript_SlashReference_SlashStrict_mode;
            }
            if (file.externalModuleIndicator) {
                return ts.Diagnostics.Invalid_use_of_0_Modules_are_automatically_in_strict_mode;
            }
            return ts.Diagnostics.Invalid_use_of_0_in_strict_mode;
        }
        function checkStrictModeFunctionName(node) {
            if (inStrictMode) {
                checkStrictModeEvalOrArguments(node, node.name);
            }
        }
        function getStrictModeBlockScopeFunctionDeclarationMessage(node) {
            if (ts.getContainingClass(node)) {
                return ts.Diagnostics.Function_declarations_are_not_allowed_inside_blocks_in_strict_mode_when_targeting_ES3_or_ES5_Class_definitions_are_automatically_in_strict_mode;
            }
            if (file.externalModuleIndicator) {
                return ts.Diagnostics.Function_declarations_are_not_allowed_inside_blocks_in_strict_mode_when_targeting_ES3_or_ES5_Modules_are_automatically_in_strict_mode;
            }
            return ts.Diagnostics.Function_declarations_are_not_allowed_inside_blocks_in_strict_mode_when_targeting_ES3_or_ES5;
        }
        function checkStrictModeFunctionDeclaration(node) {
            if (languageVersion < 2) {
                if (blockScopeContainer.kind !== 305 &&
                    blockScopeContainer.kind !== 261 &&
                    !ts.isFunctionLikeOrClassStaticBlockDeclaration(blockScopeContainer)) {
                    var errorSpan = ts.getErrorSpanForNode(file, node);
                    file.bindDiagnostics.push(ts.createFileDiagnostic(file, errorSpan.start, errorSpan.length, getStrictModeBlockScopeFunctionDeclarationMessage(node)));
                }
            }
        }
        function checkStrictModeNumericLiteral(node) {
            if (languageVersion < 1 && inStrictMode && node.numericLiteralFlags & 32) {
                file.bindDiagnostics.push(createDiagnosticForNode(node, ts.Diagnostics.Octal_literals_are_not_allowed_in_strict_mode));
            }
        }
        function checkStrictModePostfixUnaryExpression(node) {
            if (inStrictMode) {
                checkStrictModeEvalOrArguments(node, node.operand);
            }
        }
        function checkStrictModePrefixUnaryExpression(node) {
            if (inStrictMode) {
                if (node.operator === 45 || node.operator === 46) {
                    checkStrictModeEvalOrArguments(node, node.operand);
                }
            }
        }
        function checkStrictModeWithStatement(node) {
            if (inStrictMode) {
                errorOnFirstToken(node, ts.Diagnostics.with_statements_are_not_allowed_in_strict_mode);
            }
        }
        function checkStrictModeLabeledStatement(node) {
            if (inStrictMode && ts.getEmitScriptTarget(options) >= 2) {
                if (ts.isDeclarationStatement(node.statement) || ts.isVariableStatement(node.statement)) {
                    errorOnFirstToken(node.label, ts.Diagnostics.A_label_is_not_allowed_here);
                }
            }
        }
        function errorOnFirstToken(node, message, arg0, arg1, arg2) {
            var span = ts.getSpanOfTokenAtPosition(file, node.pos);
            file.bindDiagnostics.push(ts.createFileDiagnostic(file, span.start, span.length, message, arg0, arg1, arg2));
        }
        function errorOrSuggestionOnNode(isError, node, message) {
            errorOrSuggestionOnRange(isError, node, node, message);
        }
        function errorOrSuggestionOnRange(isError, startNode, endNode, message) {
            addErrorOrSuggestionDiagnostic(isError, { pos: ts.getTokenPosOfNode(startNode, file), end: endNode.end }, message);
        }
        function addErrorOrSuggestionDiagnostic(isError, range, message) {
            var diag = ts.createFileDiagnostic(file, range.pos, range.end - range.pos, message);
            if (isError) {
                file.bindDiagnostics.push(diag);
            }
            else {
                file.bindSuggestionDiagnostics = ts.append(file.bindSuggestionDiagnostics, __assign(__assign({}, diag), { category: ts.DiagnosticCategory.Suggestion }));
            }
        }
        function bind(node) {
            if (!node) {
                return;
            }
            ts.setParent(node, parent);
            if (ts.tracing)
                node.tracingPath = file.path;
            var saveInStrictMode = inStrictMode;
            bindWorker(node);
            if (node.kind > 160) {
                var saveParent = parent;
                parent = node;
                var containerFlags = getContainerFlags(node);
                if (containerFlags === 0) {
                    bindChildren(node);
                }
                else {
                    bindContainer(node, containerFlags);
                }
                parent = saveParent;
            }
            else {
                var saveParent = parent;
                if (node.kind === 1)
                    parent = node;
                bindJSDoc(node);
                parent = saveParent;
            }
            inStrictMode = saveInStrictMode;
        }
        function bindJSDoc(node) {
            if (ts.hasJSDocNodes(node)) {
                if (ts.isInJSFile(node)) {
                    for (var _i = 0, _a = node.jsDoc; _i < _a.length; _i++) {
                        var j = _a[_i];
                        bind(j);
                    }
                }
                else {
                    for (var _b = 0, _c = node.jsDoc; _b < _c.length; _b++) {
                        var j = _c[_b];
                        ts.setParent(j, node);
                        ts.setParentRecursive(j, false);
                    }
                }
            }
        }
        function updateStrictModeStatementList(statements) {
            if (!inStrictMode) {
                for (var _i = 0, statements_3 = statements; _i < statements_3.length; _i++) {
                    var statement = statements_3[_i];
                    if (!ts.isPrologueDirective(statement)) {
                        return;
                    }
                    if (isUseStrictPrologueDirective(statement)) {
                        inStrictMode = true;
                        return;
                    }
                }
            }
        }
        function isUseStrictPrologueDirective(node) {
            var nodeText = ts.getSourceTextOfNodeFromSourceFile(file, node.expression);
            return nodeText === '"use strict"' || nodeText === "'use strict'";
        }
        function bindWorker(node) {
            switch (node.kind) {
                case 79:
                    if (node.isInJSDocNamespace) {
                        var parentNode = node.parent;
                        while (parentNode && !ts.isJSDocTypeAlias(parentNode)) {
                            parentNode = parentNode.parent;
                        }
                        bindBlockScopedDeclaration(parentNode, 524288, 788968);
                        break;
                    }
                case 108:
                    if (currentFlow && (ts.isExpression(node) || parent.kind === 297)) {
                        node.flowNode = currentFlow;
                    }
                    return checkContextualIdentifier(node);
                case 161:
                    if (currentFlow && ts.isPartOfTypeQuery(node)) {
                        node.flowNode = currentFlow;
                    }
                    break;
                case 231:
                case 106:
                    node.flowNode = currentFlow;
                    break;
                case 80:
                    return checkPrivateIdentifier(node);
                case 206:
                case 207:
                    var expr = node;
                    if (currentFlow && isNarrowableReference(expr)) {
                        expr.flowNode = currentFlow;
                    }
                    if (ts.isSpecialPropertyDeclaration(expr)) {
                        bindSpecialPropertyDeclaration(expr);
                    }
                    if (ts.isInJSFile(expr) &&
                        file.commonJsModuleIndicator &&
                        ts.isModuleExportsAccessExpression(expr) &&
                        !lookupSymbolForName(blockScopeContainer, "module")) {
                        declareSymbol(file.locals, undefined, expr.expression, 1 | 134217728, 111550);
                    }
                    break;
                case 221:
                    var specialKind = ts.getAssignmentDeclarationKind(node);
                    switch (specialKind) {
                        case 1:
                            bindExportsPropertyAssignment(node);
                            break;
                        case 2:
                            bindModuleExportsAssignment(node);
                            break;
                        case 3:
                            bindPrototypePropertyAssignment(node.left, node);
                            break;
                        case 6:
                            bindPrototypeAssignment(node);
                            break;
                        case 4:
                            bindThisPropertyAssignment(node);
                            break;
                        case 5:
                            var expression = node.left.expression;
                            if (ts.isInJSFile(node) && ts.isIdentifier(expression)) {
                                var symbol = lookupSymbolForName(blockScopeContainer, expression.escapedText);
                                if (ts.isThisInitializedDeclaration(symbol === null || symbol === void 0 ? void 0 : symbol.valueDeclaration)) {
                                    bindThisPropertyAssignment(node);
                                    break;
                                }
                            }
                            bindSpecialPropertyAssignment(node);
                            break;
                        case 0:
                            break;
                        default:
                            ts.Debug.fail("Unknown binary expression special property assignment kind");
                    }
                    return checkStrictModeBinaryExpression(node);
                case 292:
                    return checkStrictModeCatchClause(node);
                case 215:
                    return checkStrictModeDeleteExpression(node);
                case 8:
                    return checkStrictModeNumericLiteral(node);
                case 220:
                    return checkStrictModePostfixUnaryExpression(node);
                case 219:
                    return checkStrictModePrefixUnaryExpression(node);
                case 248:
                    return checkStrictModeWithStatement(node);
                case 250:
                    return checkStrictModeLabeledStatement(node);
                case 192:
                    seenThisKeyword = true;
                    return;
                case 177:
                    break;
                case 163:
                    return bindTypeParameter(node);
                case 164:
                    return bindParameter(node);
                case 254:
                    return bindVariableDeclarationOrBindingElement(node);
                case 203:
                    node.flowNode = currentFlow;
                    return bindVariableDeclarationOrBindingElement(node);
                case 167:
                case 166:
                    return bindPropertyWorker(node);
                case 296:
                case 297:
                    return bindPropertyOrMethodOrAccessor(node, 4, 0);
                case 299:
                    return bindPropertyOrMethodOrAccessor(node, 8, 900095);
                case 174:
                case 175:
                case 176:
                    return declareSymbolAndAddToSymbolTable(node, 131072, 0);
                case 169:
                case 168:
                    return bindPropertyOrMethodOrAccessor(node, 8192 | (node.questionToken ? 16777216 : 0), ts.isObjectLiteralMethod(node) ? 0 : 103359);
                case 256:
                    return bindFunctionDeclaration(node);
                case 171:
                    return declareSymbolAndAddToSymbolTable(node, 16384, 0);
                case 172:
                    return bindPropertyOrMethodOrAccessor(node, 32768, 46015);
                case 173:
                    return bindPropertyOrMethodOrAccessor(node, 65536, 78783);
                case 179:
                case 317:
                case 323:
                case 180:
                    return bindFunctionOrConstructorType(node);
                case 182:
                case 322:
                case 195:
                    return bindAnonymousTypeWorker(node);
                case 332:
                    return bindJSDocClassTag(node);
                case 205:
                    return bindObjectLiteralExpression(node);
                case 213:
                case 214:
                    return bindFunctionExpression(node);
                case 208:
                    var assignmentKind = ts.getAssignmentDeclarationKind(node);
                    switch (assignmentKind) {
                        case 7:
                            return bindObjectDefinePropertyAssignment(node);
                        case 8:
                            return bindObjectDefinePropertyExport(node);
                        case 9:
                            return bindObjectDefinePrototypeProperty(node);
                        case 0:
                            break;
                        default:
                            return ts.Debug.fail("Unknown call expression assignment declaration kind");
                    }
                    if (ts.isInJSFile(node)) {
                        bindCallExpression(node);
                    }
                    break;
                case 226:
                case 257:
                    inStrictMode = true;
                    return bindClassLikeDeclaration(node);
                case 258:
                    return bindBlockScopedDeclaration(node, 64, 788872);
                case 259:
                    return bindBlockScopedDeclaration(node, 524288, 788968);
                case 260:
                    return bindEnumDeclaration(node);
                case 261:
                    return bindModuleDeclaration(node);
                case 286:
                    return bindJsxAttributes(node);
                case 285:
                    return bindJsxAttribute(node, 4, 0);
                case 265:
                case 268:
                case 270:
                case 275:
                    return declareSymbolAndAddToSymbolTable(node, 2097152, 2097152);
                case 264:
                    return bindNamespaceExportDeclaration(node);
                case 267:
                    return bindImportClause(node);
                case 272:
                    return bindExportDeclaration(node);
                case 271:
                    return bindExportAssignment(node);
                case 305:
                    updateStrictModeStatementList(node.statements);
                    return bindSourceFileIfExternalModule();
                case 235:
                    if (!ts.isFunctionLikeOrClassStaticBlockDeclaration(node.parent)) {
                        return;
                    }
                case 262:
                    return updateStrictModeStatementList(node.statements);
                case 340:
                    if (node.parent.kind === 323) {
                        return bindParameter(node);
                    }
                    if (node.parent.kind !== 322) {
                        break;
                    }
                case 347:
                    var propTag = node;
                    var flags = propTag.isBracketed || propTag.typeExpression && propTag.typeExpression.type.kind === 316 ?
                        4 | 16777216 :
                        4;
                    return declareSymbolAndAddToSymbolTable(propTag, flags, 0);
                case 345:
                case 338:
                case 339:
                    return (delayedTypeAliases || (delayedTypeAliases = [])).push(node);
            }
        }
        function bindPropertyWorker(node) {
            return bindPropertyOrMethodOrAccessor(node, 4 | (node.questionToken ? 16777216 : 0), 0);
        }
        function bindAnonymousTypeWorker(node) {
            return bindAnonymousDeclaration(node, 2048, "__type");
        }
        function bindSourceFileIfExternalModule() {
            setExportContextFlag(file);
            if (ts.isExternalModule(file)) {
                bindSourceFileAsExternalModule();
            }
            else if (ts.isJsonSourceFile(file)) {
                bindSourceFileAsExternalModule();
                var originalSymbol = file.symbol;
                declareSymbol(file.symbol.exports, file.symbol, file, 4, 67108863);
                file.symbol = originalSymbol;
            }
        }
        function bindSourceFileAsExternalModule() {
            bindAnonymousDeclaration(file, 512, "\"".concat(ts.removeFileExtension(file.fileName), "\""));
        }
        function bindExportAssignment(node) {
            if (!container.symbol || !container.symbol.exports) {
                bindAnonymousDeclaration(node, 111551, getDeclarationName(node));
            }
            else {
                var flags = ts.exportAssignmentIsAlias(node)
                    ? 2097152
                    : 4;
                var symbol = declareSymbol(container.symbol.exports, container.symbol, node, flags, 67108863);
                if (node.isExportEquals) {
                    ts.setValueDeclaration(symbol, node);
                }
            }
        }
        function bindNamespaceExportDeclaration(node) {
            if (node.modifiers && node.modifiers.length) {
                file.bindDiagnostics.push(createDiagnosticForNode(node, ts.Diagnostics.Modifiers_cannot_appear_here));
            }
            var diag = !ts.isSourceFile(node.parent) ? ts.Diagnostics.Global_module_exports_may_only_appear_at_top_level
                : !ts.isExternalModule(node.parent) ? ts.Diagnostics.Global_module_exports_may_only_appear_in_module_files
                    : !node.parent.isDeclarationFile ? ts.Diagnostics.Global_module_exports_may_only_appear_in_declaration_files
                        : undefined;
            if (diag) {
                file.bindDiagnostics.push(createDiagnosticForNode(node, diag));
            }
            else {
                file.symbol.globalExports = file.symbol.globalExports || ts.createSymbolTable();
                declareSymbol(file.symbol.globalExports, file.symbol, node, 2097152, 2097152);
            }
        }
        function bindExportDeclaration(node) {
            if (!container.symbol || !container.symbol.exports) {
                bindAnonymousDeclaration(node, 8388608, getDeclarationName(node));
            }
            else if (!node.exportClause) {
                declareSymbol(container.symbol.exports, container.symbol, node, 8388608, 0);
            }
            else if (ts.isNamespaceExport(node.exportClause)) {
                ts.setParent(node.exportClause, node);
                declareSymbol(container.symbol.exports, container.symbol, node.exportClause, 2097152, 2097152);
            }
        }
        function bindImportClause(node) {
            if (node.name) {
                declareSymbolAndAddToSymbolTable(node, 2097152, 2097152);
            }
        }
        function setCommonJsModuleIndicator(node) {
            if (file.externalModuleIndicator && file.externalModuleIndicator !== true) {
                return false;
            }
            if (!file.commonJsModuleIndicator) {
                file.commonJsModuleIndicator = node;
                if (!file.externalModuleIndicator) {
                    bindSourceFileAsExternalModule();
                }
            }
            return true;
        }
        function bindObjectDefinePropertyExport(node) {
            if (!setCommonJsModuleIndicator(node)) {
                return;
            }
            var symbol = forEachIdentifierInEntityName(node.arguments[0], undefined, function (id, symbol) {
                if (symbol) {
                    addDeclarationToSymbol(symbol, id, 1536 | 67108864);
                }
                return symbol;
            });
            if (symbol) {
                var flags = 4 | 1048576;
                declareSymbol(symbol.exports, symbol, node, flags, 0);
            }
        }
        function bindExportsPropertyAssignment(node) {
            if (!setCommonJsModuleIndicator(node)) {
                return;
            }
            var symbol = forEachIdentifierInEntityName(node.left.expression, undefined, function (id, symbol) {
                if (symbol) {
                    addDeclarationToSymbol(symbol, id, 1536 | 67108864);
                }
                return symbol;
            });
            if (symbol) {
                var isAlias = ts.isAliasableExpression(node.right) && (ts.isExportsIdentifier(node.left.expression) || ts.isModuleExportsAccessExpression(node.left.expression));
                var flags = isAlias ? 2097152 : 4 | 1048576;
                ts.setParent(node.left, node);
                declareSymbol(symbol.exports, symbol, node.left, flags, 0);
            }
        }
        function bindModuleExportsAssignment(node) {
            if (!setCommonJsModuleIndicator(node)) {
                return;
            }
            var assignedExpression = ts.getRightMostAssignedExpression(node.right);
            if (ts.isEmptyObjectLiteral(assignedExpression) || container === file && isExportsOrModuleExportsOrAlias(file, assignedExpression)) {
                return;
            }
            if (ts.isObjectLiteralExpression(assignedExpression) && ts.every(assignedExpression.properties, ts.isShorthandPropertyAssignment)) {
                ts.forEach(assignedExpression.properties, bindExportAssignedObjectMemberAlias);
                return;
            }
            var flags = ts.exportAssignmentIsAlias(node)
                ? 2097152
                : 4 | 1048576 | 512;
            var symbol = declareSymbol(file.symbol.exports, file.symbol, node, flags | 67108864, 0);
            ts.setValueDeclaration(symbol, node);
        }
        function bindExportAssignedObjectMemberAlias(node) {
            declareSymbol(file.symbol.exports, file.symbol, node, 2097152 | 67108864, 0);
        }
        function bindThisPropertyAssignment(node) {
            ts.Debug.assert(ts.isInJSFile(node));
            var hasPrivateIdentifier = (ts.isBinaryExpression(node) && ts.isPropertyAccessExpression(node.left) && ts.isPrivateIdentifier(node.left.name))
                || (ts.isPropertyAccessExpression(node) && ts.isPrivateIdentifier(node.name));
            if (hasPrivateIdentifier) {
                return;
            }
            var thisContainer = ts.getThisContainer(node, false);
            switch (thisContainer.kind) {
                case 256:
                case 213:
                    var constructorSymbol = thisContainer.symbol;
                    if (ts.isBinaryExpression(thisContainer.parent) && thisContainer.parent.operatorToken.kind === 63) {
                        var l = thisContainer.parent.left;
                        if (ts.isBindableStaticAccessExpression(l) && ts.isPrototypeAccess(l.expression)) {
                            constructorSymbol = lookupSymbolForPropertyAccess(l.expression.expression, thisParentContainer);
                        }
                    }
                    if (constructorSymbol && constructorSymbol.valueDeclaration) {
                        constructorSymbol.members = constructorSymbol.members || ts.createSymbolTable();
                        if (ts.hasDynamicName(node)) {
                            bindDynamicallyNamedThisPropertyAssignment(node, constructorSymbol, constructorSymbol.members);
                        }
                        else {
                            declareSymbol(constructorSymbol.members, constructorSymbol, node, 4 | 67108864, 0 & ~4);
                        }
                        addDeclarationToSymbol(constructorSymbol, constructorSymbol.valueDeclaration, 32);
                    }
                    break;
                case 171:
                case 167:
                case 169:
                case 172:
                case 173:
                case 170:
                    var containingClass = thisContainer.parent;
                    var symbolTable = ts.isStatic(thisContainer) ? containingClass.symbol.exports : containingClass.symbol.members;
                    if (ts.hasDynamicName(node)) {
                        bindDynamicallyNamedThisPropertyAssignment(node, containingClass.symbol, symbolTable);
                    }
                    else {
                        declareSymbol(symbolTable, containingClass.symbol, node, 4 | 67108864, 0, true);
                    }
                    break;
                case 305:
                    if (ts.hasDynamicName(node)) {
                        break;
                    }
                    else if (thisContainer.commonJsModuleIndicator) {
                        declareSymbol(thisContainer.symbol.exports, thisContainer.symbol, node, 4 | 1048576, 0);
                    }
                    else {
                        declareSymbolAndAddToSymbolTable(node, 1, 111550);
                    }
                    break;
                default:
                    ts.Debug.failBadSyntaxKind(thisContainer);
            }
        }
        function bindDynamicallyNamedThisPropertyAssignment(node, symbol, symbolTable) {
            declareSymbol(symbolTable, symbol, node, 4, 0, true, true);
            addLateBoundAssignmentDeclarationToSymbol(node, symbol);
        }
        function addLateBoundAssignmentDeclarationToSymbol(node, symbol) {
            if (symbol) {
                (symbol.assignmentDeclarationMembers || (symbol.assignmentDeclarationMembers = new ts.Map())).set(ts.getNodeId(node), node);
            }
        }
        function bindSpecialPropertyDeclaration(node) {
            if (node.expression.kind === 108) {
                bindThisPropertyAssignment(node);
            }
            else if (ts.isBindableStaticAccessExpression(node) && node.parent.parent.kind === 305) {
                if (ts.isPrototypeAccess(node.expression)) {
                    bindPrototypePropertyAssignment(node, node.parent);
                }
                else {
                    bindStaticPropertyAssignment(node);
                }
            }
        }
        function bindPrototypeAssignment(node) {
            ts.setParent(node.left, node);
            ts.setParent(node.right, node);
            bindPropertyAssignment(node.left.expression, node.left, false, true);
        }
        function bindObjectDefinePrototypeProperty(node) {
            var namespaceSymbol = lookupSymbolForPropertyAccess(node.arguments[0].expression);
            if (namespaceSymbol && namespaceSymbol.valueDeclaration) {
                addDeclarationToSymbol(namespaceSymbol, namespaceSymbol.valueDeclaration, 32);
            }
            bindPotentiallyNewExpandoMemberToNamespace(node, namespaceSymbol, true);
        }
        function bindPrototypePropertyAssignment(lhs, parent) {
            var classPrototype = lhs.expression;
            var constructorFunction = classPrototype.expression;
            ts.setParent(constructorFunction, classPrototype);
            ts.setParent(classPrototype, lhs);
            ts.setParent(lhs, parent);
            bindPropertyAssignment(constructorFunction, lhs, true, true);
        }
        function bindObjectDefinePropertyAssignment(node) {
            var namespaceSymbol = lookupSymbolForPropertyAccess(node.arguments[0]);
            var isToplevel = node.parent.parent.kind === 305;
            namespaceSymbol = bindPotentiallyMissingNamespaces(namespaceSymbol, node.arguments[0], isToplevel, false, false);
            bindPotentiallyNewExpandoMemberToNamespace(node, namespaceSymbol, false);
        }
        function bindSpecialPropertyAssignment(node) {
            var _a;
            var parentSymbol = lookupSymbolForPropertyAccess(node.left.expression, container) || lookupSymbolForPropertyAccess(node.left.expression, blockScopeContainer);
            if (!ts.isInJSFile(node) && !ts.isFunctionSymbol(parentSymbol)) {
                return;
            }
            var rootExpr = ts.getLeftmostAccessExpression(node.left);
            if (ts.isIdentifier(rootExpr) && ((_a = lookupSymbolForName(container, rootExpr.escapedText)) === null || _a === void 0 ? void 0 : _a.flags) & 2097152) {
                return;
            }
            ts.setParent(node.left, node);
            ts.setParent(node.right, node);
            if (ts.isIdentifier(node.left.expression) && container === file && isExportsOrModuleExportsOrAlias(file, node.left.expression)) {
                bindExportsPropertyAssignment(node);
            }
            else if (ts.hasDynamicName(node)) {
                bindAnonymousDeclaration(node, 4 | 67108864, "__computed");
                var sym = bindPotentiallyMissingNamespaces(parentSymbol, node.left.expression, isTopLevelNamespaceAssignment(node.left), false, false);
                addLateBoundAssignmentDeclarationToSymbol(node, sym);
            }
            else {
                bindStaticPropertyAssignment(ts.cast(node.left, ts.isBindableStaticNameExpression));
            }
        }
        function bindStaticPropertyAssignment(node) {
            ts.Debug.assert(!ts.isIdentifier(node));
            ts.setParent(node.expression, node);
            bindPropertyAssignment(node.expression, node, false, false);
        }
        function bindPotentiallyMissingNamespaces(namespaceSymbol, entityName, isToplevel, isPrototypeProperty, containerIsClass) {
            if ((namespaceSymbol === null || namespaceSymbol === void 0 ? void 0 : namespaceSymbol.flags) & 2097152) {
                return namespaceSymbol;
            }
            if (isToplevel && !isPrototypeProperty) {
                var flags_2 = 1536 | 67108864;
                var excludeFlags_1 = 110735 & ~67108864;
                namespaceSymbol = forEachIdentifierInEntityName(entityName, namespaceSymbol, function (id, symbol, parent) {
                    if (symbol) {
                        addDeclarationToSymbol(symbol, id, flags_2);
                        return symbol;
                    }
                    else {
                        var table = parent ? parent.exports :
                            file.jsGlobalAugmentations || (file.jsGlobalAugmentations = ts.createSymbolTable());
                        return declareSymbol(table, parent, id, flags_2, excludeFlags_1);
                    }
                });
            }
            if (containerIsClass && namespaceSymbol && namespaceSymbol.valueDeclaration) {
                addDeclarationToSymbol(namespaceSymbol, namespaceSymbol.valueDeclaration, 32);
            }
            return namespaceSymbol;
        }
        function bindPotentiallyNewExpandoMemberToNamespace(declaration, namespaceSymbol, isPrototypeProperty) {
            if (!namespaceSymbol || !isExpandoSymbol(namespaceSymbol)) {
                return;
            }
            var symbolTable = isPrototypeProperty ?
                (namespaceSymbol.members || (namespaceSymbol.members = ts.createSymbolTable())) :
                (namespaceSymbol.exports || (namespaceSymbol.exports = ts.createSymbolTable()));
            var includes = 0;
            var excludes = 0;
            if (ts.isFunctionLikeDeclaration(ts.getAssignedExpandoInitializer(declaration))) {
                includes = 8192;
                excludes = 103359;
            }
            else if (ts.isCallExpression(declaration) && ts.isBindableObjectDefinePropertyCall(declaration)) {
                if (ts.some(declaration.arguments[2].properties, function (p) {
                    var id = ts.getNameOfDeclaration(p);
                    return !!id && ts.isIdentifier(id) && ts.idText(id) === "set";
                })) {
                    includes |= 65536 | 4;
                    excludes |= 78783;
                }
                if (ts.some(declaration.arguments[2].properties, function (p) {
                    var id = ts.getNameOfDeclaration(p);
                    return !!id && ts.isIdentifier(id) && ts.idText(id) === "get";
                })) {
                    includes |= 32768 | 4;
                    excludes |= 46015;
                }
            }
            if (includes === 0) {
                includes = 4;
                excludes = 0;
            }
            declareSymbol(symbolTable, namespaceSymbol, declaration, includes | 67108864, excludes & ~67108864);
        }
        function isTopLevelNamespaceAssignment(propertyAccess) {
            return ts.isBinaryExpression(propertyAccess.parent)
                ? getParentOfBinaryExpression(propertyAccess.parent).parent.kind === 305
                : propertyAccess.parent.parent.kind === 305;
        }
        function bindPropertyAssignment(name, propertyAccess, isPrototypeProperty, containerIsClass) {
            var namespaceSymbol = lookupSymbolForPropertyAccess(name, container) || lookupSymbolForPropertyAccess(name, blockScopeContainer);
            var isToplevel = isTopLevelNamespaceAssignment(propertyAccess);
            namespaceSymbol = bindPotentiallyMissingNamespaces(namespaceSymbol, propertyAccess.expression, isToplevel, isPrototypeProperty, containerIsClass);
            bindPotentiallyNewExpandoMemberToNamespace(propertyAccess, namespaceSymbol, isPrototypeProperty);
        }
        function isExpandoSymbol(symbol) {
            if (symbol.flags & (16 | 32 | 1024)) {
                return true;
            }
            var node = symbol.valueDeclaration;
            if (node && ts.isCallExpression(node)) {
                return !!ts.getAssignedExpandoInitializer(node);
            }
            var init = !node ? undefined :
                ts.isVariableDeclaration(node) ? node.initializer :
                    ts.isBinaryExpression(node) ? node.right :
                        ts.isPropertyAccessExpression(node) && ts.isBinaryExpression(node.parent) ? node.parent.right :
                            undefined;
            init = init && ts.getRightMostAssignedExpression(init);
            if (init) {
                var isPrototypeAssignment = ts.isPrototypeAccess(ts.isVariableDeclaration(node) ? node.name : ts.isBinaryExpression(node) ? node.left : node);
                return !!ts.getExpandoInitializer(ts.isBinaryExpression(init) && (init.operatorToken.kind === 56 || init.operatorToken.kind === 60) ? init.right : init, isPrototypeAssignment);
            }
            return false;
        }
        function getParentOfBinaryExpression(expr) {
            while (ts.isBinaryExpression(expr.parent)) {
                expr = expr.parent;
            }
            return expr.parent;
        }
        function lookupSymbolForPropertyAccess(node, lookupContainer) {
            if (lookupContainer === void 0) { lookupContainer = container; }
            if (ts.isIdentifier(node)) {
                return lookupSymbolForName(lookupContainer, node.escapedText);
            }
            else {
                var symbol = lookupSymbolForPropertyAccess(node.expression);
                return symbol && symbol.exports && symbol.exports.get(ts.getElementOrPropertyAccessName(node));
            }
        }
        function forEachIdentifierInEntityName(e, parent, action) {
            if (isExportsOrModuleExportsOrAlias(file, e)) {
                return file.symbol;
            }
            else if (ts.isIdentifier(e)) {
                return action(e, lookupSymbolForPropertyAccess(e), parent);
            }
            else {
                var s = forEachIdentifierInEntityName(e.expression, parent, action);
                var name = ts.getNameOrArgument(e);
                if (ts.isPrivateIdentifier(name)) {
                    ts.Debug.fail("unexpected PrivateIdentifier");
                }
                return action(name, s && s.exports && s.exports.get(ts.getElementOrPropertyAccessName(e)), s);
            }
        }
        function bindCallExpression(node) {
            if (!file.commonJsModuleIndicator && ts.isRequireCall(node, false)) {
                setCommonJsModuleIndicator(node);
            }
        }
        function bindClassLikeDeclaration(node) {
            if (node.kind === 257) {
                bindBlockScopedDeclaration(node, 32, 899503);
            }
            else {
                var bindingName = node.name ? node.name.escapedText : "__class";
                bindAnonymousDeclaration(node, 32, bindingName);
                if (node.name) {
                    classifiableNames.add(node.name.escapedText);
                }
            }
            var symbol = node.symbol;
            var prototypeSymbol = createSymbol(4 | 4194304, "prototype");
            var symbolExport = symbol.exports.get(prototypeSymbol.escapedName);
            if (symbolExport) {
                if (node.name) {
                    ts.setParent(node.name, node);
                }
                file.bindDiagnostics.push(createDiagnosticForNode(symbolExport.declarations[0], ts.Diagnostics.Duplicate_identifier_0, ts.symbolName(prototypeSymbol)));
            }
            symbol.exports.set(prototypeSymbol.escapedName, prototypeSymbol);
            prototypeSymbol.parent = symbol;
        }
        function bindEnumDeclaration(node) {
            return ts.isEnumConst(node)
                ? bindBlockScopedDeclaration(node, 128, 899967)
                : bindBlockScopedDeclaration(node, 256, 899327);
        }
        function bindVariableDeclarationOrBindingElement(node) {
            if (inStrictMode) {
                checkStrictModeEvalOrArguments(node, node.name);
            }
            if (!ts.isBindingPattern(node.name)) {
                var possibleVariableDecl = node.kind === 254 ? node : node.parent.parent;
                if (ts.isInJSFile(node) &&
                    ts.isVariableDeclarationInitializedToBareOrAccessedRequire(possibleVariableDecl) &&
                    !ts.getJSDocTypeTag(node) &&
                    !(ts.getCombinedModifierFlags(node) & 1)) {
                    declareSymbolAndAddToSymbolTable(node, 2097152, 2097152);
                }
                else if (ts.isBlockOrCatchScoped(node)) {
                    bindBlockScopedDeclaration(node, 2, 111551);
                }
                else if (ts.isParameterDeclaration(node)) {
                    declareSymbolAndAddToSymbolTable(node, 1, 111551);
                }
                else {
                    declareSymbolAndAddToSymbolTable(node, 1, 111550);
                }
            }
        }
        function bindParameter(node) {
            if (node.kind === 340 && container.kind !== 323) {
                return;
            }
            if (inStrictMode && !(node.flags & 16777216)) {
                checkStrictModeEvalOrArguments(node, node.name);
            }
            if (ts.isBindingPattern(node.name)) {
                bindAnonymousDeclaration(node, 1, "__" + node.parent.parameters.indexOf(node));
            }
            else {
                declareSymbolAndAddToSymbolTable(node, 1, 111551);
            }
            if (ts.isParameterPropertyDeclaration(node, node.parent)) {
                var classDeclaration = node.parent.parent;
                declareSymbol(classDeclaration.symbol.members, classDeclaration.symbol, node, 4 | (node.questionToken ? 16777216 : 0), 0);
            }
        }
        function bindFunctionDeclaration(node) {
            if (!file.isDeclarationFile && !(node.flags & 16777216)) {
                if (ts.isAsyncFunction(node)) {
                    emitFlags |= 2048;
                }
            }
            checkStrictModeFunctionName(node);
            if (inStrictMode) {
                checkStrictModeFunctionDeclaration(node);
                bindBlockScopedDeclaration(node, 16, 110991);
            }
            else {
                declareSymbolAndAddToSymbolTable(node, 16, 110991);
            }
        }
        function bindFunctionExpression(node) {
            if (!file.isDeclarationFile && !(node.flags & 16777216)) {
                if (ts.isAsyncFunction(node)) {
                    emitFlags |= 2048;
                }
            }
            if (currentFlow) {
                node.flowNode = currentFlow;
            }
            checkStrictModeFunctionName(node);
            var bindingName = node.name ? node.name.escapedText : "__function";
            return bindAnonymousDeclaration(node, 16, bindingName);
        }
        function bindPropertyOrMethodOrAccessor(node, symbolFlags, symbolExcludes) {
            if (!file.isDeclarationFile && !(node.flags & 16777216) && ts.isAsyncFunction(node)) {
                emitFlags |= 2048;
            }
            if (currentFlow && ts.isObjectLiteralOrClassExpressionMethodOrAccessor(node)) {
                node.flowNode = currentFlow;
            }
            return ts.hasDynamicName(node)
                ? bindAnonymousDeclaration(node, symbolFlags, "__computed")
                : declareSymbolAndAddToSymbolTable(node, symbolFlags, symbolExcludes);
        }
        function getInferTypeContainer(node) {
            var extendsType = ts.findAncestor(node, function (n) { return n.parent && ts.isConditionalTypeNode(n.parent) && n.parent.extendsType === n; });
            return extendsType && extendsType.parent;
        }
        function bindTypeParameter(node) {
            if (ts.isJSDocTemplateTag(node.parent)) {
                var container_1 = ts.getEffectiveContainerForJSDocTemplateTag(node.parent);
                if (container_1) {
                    if (!container_1.locals) {
                        container_1.locals = ts.createSymbolTable();
                    }
                    declareSymbol(container_1.locals, undefined, node, 262144, 526824);
                }
                else {
                    declareSymbolAndAddToSymbolTable(node, 262144, 526824);
                }
            }
            else if (node.parent.kind === 190) {
                var container_2 = getInferTypeContainer(node.parent);
                if (container_2) {
                    if (!container_2.locals) {
                        container_2.locals = ts.createSymbolTable();
                    }
                    declareSymbol(container_2.locals, undefined, node, 262144, 526824);
                }
                else {
                    bindAnonymousDeclaration(node, 262144, getDeclarationName(node));
                }
            }
            else {
                declareSymbolAndAddToSymbolTable(node, 262144, 526824);
            }
        }
        function shouldReportErrorOnModuleDeclaration(node) {
            var instanceState = getModuleInstanceState(node);
            return instanceState === 1 || (instanceState === 2 && ts.shouldPreserveConstEnums(options));
        }
        function checkUnreachable(node) {
            if (!(currentFlow.flags & 1)) {
                return false;
            }
            if (currentFlow === unreachableFlow) {
                var reportError = (ts.isStatementButNotDeclaration(node) && node.kind !== 236) ||
                    node.kind === 257 ||
                    (node.kind === 261 && shouldReportErrorOnModuleDeclaration(node));
                if (reportError) {
                    currentFlow = reportedUnreachableFlow;
                    if (!options.allowUnreachableCode) {
                        var isError_1 = ts.unreachableCodeIsError(options) &&
                            !(node.flags & 16777216) &&
                            (!ts.isVariableStatement(node) ||
                                !!(ts.getCombinedNodeFlags(node.declarationList) & 3) ||
                                node.declarationList.declarations.some(function (d) { return !!d.initializer; }));
                        eachUnreachableRange(node, function (start, end) { return errorOrSuggestionOnRange(isError_1, start, end, ts.Diagnostics.Unreachable_code_detected); });
                    }
                }
            }
            return true;
        }
    }
    function eachUnreachableRange(node, cb) {
        if (ts.isStatement(node) && isExecutableStatement(node) && ts.isBlock(node.parent)) {
            var statements = node.parent.statements;
            var slice_1 = ts.sliceAfter(statements, node);
            ts.getRangesWhere(slice_1, isExecutableStatement, function (start, afterEnd) { return cb(slice_1[start], slice_1[afterEnd - 1]); });
        }
        else {
            cb(node, node);
        }
    }
    function isExecutableStatement(s) {
        return !ts.isFunctionDeclaration(s) && !isPurelyTypeDeclaration(s) && !ts.isEnumDeclaration(s) &&
            !(ts.isVariableStatement(s) && !(ts.getCombinedNodeFlags(s) & (1 | 2)) && s.declarationList.declarations.some(function (d) { return !d.initializer; }));
    }
    function isPurelyTypeDeclaration(s) {
        switch (s.kind) {
            case 258:
            case 259:
                return true;
            case 261:
                return getModuleInstanceState(s) !== 1;
            case 260:
                return ts.hasSyntacticModifier(s, 2048);
            default:
                return false;
        }
    }
    function isExportsOrModuleExportsOrAlias(sourceFile, node) {
        var i = 0;
        var q = [node];
        while (q.length && i < 100) {
            i++;
            node = q.shift();
            if (ts.isExportsIdentifier(node) || ts.isModuleExportsAccessExpression(node)) {
                return true;
            }
            else if (ts.isIdentifier(node)) {
                var symbol = lookupSymbolForName(sourceFile, node.escapedText);
                if (!!symbol && !!symbol.valueDeclaration && ts.isVariableDeclaration(symbol.valueDeclaration) && !!symbol.valueDeclaration.initializer) {
                    var init = symbol.valueDeclaration.initializer;
                    q.push(init);
                    if (ts.isAssignmentExpression(init, true)) {
                        q.push(init.left);
                        q.push(init.right);
                    }
                }
            }
        }
        return false;
    }
    ts.isExportsOrModuleExportsOrAlias = isExportsOrModuleExportsOrAlias;
    function lookupSymbolForName(container, name) {
        var local = container.locals && container.locals.get(name);
        if (local) {
            return local.exportSymbol || local;
        }
        if (ts.isSourceFile(container) && container.jsGlobalAugmentations && container.jsGlobalAugmentations.has(name)) {
            return container.jsGlobalAugmentations.get(name);
        }
        return container.symbol && container.symbol.exports && container.symbol.exports.get(name);
    }
})(ts || (ts = {}));
var ts;
(function (ts) {
    function createGetSymbolWalker(getRestTypeOfSignature, getTypePredicateOfSignature, getReturnTypeOfSignature, getBaseTypes, resolveStructuredTypeMembers, getTypeOfSymbol, getResolvedSymbol, getConstraintOfTypeParameter, getFirstIdentifier, getTypeArguments) {
        return getSymbolWalker;
        function getSymbolWalker(accept) {
            if (accept === void 0) { accept = function () { return true; }; }
            var visitedTypes = [];
            var visitedSymbols = [];
            return {
                walkType: function (type) {
                    try {
                        visitType(type);
                        return { visitedTypes: ts.getOwnValues(visitedTypes), visitedSymbols: ts.getOwnValues(visitedSymbols) };
                    }
                    finally {
                        ts.clear(visitedTypes);
                        ts.clear(visitedSymbols);
                    }
                },
                walkSymbol: function (symbol) {
                    try {
                        visitSymbol(symbol);
                        return { visitedTypes: ts.getOwnValues(visitedTypes), visitedSymbols: ts.getOwnValues(visitedSymbols) };
                    }
                    finally {
                        ts.clear(visitedTypes);
                        ts.clear(visitedSymbols);
                    }
                },
            };
            function visitType(type) {
                if (!type) {
                    return;
                }
                if (visitedTypes[type.id]) {
                    return;
                }
                visitedTypes[type.id] = type;
                var shouldBail = visitSymbol(type.symbol);
                if (shouldBail)
                    return;
                if (type.flags & 524288) {
                    var objectType = type;
                    var objectFlags = objectType.objectFlags;
                    if (objectFlags & 4) {
                        visitTypeReference(type);
                    }
                    if (objectFlags & 32) {
                        visitMappedType(type);
                    }
                    if (objectFlags & (1 | 2)) {
                        visitInterfaceType(type);
                    }
                    if (objectFlags & (8 | 16)) {
                        visitObjectType(objectType);
                    }
                }
                if (type.flags & 262144) {
                    visitTypeParameter(type);
                }
                if (type.flags & 3145728) {
                    visitUnionOrIntersectionType(type);
                }
                if (type.flags & 4194304) {
                    visitIndexType(type);
                }
                if (type.flags & 8388608) {
                    visitIndexedAccessType(type);
                }
            }
            function visitTypeReference(type) {
                visitType(type.target);
                ts.forEach(getTypeArguments(type), visitType);
            }
            function visitTypeParameter(type) {
                visitType(getConstraintOfTypeParameter(type));
            }
            function visitUnionOrIntersectionType(type) {
                ts.forEach(type.types, visitType);
            }
            function visitIndexType(type) {
                visitType(type.type);
            }
            function visitIndexedAccessType(type) {
                visitType(type.objectType);
                visitType(type.indexType);
                visitType(type.constraint);
            }
            function visitMappedType(type) {
                visitType(type.typeParameter);
                visitType(type.constraintType);
                visitType(type.templateType);
                visitType(type.modifiersType);
            }
            function visitSignature(signature) {
                var typePredicate = getTypePredicateOfSignature(signature);
                if (typePredicate) {
                    visitType(typePredicate.type);
                }
                ts.forEach(signature.typeParameters, visitType);
                for (var _i = 0, _a = signature.parameters; _i < _a.length; _i++) {
                    var parameter = _a[_i];
                    visitSymbol(parameter);
                }
                visitType(getRestTypeOfSignature(signature));
                visitType(getReturnTypeOfSignature(signature));
            }
            function visitInterfaceType(interfaceT) {
                visitObjectType(interfaceT);
                ts.forEach(interfaceT.typeParameters, visitType);
                ts.forEach(getBaseTypes(interfaceT), visitType);
                visitType(interfaceT.thisType);
            }
            function visitObjectType(type) {
                var resolved = resolveStructuredTypeMembers(type);
                for (var _i = 0, _a = resolved.indexInfos; _i < _a.length; _i++) {
                    var info = _a[_i];
                    visitType(info.keyType);
                    visitType(info.type);
                }
                for (var _b = 0, _c = resolved.callSignatures; _b < _c.length; _b++) {
                    var signature = _c[_b];
                    visitSignature(signature);
                }
                for (var _d = 0, _e = resolved.constructSignatures; _d < _e.length; _d++) {
                    var signature = _e[_d];
                    visitSignature(signature);
                }
                for (var _f = 0, _g = resolved.properties; _f < _g.length; _f++) {
                    var p = _g[_f];
                    visitSymbol(p);
                }
            }
            function visitSymbol(symbol) {
                if (!symbol) {
                    return false;
                }
                var symbolId = ts.getSymbolId(symbol);
                if (visitedSymbols[symbolId]) {
                    return false;
                }
                visitedSymbols[symbolId] = symbol;
                if (!accept(symbol)) {
                    return true;
                }
                var t = getTypeOfSymbol(symbol);
                visitType(t);
                if (symbol.exports) {
                    symbol.exports.forEach(visitSymbol);
                }
                ts.forEach(symbol.declarations, function (d) {
                    if (d.type && d.type.kind === 181) {
                        var query = d.type;
                        var entity = getResolvedSymbol(getFirstIdentifier(query.exprName));
                        visitSymbol(entity);
                    }
                });
                return false;
            }
        }
    }
    ts.createGetSymbolWalker = createGetSymbolWalker;
})(ts || (ts = {}));
var ts;
(function (ts) {
    var ambientModuleSymbolRegex = /^".+"$/;
    var anon = "(anonymous)";
    var nextSymbolId = 1;
    var nextNodeId = 1;
    var nextMergeId = 1;
    var nextFlowId = 1;
    var typeofEQFacts = new ts.Map(ts.getEntries({
        string: 1,
        number: 2,
        bigint: 4,
        boolean: 8,
        symbol: 16,
        undefined: 65536,
        object: 32,
        function: 64
    }));
    var typeofNEFacts = new ts.Map(ts.getEntries({
        string: 256,
        number: 512,
        bigint: 1024,
        boolean: 2048,
        symbol: 4096,
        undefined: 524288,
        object: 8192,
        function: 16384
    }));
    var isNotOverloadAndNotAccessor = ts.and(isNotOverload, isNotAccessor);
    var intrinsicTypeKinds = new ts.Map(ts.getEntries({
        Uppercase: 0,
        Lowercase: 1,
        Capitalize: 2,
        Uncapitalize: 3
    }));
    function SymbolLinks() {
    }
    function NodeLinks() {
        this.flags = 0;
    }
    function getNodeId(node) {
        if (!node.id) {
            node.id = nextNodeId;
            nextNodeId++;
        }
        return node.id;
    }
    ts.getNodeId = getNodeId;
    function getSymbolId(symbol) {
        if (!symbol.id) {
            symbol.id = nextSymbolId;
            nextSymbolId++;
        }
        return symbol.id;
    }
    ts.getSymbolId = getSymbolId;
    function isInstantiatedModule(node, preserveConstEnums) {
        var moduleState = ts.getModuleInstanceState(node);
        return moduleState === 1 ||
            (preserveConstEnums && moduleState === 2);
    }
    ts.isInstantiatedModule = isInstantiatedModule;
    function createTypeChecker(host) {
        var getPackagesMap = ts.memoize(function () {
            var map = new ts.Map();
            host.getSourceFiles().forEach(function (sf) {
                if (!sf.resolvedModules)
                    return;
                sf.resolvedModules.forEach(function (r) {
                    if (r && r.packageId)
                        map.set(r.packageId.name, r.extension === ".d.ts" || !!map.get(r.packageId.name));
                });
            });
            return map;
        });
        var deferredDiagnosticsCallbacks = [];
        var addLazyDiagnostic = function (arg) {
            deferredDiagnosticsCallbacks.push(arg);
        };
        var cancellationToken;
        var requestedExternalEmitHelpers;
        var externalHelpersModule;
        var Symbol = ts.objectAllocator.getSymbolConstructor();
        var Type = ts.objectAllocator.getTypeConstructor();
        var Signature = ts.objectAllocator.getSignatureConstructor();
        var typeCount = 0;
        var symbolCount = 0;
        var enumCount = 0;
        var totalInstantiationCount = 0;
        var instantiationCount = 0;
        var instantiationDepth = 0;
        var inlineLevel = 0;
        var currentNode;
        var varianceTypeParameter;
        var emptySymbols = ts.createSymbolTable();
        var arrayVariances = [1];
        var compilerOptions = host.getCompilerOptions();
        var languageVersion = ts.getEmitScriptTarget(compilerOptions);
        var moduleKind = ts.getEmitModuleKind(compilerOptions);
        var useDefineForClassFields = ts.getUseDefineForClassFields(compilerOptions);
        var allowSyntheticDefaultImports = ts.getAllowSyntheticDefaultImports(compilerOptions);
        var strictNullChecks = ts.getStrictOptionValue(compilerOptions, "strictNullChecks");
        var strictFunctionTypes = ts.getStrictOptionValue(compilerOptions, "strictFunctionTypes");
        var strictBindCallApply = ts.getStrictOptionValue(compilerOptions, "strictBindCallApply");
        var strictPropertyInitialization = ts.getStrictOptionValue(compilerOptions, "strictPropertyInitialization");
        var noImplicitAny = ts.getStrictOptionValue(compilerOptions, "noImplicitAny");
        var noImplicitThis = ts.getStrictOptionValue(compilerOptions, "noImplicitThis");
        var useUnknownInCatchVariables = ts.getStrictOptionValue(compilerOptions, "useUnknownInCatchVariables");
        var keyofStringsOnly = !!compilerOptions.keyofStringsOnly;
        var freshObjectLiteralFlag = compilerOptions.suppressExcessPropertyErrors ? 0 : 8192;
        var exactOptionalPropertyTypes = compilerOptions.exactOptionalPropertyTypes;
        var checkBinaryExpression = createCheckBinaryExpression();
        var emitResolver = createResolver();
        var nodeBuilder = createNodeBuilder();
        var globals = ts.createSymbolTable();
        var undefinedSymbol = createSymbol(4, "undefined");
        undefinedSymbol.declarations = [];
        var globalThisSymbol = createSymbol(1536, "globalThis", 8);
        globalThisSymbol.exports = globals;
        globalThisSymbol.declarations = [];
        globals.set(globalThisSymbol.escapedName, globalThisSymbol);
        var argumentsSymbol = createSymbol(4, "arguments");
        var requireSymbol = createSymbol(4, "require");
        var apparentArgumentCount;
        var checker = {
            getNodeCount: function () { return ts.sum(host.getSourceFiles(), "nodeCount"); },
            getIdentifierCount: function () { return ts.sum(host.getSourceFiles(), "identifierCount"); },
            getSymbolCount: function () { return ts.sum(host.getSourceFiles(), "symbolCount") + symbolCount; },
            getTypeCount: function () { return typeCount; },
            getInstantiationCount: function () { return totalInstantiationCount; },
            getRelationCacheSizes: function () { return ({
                assignable: assignableRelation.size,
                identity: identityRelation.size,
                subtype: subtypeRelation.size,
                strictSubtype: strictSubtypeRelation.size,
            }); },
            isUndefinedSymbol: function (symbol) { return symbol === undefinedSymbol; },
            isArgumentsSymbol: function (symbol) { return symbol === argumentsSymbol; },
            isUnknownSymbol: function (symbol) { return symbol === unknownSymbol; },
            getMergedSymbol: getMergedSymbol,
            getDiagnostics: getDiagnostics,
            getGlobalDiagnostics: getGlobalDiagnostics,
            getRecursionIdentity: getRecursionIdentity,
            getUnmatchedProperties: getUnmatchedProperties,
            getTypeOfSymbolAtLocation: function (symbol, locationIn) {
                var location = ts.getParseTreeNode(locationIn);
                return location ? getTypeOfSymbolAtLocation(symbol, location) : errorType;
            },
            getTypeOfSymbol: getTypeOfSymbol,
            getSymbolsOfParameterPropertyDeclaration: function (parameterIn, parameterName) {
                var parameter = ts.getParseTreeNode(parameterIn, ts.isParameter);
                if (parameter === undefined)
                    return ts.Debug.fail("Cannot get symbols of a synthetic parameter that cannot be resolved to a parse-tree node.");
                return getSymbolsOfParameterPropertyDeclaration(parameter, ts.escapeLeadingUnderscores(parameterName));
            },
            getDeclaredTypeOfSymbol: getDeclaredTypeOfSymbol,
            getPropertiesOfType: getPropertiesOfType,
            getPropertyOfType: function (type, name) { return getPropertyOfType(type, ts.escapeLeadingUnderscores(name)); },
            getPrivateIdentifierPropertyOfType: function (leftType, name, location) {
                var node = ts.getParseTreeNode(location);
                if (!node) {
                    return undefined;
                }
                var propName = ts.escapeLeadingUnderscores(name);
                var lexicallyScopedIdentifier = lookupSymbolForPrivateIdentifierDeclaration(propName, node);
                return lexicallyScopedIdentifier ? getPrivateIdentifierPropertyOfType(leftType, lexicallyScopedIdentifier) : undefined;
            },
            getTypeOfPropertyOfType: function (type, name) { return getTypeOfPropertyOfType(type, ts.escapeLeadingUnderscores(name)); },
            getIndexInfoOfType: function (type, kind) { return getIndexInfoOfType(type, kind === 0 ? stringType : numberType); },
            getIndexInfosOfType: getIndexInfosOfType,
            getSignaturesOfType: getSignaturesOfType,
            getIndexTypeOfType: function (type, kind) { return getIndexTypeOfType(type, kind === 0 ? stringType : numberType); },
            getIndexType: function (type) { return getIndexType(type); },
            getBaseTypes: getBaseTypes,
            getBaseTypeOfLiteralType: getBaseTypeOfLiteralType,
            getWidenedType: getWidenedType,
            getTypeFromTypeNode: function (nodeIn) {
                var node = ts.getParseTreeNode(nodeIn, ts.isTypeNode);
                return node ? getTypeFromTypeNode(node) : errorType;
            },
            getParameterType: getTypeAtPosition,
            getParameterIdentifierNameAtPosition: getParameterIdentifierNameAtPosition,
            getPromisedTypeOfPromise: getPromisedTypeOfPromise,
            getAwaitedType: function (type) { return getAwaitedType(type); },
            getReturnTypeOfSignature: getReturnTypeOfSignature,
            isNullableType: isNullableType,
            getNullableType: getNullableType,
            getNonNullableType: getNonNullableType,
            getNonOptionalType: removeOptionalTypeMarker,
            getTypeArguments: getTypeArguments,
            typeToTypeNode: nodeBuilder.typeToTypeNode,
            indexInfoToIndexSignatureDeclaration: nodeBuilder.indexInfoToIndexSignatureDeclaration,
            signatureToSignatureDeclaration: nodeBuilder.signatureToSignatureDeclaration,
            symbolToEntityName: nodeBuilder.symbolToEntityName,
            symbolToExpression: nodeBuilder.symbolToExpression,
            symbolToTypeParameterDeclarations: nodeBuilder.symbolToTypeParameterDeclarations,
            symbolToParameterDeclaration: nodeBuilder.symbolToParameterDeclaration,
            typeParameterToDeclaration: nodeBuilder.typeParameterToDeclaration,
            getSymbolsInScope: function (locationIn, meaning) {
                var location = ts.getParseTreeNode(locationIn);
                return location ? getSymbolsInScope(location, meaning) : [];
            },
            getSymbolAtLocation: function (nodeIn) {
                var node = ts.getParseTreeNode(nodeIn);
                return node ? getSymbolAtLocation(node, true) : undefined;
            },
            getIndexInfosAtLocation: function (nodeIn) {
                var node = ts.getParseTreeNode(nodeIn);
                return node ? getIndexInfosAtLocation(node) : undefined;
            },
            getShorthandAssignmentValueSymbol: function (nodeIn) {
                var node = ts.getParseTreeNode(nodeIn);
                return node ? getShorthandAssignmentValueSymbol(node) : undefined;
            },
            getExportSpecifierLocalTargetSymbol: function (nodeIn) {
                var node = ts.getParseTreeNode(nodeIn, ts.isExportSpecifier);
                return node ? getExportSpecifierLocalTargetSymbol(node) : undefined;
            },
            getExportSymbolOfSymbol: function (symbol) {
                return getMergedSymbol(symbol.exportSymbol || symbol);
            },
            getTypeAtLocation: function (nodeIn) {
                var node = ts.getParseTreeNode(nodeIn);
                return node ? getTypeOfNode(node) : errorType;
            },
            getTypeOfAssignmentPattern: function (nodeIn) {
                var node = ts.getParseTreeNode(nodeIn, ts.isAssignmentPattern);
                return node && getTypeOfAssignmentPattern(node) || errorType;
            },
            getPropertySymbolOfDestructuringAssignment: function (locationIn) {
                var location = ts.getParseTreeNode(locationIn, ts.isIdentifier);
                return location ? getPropertySymbolOfDestructuringAssignment(location) : undefined;
            },
            signatureToString: function (signature, enclosingDeclaration, flags, kind) {
                return signatureToString(signature, ts.getParseTreeNode(enclosingDeclaration), flags, kind);
            },
            typeToString: function (type, enclosingDeclaration, flags) {
                return typeToString(type, ts.getParseTreeNode(enclosingDeclaration), flags);
            },
            symbolToString: function (symbol, enclosingDeclaration, meaning, flags) {
                return symbolToString(symbol, ts.getParseTreeNode(enclosingDeclaration), meaning, flags);
            },
            typePredicateToString: function (predicate, enclosingDeclaration, flags) {
                return typePredicateToString(predicate, ts.getParseTreeNode(enclosingDeclaration), flags);
            },
            writeSignature: function (signature, enclosingDeclaration, flags, kind, writer) {
                return signatureToString(signature, ts.getParseTreeNode(enclosingDeclaration), flags, kind, writer);
            },
            writeType: function (type, enclosingDeclaration, flags, writer) {
                return typeToString(type, ts.getParseTreeNode(enclosingDeclaration), flags, writer);
            },
            writeSymbol: function (symbol, enclosingDeclaration, meaning, flags, writer) {
                return symbolToString(symbol, ts.getParseTreeNode(enclosingDeclaration), meaning, flags, writer);
            },
            writeTypePredicate: function (predicate, enclosingDeclaration, flags, writer) {
                return typePredicateToString(predicate, ts.getParseTreeNode(enclosingDeclaration), flags, writer);
            },
            getAugmentedPropertiesOfType: getAugmentedPropertiesOfType,
            getRootSymbols: getRootSymbols,
            getSymbolOfExpando: getSymbolOfExpando,
            getContextualType: function (nodeIn, contextFlags) {
                var node = ts.getParseTreeNode(nodeIn, ts.isExpression);
                if (!node) {
                    return undefined;
                }
                if (contextFlags & 4) {
                    return runWithInferenceBlockedFromSourceNode(node, function () { return getContextualType(node, contextFlags); });
                }
                return getContextualType(node, contextFlags);
            },
            getContextualTypeForObjectLiteralElement: function (nodeIn) {
                var node = ts.getParseTreeNode(nodeIn, ts.isObjectLiteralElementLike);
                return node ? getContextualTypeForObjectLiteralElement(node) : undefined;
            },
            getContextualTypeForArgumentAtIndex: function (nodeIn, argIndex) {
                var node = ts.getParseTreeNode(nodeIn, ts.isCallLikeExpression);
                return node && getContextualTypeForArgumentAtIndex(node, argIndex);
            },
            getContextualTypeForJsxAttribute: function (nodeIn) {
                var node = ts.getParseTreeNode(nodeIn, ts.isJsxAttributeLike);
                return node && getContextualTypeForJsxAttribute(node);
            },
            isContextSensitive: isContextSensitive,
            getTypeOfPropertyOfContextualType: getTypeOfPropertyOfContextualType,
            getFullyQualifiedName: getFullyQualifiedName,
            getResolvedSignature: function (node, candidatesOutArray, argumentCount) {
                return getResolvedSignatureWorker(node, candidatesOutArray, argumentCount, 0);
            },
            getResolvedSignatureForStringLiteralCompletions: function (call, editingArgument, candidatesOutArray) {
                return getResolvedSignatureWorker(call, candidatesOutArray, undefined, 32, editingArgument);
            },
            getResolvedSignatureForSignatureHelp: function (node, candidatesOutArray, argumentCount) {
                return getResolvedSignatureWorker(node, candidatesOutArray, argumentCount, 16);
            },
            getExpandedParameters: getExpandedParameters,
            hasEffectiveRestParameter: hasEffectiveRestParameter,
            containsArgumentsReference: containsArgumentsReference,
            getConstantValue: function (nodeIn) {
                var node = ts.getParseTreeNode(nodeIn, canHaveConstantValue);
                return node ? getConstantValue(node) : undefined;
            },
            isValidPropertyAccess: function (nodeIn, propertyName) {
                var node = ts.getParseTreeNode(nodeIn, ts.isPropertyAccessOrQualifiedNameOrImportTypeNode);
                return !!node && isValidPropertyAccess(node, ts.escapeLeadingUnderscores(propertyName));
            },
            isValidPropertyAccessForCompletions: function (nodeIn, type, property) {
                var node = ts.getParseTreeNode(nodeIn, ts.isPropertyAccessExpression);
                return !!node && isValidPropertyAccessForCompletions(node, type, property);
            },
            getSignatureFromDeclaration: function (declarationIn) {
                var declaration = ts.getParseTreeNode(declarationIn, ts.isFunctionLike);
                return declaration ? getSignatureFromDeclaration(declaration) : undefined;
            },
            isImplementationOfOverload: function (nodeIn) {
                var node = ts.getParseTreeNode(nodeIn, ts.isFunctionLike);
                return node ? isImplementationOfOverload(node) : undefined;
            },
            getImmediateAliasedSymbol: getImmediateAliasedSymbol,
            getAliasedSymbol: resolveAlias,
            getEmitResolver: getEmitResolver,
            getExportsOfModule: getExportsOfModuleAsArray,
            getExportsAndPropertiesOfModule: getExportsAndPropertiesOfModule,
            forEachExportAndPropertyOfModule: forEachExportAndPropertyOfModule,
            getSymbolWalker: ts.createGetSymbolWalker(getRestTypeOfSignature, getTypePredicateOfSignature, getReturnTypeOfSignature, getBaseTypes, resolveStructuredTypeMembers, getTypeOfSymbol, getResolvedSymbol, getConstraintOfTypeParameter, ts.getFirstIdentifier, getTypeArguments),
            getAmbientModules: getAmbientModules,
            getJsxIntrinsicTagNamesAt: getJsxIntrinsicTagNamesAt,
            isOptionalParameter: function (nodeIn) {
                var node = ts.getParseTreeNode(nodeIn, ts.isParameter);
                return node ? isOptionalParameter(node) : false;
            },
            tryGetMemberInModuleExports: function (name, symbol) { return tryGetMemberInModuleExports(ts.escapeLeadingUnderscores(name), symbol); },
            tryGetMemberInModuleExportsAndProperties: function (name, symbol) { return tryGetMemberInModuleExportsAndProperties(ts.escapeLeadingUnderscores(name), symbol); },
            tryFindAmbientModule: function (moduleName) { return tryFindAmbientModule(moduleName, true); },
            tryFindAmbientModuleWithoutAugmentations: function (moduleName) {
                return tryFindAmbientModule(moduleName, false);
            },
            getApparentType: getApparentType,
            getUnionType: getUnionType,
            isTypeAssignableTo: isTypeAssignableTo,
            createAnonymousType: createAnonymousType,
            createSignature: createSignature,
            createSymbol: createSymbol,
            createIndexInfo: createIndexInfo,
            getAnyType: function () { return anyType; },
            getStringType: function () { return stringType; },
            getNumberType: function () { return numberType; },
            createPromiseType: createPromiseType,
            createArrayType: createArrayType,
            getElementTypeOfArrayType: getElementTypeOfArrayType,
            getBooleanType: function () { return booleanType; },
            getFalseType: function (fresh) { return fresh ? falseType : regularFalseType; },
            getTrueType: function (fresh) { return fresh ? trueType : regularTrueType; },
            getVoidType: function () { return voidType; },
            getUndefinedType: function () { return undefinedType; },
            getNullType: function () { return nullType; },
            getESSymbolType: function () { return esSymbolType; },
            getNeverType: function () { return neverType; },
            getOptionalType: function () { return optionalType; },
            getPromiseType: function () { return getGlobalPromiseType(false); },
            getPromiseLikeType: function () { return getGlobalPromiseLikeType(false); },
            isSymbolAccessible: isSymbolAccessible,
            isArrayType: isArrayType,
            isTupleType: isTupleType,
            isArrayLikeType: isArrayLikeType,
            isTypeInvalidDueToUnionDiscriminant: isTypeInvalidDueToUnionDiscriminant,
            getExactOptionalProperties: getExactOptionalProperties,
            getAllPossiblePropertiesOfTypes: getAllPossiblePropertiesOfTypes,
            getSuggestedSymbolForNonexistentProperty: getSuggestedSymbolForNonexistentProperty,
            getSuggestionForNonexistentProperty: getSuggestionForNonexistentProperty,
            getSuggestedSymbolForNonexistentJSXAttribute: getSuggestedSymbolForNonexistentJSXAttribute,
            getSuggestedSymbolForNonexistentSymbol: function (location, name, meaning) { return getSuggestedSymbolForNonexistentSymbol(location, ts.escapeLeadingUnderscores(name), meaning); },
            getSuggestionForNonexistentSymbol: function (location, name, meaning) { return getSuggestionForNonexistentSymbol(location, ts.escapeLeadingUnderscores(name), meaning); },
            getSuggestedSymbolForNonexistentModule: getSuggestedSymbolForNonexistentModule,
            getSuggestionForNonexistentExport: getSuggestionForNonexistentExport,
            getSuggestedSymbolForNonexistentClassMember: getSuggestedSymbolForNonexistentClassMember,
            getBaseConstraintOfType: getBaseConstraintOfType,
            getDefaultFromTypeParameter: function (type) { return type && type.flags & 262144 ? getDefaultFromTypeParameter(type) : undefined; },
            resolveName: function (name, location, meaning, excludeGlobals) {
                return resolveName(location, ts.escapeLeadingUnderscores(name), meaning, undefined, undefined, false, excludeGlobals);
            },
            getJsxNamespace: function (n) { return ts.unescapeLeadingUnderscores(getJsxNamespace(n)); },
            getJsxFragmentFactory: function (n) {
                var jsxFragmentFactory = getJsxFragmentFactoryEntity(n);
                return jsxFragmentFactory && ts.unescapeLeadingUnderscores(ts.getFirstIdentifier(jsxFragmentFactory).escapedText);
            },
            getAccessibleSymbolChain: getAccessibleSymbolChain,
            getTypePredicateOfSignature: getTypePredicateOfSignature,
            resolveExternalModuleName: function (moduleSpecifierIn) {
                var moduleSpecifier = ts.getParseTreeNode(moduleSpecifierIn, ts.isExpression);
                return moduleSpecifier && resolveExternalModuleName(moduleSpecifier, moduleSpecifier, true);
            },
            resolveExternalModuleSymbol: resolveExternalModuleSymbol,
            tryGetThisTypeAt: function (nodeIn, includeGlobalThis) {
                var node = ts.getParseTreeNode(nodeIn);
                return node && tryGetThisTypeAt(node, includeGlobalThis);
            },
            getTypeArgumentConstraint: function (nodeIn) {
                var node = ts.getParseTreeNode(nodeIn, ts.isTypeNode);
                return node && getTypeArgumentConstraint(node);
            },
            getSuggestionDiagnostics: function (fileIn, ct) {
                var file = ts.getParseTreeNode(fileIn, ts.isSourceFile) || ts.Debug.fail("Could not determine parsed source file.");
                if (ts.skipTypeChecking(file, compilerOptions, host)) {
                    return ts.emptyArray;
                }
                var diagnostics;
                try {
                    cancellationToken = ct;
                    checkSourceFileWithEagerDiagnostics(file);
                    ts.Debug.assert(!!(getNodeLinks(file).flags & 1));
                    diagnostics = ts.addRange(diagnostics, suggestionDiagnostics.getDiagnostics(file.fileName));
                    checkUnusedIdentifiers(getPotentiallyUnusedIdentifiers(file), function (containingNode, kind, diag) {
                        if (!ts.containsParseError(containingNode) && !unusedIsError(kind, !!(containingNode.flags & 16777216))) {
                            (diagnostics || (diagnostics = [])).push(__assign(__assign({}, diag), { category: ts.DiagnosticCategory.Suggestion }));
                        }
                    });
                    return diagnostics || ts.emptyArray;
                }
                finally {
                    cancellationToken = undefined;
                }
            },
            runWithCancellationToken: function (token, callback) {
                try {
                    cancellationToken = token;
                    return callback(checker);
                }
                finally {
                    cancellationToken = undefined;
                }
            },
            getLocalTypeParametersOfClassOrInterfaceOrTypeAlias: getLocalTypeParametersOfClassOrInterfaceOrTypeAlias,
            isDeclarationVisible: isDeclarationVisible,
            isPropertyAccessible: isPropertyAccessible,
            getTypeOnlyAliasDeclaration: getTypeOnlyAliasDeclaration,
            getMemberOverrideModifierStatus: getMemberOverrideModifierStatus,
        };
        function runWithInferenceBlockedFromSourceNode(node, fn) {
            var containingCall = ts.findAncestor(node, ts.isCallLikeExpression);
            var containingCallResolvedSignature = containingCall && getNodeLinks(containingCall).resolvedSignature;
            if (containingCall) {
                var toMarkSkip = node;
                do {
                    getNodeLinks(toMarkSkip).skipDirectInference = true;
                    toMarkSkip = toMarkSkip.parent;
                } while (toMarkSkip && toMarkSkip !== containingCall);
                getNodeLinks(containingCall).resolvedSignature = undefined;
            }
            var result = fn();
            if (containingCall) {
                var toMarkSkip = node;
                do {
                    getNodeLinks(toMarkSkip).skipDirectInference = undefined;
                    toMarkSkip = toMarkSkip.parent;
                } while (toMarkSkip && toMarkSkip !== containingCall);
                getNodeLinks(containingCall).resolvedSignature = containingCallResolvedSignature;
            }
            return result;
        }
        function getResolvedSignatureWorker(nodeIn, candidatesOutArray, argumentCount, checkMode, editingArgument) {
            var node = ts.getParseTreeNode(nodeIn, ts.isCallLikeExpression);
            apparentArgumentCount = argumentCount;
            var res = !node ? undefined :
                editingArgument ? runWithInferenceBlockedFromSourceNode(editingArgument, function () { return getResolvedSignature(node, candidatesOutArray, checkMode); }) :
                    getResolvedSignature(node, candidatesOutArray, checkMode);
            apparentArgumentCount = undefined;
            return res;
        }
        var tupleTypes = new ts.Map();
        var unionTypes = new ts.Map();
        var intersectionTypes = new ts.Map();
        var stringLiteralTypes = new ts.Map();
        var numberLiteralTypes = new ts.Map();
        var bigIntLiteralTypes = new ts.Map();
        var enumLiteralTypes = new ts.Map();
        var indexedAccessTypes = new ts.Map();
        var templateLiteralTypes = new ts.Map();
        var stringMappingTypes = new ts.Map();
        var substitutionTypes = new ts.Map();
        var subtypeReductionCache = new ts.Map();
        var evolvingArrayTypes = [];
        var undefinedProperties = new ts.Map();
        var markerTypes = new ts.Set();
        var unknownSymbol = createSymbol(4, "unknown");
        var resolvingSymbol = createSymbol(0, "__resolving__");
        var unresolvedSymbols = new ts.Map();
        var errorTypes = new ts.Map();
        var anyType = createIntrinsicType(1, "any");
        var autoType = createIntrinsicType(1, "any");
        var wildcardType = createIntrinsicType(1, "any");
        var errorType = createIntrinsicType(1, "error");
        var unresolvedType = createIntrinsicType(1, "unresolved");
        var nonInferrableAnyType = createIntrinsicType(1, "any", 65536);
        var intrinsicMarkerType = createIntrinsicType(1, "intrinsic");
        var unknownType = createIntrinsicType(2, "unknown");
        var nonNullUnknownType = createIntrinsicType(2, "unknown");
        var undefinedType = createIntrinsicType(32768, "undefined");
        var undefinedWideningType = strictNullChecks ? undefinedType : createIntrinsicType(32768, "undefined", 65536);
        var optionalType = createIntrinsicType(32768, "undefined");
        var missingType = exactOptionalPropertyTypes ? createIntrinsicType(32768, "undefined") : undefinedType;
        var nullType = createIntrinsicType(65536, "null");
        var nullWideningType = strictNullChecks ? nullType : createIntrinsicType(65536, "null", 65536);
        var stringType = createIntrinsicType(4, "string");
        var numberType = createIntrinsicType(8, "number");
        var bigintType = createIntrinsicType(64, "bigint");
        var falseType = createIntrinsicType(512, "false");
        var regularFalseType = createIntrinsicType(512, "false");
        var trueType = createIntrinsicType(512, "true");
        var regularTrueType = createIntrinsicType(512, "true");
        trueType.regularType = regularTrueType;
        trueType.freshType = trueType;
        regularTrueType.regularType = regularTrueType;
        regularTrueType.freshType = trueType;
        falseType.regularType = regularFalseType;
        falseType.freshType = falseType;
        regularFalseType.regularType = regularFalseType;
        regularFalseType.freshType = falseType;
        var booleanType = getUnionType([regularFalseType, regularTrueType]);
        var esSymbolType = createIntrinsicType(4096, "symbol");
        var voidType = createIntrinsicType(16384, "void");
        var neverType = createIntrinsicType(131072, "never");
        var silentNeverType = createIntrinsicType(131072, "never");
        var nonInferrableType = createIntrinsicType(131072, "never", 262144);
        var implicitNeverType = createIntrinsicType(131072, "never");
        var unreachableNeverType = createIntrinsicType(131072, "never");
        var nonPrimitiveType = createIntrinsicType(67108864, "object");
        var stringOrNumberType = getUnionType([stringType, numberType]);
        var stringNumberSymbolType = getUnionType([stringType, numberType, esSymbolType]);
        var keyofConstraintType = keyofStringsOnly ? stringType : stringNumberSymbolType;
        var numberOrBigIntType = getUnionType([numberType, bigintType]);
        var templateConstraintType = getUnionType([stringType, numberType, booleanType, bigintType, nullType, undefinedType]);
        var numericStringType = getTemplateLiteralType(["", ""], [numberType]);
        var restrictiveMapper = makeFunctionTypeMapper(function (t) { return t.flags & 262144 ? getRestrictiveTypeParameter(t) : t; });
        var permissiveMapper = makeFunctionTypeMapper(function (t) { return t.flags & 262144 ? wildcardType : t; });
        var uniqueLiteralType = createIntrinsicType(131072, "never");
        var uniqueLiteralMapper = makeFunctionTypeMapper(function (t) { return t.flags & 262144 ? uniqueLiteralType : t; });
        var emptyObjectType = createAnonymousType(undefined, emptySymbols, ts.emptyArray, ts.emptyArray, ts.emptyArray);
        var emptyJsxObjectType = createAnonymousType(undefined, emptySymbols, ts.emptyArray, ts.emptyArray, ts.emptyArray);
        emptyJsxObjectType.objectFlags |= 2048;
        var emptyTypeLiteralSymbol = createSymbol(2048, "__type");
        emptyTypeLiteralSymbol.members = ts.createSymbolTable();
        var emptyTypeLiteralType = createAnonymousType(emptyTypeLiteralSymbol, emptySymbols, ts.emptyArray, ts.emptyArray, ts.emptyArray);
        var emptyGenericType = createAnonymousType(undefined, emptySymbols, ts.emptyArray, ts.emptyArray, ts.emptyArray);
        emptyGenericType.instantiations = new ts.Map();
        var anyFunctionType = createAnonymousType(undefined, emptySymbols, ts.emptyArray, ts.emptyArray, ts.emptyArray);
        anyFunctionType.objectFlags |= 262144;
        var noConstraintType = createAnonymousType(undefined, emptySymbols, ts.emptyArray, ts.emptyArray, ts.emptyArray);
        var circularConstraintType = createAnonymousType(undefined, emptySymbols, ts.emptyArray, ts.emptyArray, ts.emptyArray);
        var resolvingDefaultType = createAnonymousType(undefined, emptySymbols, ts.emptyArray, ts.emptyArray, ts.emptyArray);
        var markerSuperType = createTypeParameter();
        var markerSubType = createTypeParameter();
        markerSubType.constraint = markerSuperType;
        var markerOtherType = createTypeParameter();
        var noTypePredicate = createTypePredicate(1, "<<unresolved>>", 0, anyType);
        var anySignature = createSignature(undefined, undefined, undefined, ts.emptyArray, anyType, undefined, 0, 0);
        var unknownSignature = createSignature(undefined, undefined, undefined, ts.emptyArray, errorType, undefined, 0, 0);
        var resolvingSignature = createSignature(undefined, undefined, undefined, ts.emptyArray, anyType, undefined, 0, 0);
        var silentNeverSignature = createSignature(undefined, undefined, undefined, ts.emptyArray, silentNeverType, undefined, 0, 0);
        var enumNumberIndexInfo = createIndexInfo(numberType, stringType, true);
        var iterationTypesCache = new ts.Map();
        var noIterationTypes = {
            get yieldType() { return ts.Debug.fail("Not supported"); },
            get returnType() { return ts.Debug.fail("Not supported"); },
            get nextType() { return ts.Debug.fail("Not supported"); },
        };
        var anyIterationTypes = createIterationTypes(anyType, anyType, anyType);
        var anyIterationTypesExceptNext = createIterationTypes(anyType, anyType, unknownType);
        var defaultIterationTypes = createIterationTypes(neverType, anyType, undefinedType);
        var asyncIterationTypesResolver = {
            iterableCacheKey: "iterationTypesOfAsyncIterable",
            iteratorCacheKey: "iterationTypesOfAsyncIterator",
            iteratorSymbolName: "asyncIterator",
            getGlobalIteratorType: getGlobalAsyncIteratorType,
            getGlobalIterableType: getGlobalAsyncIterableType,
            getGlobalIterableIteratorType: getGlobalAsyncIterableIteratorType,
            getGlobalGeneratorType: getGlobalAsyncGeneratorType,
            resolveIterationType: getAwaitedType,
            mustHaveANextMethodDiagnostic: ts.Diagnostics.An_async_iterator_must_have_a_next_method,
            mustBeAMethodDiagnostic: ts.Diagnostics.The_0_property_of_an_async_iterator_must_be_a_method,
            mustHaveAValueDiagnostic: ts.Diagnostics.The_type_returned_by_the_0_method_of_an_async_iterator_must_be_a_promise_for_a_type_with_a_value_property,
        };
        var syncIterationTypesResolver = {
            iterableCacheKey: "iterationTypesOfIterable",
            iteratorCacheKey: "iterationTypesOfIterator",
            iteratorSymbolName: "iterator",
            getGlobalIteratorType: getGlobalIteratorType,
            getGlobalIterableType: getGlobalIterableType,
            getGlobalIterableIteratorType: getGlobalIterableIteratorType,
            getGlobalGeneratorType: getGlobalGeneratorType,
            resolveIterationType: function (type, _errorNode) { return type; },
            mustHaveANextMethodDiagnostic: ts.Diagnostics.An_iterator_must_have_a_next_method,
            mustBeAMethodDiagnostic: ts.Diagnostics.The_0_property_of_an_iterator_must_be_a_method,
            mustHaveAValueDiagnostic: ts.Diagnostics.The_type_returned_by_the_0_method_of_an_iterator_must_have_a_value_property,
        };
        var amalgamatedDuplicates;
        var reverseMappedCache = new ts.Map();
        var inInferTypeForHomomorphicMappedType = false;
        var ambientModulesCache;
        var patternAmbientModules;
        var patternAmbientModuleAugmentations;
        var globalObjectType;
        var globalFunctionType;
        var globalCallableFunctionType;
        var globalNewableFunctionType;
        var globalArrayType;
        var globalReadonlyArrayType;
        var globalStringType;
        var globalNumberType;
        var globalBooleanType;
        var globalRegExpType;
        var globalThisType;
        var anyArrayType;
        var autoArrayType;
        var anyReadonlyArrayType;
        var deferredGlobalNonNullableTypeAlias;
        var deferredGlobalESSymbolConstructorSymbol;
        var deferredGlobalESSymbolConstructorTypeSymbol;
        var deferredGlobalESSymbolType;
        var deferredGlobalTypedPropertyDescriptorType;
        var deferredGlobalPromiseType;
        var deferredGlobalPromiseLikeType;
        var deferredGlobalPromiseConstructorSymbol;
        var deferredGlobalPromiseConstructorLikeType;
        var deferredGlobalIterableType;
        var deferredGlobalIteratorType;
        var deferredGlobalIterableIteratorType;
        var deferredGlobalGeneratorType;
        var deferredGlobalIteratorYieldResultType;
        var deferredGlobalIteratorReturnResultType;
        var deferredGlobalAsyncIterableType;
        var deferredGlobalAsyncIteratorType;
        var deferredGlobalAsyncIterableIteratorType;
        var deferredGlobalAsyncGeneratorType;
        var deferredGlobalTemplateStringsArrayType;
        var deferredGlobalImportMetaType;
        var deferredGlobalImportMetaExpressionType;
        var deferredGlobalImportCallOptionsType;
        var deferredGlobalExtractSymbol;
        var deferredGlobalOmitSymbol;
        var deferredGlobalAwaitedSymbol;
        var deferredGlobalBigIntType;
        var allPotentiallyUnusedIdentifiers = new ts.Map();
        var flowLoopStart = 0;
        var flowLoopCount = 0;
        var sharedFlowCount = 0;
        var flowAnalysisDisabled = false;
        var flowInvocationCount = 0;
        var lastFlowNode;
        var lastFlowNodeReachable;
        var flowTypeCache;
        var emptyStringType = getStringLiteralType("");
        var zeroType = getNumberLiteralType(0);
        var zeroBigIntType = getBigIntLiteralType({ negative: false, base10Value: "0" });
        var resolutionTargets = [];
        var resolutionResults = [];
        var resolutionPropertyNames = [];
        var suggestionCount = 0;
        var maximumSuggestionCount = 10;
        var mergedSymbols = [];
        var symbolLinks = [];
        var nodeLinks = [];
        var flowLoopCaches = [];
        var flowLoopNodes = [];
        var flowLoopKeys = [];
        var flowLoopTypes = [];
        var sharedFlowNodes = [];
        var sharedFlowTypes = [];
        var flowNodeReachable = [];
        var flowNodePostSuper = [];
        var potentialThisCollisions = [];
        var potentialNewTargetCollisions = [];
        var potentialWeakMapSetCollisions = [];
        var potentialReflectCollisions = [];
        var awaitedTypeStack = [];
        var diagnostics = ts.createDiagnosticCollection();
        var suggestionDiagnostics = ts.createDiagnosticCollection();
        var typeofTypesByName = new ts.Map(ts.getEntries({
            string: stringType,
            number: numberType,
            bigint: bigintType,
            boolean: booleanType,
            symbol: esSymbolType,
            undefined: undefinedType
        }));
        var typeofType = createTypeofType();
        var _jsxNamespace;
        var _jsxFactoryEntity;
        var outofbandVarianceMarkerHandler;
        var subtypeRelation = new ts.Map();
        var strictSubtypeRelation = new ts.Map();
        var assignableRelation = new ts.Map();
        var comparableRelation = new ts.Map();
        var identityRelation = new ts.Map();
        var enumRelation = new ts.Map();
        var builtinGlobals = ts.createSymbolTable();
        builtinGlobals.set(undefinedSymbol.escapedName, undefinedSymbol);
        var suggestedExtensions = [
            [".mts", ".mjs"],
            [".ts", ".js"],
            [".cts", ".cjs"],
            [".mjs", ".mjs"],
            [".js", ".js"],
            [".cjs", ".cjs"],
            [".tsx", compilerOptions.jsx === 1 ? ".jsx" : ".js"],
            [".jsx", ".jsx"],
            [".json", ".json"],
        ];
        initializeTypeChecker();
        return checker;
        function getJsxNamespace(location) {
            if (location) {
                var file = ts.getSourceFileOfNode(location);
                if (file) {
                    if (ts.isJsxOpeningFragment(location)) {
                        if (file.localJsxFragmentNamespace) {
                            return file.localJsxFragmentNamespace;
                        }
                        var jsxFragmentPragma = file.pragmas.get("jsxfrag");
                        if (jsxFragmentPragma) {
                            var chosenPragma = ts.isArray(jsxFragmentPragma) ? jsxFragmentPragma[0] : jsxFragmentPragma;
                            file.localJsxFragmentFactory = ts.parseIsolatedEntityName(chosenPragma.arguments.factory, languageVersion);
                            ts.visitNode(file.localJsxFragmentFactory, markAsSynthetic);
                            if (file.localJsxFragmentFactory) {
                                return file.localJsxFragmentNamespace = ts.getFirstIdentifier(file.localJsxFragmentFactory).escapedText;
                            }
                        }
                        var entity = getJsxFragmentFactoryEntity(location);
                        if (entity) {
                            file.localJsxFragmentFactory = entity;
                            return file.localJsxFragmentNamespace = ts.getFirstIdentifier(entity).escapedText;
                        }
                    }
                    else {
                        var localJsxNamespace = getLocalJsxNamespace(file);
                        if (localJsxNamespace) {
                            return file.localJsxNamespace = localJsxNamespace;
                        }
                    }
                }
            }
            if (!_jsxNamespace) {
                _jsxNamespace = "React";
                if (compilerOptions.jsxFactory) {
                    _jsxFactoryEntity = ts.parseIsolatedEntityName(compilerOptions.jsxFactory, languageVersion);
                    ts.visitNode(_jsxFactoryEntity, markAsSynthetic);
                    if (_jsxFactoryEntity) {
                        _jsxNamespace = ts.getFirstIdentifier(_jsxFactoryEntity).escapedText;
                    }
                }
                else if (compilerOptions.reactNamespace) {
                    _jsxNamespace = ts.escapeLeadingUnderscores(compilerOptions.reactNamespace);
                }
            }
            if (!_jsxFactoryEntity) {
                _jsxFactoryEntity = ts.factory.createQualifiedName(ts.factory.createIdentifier(ts.unescapeLeadingUnderscores(_jsxNamespace)), "createElement");
            }
            return _jsxNamespace;
        }
        function getLocalJsxNamespace(file) {
            if (file.localJsxNamespace) {
                return file.localJsxNamespace;
            }
            var jsxPragma = file.pragmas.get("jsx");
            if (jsxPragma) {
                var chosenPragma = ts.isArray(jsxPragma) ? jsxPragma[0] : jsxPragma;
                file.localJsxFactory = ts.parseIsolatedEntityName(chosenPragma.arguments.factory, languageVersion);
                ts.visitNode(file.localJsxFactory, markAsSynthetic);
                if (file.localJsxFactory) {
                    return file.localJsxNamespace = ts.getFirstIdentifier(file.localJsxFactory).escapedText;
                }
            }
        }
        function markAsSynthetic(node) {
            ts.setTextRangePosEnd(node, -1, -1);
            return ts.visitEachChild(node, markAsSynthetic, ts.nullTransformationContext);
        }
        function getEmitResolver(sourceFile, cancellationToken) {
            getDiagnostics(sourceFile, cancellationToken);
            return emitResolver;
        }
        function lookupOrIssueError(location, message, arg0, arg1, arg2, arg3) {
            var diagnostic = location
                ? ts.createDiagnosticForNode(location, message, arg0, arg1, arg2, arg3)
                : ts.createCompilerDiagnostic(message, arg0, arg1, arg2, arg3);
            var existing = diagnostics.lookup(diagnostic);
            if (existing) {
                return existing;
            }
            else {
                diagnostics.add(diagnostic);
                return diagnostic;
            }
        }
        function errorSkippedOn(key, location, message, arg0, arg1, arg2, arg3) {
            var diagnostic = error(location, message, arg0, arg1, arg2, arg3);
            diagnostic.skippedOn = key;
            return diagnostic;
        }
        function createError(location, message, arg0, arg1, arg2, arg3) {
            return location
                ? ts.createDiagnosticForNode(location, message, arg0, arg1, arg2, arg3)
                : ts.createCompilerDiagnostic(message, arg0, arg1, arg2, arg3);
        }
        function error(location, message, arg0, arg1, arg2, arg3) {
            var diagnostic = createError(location, message, arg0, arg1, arg2, arg3);
            diagnostics.add(diagnostic);
            return diagnostic;
        }
        function addErrorOrSuggestion(isError, diagnostic) {
            if (isError) {
                diagnostics.add(diagnostic);
            }
            else {
                suggestionDiagnostics.add(__assign(__assign({}, diagnostic), { category: ts.DiagnosticCategory.Suggestion }));
            }
        }
        function errorOrSuggestion(isError, location, message, arg0, arg1, arg2, arg3) {
            if (location.pos < 0 || location.end < 0) {
                if (!isError) {
                    return;
                }
                var file = ts.getSourceFileOfNode(location);
                addErrorOrSuggestion(isError, "message" in message ? ts.createFileDiagnostic(file, 0, 0, message, arg0, arg1, arg2, arg3) : ts.createDiagnosticForFileFromMessageChain(file, message));
                return;
            }
            addErrorOrSuggestion(isError, "message" in message ? ts.createDiagnosticForNode(location, message, arg0, arg1, arg2, arg3) : ts.createDiagnosticForNodeFromMessageChain(location, message));
        }
        function errorAndMaybeSuggestAwait(location, maybeMissingAwait, message, arg0, arg1, arg2, arg3) {
            var diagnostic = error(location, message, arg0, arg1, arg2, arg3);
            if (maybeMissingAwait) {
                var related = ts.createDiagnosticForNode(location, ts.Diagnostics.Did_you_forget_to_use_await);
                ts.addRelatedInfo(diagnostic, related);
            }
            return diagnostic;
        }
        function addDeprecatedSuggestionWorker(declarations, diagnostic) {
            var deprecatedTag = Array.isArray(declarations) ? ts.forEach(declarations, ts.getJSDocDeprecatedTag) : ts.getJSDocDeprecatedTag(declarations);
            if (deprecatedTag) {
                ts.addRelatedInfo(diagnostic, ts.createDiagnosticForNode(deprecatedTag, ts.Diagnostics.The_declaration_was_marked_as_deprecated_here));
            }
            suggestionDiagnostics.add(diagnostic);
            return diagnostic;
        }
        function isDeprecatedSymbol(symbol) {
            return !!(getDeclarationNodeFlagsFromSymbol(symbol) & 268435456);
        }
        function addDeprecatedSuggestion(location, declarations, deprecatedEntity) {
            var diagnostic = ts.createDiagnosticForNode(location, ts.Diagnostics._0_is_deprecated, deprecatedEntity);
            return addDeprecatedSuggestionWorker(declarations, diagnostic);
        }
        function addDeprecatedSuggestionWithSignature(location, declaration, deprecatedEntity, signatureString) {
            var diagnostic = deprecatedEntity
                ? ts.createDiagnosticForNode(location, ts.Diagnostics.The_signature_0_of_1_is_deprecated, signatureString, deprecatedEntity)
                : ts.createDiagnosticForNode(location, ts.Diagnostics._0_is_deprecated, signatureString);
            return addDeprecatedSuggestionWorker(declaration, diagnostic);
        }
        function createSymbol(flags, name, checkFlags) {
            symbolCount++;
            var symbol = new Symbol(flags | 33554432, name);
            symbol.checkFlags = checkFlags || 0;
            return symbol;
        }
        function getExcludedSymbolFlags(flags) {
            var result = 0;
            if (flags & 2)
                result |= 111551;
            if (flags & 1)
                result |= 111550;
            if (flags & 4)
                result |= 0;
            if (flags & 8)
                result |= 900095;
            if (flags & 16)
                result |= 110991;
            if (flags & 32)
                result |= 899503;
            if (flags & 64)
                result |= 788872;
            if (flags & 256)
                result |= 899327;
            if (flags & 128)
                result |= 899967;
            if (flags & 512)
                result |= 110735;
            if (flags & 8192)
                result |= 103359;
            if (flags & 32768)
                result |= 46015;
            if (flags & 65536)
                result |= 78783;
            if (flags & 262144)
                result |= 526824;
            if (flags & 524288)
                result |= 788968;
            if (flags & 2097152)
                result |= 2097152;
            return result;
        }
        function recordMergedSymbol(target, source) {
            if (!source.mergeId) {
                source.mergeId = nextMergeId;
                nextMergeId++;
            }
            mergedSymbols[source.mergeId] = target;
        }
        function cloneSymbol(symbol) {
            var result = createSymbol(symbol.flags, symbol.escapedName);
            result.declarations = symbol.declarations ? symbol.declarations.slice() : [];
            result.parent = symbol.parent;
            if (symbol.valueDeclaration)
                result.valueDeclaration = symbol.valueDeclaration;
            if (symbol.constEnumOnlyModule)
                result.constEnumOnlyModule = true;
            if (symbol.members)
                result.members = new ts.Map(symbol.members);
            if (symbol.exports)
                result.exports = new ts.Map(symbol.exports);
            recordMergedSymbol(result, symbol);
            return result;
        }
        function mergeSymbol(target, source, unidirectional) {
            if (unidirectional === void 0) { unidirectional = false; }
            if (!(target.flags & getExcludedSymbolFlags(source.flags)) ||
                (source.flags | target.flags) & 67108864) {
                if (source === target) {
                    return target;
                }
                if (!(target.flags & 33554432)) {
                    var resolvedTarget = resolveSymbol(target);
                    if (resolvedTarget === unknownSymbol) {
                        return source;
                    }
                    target = cloneSymbol(resolvedTarget);
                }
                if (source.flags & 512 && target.flags & 512 && target.constEnumOnlyModule && !source.constEnumOnlyModule) {
                    target.constEnumOnlyModule = false;
                }
                target.flags |= source.flags;
                if (source.valueDeclaration) {
                    ts.setValueDeclaration(target, source.valueDeclaration);
                }
                ts.addRange(target.declarations, source.declarations);
                if (source.members) {
                    if (!target.members)
                        target.members = ts.createSymbolTable();
                    mergeSymbolTable(target.members, source.members, unidirectional);
                }
                if (source.exports) {
                    if (!target.exports)
                        target.exports = ts.createSymbolTable();
                    mergeSymbolTable(target.exports, source.exports, unidirectional);
                }
                if (!unidirectional) {
                    recordMergedSymbol(target, source);
                }
            }
            else if (target.flags & 1024) {
                if (target !== globalThisSymbol) {
                    error(source.declarations && ts.getNameOfDeclaration(source.declarations[0]), ts.Diagnostics.Cannot_augment_module_0_with_value_exports_because_it_resolves_to_a_non_module_entity, symbolToString(target));
                }
            }
            else {
                var isEitherEnum = !!(target.flags & 384 || source.flags & 384);
                var isEitherBlockScoped_1 = !!(target.flags & 2 || source.flags & 2);
                var message = isEitherEnum ? ts.Diagnostics.Enum_declarations_can_only_merge_with_namespace_or_other_enum_declarations
                    : isEitherBlockScoped_1 ? ts.Diagnostics.Cannot_redeclare_block_scoped_variable_0
                        : ts.Diagnostics.Duplicate_identifier_0;
                var sourceSymbolFile = source.declarations && ts.getSourceFileOfNode(source.declarations[0]);
                var targetSymbolFile = target.declarations && ts.getSourceFileOfNode(target.declarations[0]);
                var isSourcePlainJs = ts.isPlainJsFile(sourceSymbolFile, compilerOptions.checkJs);
                var isTargetPlainJs = ts.isPlainJsFile(targetSymbolFile, compilerOptions.checkJs);
                var symbolName_1 = symbolToString(source);
                if (sourceSymbolFile && targetSymbolFile && amalgamatedDuplicates && !isEitherEnum && sourceSymbolFile !== targetSymbolFile) {
                    var firstFile_1 = ts.comparePaths(sourceSymbolFile.path, targetSymbolFile.path) === -1 ? sourceSymbolFile : targetSymbolFile;
                    var secondFile_1 = firstFile_1 === sourceSymbolFile ? targetSymbolFile : sourceSymbolFile;
                    var filesDuplicates = ts.getOrUpdate(amalgamatedDuplicates, "".concat(firstFile_1.path, "|").concat(secondFile_1.path), function () {
                        return ({ firstFile: firstFile_1, secondFile: secondFile_1, conflictingSymbols: new ts.Map() });
                    });
                    var conflictingSymbolInfo = ts.getOrUpdate(filesDuplicates.conflictingSymbols, symbolName_1, function () {
                        return ({ isBlockScoped: isEitherBlockScoped_1, firstFileLocations: [], secondFileLocations: [] });
                    });
                    if (!isSourcePlainJs)
                        addDuplicateLocations(conflictingSymbolInfo.firstFileLocations, source);
                    if (!isTargetPlainJs)
                        addDuplicateLocations(conflictingSymbolInfo.secondFileLocations, target);
                }
                else {
                    if (!isSourcePlainJs)
                        addDuplicateDeclarationErrorsForSymbols(source, message, symbolName_1, target);
                    if (!isTargetPlainJs)
                        addDuplicateDeclarationErrorsForSymbols(target, message, symbolName_1, source);
                }
            }
            return target;
            function addDuplicateLocations(locs, symbol) {
                if (symbol.declarations) {
                    for (var _i = 0, _a = symbol.declarations; _i < _a.length; _i++) {
                        var decl = _a[_i];
                        ts.pushIfUnique(locs, decl);
                    }
                }
            }
        }
        function addDuplicateDeclarationErrorsForSymbols(target, message, symbolName, source) {
            ts.forEach(target.declarations, function (node) {
                addDuplicateDeclarationError(node, message, symbolName, source.declarations);
            });
        }
        function addDuplicateDeclarationError(node, message, symbolName, relatedNodes) {
            var errorNode = (ts.getExpandoInitializer(node, false) ? ts.getNameOfExpando(node) : ts.getNameOfDeclaration(node)) || node;
            var err = lookupOrIssueError(errorNode, message, symbolName);
            var _loop_7 = function (relatedNode) {
                var adjustedNode = (ts.getExpandoInitializer(relatedNode, false) ? ts.getNameOfExpando(relatedNode) : ts.getNameOfDeclaration(relatedNode)) || relatedNode;
                if (adjustedNode === errorNode)
                    return "continue";
                err.relatedInformation = err.relatedInformation || [];
                var leadingMessage = ts.createDiagnosticForNode(adjustedNode, ts.Diagnostics._0_was_also_declared_here, symbolName);
                var followOnMessage = ts.createDiagnosticForNode(adjustedNode, ts.Diagnostics.and_here);
                if (ts.length(err.relatedInformation) >= 5 || ts.some(err.relatedInformation, function (r) { return ts.compareDiagnostics(r, followOnMessage) === 0 || ts.compareDiagnostics(r, leadingMessage) === 0; }))
                    return "continue";
                ts.addRelatedInfo(err, !ts.length(err.relatedInformation) ? leadingMessage : followOnMessage);
            };
            for (var _i = 0, _a = relatedNodes || ts.emptyArray; _i < _a.length; _i++) {
                var relatedNode = _a[_i];
                _loop_7(relatedNode);
            }
        }
        function combineSymbolTables(first, second) {
            if (!(first === null || first === void 0 ? void 0 : first.size))
                return second;
            if (!(second === null || second === void 0 ? void 0 : second.size))
                return first;
            var combined = ts.createSymbolTable();
            mergeSymbolTable(combined, first);
            mergeSymbolTable(combined, second);
            return combined;
        }
        function mergeSymbolTable(target, source, unidirectional) {
            if (unidirectional === void 0) { unidirectional = false; }
            source.forEach(function (sourceSymbol, id) {
                var targetSymbol = target.get(id);
                target.set(id, targetSymbol ? mergeSymbol(targetSymbol, sourceSymbol, unidirectional) : sourceSymbol);
            });
        }
        function mergeModuleAugmentation(moduleName) {
            var _a, _b, _c;
            var moduleAugmentation = moduleName.parent;
            if (((_a = moduleAugmentation.symbol.declarations) === null || _a === void 0 ? void 0 : _a[0]) !== moduleAugmentation) {
                ts.Debug.assert(moduleAugmentation.symbol.declarations.length > 1);
                return;
            }
            if (ts.isGlobalScopeAugmentation(moduleAugmentation)) {
                mergeSymbolTable(globals, moduleAugmentation.symbol.exports);
            }
            else {
                var moduleNotFoundError = !(moduleName.parent.parent.flags & 16777216)
                    ? ts.Diagnostics.Invalid_module_name_in_augmentation_module_0_cannot_be_found
                    : undefined;
                var mainModule_1 = resolveExternalModuleNameWorker(moduleName, moduleName, moduleNotFoundError, true);
                if (!mainModule_1) {
                    return;
                }
                mainModule_1 = resolveExternalModuleSymbol(mainModule_1);
                if (mainModule_1.flags & 1920) {
                    if (ts.some(patternAmbientModules, function (module) { return mainModule_1 === module.symbol; })) {
                        var merged = mergeSymbol(moduleAugmentation.symbol, mainModule_1, true);
                        if (!patternAmbientModuleAugmentations) {
                            patternAmbientModuleAugmentations = new ts.Map();
                        }
                        patternAmbientModuleAugmentations.set(moduleName.text, merged);
                    }
                    else {
                        if (((_b = mainModule_1.exports) === null || _b === void 0 ? void 0 : _b.get("__export")) && ((_c = moduleAugmentation.symbol.exports) === null || _c === void 0 ? void 0 : _c.size)) {
                            var resolvedExports = getResolvedMembersOrExportsOfSymbol(mainModule_1, "resolvedExports");
                            for (var _i = 0, _d = ts.arrayFrom(moduleAugmentation.symbol.exports.entries()); _i < _d.length; _i++) {
                                var _e = _d[_i], key = _e[0], value = _e[1];
                                if (resolvedExports.has(key) && !mainModule_1.exports.has(key)) {
                                    mergeSymbol(resolvedExports.get(key), value);
                                }
                            }
                        }
                        mergeSymbol(mainModule_1, moduleAugmentation.symbol);
                    }
                }
                else {
                    error(moduleName, ts.Diagnostics.Cannot_augment_module_0_because_it_resolves_to_a_non_module_entity, moduleName.text);
                }
            }
        }
        function addToSymbolTable(target, source, message) {
            source.forEach(function (sourceSymbol, id) {
                var targetSymbol = target.get(id);
                if (targetSymbol) {
                    ts.forEach(targetSymbol.declarations, addDeclarationDiagnostic(ts.unescapeLeadingUnderscores(id), message));
                }
                else {
                    target.set(id, sourceSymbol);
                }
            });
            function addDeclarationDiagnostic(id, message) {
                return function (declaration) { return diagnostics.add(ts.createDiagnosticForNode(declaration, message, id)); };
            }
        }
        function getSymbolLinks(symbol) {
            if (symbol.flags & 33554432)
                return symbol;
            var id = getSymbolId(symbol);
            return symbolLinks[id] || (symbolLinks[id] = new SymbolLinks());
        }
        function getNodeLinks(node) {
            var nodeId = getNodeId(node);
            return nodeLinks[nodeId] || (nodeLinks[nodeId] = new NodeLinks());
        }
        function isGlobalSourceFile(node) {
            return node.kind === 305 && !ts.isExternalOrCommonJsModule(node);
        }
        function getSymbol(symbols, name, meaning) {
            if (meaning) {
                var symbol = getMergedSymbol(symbols.get(name));
                if (symbol) {
                    ts.Debug.assert((ts.getCheckFlags(symbol) & 1) === 0, "Should never get an instantiated symbol here.");
                    if (symbol.flags & meaning) {
                        return symbol;
                    }
                    if (symbol.flags & 2097152) {
                        var target = resolveAlias(symbol);
                        if (target === unknownSymbol || target.flags & meaning) {
                            return symbol;
                        }
                    }
                }
            }
        }
        function getSymbolsOfParameterPropertyDeclaration(parameter, parameterName) {
            var constructorDeclaration = parameter.parent;
            var classDeclaration = parameter.parent.parent;
            var parameterSymbol = getSymbol(constructorDeclaration.locals, parameterName, 111551);
            var propertySymbol = getSymbol(getMembersOfSymbol(classDeclaration.symbol), parameterName, 111551);
            if (parameterSymbol && propertySymbol) {
                return [parameterSymbol, propertySymbol];
            }
            return ts.Debug.fail("There should exist two symbols, one as property declaration and one as parameter declaration");
        }
        function isBlockScopedNameDeclaredBeforeUse(declaration, usage) {
            var declarationFile = ts.getSourceFileOfNode(declaration);
            var useFile = ts.getSourceFileOfNode(usage);
            var declContainer = ts.getEnclosingBlockScopeContainer(declaration);
            if (declarationFile !== useFile) {
                if ((moduleKind && (declarationFile.externalModuleIndicator || useFile.externalModuleIndicator)) ||
                    (!ts.outFile(compilerOptions)) ||
                    isInTypeQuery(usage) ||
                    declaration.flags & 16777216) {
                    return true;
                }
                if (isUsedInFunctionOrInstanceProperty(usage, declaration)) {
                    return true;
                }
                var sourceFiles = host.getSourceFiles();
                return sourceFiles.indexOf(declarationFile) <= sourceFiles.indexOf(useFile);
            }
            if (declaration.pos <= usage.pos && !(ts.isPropertyDeclaration(declaration) && ts.isThisProperty(usage.parent) && !declaration.initializer && !declaration.exclamationToken)) {
                if (declaration.kind === 203) {
                    var errorBindingElement = ts.getAncestor(usage, 203);
                    if (errorBindingElement) {
                        return ts.findAncestor(errorBindingElement, ts.isBindingElement) !== ts.findAncestor(declaration, ts.isBindingElement) ||
                            declaration.pos < errorBindingElement.pos;
                    }
                    return isBlockScopedNameDeclaredBeforeUse(ts.getAncestor(declaration, 254), usage);
                }
                else if (declaration.kind === 254) {
                    return !isImmediatelyUsedInInitializerOfBlockScopedVariable(declaration, usage);
                }
                else if (ts.isClassDeclaration(declaration)) {
                    return !ts.findAncestor(usage, function (n) { return ts.isComputedPropertyName(n) && n.parent.parent === declaration; });
                }
                else if (ts.isPropertyDeclaration(declaration)) {
                    return !isPropertyImmediatelyReferencedWithinDeclaration(declaration, usage, false);
                }
                else if (ts.isParameterPropertyDeclaration(declaration, declaration.parent)) {
                    return !(ts.getEmitScriptTarget(compilerOptions) === 99 && useDefineForClassFields
                        && ts.getContainingClass(declaration) === ts.getContainingClass(usage)
                        && isUsedInFunctionOrInstanceProperty(usage, declaration));
                }
                return true;
            }
            if (usage.parent.kind === 275 || (usage.parent.kind === 271 && usage.parent.isExportEquals)) {
                return true;
            }
            if (usage.kind === 271 && usage.isExportEquals) {
                return true;
            }
            if (!!(usage.flags & 8388608) || isInTypeQuery(usage) || usageInTypeDeclaration()) {
                return true;
            }
            if (isUsedInFunctionOrInstanceProperty(usage, declaration)) {
                if (ts.getEmitScriptTarget(compilerOptions) === 99 && useDefineForClassFields
                    && ts.getContainingClass(declaration)
                    && (ts.isPropertyDeclaration(declaration) || ts.isParameterPropertyDeclaration(declaration, declaration.parent))) {
                    return !isPropertyImmediatelyReferencedWithinDeclaration(declaration, usage, true);
                }
                else {
                    return true;
                }
            }
            return false;
            function usageInTypeDeclaration() {
                return !!ts.findAncestor(usage, function (node) { return ts.isInterfaceDeclaration(node) || ts.isTypeAliasDeclaration(node); });
            }
            function isImmediatelyUsedInInitializerOfBlockScopedVariable(declaration, usage) {
                switch (declaration.parent.parent.kind) {
                    case 237:
                    case 242:
                    case 244:
                        if (isSameScopeDescendentOf(usage, declaration, declContainer)) {
                            return true;
                        }
                        break;
                }
                var grandparent = declaration.parent.parent;
                return ts.isForInOrOfStatement(grandparent) && isSameScopeDescendentOf(usage, grandparent.expression, declContainer);
            }
            function isUsedInFunctionOrInstanceProperty(usage, declaration) {
                return !!ts.findAncestor(usage, function (current) {
                    if (current === declContainer) {
                        return "quit";
                    }
                    if (ts.isFunctionLike(current)) {
                        return true;
                    }
                    if (ts.isClassStaticBlockDeclaration(current)) {
                        return declaration.pos < usage.pos;
                    }
                    var propertyDeclaration = ts.tryCast(current.parent, ts.isPropertyDeclaration);
                    if (propertyDeclaration) {
                        var initializerOfProperty = propertyDeclaration.initializer === current;
                        if (initializerOfProperty) {
                            if (ts.isStatic(current.parent)) {
                                if (declaration.kind === 169) {
                                    return true;
                                }
                                if (ts.isPropertyDeclaration(declaration) && ts.getContainingClass(usage) === ts.getContainingClass(declaration)) {
                                    var propName = declaration.name;
                                    if (ts.isIdentifier(propName) || ts.isPrivateIdentifier(propName)) {
                                        var type = getTypeOfSymbol(getSymbolOfNode(declaration));
                                        var staticBlocks = ts.filter(declaration.parent.members, ts.isClassStaticBlockDeclaration);
                                        if (isPropertyInitializedInStaticBlocks(propName, type, staticBlocks, declaration.parent.pos, current.pos)) {
                                            return true;
                                        }
                                    }
                                }
                            }
                            else {
                                var isDeclarationInstanceProperty = declaration.kind === 167 && !ts.isStatic(declaration);
                                if (!isDeclarationInstanceProperty || ts.getContainingClass(usage) !== ts.getContainingClass(declaration)) {
                                    return true;
                                }
                            }
                        }
                    }
                    return false;
                });
            }
            function isPropertyImmediatelyReferencedWithinDeclaration(declaration, usage, stopAtAnyPropertyDeclaration) {
                if (usage.end > declaration.end) {
                    return false;
                }
                var ancestorChangingReferenceScope = ts.findAncestor(usage, function (node) {
                    if (node === declaration) {
                        return "quit";
                    }
                    switch (node.kind) {
                        case 214:
                            return true;
                        case 167:
                            return stopAtAnyPropertyDeclaration &&
                                (ts.isPropertyDeclaration(declaration) && node.parent === declaration.parent
                                    || ts.isParameterPropertyDeclaration(declaration, declaration.parent) && node.parent === declaration.parent.parent)
                                ? "quit" : true;
                        case 235:
                            switch (node.parent.kind) {
                                case 172:
                                case 169:
                                case 173:
                                    return true;
                                default:
                                    return false;
                            }
                        default:
                            return false;
                    }
                });
                return ancestorChangingReferenceScope === undefined;
            }
        }
        function useOuterVariableScopeInParameter(result, location, lastLocation) {
            var target = ts.getEmitScriptTarget(compilerOptions);
            var functionLocation = location;
            if (ts.isParameter(lastLocation)
                && functionLocation.body
                && result.valueDeclaration
                && result.valueDeclaration.pos >= functionLocation.body.pos
                && result.valueDeclaration.end <= functionLocation.body.end) {
                if (target >= 2) {
                    var links = getNodeLinks(functionLocation);
                    if (links.declarationRequiresScopeChange === undefined) {
                        links.declarationRequiresScopeChange = ts.forEach(functionLocation.parameters, requiresScopeChange) || false;
                    }
                    return !links.declarationRequiresScopeChange;
                }
            }
            return false;
            function requiresScopeChange(node) {
                return requiresScopeChangeWorker(node.name)
                    || !!node.initializer && requiresScopeChangeWorker(node.initializer);
            }
            function requiresScopeChangeWorker(node) {
                switch (node.kind) {
                    case 214:
                    case 213:
                    case 256:
                    case 171:
                        return false;
                    case 169:
                    case 172:
                    case 173:
                    case 296:
                        return requiresScopeChangeWorker(node.name);
                    case 167:
                        if (ts.hasStaticModifier(node)) {
                            return target < 99 || !useDefineForClassFields;
                        }
                        return requiresScopeChangeWorker(node.name);
                    default:
                        if (ts.isNullishCoalesce(node) || ts.isOptionalChain(node)) {
                            return target < 7;
                        }
                        if (ts.isBindingElement(node) && node.dotDotDotToken && ts.isObjectBindingPattern(node.parent)) {
                            return target < 4;
                        }
                        if (ts.isTypeNode(node))
                            return false;
                        return ts.forEachChild(node, requiresScopeChangeWorker) || false;
                }
            }
        }
        function isConstAssertion(location) {
            return (ts.isAssertionExpression(location) && ts.isConstTypeReference(location.type))
                || (ts.isJSDocTypeTag(location) && ts.isConstTypeReference(location.typeExpression));
        }
        function resolveName(location, name, meaning, nameNotFoundMessage, nameArg, isUse, excludeGlobals, getSpellingSuggstions) {
            if (excludeGlobals === void 0) { excludeGlobals = false; }
            if (getSpellingSuggstions === void 0) { getSpellingSuggstions = true; }
            return resolveNameHelper(location, name, meaning, nameNotFoundMessage, nameArg, isUse, excludeGlobals, getSpellingSuggstions, getSymbol);
        }
        function resolveNameHelper(location, name, meaning, nameNotFoundMessage, nameArg, isUse, excludeGlobals, getSpellingSuggestions, lookup) {
            var _a, _b, _c;
            var originalLocation = location;
            var result;
            var lastLocation;
            var lastSelfReferenceLocation;
            var propertyWithInvalidInitializer;
            var associatedDeclarationForContainingInitializerOrBindingName;
            var withinDeferredContext = false;
            var errorLocation = location;
            var grandparent;
            var isInExternalModule = false;
            loop: while (location) {
                if (name === "const" && isConstAssertion(location)) {
                    return undefined;
                }
                if (location.locals && !isGlobalSourceFile(location)) {
                    if (result = lookup(location.locals, name, meaning)) {
                        var useResult = true;
                        if (ts.isFunctionLike(location) && lastLocation && lastLocation !== location.body) {
                            if (meaning & result.flags & 788968 && lastLocation.kind !== 320) {
                                useResult = result.flags & 262144
                                    ? lastLocation === location.type ||
                                        lastLocation.kind === 164 ||
                                        lastLocation.kind === 340 ||
                                        lastLocation.kind === 341 ||
                                        lastLocation.kind === 163
                                    : false;
                            }
                            if (meaning & result.flags & 3) {
                                if (useOuterVariableScopeInParameter(result, location, lastLocation)) {
                                    useResult = false;
                                }
                                else if (result.flags & 1) {
                                    useResult =
                                        lastLocation.kind === 164 ||
                                            (lastLocation === location.type &&
                                                !!ts.findAncestor(result.valueDeclaration, ts.isParameter));
                                }
                            }
                        }
                        else if (location.kind === 189) {
                            useResult = lastLocation === location.trueType;
                        }
                        if (useResult) {
                            break loop;
                        }
                        else {
                            result = undefined;
                        }
                    }
                }
                withinDeferredContext = withinDeferredContext || getIsDeferredContext(location, lastLocation);
                switch (location.kind) {
                    case 305:
                        if (!ts.isExternalOrCommonJsModule(location))
                            break;
                        isInExternalModule = true;
                    case 261:
                        var moduleExports = ((_a = getSymbolOfNode(location)) === null || _a === void 0 ? void 0 : _a.exports) || emptySymbols;
                        if (location.kind === 305 || (ts.isModuleDeclaration(location) && location.flags & 16777216 && !ts.isGlobalScopeAugmentation(location))) {
                            if (result = moduleExports.get("default")) {
                                var localSymbol = ts.getLocalSymbolForExportDefault(result);
                                if (localSymbol && (result.flags & meaning) && localSymbol.escapedName === name) {
                                    break loop;
                                }
                                result = undefined;
                            }
                            var moduleExport = moduleExports.get(name);
                            if (moduleExport &&
                                moduleExport.flags === 2097152 &&
                                (ts.getDeclarationOfKind(moduleExport, 275) || ts.getDeclarationOfKind(moduleExport, 274))) {
                                break;
                            }
                        }
                        if (name !== "default" && (result = lookup(moduleExports, name, meaning & 2623475))) {
                            if (ts.isSourceFile(location) && location.commonJsModuleIndicator && !((_b = result.declarations) === null || _b === void 0 ? void 0 : _b.some(ts.isJSDocTypeAlias))) {
                                result = undefined;
                            }
                            else {
                                break loop;
                            }
                        }
                        break;
                    case 260:
                        if (result = lookup(((_c = getSymbolOfNode(location)) === null || _c === void 0 ? void 0 : _c.exports) || emptySymbols, name, meaning & 8)) {
                            break loop;
                        }
                        break;
                    case 167:
                        if (!ts.isStatic(location)) {
                            var ctor = findConstructorDeclaration(location.parent);
                            if (ctor && ctor.locals) {
                                if (lookup(ctor.locals, name, meaning & 111551)) {
                                    propertyWithInvalidInitializer = location;
                                }
                            }
                        }
                        break;
                    case 257:
                    case 226:
                    case 258:
                        if (result = lookup(getSymbolOfNode(location).members || emptySymbols, name, meaning & 788968)) {
                            if (!isTypeParameterSymbolDeclaredInContainer(result, location)) {
                                result = undefined;
                                break;
                            }
                            if (lastLocation && ts.isStatic(lastLocation)) {
                                error(errorLocation, ts.Diagnostics.Static_members_cannot_reference_class_type_parameters);
                                return undefined;
                            }
                            break loop;
                        }
                        if (location.kind === 226 && meaning & 32) {
                            var className = location.name;
                            if (className && name === className.escapedText) {
                                result = location.symbol;
                                break loop;
                            }
                        }
                        break;
                    case 228:
                        if (lastLocation === location.expression && location.parent.token === 94) {
                            var container = location.parent.parent;
                            if (ts.isClassLike(container) && (result = lookup(getSymbolOfNode(container).members, name, meaning & 788968))) {
                                if (nameNotFoundMessage) {
                                    error(errorLocation, ts.Diagnostics.Base_class_expressions_cannot_reference_class_type_parameters);
                                }
                                return undefined;
                            }
                        }
                        break;
                    case 162:
                        grandparent = location.parent.parent;
                        if (ts.isClassLike(grandparent) || grandparent.kind === 258) {
                            if (result = lookup(getSymbolOfNode(grandparent).members, name, meaning & 788968)) {
                                error(errorLocation, ts.Diagnostics.A_computed_property_name_cannot_reference_a_type_parameter_from_its_containing_type);
                                return undefined;
                            }
                        }
                        break;
                    case 214:
                        if (ts.getEmitScriptTarget(compilerOptions) >= 2) {
                            break;
                        }
                    case 169:
                    case 171:
                    case 172:
                    case 173:
                    case 256:
                        if (meaning & 3 && name === "arguments") {
                            result = argumentsSymbol;
                            break loop;
                        }
                        break;
                    case 213:
                        if (meaning & 3 && name === "arguments") {
                            result = argumentsSymbol;
                            break loop;
                        }
                        if (meaning & 16) {
                            var functionName = location.name;
                            if (functionName && name === functionName.escapedText) {
                                result = location.symbol;
                                break loop;
                            }
                        }
                        break;
                    case 165:
                        if (location.parent && location.parent.kind === 164) {
                            location = location.parent;
                        }
                        if (location.parent && (ts.isClassElement(location.parent) || location.parent.kind === 257)) {
                            location = location.parent;
                        }
                        break;
                    case 345:
                    case 338:
                    case 339:
                        var root = ts.getJSDocRoot(location);
                        if (root) {
                            location = root.parent;
                        }
                        break;
                    case 164:
                        if (lastLocation && (lastLocation === location.initializer ||
                            lastLocation === location.name && ts.isBindingPattern(lastLocation))) {
                            if (!associatedDeclarationForContainingInitializerOrBindingName) {
                                associatedDeclarationForContainingInitializerOrBindingName = location;
                            }
                        }
                        break;
                    case 203:
                        if (lastLocation && (lastLocation === location.initializer ||
                            lastLocation === location.name && ts.isBindingPattern(lastLocation))) {
                            if (ts.isParameterDeclaration(location) && !associatedDeclarationForContainingInitializerOrBindingName) {
                                associatedDeclarationForContainingInitializerOrBindingName = location;
                            }
                        }
                        break;
                    case 190:
                        if (meaning & 262144) {
                            var parameterName = location.typeParameter.name;
                            if (parameterName && name === parameterName.escapedText) {
                                result = location.typeParameter.symbol;
                                break loop;
                            }
                        }
                        break;
                }
                if (isSelfReferenceLocation(location)) {
                    lastSelfReferenceLocation = location;
                }
                lastLocation = location;
                location = ts.isJSDocTemplateTag(location) ? ts.getEffectiveContainerForJSDocTemplateTag(location) || location.parent :
                    ts.isJSDocParameterTag(location) || ts.isJSDocReturnTag(location) ? ts.getHostSignatureFromJSDoc(location) || location.parent :
                        location.parent;
            }
            if (isUse && result && (!lastSelfReferenceLocation || result !== lastSelfReferenceLocation.symbol)) {
                result.isReferenced |= meaning;
            }
            if (!result) {
                if (lastLocation) {
                    ts.Debug.assert(lastLocation.kind === 305);
                    if (lastLocation.commonJsModuleIndicator && name === "exports" && meaning & lastLocation.symbol.flags) {
                        return lastLocation.symbol;
                    }
                }
                if (!excludeGlobals) {
                    result = lookup(globals, name, meaning);
                }
            }
            if (!result) {
                if (originalLocation && ts.isInJSFile(originalLocation) && originalLocation.parent) {
                    if (ts.isRequireCall(originalLocation.parent, false)) {
                        return requireSymbol;
                    }
                }
            }
            if (!result) {
                if (nameNotFoundMessage) {
                    addLazyDiagnostic(function () {
                        if (!errorLocation ||
                            !checkAndReportErrorForMissingPrefix(errorLocation, name, nameArg) &&
                                !checkAndReportErrorForExtendingInterface(errorLocation) &&
                                !checkAndReportErrorForUsingTypeAsNamespace(errorLocation, name, meaning) &&
                                !checkAndReportErrorForExportingPrimitiveType(errorLocation, name) &&
                                !checkAndReportErrorForUsingTypeAsValue(errorLocation, name, meaning) &&
                                !checkAndReportErrorForUsingNamespaceModuleAsValue(errorLocation, name, meaning) &&
                                !checkAndReportErrorForUsingValueAsType(errorLocation, name, meaning)) {
                            var suggestion = void 0;
                            if (getSpellingSuggestions && suggestionCount < maximumSuggestionCount) {
                                suggestion = getSuggestedSymbolForNonexistentSymbol(originalLocation, name, meaning);
                                var isGlobalScopeAugmentationDeclaration = (suggestion === null || suggestion === void 0 ? void 0 : suggestion.valueDeclaration) && ts.isAmbientModule(suggestion.valueDeclaration) && ts.isGlobalScopeAugmentation(suggestion.valueDeclaration);
                                if (isGlobalScopeAugmentationDeclaration) {
                                    suggestion = undefined;
                                }
                                if (suggestion) {
                                    var suggestionName = symbolToString(suggestion);
                                    var isUncheckedJS = isUncheckedJSSuggestion(originalLocation, suggestion, false);
                                    var message = meaning === 1920 || nameArg && typeof nameArg !== "string" && ts.nodeIsSynthesized(nameArg) ? ts.Diagnostics.Cannot_find_namespace_0_Did_you_mean_1
                                        : isUncheckedJS ? ts.Diagnostics.Could_not_find_name_0_Did_you_mean_1
                                            : ts.Diagnostics.Cannot_find_name_0_Did_you_mean_1;
                                    var diagnostic = createError(errorLocation, message, diagnosticName(nameArg), suggestionName);
                                    addErrorOrSuggestion(!isUncheckedJS, diagnostic);
                                    if (suggestion.valueDeclaration) {
                                        ts.addRelatedInfo(diagnostic, ts.createDiagnosticForNode(suggestion.valueDeclaration, ts.Diagnostics._0_is_declared_here, suggestionName));
                                    }
                                }
                            }
                            if (!suggestion) {
                                if (nameArg) {
                                    var lib = getSuggestedLibForNonExistentName(nameArg);
                                    if (lib) {
                                        error(errorLocation, nameNotFoundMessage, diagnosticName(nameArg), lib);
                                    }
                                    else {
                                        error(errorLocation, nameNotFoundMessage, diagnosticName(nameArg));
                                    }
                                }
                            }
                            suggestionCount++;
                        }
                    });
                }
                return undefined;
            }
            if (propertyWithInvalidInitializer && !(ts.getEmitScriptTarget(compilerOptions) === 99 && useDefineForClassFields)) {
                var propertyName = propertyWithInvalidInitializer.name;
                error(errorLocation, ts.Diagnostics.Initializer_of_instance_member_variable_0_cannot_reference_identifier_1_declared_in_the_constructor, ts.declarationNameToString(propertyName), diagnosticName(nameArg));
                return undefined;
            }
            if (nameNotFoundMessage) {
                addLazyDiagnostic(function () {
                    if (errorLocation &&
                        (meaning & 2 ||
                            ((meaning & 32 || meaning & 384) && (meaning & 111551) === 111551))) {
                        var exportOrLocalSymbol = getExportSymbolOfValueSymbolIfExported(result);
                        if (exportOrLocalSymbol.flags & 2 || exportOrLocalSymbol.flags & 32 || exportOrLocalSymbol.flags & 384) {
                            checkResolvedBlockScopedVariable(exportOrLocalSymbol, errorLocation);
                        }
                    }
                    if (result && isInExternalModule && (meaning & 111551) === 111551 && !(originalLocation.flags & 8388608)) {
                        var merged = getMergedSymbol(result);
                        if (ts.length(merged.declarations) && ts.every(merged.declarations, function (d) { return ts.isNamespaceExportDeclaration(d) || ts.isSourceFile(d) && !!d.symbol.globalExports; })) {
                            errorOrSuggestion(!compilerOptions.allowUmdGlobalAccess, errorLocation, ts.Diagnostics._0_refers_to_a_UMD_global_but_the_current_file_is_a_module_Consider_adding_an_import_instead, ts.unescapeLeadingUnderscores(name));
                        }
                    }
                    if (result && associatedDeclarationForContainingInitializerOrBindingName && !withinDeferredContext && (meaning & 111551) === 111551) {
                        var candidate = getMergedSymbol(getLateBoundSymbol(result));
                        var root = ts.getRootDeclaration(associatedDeclarationForContainingInitializerOrBindingName);
                        if (candidate === getSymbolOfNode(associatedDeclarationForContainingInitializerOrBindingName)) {
                            error(errorLocation, ts.Diagnostics.Parameter_0_cannot_reference_itself, ts.declarationNameToString(associatedDeclarationForContainingInitializerOrBindingName.name));
                        }
                        else if (candidate.valueDeclaration && candidate.valueDeclaration.pos > associatedDeclarationForContainingInitializerOrBindingName.pos && root.parent.locals && lookup(root.parent.locals, candidate.escapedName, meaning) === candidate) {
                            error(errorLocation, ts.Diagnostics.Parameter_0_cannot_reference_identifier_1_declared_after_it, ts.declarationNameToString(associatedDeclarationForContainingInitializerOrBindingName.name), ts.declarationNameToString(errorLocation));
                        }
                    }
                    if (result && errorLocation && meaning & 111551 && result.flags & 2097152 && !(result.flags & 111551) && !ts.isValidTypeOnlyAliasUseSite(errorLocation)) {
                        var typeOnlyDeclaration = getTypeOnlyAliasDeclaration(result);
                        if (typeOnlyDeclaration) {
                            var message = typeOnlyDeclaration.kind === 275
                                ? ts.Diagnostics._0_cannot_be_used_as_a_value_because_it_was_exported_using_export_type
                                : ts.Diagnostics._0_cannot_be_used_as_a_value_because_it_was_imported_using_import_type;
                            var unescapedName = ts.unescapeLeadingUnderscores(name);
                            addTypeOnlyDeclarationRelatedInfo(error(errorLocation, message, unescapedName), typeOnlyDeclaration, unescapedName);
                        }
                    }
                });
            }
            return result;
        }
        function addTypeOnlyDeclarationRelatedInfo(diagnostic, typeOnlyDeclaration, unescapedName) {
            if (!typeOnlyDeclaration)
                return diagnostic;
            return ts.addRelatedInfo(diagnostic, ts.createDiagnosticForNode(typeOnlyDeclaration, typeOnlyDeclaration.kind === 275 ? ts.Diagnostics._0_was_exported_here : ts.Diagnostics._0_was_imported_here, unescapedName));
        }
        function getIsDeferredContext(location, lastLocation) {
            if (location.kind !== 214 && location.kind !== 213) {
                return ts.isTypeQueryNode(location) || ((ts.isFunctionLikeDeclaration(location) ||
                    (location.kind === 167 && !ts.isStatic(location))) && (!lastLocation || lastLocation !== location.name));
            }
            if (lastLocation && lastLocation === location.name) {
                return false;
            }
            if (location.asteriskToken || ts.hasSyntacticModifier(location, 256)) {
                return true;
            }
            return !ts.getImmediatelyInvokedFunctionExpression(location);
        }
        function isSelfReferenceLocation(node) {
            switch (node.kind) {
                case 256:
                case 257:
                case 258:
                case 260:
                case 259:
                case 261:
                    return true;
                default:
                    return false;
            }
        }
        function diagnosticName(nameArg) {
            return ts.isString(nameArg) ? ts.unescapeLeadingUnderscores(nameArg) : ts.declarationNameToString(nameArg);
        }
        function isTypeParameterSymbolDeclaredInContainer(symbol, container) {
            if (symbol.declarations) {
                for (var _i = 0, _a = symbol.declarations; _i < _a.length; _i++) {
                    var decl = _a[_i];
                    if (decl.kind === 163) {
                        var parent = ts.isJSDocTemplateTag(decl.parent) ? ts.getJSDocHost(decl.parent) : decl.parent;
                        if (parent === container) {
                            return !(ts.isJSDocTemplateTag(decl.parent) && ts.find(decl.parent.parent.tags, ts.isJSDocTypeAlias));
                        }
                    }
                }
            }
            return false;
        }
        function checkAndReportErrorForMissingPrefix(errorLocation, name, nameArg) {
            if (!ts.isIdentifier(errorLocation) || errorLocation.escapedText !== name || isTypeReferenceIdentifier(errorLocation) || isInTypeQuery(errorLocation)) {
                return false;
            }
            var container = ts.getThisContainer(errorLocation, false);
            var location = container;
            while (location) {
                if (ts.isClassLike(location.parent)) {
                    var classSymbol = getSymbolOfNode(location.parent);
                    if (!classSymbol) {
                        break;
                    }
                    var constructorType = getTypeOfSymbol(classSymbol);
                    if (getPropertyOfType(constructorType, name)) {
                        error(errorLocation, ts.Diagnostics.Cannot_find_name_0_Did_you_mean_the_static_member_1_0, diagnosticName(nameArg), symbolToString(classSymbol));
                        return true;
                    }
                    if (location === container && !ts.isStatic(location)) {
                        var instanceType = getDeclaredTypeOfSymbol(classSymbol).thisType;
                        if (getPropertyOfType(instanceType, name)) {
                            error(errorLocation, ts.Diagnostics.Cannot_find_name_0_Did_you_mean_the_instance_member_this_0, diagnosticName(nameArg));
                            return true;
                        }
                    }
                }
                location = location.parent;
            }
            return false;
        }
        function checkAndReportErrorForExtendingInterface(errorLocation) {
            var expression = getEntityNameForExtendingInterface(errorLocation);
            if (expression && resolveEntityName(expression, 64, true)) {
                error(errorLocation, ts.Diagnostics.Cannot_extend_an_interface_0_Did_you_mean_implements, ts.getTextOfNode(expression));
                return true;
            }
            return false;
        }
        function getEntityNameForExtendingInterface(node) {
            switch (node.kind) {
                case 79:
                case 206:
                    return node.parent ? getEntityNameForExtendingInterface(node.parent) : undefined;
                case 228:
                    if (ts.isEntityNameExpression(node.expression)) {
                        return node.expression;
                    }
                default:
                    return undefined;
            }
        }
        function checkAndReportErrorForUsingTypeAsNamespace(errorLocation, name, meaning) {
            var namespaceMeaning = 1920 | (ts.isInJSFile(errorLocation) ? 111551 : 0);
            if (meaning === namespaceMeaning) {
                var symbol = resolveSymbol(resolveName(errorLocation, name, 788968 & ~namespaceMeaning, undefined, undefined, false));
                var parent = errorLocation.parent;
                if (symbol) {
                    if (ts.isQualifiedName(parent)) {
                        ts.Debug.assert(parent.left === errorLocation, "Should only be resolving left side of qualified name as a namespace");
                        var propName = parent.right.escapedText;
                        var propType = getPropertyOfType(getDeclaredTypeOfSymbol(symbol), propName);
                        if (propType) {
                            error(parent, ts.Diagnostics.Cannot_access_0_1_because_0_is_a_type_but_not_a_namespace_Did_you_mean_to_retrieve_the_type_of_the_property_1_in_0_with_0_1, ts.unescapeLeadingUnderscores(name), ts.unescapeLeadingUnderscores(propName));
                            return true;
                        }
                    }
                    error(errorLocation, ts.Diagnostics._0_only_refers_to_a_type_but_is_being_used_as_a_namespace_here, ts.unescapeLeadingUnderscores(name));
                    return true;
                }
            }
            return false;
        }
        function checkAndReportErrorForUsingValueAsType(errorLocation, name, meaning) {
            if (meaning & (788968 & ~1920)) {
                var symbol = resolveSymbol(resolveName(errorLocation, name, ~788968 & 111551, undefined, undefined, false));
                if (symbol && !(symbol.flags & 1920)) {
                    error(errorLocation, ts.Diagnostics._0_refers_to_a_value_but_is_being_used_as_a_type_here_Did_you_mean_typeof_0, ts.unescapeLeadingUnderscores(name));
                    return true;
                }
            }
            return false;
        }
        function isPrimitiveTypeName(name) {
            return name === "any" || name === "string" || name === "number" || name === "boolean" || name === "never" || name === "unknown";
        }
        function checkAndReportErrorForExportingPrimitiveType(errorLocation, name) {
            if (isPrimitiveTypeName(name) && errorLocation.parent.kind === 275) {
                error(errorLocation, ts.Diagnostics.Cannot_export_0_Only_local_declarations_can_be_exported_from_a_module, name);
                return true;
            }
            return false;
        }
        function checkAndReportErrorForUsingTypeAsValue(errorLocation, name, meaning) {
            if (meaning & (111551 & ~1024)) {
                if (isPrimitiveTypeName(name)) {
                    error(errorLocation, ts.Diagnostics._0_only_refers_to_a_type_but_is_being_used_as_a_value_here, ts.unescapeLeadingUnderscores(name));
                    return true;
                }
                var symbol = resolveSymbol(resolveName(errorLocation, name, 788968 & ~111551, undefined, undefined, false));
                if (symbol && !(symbol.flags & 1024)) {
                    var rawName = ts.unescapeLeadingUnderscores(name);
                    if (isES2015OrLaterConstructorName(name)) {
                        error(errorLocation, ts.Diagnostics._0_only_refers_to_a_type_but_is_being_used_as_a_value_here_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_es2015_or_later, rawName);
                    }
                    else if (maybeMappedType(errorLocation, symbol)) {
                        error(errorLocation, ts.Diagnostics._0_only_refers_to_a_type_but_is_being_used_as_a_value_here_Did_you_mean_to_use_1_in_0, rawName, rawName === "K" ? "P" : "K");
                    }
                    else {
                        error(errorLocation, ts.Diagnostics._0_only_refers_to_a_type_but_is_being_used_as_a_value_here, rawName);
                    }
                    return true;
                }
            }
            return false;
        }
        function maybeMappedType(node, symbol) {
            var container = ts.findAncestor(node.parent, function (n) {
                return ts.isComputedPropertyName(n) || ts.isPropertySignature(n) ? false : ts.isTypeLiteralNode(n) || "quit";
            });
            if (container && container.members.length === 1) {
                var type = getDeclaredTypeOfSymbol(symbol);
                return !!(type.flags & 1048576) && allTypesAssignableToKind(type, 384, true);
            }
            return false;
        }
        function isES2015OrLaterConstructorName(n) {
            switch (n) {
                case "Promise":
                case "Symbol":
                case "Map":
                case "WeakMap":
                case "Set":
                case "WeakSet":
                    return true;
            }
            return false;
        }
        function checkAndReportErrorForUsingNamespaceModuleAsValue(errorLocation, name, meaning) {
            if (meaning & (111551 & ~1024 & ~788968)) {
                var symbol = resolveSymbol(resolveName(errorLocation, name, 1024 & ~111551, undefined, undefined, false));
                if (symbol) {
                    error(errorLocation, ts.Diagnostics.Cannot_use_namespace_0_as_a_value, ts.unescapeLeadingUnderscores(name));
                    return true;
                }
            }
            else if (meaning & (788968 & ~1024 & ~111551)) {
                var symbol = resolveSymbol(resolveName(errorLocation, name, (512 | 1024) & ~788968, undefined, undefined, false));
                if (symbol) {
                    error(errorLocation, ts.Diagnostics.Cannot_use_namespace_0_as_a_type, ts.unescapeLeadingUnderscores(name));
                    return true;
                }
            }
            return false;
        }
        function checkResolvedBlockScopedVariable(result, errorLocation) {
            var _a;
            ts.Debug.assert(!!(result.flags & 2 || result.flags & 32 || result.flags & 384));
            if (result.flags & (16 | 1 | 67108864) && result.flags & 32) {
                return;
            }
            var declaration = (_a = result.declarations) === null || _a === void 0 ? void 0 : _a.find(function (d) { return ts.isBlockOrCatchScoped(d) || ts.isClassLike(d) || (d.kind === 260); });
            if (declaration === undefined)
                return ts.Debug.fail("checkResolvedBlockScopedVariable could not find block-scoped declaration");
            if (!(declaration.flags & 16777216) && !isBlockScopedNameDeclaredBeforeUse(declaration, errorLocation)) {
                var diagnosticMessage = void 0;
                var declarationName = ts.declarationNameToString(ts.getNameOfDeclaration(declaration));
                if (result.flags & 2) {
                    diagnosticMessage = error(errorLocation, ts.Diagnostics.Block_scoped_variable_0_used_before_its_declaration, declarationName);
                }
                else if (result.flags & 32) {
                    diagnosticMessage = error(errorLocation, ts.Diagnostics.Class_0_used_before_its_declaration, declarationName);
                }
                else if (result.flags & 256) {
                    diagnosticMessage = error(errorLocation, ts.Diagnostics.Enum_0_used_before_its_declaration, declarationName);
                }
                else {
                    ts.Debug.assert(!!(result.flags & 128));
                    if (ts.shouldPreserveConstEnums(compilerOptions)) {
                        diagnosticMessage = error(errorLocation, ts.Diagnostics.Enum_0_used_before_its_declaration, declarationName);
                    }
                }
                if (diagnosticMessage) {
                    ts.addRelatedInfo(diagnosticMessage, ts.createDiagnosticForNode(declaration, ts.Diagnostics._0_is_declared_here, declarationName));
                }
            }
        }
        function isSameScopeDescendentOf(initial, parent, stopAt) {
            return !!parent && !!ts.findAncestor(initial, function (n) { return n === parent
                || (n === stopAt || ts.isFunctionLike(n) && !ts.getImmediatelyInvokedFunctionExpression(n) ? "quit" : false); });
        }
        function getAnyImportSyntax(node) {
            switch (node.kind) {
                case 265:
                    return node;
                case 267:
                    return node.parent;
                case 268:
                    return node.parent.parent;
                case 270:
                    return node.parent.parent.parent;
                default:
                    return undefined;
            }
        }
        function getDeclarationOfAliasSymbol(symbol) {
            return symbol.declarations && ts.findLast(symbol.declarations, isAliasSymbolDeclaration);
        }
        function isAliasSymbolDeclaration(node) {
            return node.kind === 265
                || node.kind === 264
                || node.kind === 267 && !!node.name
                || node.kind === 268
                || node.kind === 274
                || node.kind === 270
                || node.kind === 275
                || node.kind === 271 && ts.exportAssignmentIsAlias(node)
                || ts.isBinaryExpression(node) && ts.getAssignmentDeclarationKind(node) === 2 && ts.exportAssignmentIsAlias(node)
                || ts.isAccessExpression(node)
                    && ts.isBinaryExpression(node.parent)
                    && node.parent.left === node
                    && node.parent.operatorToken.kind === 63
                    && isAliasableOrJsExpression(node.parent.right)
                || node.kind === 297
                || node.kind === 296 && isAliasableOrJsExpression(node.initializer)
                || node.kind === 254 && ts.isVariableDeclarationInitializedToBareOrAccessedRequire(node)
                || node.kind === 203 && ts.isVariableDeclarationInitializedToBareOrAccessedRequire(node.parent.parent);
        }
        function isAliasableOrJsExpression(e) {
            return ts.isAliasableExpression(e) || ts.isFunctionExpression(e) && isJSConstructor(e);
        }
        function getTargetOfImportEqualsDeclaration(node, dontResolveAlias) {
            var commonJSPropertyAccess = getCommonJSPropertyAccess(node);
            if (commonJSPropertyAccess) {
                var name = ts.getLeftmostAccessExpression(commonJSPropertyAccess.expression).arguments[0];
                return ts.isIdentifier(commonJSPropertyAccess.name)
                    ? resolveSymbol(getPropertyOfType(resolveExternalModuleTypeByLiteral(name), commonJSPropertyAccess.name.escapedText))
                    : undefined;
            }
            if (ts.isVariableDeclaration(node) || node.moduleReference.kind === 277) {
                var immediate = resolveExternalModuleName(node, ts.getExternalModuleRequireArgument(node) || ts.getExternalModuleImportEqualsDeclarationExpression(node));
                var resolved_4 = resolveExternalModuleSymbol(immediate);
                markSymbolOfAliasDeclarationIfTypeOnly(node, immediate, resolved_4, false);
                return resolved_4;
            }
            var resolved = getSymbolOfPartOfRightHandSideOfImportEquals(node.moduleReference, dontResolveAlias);
            checkAndReportErrorForResolvingImportAliasToTypeOnlySymbol(node, resolved);
            return resolved;
        }
        function checkAndReportErrorForResolvingImportAliasToTypeOnlySymbol(node, resolved) {
            if (markSymbolOfAliasDeclarationIfTypeOnly(node, undefined, resolved, false) && !node.isTypeOnly) {
                var typeOnlyDeclaration = getTypeOnlyAliasDeclaration(getSymbolOfNode(node));
                var isExport = typeOnlyDeclaration.kind === 275;
                var message = isExport
                    ? ts.Diagnostics.An_import_alias_cannot_reference_a_declaration_that_was_exported_using_export_type
                    : ts.Diagnostics.An_import_alias_cannot_reference_a_declaration_that_was_imported_using_import_type;
                var relatedMessage = isExport
                    ? ts.Diagnostics._0_was_exported_here
                    : ts.Diagnostics._0_was_imported_here;
                var name = ts.unescapeLeadingUnderscores(typeOnlyDeclaration.name.escapedText);
                ts.addRelatedInfo(error(node.moduleReference, message), ts.createDiagnosticForNode(typeOnlyDeclaration, relatedMessage, name));
            }
        }
        function resolveExportByName(moduleSymbol, name, sourceNode, dontResolveAlias) {
            var exportValue = moduleSymbol.exports.get("export=");
            var exportSymbol = exportValue ? getPropertyOfType(getTypeOfSymbol(exportValue), name) : moduleSymbol.exports.get(name);
            var resolved = resolveSymbol(exportSymbol, dontResolveAlias);
            markSymbolOfAliasDeclarationIfTypeOnly(sourceNode, exportSymbol, resolved, false);
            return resolved;
        }
        function isSyntacticDefault(node) {
            return ((ts.isExportAssignment(node) && !node.isExportEquals) || ts.hasSyntacticModifier(node, 512) || ts.isExportSpecifier(node));
        }
        function getUsageModeForExpression(usage) {
            return ts.isStringLiteralLike(usage) ? ts.getModeForUsageLocation(ts.getSourceFileOfNode(usage), usage) : undefined;
        }
        function isESMFormatImportImportingCommonjsFormatFile(usageMode, targetMode) {
            return usageMode === ts.ModuleKind.ESNext && targetMode === ts.ModuleKind.CommonJS;
        }
        function isOnlyImportedAsDefault(usage) {
            var usageMode = getUsageModeForExpression(usage);
            return usageMode === ts.ModuleKind.ESNext && ts.endsWith(usage.text, ".json");
        }
        function canHaveSyntheticDefault(file, moduleSymbol, dontResolveAlias, usage) {
            var usageMode = file && getUsageModeForExpression(usage);
            if (file && usageMode !== undefined) {
                var result = isESMFormatImportImportingCommonjsFormatFile(usageMode, file.impliedNodeFormat);
                if (usageMode === ts.ModuleKind.ESNext || result) {
                    return result;
                }
            }
            if (!allowSyntheticDefaultImports) {
                return false;
            }
            if (!file || file.isDeclarationFile) {
                var defaultExportSymbol = resolveExportByName(moduleSymbol, "default", undefined, true);
                if (defaultExportSymbol && ts.some(defaultExportSymbol.declarations, isSyntacticDefault)) {
                    return false;
                }
                if (resolveExportByName(moduleSymbol, ts.escapeLeadingUnderscores("__esModule"), undefined, dontResolveAlias)) {
                    return false;
                }
                return true;
            }
            if (!ts.isSourceFileJS(file)) {
                return hasExportAssignmentSymbol(moduleSymbol);
            }
            return typeof file.externalModuleIndicator !== "object" && !resolveExportByName(moduleSymbol, ts.escapeLeadingUnderscores("__esModule"), undefined, dontResolveAlias);
        }
        function getTargetOfImportClause(node, dontResolveAlias) {
            var _a;
            var moduleSymbol = resolveExternalModuleName(node, node.parent.moduleSpecifier);
            if (moduleSymbol) {
                var exportDefaultSymbol = void 0;
                if (ts.isShorthandAmbientModuleSymbol(moduleSymbol)) {
                    exportDefaultSymbol = moduleSymbol;
                }
                else {
                    exportDefaultSymbol = resolveExportByName(moduleSymbol, "default", node, dontResolveAlias);
                }
                var file = (_a = moduleSymbol.declarations) === null || _a === void 0 ? void 0 : _a.find(ts.isSourceFile);
                var hasDefaultOnly = isOnlyImportedAsDefault(node.parent.moduleSpecifier);
                var hasSyntheticDefault = canHaveSyntheticDefault(file, moduleSymbol, dontResolveAlias, node.parent.moduleSpecifier);
                if (!exportDefaultSymbol && !hasSyntheticDefault && !hasDefaultOnly) {
                    if (hasExportAssignmentSymbol(moduleSymbol)) {
                        var compilerOptionName = moduleKind >= ts.ModuleKind.ES2015 ? "allowSyntheticDefaultImports" : "esModuleInterop";
                        var exportEqualsSymbol = moduleSymbol.exports.get("export=");
                        var exportAssignment = exportEqualsSymbol.valueDeclaration;
                        var err = error(node.name, ts.Diagnostics.Module_0_can_only_be_default_imported_using_the_1_flag, symbolToString(moduleSymbol), compilerOptionName);
                        if (exportAssignment) {
                            ts.addRelatedInfo(err, ts.createDiagnosticForNode(exportAssignment, ts.Diagnostics.This_module_is_declared_with_using_export_and_can_only_be_used_with_a_default_import_when_using_the_0_flag, compilerOptionName));
                        }
                    }
                    else {
                        reportNonDefaultExport(moduleSymbol, node);
                    }
                }
                else if (hasSyntheticDefault || hasDefaultOnly) {
                    var resolved = resolveExternalModuleSymbol(moduleSymbol, dontResolveAlias) || resolveSymbol(moduleSymbol, dontResolveAlias);
                    markSymbolOfAliasDeclarationIfTypeOnly(node, moduleSymbol, resolved, false);
                    return resolved;
                }
                markSymbolOfAliasDeclarationIfTypeOnly(node, exportDefaultSymbol, undefined, false);
                return exportDefaultSymbol;
            }
        }
        function reportNonDefaultExport(moduleSymbol, node) {
            var _a, _b, _c;
            if ((_a = moduleSymbol.exports) === null || _a === void 0 ? void 0 : _a.has(node.symbol.escapedName)) {
                error(node.name, ts.Diagnostics.Module_0_has_no_default_export_Did_you_mean_to_use_import_1_from_0_instead, symbolToString(moduleSymbol), symbolToString(node.symbol));
            }
            else {
                var diagnostic = error(node.name, ts.Diagnostics.Module_0_has_no_default_export, symbolToString(moduleSymbol));
                var exportStar = (_b = moduleSymbol.exports) === null || _b === void 0 ? void 0 : _b.get("__export");
                if (exportStar) {
                    var defaultExport = (_c = exportStar.declarations) === null || _c === void 0 ? void 0 : _c.find(function (decl) {
                        var _a, _b;
                        return !!(ts.isExportDeclaration(decl) && decl.moduleSpecifier &&
                            ((_b = (_a = resolveExternalModuleName(decl, decl.moduleSpecifier)) === null || _a === void 0 ? void 0 : _a.exports) === null || _b === void 0 ? void 0 : _b.has("default")));
                    });
                    if (defaultExport) {
                        ts.addRelatedInfo(diagnostic, ts.createDiagnosticForNode(defaultExport, ts.Diagnostics.export_Asterisk_does_not_re_export_a_default));
                    }
                }
            }
        }
        function getTargetOfNamespaceImport(node, dontResolveAlias) {
            var moduleSpecifier = node.parent.parent.moduleSpecifier;
            var immediate = resolveExternalModuleName(node, moduleSpecifier);
            var resolved = resolveESModuleSymbol(immediate, moduleSpecifier, dontResolveAlias, false);
            markSymbolOfAliasDeclarationIfTypeOnly(node, immediate, resolved, false);
            return resolved;
        }
        function getTargetOfNamespaceExport(node, dontResolveAlias) {
            var moduleSpecifier = node.parent.moduleSpecifier;
            var immediate = moduleSpecifier && resolveExternalModuleName(node, moduleSpecifier);
            var resolved = moduleSpecifier && resolveESModuleSymbol(immediate, moduleSpecifier, dontResolveAlias, false);
            markSymbolOfAliasDeclarationIfTypeOnly(node, immediate, resolved, false);
            return resolved;
        }
        function combineValueAndTypeSymbols(valueSymbol, typeSymbol) {
            if (valueSymbol === unknownSymbol && typeSymbol === unknownSymbol) {
                return unknownSymbol;
            }
            if (valueSymbol.flags & (788968 | 1920)) {
                return valueSymbol;
            }
            var result = createSymbol(valueSymbol.flags | typeSymbol.flags, valueSymbol.escapedName);
            result.declarations = ts.deduplicate(ts.concatenate(valueSymbol.declarations, typeSymbol.declarations), ts.equateValues);
            result.parent = valueSymbol.parent || typeSymbol.parent;
            if (valueSymbol.valueDeclaration)
                result.valueDeclaration = valueSymbol.valueDeclaration;
            if (typeSymbol.members)
                result.members = new ts.Map(typeSymbol.members);
            if (valueSymbol.exports)
                result.exports = new ts.Map(valueSymbol.exports);
            return result;
        }
        function getExportOfModule(symbol, name, specifier, dontResolveAlias) {
            if (symbol.flags & 1536) {
                var exportSymbol = getExportsOfSymbol(symbol).get(name.escapedText);
                var resolved = resolveSymbol(exportSymbol, dontResolveAlias);
                markSymbolOfAliasDeclarationIfTypeOnly(specifier, exportSymbol, resolved, false);
                return resolved;
            }
        }
        function getPropertyOfVariable(symbol, name) {
            if (symbol.flags & 3) {
                var typeAnnotation = symbol.valueDeclaration.type;
                if (typeAnnotation) {
                    return resolveSymbol(getPropertyOfType(getTypeFromTypeNode(typeAnnotation), name));
                }
            }
        }
        function getExternalModuleMember(node, specifier, dontResolveAlias) {
            var _a, _b;
            if (dontResolveAlias === void 0) { dontResolveAlias = false; }
            var moduleSpecifier = ts.getExternalModuleRequireArgument(node) || node.moduleSpecifier;
            var moduleSymbol = resolveExternalModuleName(node, moduleSpecifier);
            var name = !ts.isPropertyAccessExpression(specifier) && specifier.propertyName || specifier.name;
            if (!ts.isIdentifier(name)) {
                return undefined;
            }
            var suppressInteropError = name.escapedText === "default" && !!(compilerOptions.allowSyntheticDefaultImports || ts.getESModuleInterop(compilerOptions));
            var targetSymbol = resolveESModuleSymbol(moduleSymbol, moduleSpecifier, false, suppressInteropError);
            if (targetSymbol) {
                if (name.escapedText) {
                    if (ts.isShorthandAmbientModuleSymbol(moduleSymbol)) {
                        return moduleSymbol;
                    }
                    var symbolFromVariable = void 0;
                    if (moduleSymbol && moduleSymbol.exports && moduleSymbol.exports.get("export=")) {
                        symbolFromVariable = getPropertyOfType(getTypeOfSymbol(targetSymbol), name.escapedText, true);
                    }
                    else {
                        symbolFromVariable = getPropertyOfVariable(targetSymbol, name.escapedText);
                    }
                    symbolFromVariable = resolveSymbol(symbolFromVariable, dontResolveAlias);
                    var symbolFromModule = getExportOfModule(targetSymbol, name, specifier, dontResolveAlias);
                    if (symbolFromModule === undefined && name.escapedText === "default") {
                        var file = (_a = moduleSymbol.declarations) === null || _a === void 0 ? void 0 : _a.find(ts.isSourceFile);
                        if (isOnlyImportedAsDefault(moduleSpecifier) || canHaveSyntheticDefault(file, moduleSymbol, dontResolveAlias, moduleSpecifier)) {
                            symbolFromModule = resolveExternalModuleSymbol(moduleSymbol, dontResolveAlias) || resolveSymbol(moduleSymbol, dontResolveAlias);
                        }
                    }
                    var symbol = symbolFromModule && symbolFromVariable && symbolFromModule !== symbolFromVariable ?
                        combineValueAndTypeSymbols(symbolFromVariable, symbolFromModule) :
                        symbolFromModule || symbolFromVariable;
                    if (!symbol) {
                        var moduleName = getFullyQualifiedName(moduleSymbol, node);
                        var declarationName = ts.declarationNameToString(name);
                        var suggestion = getSuggestedSymbolForNonexistentModule(name, targetSymbol);
                        if (suggestion !== undefined) {
                            var suggestionName = symbolToString(suggestion);
                            var diagnostic = error(name, ts.Diagnostics._0_has_no_exported_member_named_1_Did_you_mean_2, moduleName, declarationName, suggestionName);
                            if (suggestion.valueDeclaration) {
                                ts.addRelatedInfo(diagnostic, ts.createDiagnosticForNode(suggestion.valueDeclaration, ts.Diagnostics._0_is_declared_here, suggestionName));
                            }
                        }
                        else {
                            if ((_b = moduleSymbol.exports) === null || _b === void 0 ? void 0 : _b.has("default")) {
                                error(name, ts.Diagnostics.Module_0_has_no_exported_member_1_Did_you_mean_to_use_import_1_from_0_instead, moduleName, declarationName);
                            }
                            else {
                                reportNonExportedMember(node, name, declarationName, moduleSymbol, moduleName);
                            }
                        }
                    }
                    return symbol;
                }
            }
        }
        function reportNonExportedMember(node, name, declarationName, moduleSymbol, moduleName) {
            var _a, _b;
            var localSymbol = (_b = (_a = moduleSymbol.valueDeclaration) === null || _a === void 0 ? void 0 : _a.locals) === null || _b === void 0 ? void 0 : _b.get(name.escapedText);
            var exports = moduleSymbol.exports;
            if (localSymbol) {
                var exportedEqualsSymbol = exports === null || exports === void 0 ? void 0 : exports.get("export=");
                if (exportedEqualsSymbol) {
                    getSymbolIfSameReference(exportedEqualsSymbol, localSymbol) ? reportInvalidImportEqualsExportMember(node, name, declarationName, moduleName) :
                        error(name, ts.Diagnostics.Module_0_has_no_exported_member_1, moduleName, declarationName);
                }
                else {
                    var exportedSymbol = exports ? ts.find(symbolsToArray(exports), function (symbol) { return !!getSymbolIfSameReference(symbol, localSymbol); }) : undefined;
                    var diagnostic = exportedSymbol ? error(name, ts.Diagnostics.Module_0_declares_1_locally_but_it_is_exported_as_2, moduleName, declarationName, symbolToString(exportedSymbol)) :
                        error(name, ts.Diagnostics.Module_0_declares_1_locally_but_it_is_not_exported, moduleName, declarationName);
                    if (localSymbol.declarations) {
                        ts.addRelatedInfo.apply(void 0, __spreadArray([diagnostic], ts.map(localSymbol.declarations, function (decl, index) {
                            return ts.createDiagnosticForNode(decl, index === 0 ? ts.Diagnostics._0_is_declared_here : ts.Diagnostics.and_here, declarationName);
                        }), false));
                    }
                }
            }
            else {
                error(name, ts.Diagnostics.Module_0_has_no_exported_member_1, moduleName, declarationName);
            }
        }
        function reportInvalidImportEqualsExportMember(node, name, declarationName, moduleName) {
            if (moduleKind >= ts.ModuleKind.ES2015) {
                var message = ts.getESModuleInterop(compilerOptions) ? ts.Diagnostics._0_can_only_be_imported_by_using_a_default_import :
                    ts.Diagnostics._0_can_only_be_imported_by_turning_on_the_esModuleInterop_flag_and_using_a_default_import;
                error(name, message, declarationName);
            }
            else {
                if (ts.isInJSFile(node)) {
                    var message = ts.getESModuleInterop(compilerOptions) ? ts.Diagnostics._0_can_only_be_imported_by_using_a_require_call_or_by_using_a_default_import :
                        ts.Diagnostics._0_can_only_be_imported_by_using_a_require_call_or_by_turning_on_the_esModuleInterop_flag_and_using_a_default_import;
                    error(name, message, declarationName);
                }
                else {
                    var message = ts.getESModuleInterop(compilerOptions) ? ts.Diagnostics._0_can_only_be_imported_by_using_import_1_require_2_or_a_default_import :
                        ts.Diagnostics._0_can_only_be_imported_by_using_import_1_require_2_or_by_turning_on_the_esModuleInterop_flag_and_using_a_default_import;
                    error(name, message, declarationName, declarationName, moduleName);
                }
            }
        }
        function getTargetOfImportSpecifier(node, dontResolveAlias) {
            var root = ts.isBindingElement(node) ? ts.getRootDeclaration(node) : node.parent.parent.parent;
            var commonJSPropertyAccess = getCommonJSPropertyAccess(root);
            var resolved = getExternalModuleMember(root, commonJSPropertyAccess || node, dontResolveAlias);
            var name = node.propertyName || node.name;
            if (commonJSPropertyAccess && resolved && ts.isIdentifier(name)) {
                return resolveSymbol(getPropertyOfType(getTypeOfSymbol(resolved), name.escapedText), dontResolveAlias);
            }
            markSymbolOfAliasDeclarationIfTypeOnly(node, undefined, resolved, false);
            return resolved;
        }
        function getCommonJSPropertyAccess(node) {
            if (ts.isVariableDeclaration(node) && node.initializer && ts.isPropertyAccessExpression(node.initializer)) {
                return node.initializer;
            }
        }
        function getTargetOfNamespaceExportDeclaration(node, dontResolveAlias) {
            var resolved = resolveExternalModuleSymbol(node.parent.symbol, dontResolveAlias);
            markSymbolOfAliasDeclarationIfTypeOnly(node, undefined, resolved, false);
            return resolved;
        }
        function getTargetOfExportSpecifier(node, meaning, dontResolveAlias) {
            var resolved = node.parent.parent.moduleSpecifier ?
                getExternalModuleMember(node.parent.parent, node, dontResolveAlias) :
                resolveEntityName(node.propertyName || node.name, meaning, false, dontResolveAlias);
            markSymbolOfAliasDeclarationIfTypeOnly(node, undefined, resolved, false);
            return resolved;
        }
        function getTargetOfExportAssignment(node, dontResolveAlias) {
            var expression = ts.isExportAssignment(node) ? node.expression : node.right;
            var resolved = getTargetOfAliasLikeExpression(expression, dontResolveAlias);
            markSymbolOfAliasDeclarationIfTypeOnly(node, undefined, resolved, false);
            return resolved;
        }
        function getTargetOfAliasLikeExpression(expression, dontResolveAlias) {
            if (ts.isClassExpression(expression)) {
                return checkExpressionCached(expression).symbol;
            }
            if (!ts.isEntityName(expression) && !ts.isEntityNameExpression(expression)) {
                return undefined;
            }
            var aliasLike = resolveEntityName(expression, 111551 | 788968 | 1920, true, dontResolveAlias);
            if (aliasLike) {
                return aliasLike;
            }
            checkExpressionCached(expression);
            return getNodeLinks(expression).resolvedSymbol;
        }
        function getTargetOfPropertyAssignment(node, dontRecursivelyResolve) {
            var expression = node.initializer;
            return getTargetOfAliasLikeExpression(expression, dontRecursivelyResolve);
        }
        function getTargetOfAccessExpression(node, dontRecursivelyResolve) {
            if (!(ts.isBinaryExpression(node.parent) && node.parent.left === node && node.parent.operatorToken.kind === 63)) {
                return undefined;
            }
            return getTargetOfAliasLikeExpression(node.parent.right, dontRecursivelyResolve);
        }
        function getTargetOfAliasDeclaration(node, dontRecursivelyResolve) {
            if (dontRecursivelyResolve === void 0) { dontRecursivelyResolve = false; }
            switch (node.kind) {
                case 265:
                case 254:
                    return getTargetOfImportEqualsDeclaration(node, dontRecursivelyResolve);
                case 267:
                    return getTargetOfImportClause(node, dontRecursivelyResolve);
                case 268:
                    return getTargetOfNamespaceImport(node, dontRecursivelyResolve);
                case 274:
                    return getTargetOfNamespaceExport(node, dontRecursivelyResolve);
                case 270:
                case 203:
                    return getTargetOfImportSpecifier(node, dontRecursivelyResolve);
                case 275:
                    return getTargetOfExportSpecifier(node, 111551 | 788968 | 1920, dontRecursivelyResolve);
                case 271:
                case 221:
                    return getTargetOfExportAssignment(node, dontRecursivelyResolve);
                case 264:
                    return getTargetOfNamespaceExportDeclaration(node, dontRecursivelyResolve);
                case 297:
                    return resolveEntityName(node.name, 111551 | 788968 | 1920, true, dontRecursivelyResolve);
                case 296:
                    return getTargetOfPropertyAssignment(node, dontRecursivelyResolve);
                case 207:
                case 206:
                    return getTargetOfAccessExpression(node, dontRecursivelyResolve);
                default:
                    return ts.Debug.fail();
            }
        }
        function isNonLocalAlias(symbol, excludes) {
            if (excludes === void 0) { excludes = 111551 | 788968 | 1920; }
            if (!symbol)
                return false;
            return (symbol.flags & (2097152 | excludes)) === 2097152 || !!(symbol.flags & 2097152 && symbol.flags & 67108864);
        }
        function resolveSymbol(symbol, dontResolveAlias) {
            return !dontResolveAlias && isNonLocalAlias(symbol) ? resolveAlias(symbol) : symbol;
        }
        function resolveAlias(symbol) {
            ts.Debug.assert((symbol.flags & 2097152) !== 0, "Should only get Alias here.");
            var links = getSymbolLinks(symbol);
            if (!links.aliasTarget) {
                links.aliasTarget = resolvingSymbol;
                var node = getDeclarationOfAliasSymbol(symbol);
                if (!node)
                    return ts.Debug.fail();
                var target = getTargetOfAliasDeclaration(node);
                if (links.aliasTarget === resolvingSymbol) {
                    links.aliasTarget = target || unknownSymbol;
                }
                else {
                    error(node, ts.Diagnostics.Circular_definition_of_import_alias_0, symbolToString(symbol));
                }
            }
            else if (links.aliasTarget === resolvingSymbol) {
                links.aliasTarget = unknownSymbol;
            }
            return links.aliasTarget;
        }
        function tryResolveAlias(symbol) {
            var links = getSymbolLinks(symbol);
            if (links.aliasTarget !== resolvingSymbol) {
                return resolveAlias(symbol);
            }
            return undefined;
        }
        function markSymbolOfAliasDeclarationIfTypeOnly(aliasDeclaration, immediateTarget, finalTarget, overwriteEmpty) {
            if (!aliasDeclaration || ts.isPropertyAccessExpression(aliasDeclaration))
                return false;
            var sourceSymbol = getSymbolOfNode(aliasDeclaration);
            if (ts.isTypeOnlyImportOrExportDeclaration(aliasDeclaration)) {
                var links_1 = getSymbolLinks(sourceSymbol);
                links_1.typeOnlyDeclaration = aliasDeclaration;
                return true;
            }
            var links = getSymbolLinks(sourceSymbol);
            return markSymbolOfAliasDeclarationIfTypeOnlyWorker(links, immediateTarget, overwriteEmpty)
                || markSymbolOfAliasDeclarationIfTypeOnlyWorker(links, finalTarget, overwriteEmpty);
        }
        function markSymbolOfAliasDeclarationIfTypeOnlyWorker(aliasDeclarationLinks, target, overwriteEmpty) {
            var _a, _b, _c;
            if (target && (aliasDeclarationLinks.typeOnlyDeclaration === undefined || overwriteEmpty && aliasDeclarationLinks.typeOnlyDeclaration === false)) {
                var exportSymbol = (_b = (_a = target.exports) === null || _a === void 0 ? void 0 : _a.get("export=")) !== null && _b !== void 0 ? _b : target;
                var typeOnly = exportSymbol.declarations && ts.find(exportSymbol.declarations, ts.isTypeOnlyImportOrExportDeclaration);
                aliasDeclarationLinks.typeOnlyDeclaration = (_c = typeOnly !== null && typeOnly !== void 0 ? typeOnly : getSymbolLinks(exportSymbol).typeOnlyDeclaration) !== null && _c !== void 0 ? _c : false;
            }
            return !!aliasDeclarationLinks.typeOnlyDeclaration;
        }
        function getTypeOnlyAliasDeclaration(symbol) {
            if (!(symbol.flags & 2097152)) {
                return undefined;
            }
            var links = getSymbolLinks(symbol);
            return links.typeOnlyDeclaration || undefined;
        }
        function markExportAsReferenced(node) {
            var symbol = getSymbolOfNode(node);
            var target = resolveAlias(symbol);
            if (target) {
                var markAlias = target === unknownSymbol ||
                    ((target.flags & 111551) && !isConstEnumOrConstEnumOnlyModule(target) && !getTypeOnlyAliasDeclaration(symbol));
                if (markAlias) {
                    markAliasSymbolAsReferenced(symbol);
                }
            }
        }
        function markAliasSymbolAsReferenced(symbol) {
            var links = getSymbolLinks(symbol);
            if (!links.referenced) {
                links.referenced = true;
                var node = getDeclarationOfAliasSymbol(symbol);
                if (!node)
                    return ts.Debug.fail();
                if (ts.isInternalModuleImportEqualsDeclaration(node)) {
                    var target = resolveSymbol(symbol);
                    if (target === unknownSymbol || target.flags & 111551) {
                        checkExpressionCached(node.moduleReference);
                    }
                }
            }
        }
        function markConstEnumAliasAsReferenced(symbol) {
            var links = getSymbolLinks(symbol);
            if (!links.constEnumReferenced) {
                links.constEnumReferenced = true;
            }
        }
        function getSymbolOfPartOfRightHandSideOfImportEquals(entityName, dontResolveAlias) {
            if (entityName.kind === 79 && ts.isRightSideOfQualifiedNameOrPropertyAccess(entityName)) {
                entityName = entityName.parent;
            }
            if (entityName.kind === 79 || entityName.parent.kind === 161) {
                return resolveEntityName(entityName, 1920, false, dontResolveAlias);
            }
            else {
                ts.Debug.assert(entityName.parent.kind === 265);
                return resolveEntityName(entityName, 111551 | 788968 | 1920, false, dontResolveAlias);
            }
        }
        function getFullyQualifiedName(symbol, containingLocation) {
            return symbol.parent ? getFullyQualifiedName(symbol.parent, containingLocation) + "." + symbolToString(symbol) : symbolToString(symbol, containingLocation, undefined, 16 | 4);
        }
        function getContainingQualifiedNameNode(node) {
            while (ts.isQualifiedName(node.parent)) {
                node = node.parent;
            }
            return node;
        }
        function tryGetQualifiedNameAsValue(node) {
            var left = ts.getFirstIdentifier(node);
            var symbol = resolveName(left, left.escapedText, 111551, undefined, left, true);
            if (!symbol) {
                return undefined;
            }
            while (ts.isQualifiedName(left.parent)) {
                var type = getTypeOfSymbol(symbol);
                symbol = getPropertyOfType(type, left.parent.right.escapedText);
                if (!symbol) {
                    return undefined;
                }
                left = left.parent;
            }
            return symbol;
        }
        function resolveEntityName(name, meaning, ignoreErrors, dontResolveAlias, location) {
            if (ts.nodeIsMissing(name)) {
                return undefined;
            }
            var namespaceMeaning = 1920 | (ts.isInJSFile(name) ? meaning & 111551 : 0);
            var symbol;
            if (name.kind === 79) {
                var message = meaning === namespaceMeaning || ts.nodeIsSynthesized(name) ? ts.Diagnostics.Cannot_find_namespace_0 : getCannotFindNameDiagnosticForName(ts.getFirstIdentifier(name));
                var symbolFromJSPrototype = ts.isInJSFile(name) && !ts.nodeIsSynthesized(name) ? resolveEntityNameFromAssignmentDeclaration(name, meaning) : undefined;
                symbol = getMergedSymbol(resolveName(location || name, name.escapedText, meaning, ignoreErrors || symbolFromJSPrototype ? undefined : message, name, true, false));
                if (!symbol) {
                    return getMergedSymbol(symbolFromJSPrototype);
                }
            }
            else if (name.kind === 161 || name.kind === 206) {
                var left = name.kind === 161 ? name.left : name.expression;
                var right = name.kind === 161 ? name.right : name.name;
                var namespace = resolveEntityName(left, namespaceMeaning, ignoreErrors, false, location);
                if (!namespace || ts.nodeIsMissing(right)) {
                    return undefined;
                }
                else if (namespace === unknownSymbol) {
                    return namespace;
                }
                if (namespace.valueDeclaration &&
                    ts.isInJSFile(namespace.valueDeclaration) &&
                    ts.isVariableDeclaration(namespace.valueDeclaration) &&
                    namespace.valueDeclaration.initializer &&
                    isCommonJsRequire(namespace.valueDeclaration.initializer)) {
                    var moduleName = namespace.valueDeclaration.initializer.arguments[0];
                    var moduleSym = resolveExternalModuleName(moduleName, moduleName);
                    if (moduleSym) {
                        var resolvedModuleSymbol = resolveExternalModuleSymbol(moduleSym);
                        if (resolvedModuleSymbol) {
                            namespace = resolvedModuleSymbol;
                        }
                    }
                }
                symbol = getMergedSymbol(getSymbol(getExportsOfSymbol(namespace), right.escapedText, meaning));
                if (!symbol) {
                    if (!ignoreErrors) {
                        var namespaceName = getFullyQualifiedName(namespace);
                        var declarationName = ts.declarationNameToString(right);
                        var suggestionForNonexistentModule = getSuggestedSymbolForNonexistentModule(right, namespace);
                        if (suggestionForNonexistentModule) {
                            error(right, ts.Diagnostics._0_has_no_exported_member_named_1_Did_you_mean_2, namespaceName, declarationName, symbolToString(suggestionForNonexistentModule));
                            return undefined;
                        }
                        var containingQualifiedName = ts.isQualifiedName(name) && getContainingQualifiedNameNode(name);
                        var canSuggestTypeof = globalObjectType
                            && (meaning & 788968)
                            && containingQualifiedName
                            && !ts.isTypeOfExpression(containingQualifiedName.parent)
                            && tryGetQualifiedNameAsValue(containingQualifiedName);
                        if (canSuggestTypeof) {
                            error(containingQualifiedName, ts.Diagnostics._0_refers_to_a_value_but_is_being_used_as_a_type_here_Did_you_mean_typeof_0, ts.entityNameToString(containingQualifiedName));
                            return undefined;
                        }
                        if (meaning & 1920 && ts.isQualifiedName(name.parent)) {
                            var exportedTypeSymbol = getMergedSymbol(getSymbol(getExportsOfSymbol(namespace), right.escapedText, 788968));
                            if (exportedTypeSymbol) {
                                error(name.parent.right, ts.Diagnostics.Cannot_access_0_1_because_0_is_a_type_but_not_a_namespace_Did_you_mean_to_retrieve_the_type_of_the_property_1_in_0_with_0_1, symbolToString(exportedTypeSymbol), ts.unescapeLeadingUnderscores(name.parent.right.escapedText));
                                return undefined;
                            }
                        }
                        error(right, ts.Diagnostics.Namespace_0_has_no_exported_member_1, namespaceName, declarationName);
                    }
                    return undefined;
                }
            }
            else {
                throw ts.Debug.assertNever(name, "Unknown entity name kind.");
            }
            ts.Debug.assert((ts.getCheckFlags(symbol) & 1) === 0, "Should never get an instantiated symbol here.");
            if (!ts.nodeIsSynthesized(name) && ts.isEntityName(name) && (symbol.flags & 2097152 || name.parent.kind === 271)) {
                markSymbolOfAliasDeclarationIfTypeOnly(ts.getAliasDeclarationFromName(name), symbol, undefined, true);
            }
            return (symbol.flags & meaning) || dontResolveAlias ? symbol : resolveAlias(symbol);
        }
        function resolveEntityNameFromAssignmentDeclaration(name, meaning) {
            if (isJSDocTypeReference(name.parent)) {
                var secondaryLocation = getAssignmentDeclarationLocation(name.parent);
                if (secondaryLocation) {
                    return resolveName(secondaryLocation, name.escapedText, meaning, undefined, name, true);
                }
            }
        }
        function getAssignmentDeclarationLocation(node) {
            var typeAlias = ts.findAncestor(node, function (node) { return !(ts.isJSDocNode(node) || node.flags & 8388608) ? "quit" : ts.isJSDocTypeAlias(node); });
            if (typeAlias) {
                return;
            }
            var host = ts.getJSDocHost(node);
            if (host && ts.isExpressionStatement(host) && ts.isPrototypePropertyAssignment(host.expression)) {
                var symbol = getSymbolOfNode(host.expression.left);
                if (symbol) {
                    return getDeclarationOfJSPrototypeContainer(symbol);
                }
            }
            if (host && ts.isFunctionExpression(host) && ts.isPrototypePropertyAssignment(host.parent) && ts.isExpressionStatement(host.parent.parent)) {
                var symbol = getSymbolOfNode(host.parent.left);
                if (symbol) {
                    return getDeclarationOfJSPrototypeContainer(symbol);
                }
            }
            if (host && (ts.isObjectLiteralMethod(host) || ts.isPropertyAssignment(host)) &&
                ts.isBinaryExpression(host.parent.parent) &&
                ts.getAssignmentDeclarationKind(host.parent.parent) === 6) {
                var symbol = getSymbolOfNode(host.parent.parent.left);
                if (symbol) {
                    return getDeclarationOfJSPrototypeContainer(symbol);
                }
            }
            var sig = ts.getEffectiveJSDocHost(node);
            if (sig && ts.isFunctionLike(sig)) {
                var symbol = getSymbolOfNode(sig);
                return symbol && symbol.valueDeclaration;
            }
        }
        function getDeclarationOfJSPrototypeContainer(symbol) {
            var decl = symbol.parent.valueDeclaration;
            if (!decl) {
                return undefined;
            }
            var initializer = ts.isAssignmentDeclaration(decl) ? ts.getAssignedExpandoInitializer(decl) :
                ts.hasOnlyExpressionInitializer(decl) ? ts.getDeclaredExpandoInitializer(decl) :
                    undefined;
            return initializer || decl;
        }
        function getExpandoSymbol(symbol) {
            var decl = symbol.valueDeclaration;
            if (!decl || !ts.isInJSFile(decl) || symbol.flags & 524288 || ts.getExpandoInitializer(decl, false)) {
                return undefined;
            }
            var init = ts.isVariableDeclaration(decl) ? ts.getDeclaredExpandoInitializer(decl) : ts.getAssignedExpandoInitializer(decl);
            if (init) {
                var initSymbol = getSymbolOfNode(init);
                if (initSymbol) {
                    return mergeJSSymbols(initSymbol, symbol);
                }
            }
        }
        function resolveExternalModuleName(location, moduleReferenceExpression, ignoreErrors) {
            var isClassic = ts.getEmitModuleResolutionKind(compilerOptions) === ts.ModuleResolutionKind.Classic;
            var errorMessage = isClassic ?
                ts.Diagnostics.Cannot_find_module_0_Did_you_mean_to_set_the_moduleResolution_option_to_node_or_to_add_aliases_to_the_paths_option
                : ts.Diagnostics.Cannot_find_module_0_or_its_corresponding_type_declarations;
            return resolveExternalModuleNameWorker(location, moduleReferenceExpression, ignoreErrors ? undefined : errorMessage);
        }
        function resolveExternalModuleNameWorker(location, moduleReferenceExpression, moduleNotFoundError, isForAugmentation) {
            if (isForAugmentation === void 0) { isForAugmentation = false; }
            return ts.isStringLiteralLike(moduleReferenceExpression)
                ? resolveExternalModule(location, moduleReferenceExpression.text, moduleNotFoundError, moduleReferenceExpression, isForAugmentation)
                : undefined;
        }
        function resolveExternalModule(location, moduleReference, moduleNotFoundError, errorNode, isForAugmentation) {
            var _a, _b, _c, _d, _e, _f, _g, _h;
            if (isForAugmentation === void 0) { isForAugmentation = false; }
            if (ts.startsWith(moduleReference, "@types/")) {
                var diag = ts.Diagnostics.Cannot_import_type_declaration_files_Consider_importing_0_instead_of_1;
                var withoutAtTypePrefix = ts.removePrefix(moduleReference, "@types/");
                error(errorNode, diag, withoutAtTypePrefix, moduleReference);
            }
            var ambientModule = tryFindAmbientModule(moduleReference, true);
            if (ambientModule) {
                return ambientModule;
            }
            var currentSourceFile = ts.getSourceFileOfNode(location);
            var contextSpecifier = ts.isStringLiteralLike(location)
                ? location
                : ((_a = ts.findAncestor(location, ts.isImportCall)) === null || _a === void 0 ? void 0 : _a.arguments[0]) ||
                    ((_b = ts.findAncestor(location, ts.isImportDeclaration)) === null || _b === void 0 ? void 0 : _b.moduleSpecifier) ||
                    ((_c = ts.findAncestor(location, ts.isExternalModuleImportEqualsDeclaration)) === null || _c === void 0 ? void 0 : _c.moduleReference.expression) ||
                    ((_d = ts.findAncestor(location, ts.isExportDeclaration)) === null || _d === void 0 ? void 0 : _d.moduleSpecifier) ||
                    ((_e = (ts.isModuleDeclaration(location) ? location : location.parent && ts.isModuleDeclaration(location.parent) && location.parent.name === location ? location.parent : undefined)) === null || _e === void 0 ? void 0 : _e.name) ||
                    ((_f = (ts.isLiteralImportTypeNode(location) ? location : undefined)) === null || _f === void 0 ? void 0 : _f.argument.literal);
            var mode = contextSpecifier && ts.isStringLiteralLike(contextSpecifier) ? ts.getModeForUsageLocation(currentSourceFile, contextSpecifier) : currentSourceFile.impliedNodeFormat;
            var resolvedModule = ts.getResolvedModule(currentSourceFile, moduleReference, mode);
            var resolutionDiagnostic = resolvedModule && ts.getResolutionDiagnostic(compilerOptions, resolvedModule);
            var sourceFile = resolvedModule
                && (!resolutionDiagnostic || resolutionDiagnostic === ts.Diagnostics.Module_0_was_resolved_to_1_but_jsx_is_not_set)
                && host.getSourceFile(resolvedModule.resolvedFileName);
            if (sourceFile) {
                if (resolutionDiagnostic) {
                    error(errorNode, resolutionDiagnostic, moduleReference, resolvedModule.resolvedFileName);
                }
                if (sourceFile.symbol) {
                    if (resolvedModule.isExternalLibraryImport && !ts.resolutionExtensionIsTSOrJson(resolvedModule.extension)) {
                        errorOnImplicitAnyModule(false, errorNode, resolvedModule, moduleReference);
                    }
                    if (ts.getEmitModuleResolutionKind(compilerOptions) === ts.ModuleResolutionKind.Node16 || ts.getEmitModuleResolutionKind(compilerOptions) === ts.ModuleResolutionKind.NodeNext) {
                        var isSyncImport = (currentSourceFile.impliedNodeFormat === ts.ModuleKind.CommonJS && !ts.findAncestor(location, ts.isImportCall)) || !!ts.findAncestor(location, ts.isImportEqualsDeclaration);
                        var overrideClauseHost = ts.findAncestor(location, function (l) { return ts.isImportTypeNode(l) || ts.isExportDeclaration(l) || ts.isImportDeclaration(l); });
                        var overrideClause = overrideClauseHost && ts.isImportTypeNode(overrideClauseHost) ? (_g = overrideClauseHost.assertions) === null || _g === void 0 ? void 0 : _g.assertClause : overrideClauseHost === null || overrideClauseHost === void 0 ? void 0 : overrideClauseHost.assertClause;
                        if (isSyncImport && sourceFile.impliedNodeFormat === ts.ModuleKind.ESNext && !ts.getResolutionModeOverrideForClause(overrideClause)) {
                            error(errorNode, ts.Diagnostics.Module_0_cannot_be_imported_using_this_construct_The_specifier_only_resolves_to_an_ES_module_which_cannot_be_imported_synchronously_Use_dynamic_import_instead, moduleReference);
                        }
                    }
                    return getMergedSymbol(sourceFile.symbol);
                }
                if (moduleNotFoundError) {
                    error(errorNode, ts.Diagnostics.File_0_is_not_a_module, sourceFile.fileName);
                }
                return undefined;
            }
            if (patternAmbientModules) {
                var pattern = ts.findBestPatternMatch(patternAmbientModules, function (_) { return _.pattern; }, moduleReference);
                if (pattern) {
                    var augmentation = patternAmbientModuleAugmentations && patternAmbientModuleAugmentations.get(moduleReference);
                    if (augmentation) {
                        return getMergedSymbol(augmentation);
                    }
                    return getMergedSymbol(pattern.symbol);
                }
            }
            if (resolvedModule && !ts.resolutionExtensionIsTSOrJson(resolvedModule.extension) && resolutionDiagnostic === undefined || resolutionDiagnostic === ts.Diagnostics.Could_not_find_a_declaration_file_for_module_0_1_implicitly_has_an_any_type) {
                if (isForAugmentation) {
                    var diag = ts.Diagnostics.Invalid_module_name_in_augmentation_Module_0_resolves_to_an_untyped_module_at_1_which_cannot_be_augmented;
                    error(errorNode, diag, moduleReference, resolvedModule.resolvedFileName);
                }
                else {
                    errorOnImplicitAnyModule(noImplicitAny && !!moduleNotFoundError, errorNode, resolvedModule, moduleReference);
                }
                return undefined;
            }
            if (moduleNotFoundError) {
                if (resolvedModule) {
                    var redirect = host.getProjectReferenceRedirect(resolvedModule.resolvedFileName);
                    if (redirect) {
                        error(errorNode, ts.Diagnostics.Output_file_0_has_not_been_built_from_source_file_1, redirect, resolvedModule.resolvedFileName);
                        return undefined;
                    }
                }
                if (resolutionDiagnostic) {
                    error(errorNode, resolutionDiagnostic, moduleReference, resolvedModule.resolvedFileName);
                }
                else {
                    var tsExtension = ts.tryExtractTSExtension(moduleReference);
                    var isExtensionlessRelativePathImport = ts.pathIsRelative(moduleReference) && !ts.hasExtension(moduleReference);
                    var moduleResolutionKind = ts.getEmitModuleResolutionKind(compilerOptions);
                    var resolutionIsNode16OrNext = moduleResolutionKind === ts.ModuleResolutionKind.Node16 ||
                        moduleResolutionKind === ts.ModuleResolutionKind.NodeNext;
                    if (tsExtension) {
                        var diag = ts.Diagnostics.An_import_path_cannot_end_with_a_0_extension_Consider_importing_1_instead;
                        var importSourceWithoutExtension = ts.removeExtension(moduleReference, tsExtension);
                        var replacedImportSource = importSourceWithoutExtension;
                        if (moduleKind >= ts.ModuleKind.ES2015) {
                            replacedImportSource += tsExtension === ".mts" ? ".mjs" : tsExtension === ".cts" ? ".cjs" : ".js";
                        }
                        error(errorNode, diag, tsExtension, replacedImportSource);
                    }
                    else if (!compilerOptions.resolveJsonModule &&
                        ts.fileExtensionIs(moduleReference, ".json") &&
                        ts.getEmitModuleResolutionKind(compilerOptions) !== ts.ModuleResolutionKind.Classic &&
                        ts.hasJsonModuleEmitEnabled(compilerOptions)) {
                        error(errorNode, ts.Diagnostics.Cannot_find_module_0_Consider_using_resolveJsonModule_to_import_module_with_json_extension, moduleReference);
                    }
                    else if (mode === ts.ModuleKind.ESNext && resolutionIsNode16OrNext && isExtensionlessRelativePathImport) {
                        var absoluteRef_1 = ts.getNormalizedAbsolutePath(moduleReference, ts.getDirectoryPath(currentSourceFile.path));
                        var suggestedExt = (_h = suggestedExtensions.find(function (_a) {
                            var actualExt = _a[0], _importExt = _a[1];
                            return host.fileExists(absoluteRef_1 + actualExt);
                        })) === null || _h === void 0 ? void 0 : _h[1];
                        if (suggestedExt) {
                            error(errorNode, ts.Diagnostics.Relative_import_paths_need_explicit_file_extensions_in_EcmaScript_imports_when_moduleResolution_is_node16_or_nodenext_Did_you_mean_0, moduleReference + suggestedExt);
                        }
                        else {
                            error(errorNode, ts.Diagnostics.Relative_import_paths_need_explicit_file_extensions_in_EcmaScript_imports_when_moduleResolution_is_node16_or_nodenext_Consider_adding_an_extension_to_the_import_path);
                        }
                    }
                    else {
                        error(errorNode, moduleNotFoundError, moduleReference);
                    }
                }
            }
            return undefined;
        }
        function errorOnImplicitAnyModule(isError, errorNode, _a, moduleReference) {
            var packageId = _a.packageId, resolvedFileName = _a.resolvedFileName;
            var errorInfo = !ts.isExternalModuleNameRelative(moduleReference) && packageId
                ? typesPackageExists(packageId.name)
                    ? ts.chainDiagnosticMessages(undefined, ts.Diagnostics.If_the_0_package_actually_exposes_this_module_consider_sending_a_pull_request_to_amend_https_Colon_Slash_Slashgithub_com_SlashDefinitelyTyped_SlashDefinitelyTyped_Slashtree_Slashmaster_Slashtypes_Slash_1, packageId.name, ts.mangleScopedPackageName(packageId.name))
                    : packageBundlesTypes(packageId.name)
                        ? ts.chainDiagnosticMessages(undefined, ts.Diagnostics.If_the_0_package_actually_exposes_this_module_try_adding_a_new_declaration_d_ts_file_containing_declare_module_1, packageId.name, moduleReference)
                        : ts.chainDiagnosticMessages(undefined, ts.Diagnostics.Try_npm_i_save_dev_types_Slash_1_if_it_exists_or_add_a_new_declaration_d_ts_file_containing_declare_module_0, moduleReference, ts.mangleScopedPackageName(packageId.name))
                : undefined;
            errorOrSuggestion(isError, errorNode, ts.chainDiagnosticMessages(errorInfo, ts.Diagnostics.Could_not_find_a_declaration_file_for_module_0_1_implicitly_has_an_any_type, moduleReference, resolvedFileName));
        }
        function typesPackageExists(packageName) {
            return getPackagesMap().has(ts.getTypesPackageName(packageName));
        }
        function packageBundlesTypes(packageName) {
            return !!getPackagesMap().get(packageName);
        }
        function resolveExternalModuleSymbol(moduleSymbol, dontResolveAlias) {
            if (moduleSymbol === null || moduleSymbol === void 0 ? void 0 : moduleSymbol.exports) {
                var exportEquals = resolveSymbol(moduleSymbol.exports.get("export="), dontResolveAlias);
                var exported = getCommonJsExportEquals(getMergedSymbol(exportEquals), getMergedSymbol(moduleSymbol));
                return getMergedSymbol(exported) || moduleSymbol;
            }
            return undefined;
        }
        function getCommonJsExportEquals(exported, moduleSymbol) {
            if (!exported || exported === unknownSymbol || exported === moduleSymbol || moduleSymbol.exports.size === 1 || exported.flags & 2097152) {
                return exported;
            }
            var links = getSymbolLinks(exported);
            if (links.cjsExportMerged) {
                return links.cjsExportMerged;
            }
            var merged = exported.flags & 33554432 ? exported : cloneSymbol(exported);
            merged.flags = merged.flags | 512;
            if (merged.exports === undefined) {
                merged.exports = ts.createSymbolTable();
            }
            moduleSymbol.exports.forEach(function (s, name) {
                if (name === "export=")
                    return;
                merged.exports.set(name, merged.exports.has(name) ? mergeSymbol(merged.exports.get(name), s) : s);
            });
            getSymbolLinks(merged).cjsExportMerged = merged;
            return links.cjsExportMerged = merged;
        }
        function resolveESModuleSymbol(moduleSymbol, referencingLocation, dontResolveAlias, suppressInteropError) {
            var _a;
            var symbol = resolveExternalModuleSymbol(moduleSymbol, dontResolveAlias);
            if (!dontResolveAlias && symbol) {
                if (!suppressInteropError && !(symbol.flags & (1536 | 3)) && !ts.getDeclarationOfKind(symbol, 305)) {
                    var compilerOptionName = moduleKind >= ts.ModuleKind.ES2015
                        ? "allowSyntheticDefaultImports"
                        : "esModuleInterop";
                    error(referencingLocation, ts.Diagnostics.This_module_can_only_be_referenced_with_ECMAScript_imports_Slashexports_by_turning_on_the_0_flag_and_referencing_its_default_export, compilerOptionName);
                    return symbol;
                }
                var referenceParent = referencingLocation.parent;
                if ((ts.isImportDeclaration(referenceParent) && ts.getNamespaceDeclarationNode(referenceParent)) ||
                    ts.isImportCall(referenceParent)) {
                    var reference = ts.isImportCall(referenceParent) ? referenceParent.arguments[0] : referenceParent.moduleSpecifier;
                    var type = getTypeOfSymbol(symbol);
                    var defaultOnlyType = getTypeWithSyntheticDefaultOnly(type, symbol, moduleSymbol, reference);
                    if (defaultOnlyType) {
                        return cloneTypeAsModuleType(symbol, defaultOnlyType, referenceParent);
                    }
                    var targetFile = (_a = moduleSymbol === null || moduleSymbol === void 0 ? void 0 : moduleSymbol.declarations) === null || _a === void 0 ? void 0 : _a.find(ts.isSourceFile);
                    var isEsmCjsRef = targetFile && isESMFormatImportImportingCommonjsFormatFile(getUsageModeForExpression(reference), targetFile.impliedNodeFormat);
                    if (ts.getESModuleInterop(compilerOptions) || isEsmCjsRef) {
                        var sigs = getSignaturesOfStructuredType(type, 0);
                        if (!sigs || !sigs.length) {
                            sigs = getSignaturesOfStructuredType(type, 1);
                        }
                        if ((sigs && sigs.length) ||
                            getPropertyOfType(type, "default", true) ||
                            isEsmCjsRef) {
                            var moduleType = getTypeWithSyntheticDefaultImportType(type, symbol, moduleSymbol, reference);
                            return cloneTypeAsModuleType(symbol, moduleType, referenceParent);
                        }
                    }
                }
            }
            return symbol;
        }
        function cloneTypeAsModuleType(symbol, moduleType, referenceParent) {
            var result = createSymbol(symbol.flags, symbol.escapedName);
            result.declarations = symbol.declarations ? symbol.declarations.slice() : [];
            result.parent = symbol.parent;
            result.target = symbol;
            result.originatingImport = referenceParent;
            if (symbol.valueDeclaration)
                result.valueDeclaration = symbol.valueDeclaration;
            if (symbol.constEnumOnlyModule)
                result.constEnumOnlyModule = true;
            if (symbol.members)
                result.members = new ts.Map(symbol.members);
            if (symbol.exports)
                result.exports = new ts.Map(symbol.exports);
            var resolvedModuleType = resolveStructuredTypeMembers(moduleType);
            result.type = createAnonymousType(result, resolvedModuleType.members, ts.emptyArray, ts.emptyArray, resolvedModuleType.indexInfos);
            return result;
        }
        function hasExportAssignmentSymbol(moduleSymbol) {
            return moduleSymbol.exports.get("export=") !== undefined;
        }
        function getExportsOfModuleAsArray(moduleSymbol) {
            return symbolsToArray(getExportsOfModule(moduleSymbol));
        }
        function getExportsAndPropertiesOfModule(moduleSymbol) {
            var exports = getExportsOfModuleAsArray(moduleSymbol);
            var exportEquals = resolveExternalModuleSymbol(moduleSymbol);
            if (exportEquals !== moduleSymbol) {
                var type = getTypeOfSymbol(exportEquals);
                if (shouldTreatPropertiesOfExternalModuleAsExports(type)) {
                    ts.addRange(exports, getPropertiesOfType(type));
                }
            }
            return exports;
        }
        function forEachExportAndPropertyOfModule(moduleSymbol, cb) {
            var exports = getExportsOfModule(moduleSymbol);
            exports.forEach(function (symbol, key) {
                if (!isReservedMemberName(key)) {
                    cb(symbol, key);
                }
            });
            var exportEquals = resolveExternalModuleSymbol(moduleSymbol);
            if (exportEquals !== moduleSymbol) {
                var type = getTypeOfSymbol(exportEquals);
                if (shouldTreatPropertiesOfExternalModuleAsExports(type)) {
                    forEachPropertyOfType(type, function (symbol, escapedName) {
                        cb(symbol, escapedName);
                    });
                }
            }
        }
        function tryGetMemberInModuleExports(memberName, moduleSymbol) {
            var symbolTable = getExportsOfModule(moduleSymbol);
            if (symbolTable) {
                return symbolTable.get(memberName);
            }
        }
        function tryGetMemberInModuleExportsAndProperties(memberName, moduleSymbol) {
            var symbol = tryGetMemberInModuleExports(memberName, moduleSymbol);
            if (symbol) {
                return symbol;
            }
            var exportEquals = resolveExternalModuleSymbol(moduleSymbol);
            if (exportEquals === moduleSymbol) {
                return undefined;
            }
            var type = getTypeOfSymbol(exportEquals);
            return shouldTreatPropertiesOfExternalModuleAsExports(type) ? getPropertyOfType(type, memberName) : undefined;
        }
        function shouldTreatPropertiesOfExternalModuleAsExports(resolvedExternalModuleType) {
            return !(resolvedExternalModuleType.flags & 131068 ||
                ts.getObjectFlags(resolvedExternalModuleType) & 1 ||
                isArrayType(resolvedExternalModuleType) ||
                isTupleType(resolvedExternalModuleType));
        }
        function getExportsOfSymbol(symbol) {
            return symbol.flags & 6256 ? getResolvedMembersOrExportsOfSymbol(symbol, "resolvedExports") :
                symbol.flags & 1536 ? getExportsOfModule(symbol) :
                    symbol.exports || emptySymbols;
        }
        function getExportsOfModule(moduleSymbol) {
            var links = getSymbolLinks(moduleSymbol);
            return links.resolvedExports || (links.resolvedExports = getExportsOfModuleWorker(moduleSymbol));
        }
        function extendExportSymbols(target, source, lookupTable, exportNode) {
            if (!source)
                return;
            source.forEach(function (sourceSymbol, id) {
                if (id === "default")
                    return;
                var targetSymbol = target.get(id);
                if (!targetSymbol) {
                    target.set(id, sourceSymbol);
                    if (lookupTable && exportNode) {
                        lookupTable.set(id, {
                            specifierText: ts.getTextOfNode(exportNode.moduleSpecifier)
                        });
                    }
                }
                else if (lookupTable && exportNode && targetSymbol && resolveSymbol(targetSymbol) !== resolveSymbol(sourceSymbol)) {
                    var collisionTracker = lookupTable.get(id);
                    if (!collisionTracker.exportsWithDuplicate) {
                        collisionTracker.exportsWithDuplicate = [exportNode];
                    }
                    else {
                        collisionTracker.exportsWithDuplicate.push(exportNode);
                    }
                }
            });
        }
        function getExportsOfModuleWorker(moduleSymbol) {
            var visitedSymbols = [];
            moduleSymbol = resolveExternalModuleSymbol(moduleSymbol);
            return visit(moduleSymbol) || emptySymbols;
            function visit(symbol) {
                if (!(symbol && symbol.exports && ts.pushIfUnique(visitedSymbols, symbol))) {
                    return;
                }
                var symbols = new ts.Map(symbol.exports);
                var exportStars = symbol.exports.get("__export");
                if (exportStars) {
                    var nestedSymbols = ts.createSymbolTable();
                    var lookupTable_1 = new ts.Map();
                    if (exportStars.declarations) {
                        for (var _i = 0, _a = exportStars.declarations; _i < _a.length; _i++) {
                            var node = _a[_i];
                            var resolvedModule = resolveExternalModuleName(node, node.moduleSpecifier);
                            var exportedSymbols = visit(resolvedModule);
                            extendExportSymbols(nestedSymbols, exportedSymbols, lookupTable_1, node);
                        }
                    }
                    lookupTable_1.forEach(function (_a, id) {
                        var exportsWithDuplicate = _a.exportsWithDuplicate;
                        if (id === "export=" || !(exportsWithDuplicate && exportsWithDuplicate.length) || symbols.has(id)) {
                            return;
                        }
                        for (var _i = 0, exportsWithDuplicate_1 = exportsWithDuplicate; _i < exportsWithDuplicate_1.length; _i++) {
                            var node = exportsWithDuplicate_1[_i];
                            diagnostics.add(ts.createDiagnosticForNode(node, ts.Diagnostics.Module_0_has_already_exported_a_member_named_1_Consider_explicitly_re_exporting_to_resolve_the_ambiguity, lookupTable_1.get(id).specifierText, ts.unescapeLeadingUnderscores(id)));
                        }
                    });
                    extendExportSymbols(symbols, nestedSymbols);
                }
                return symbols;
            }
        }
        function getMergedSymbol(symbol) {
            var merged;
            return symbol && symbol.mergeId && (merged = mergedSymbols[symbol.mergeId]) ? merged : symbol;
        }
        function getSymbolOfNode(node) {
            return getMergedSymbol(node.symbol && getLateBoundSymbol(node.symbol));
        }
        function getParentOfSymbol(symbol) {
            return getMergedSymbol(symbol.parent && getLateBoundSymbol(symbol.parent));
        }
        function getAlternativeContainingModules(symbol, enclosingDeclaration) {
            var containingFile = ts.getSourceFileOfNode(enclosingDeclaration);
            var id = getNodeId(containingFile);
            var links = getSymbolLinks(symbol);
            var results;
            if (links.extendedContainersByFile && (results = links.extendedContainersByFile.get(id))) {
                return results;
            }
            if (containingFile && containingFile.imports) {
                for (var _i = 0, _a = containingFile.imports; _i < _a.length; _i++) {
                    var importRef = _a[_i];
                    if (ts.nodeIsSynthesized(importRef))
                        continue;
                    var resolvedModule = resolveExternalModuleName(enclosingDeclaration, importRef, true);
                    if (!resolvedModule)
                        continue;
                    var ref = getAliasForSymbolInContainer(resolvedModule, symbol);
                    if (!ref)
                        continue;
                    results = ts.append(results, resolvedModule);
                }
                if (ts.length(results)) {
                    (links.extendedContainersByFile || (links.extendedContainersByFile = new ts.Map())).set(id, results);
                    return results;
                }
            }
            if (links.extendedContainers) {
                return links.extendedContainers;
            }
            var otherFiles = host.getSourceFiles();
            for (var _b = 0, otherFiles_1 = otherFiles; _b < otherFiles_1.length; _b++) {
                var file = otherFiles_1[_b];
                if (!ts.isExternalModule(file))
                    continue;
                var sym = getSymbolOfNode(file);
                var ref = getAliasForSymbolInContainer(sym, symbol);
                if (!ref)
                    continue;
                results = ts.append(results, sym);
            }
            return links.extendedContainers = results || ts.emptyArray;
        }
        function getContainersOfSymbol(symbol, enclosingDeclaration, meaning) {
            var container = getParentOfSymbol(symbol);
            if (container && !(symbol.flags & 262144)) {
                var additionalContainers = ts.mapDefined(container.declarations, fileSymbolIfFileSymbolExportEqualsContainer);
                var reexportContainers = enclosingDeclaration && getAlternativeContainingModules(symbol, enclosingDeclaration);
                var objectLiteralContainer = getVariableDeclarationOfObjectLiteral(container, meaning);
                if (enclosingDeclaration &&
                    container.flags & getQualifiedLeftMeaning(meaning) &&
                    getAccessibleSymbolChain(container, enclosingDeclaration, 1920, false)) {
                    return ts.append(ts.concatenate(ts.concatenate([container], additionalContainers), reexportContainers), objectLiteralContainer);
                }
                var firstVariableMatch = !(container.flags & getQualifiedLeftMeaning(meaning))
                    && container.flags & 788968
                    && getDeclaredTypeOfSymbol(container).flags & 524288
                    && meaning === 111551
                    ? forEachSymbolTableInScope(enclosingDeclaration, function (t) {
                        return ts.forEachEntry(t, function (s) {
                            if (s.flags & getQualifiedLeftMeaning(meaning) && getTypeOfSymbol(s) === getDeclaredTypeOfSymbol(container)) {
                                return s;
                            }
                        });
                    }) : undefined;
                var res = firstVariableMatch ? __spreadArray(__spreadArray([firstVariableMatch], additionalContainers, true), [container], false) : __spreadArray(__spreadArray([], additionalContainers, true), [container], false);
                res = ts.append(res, objectLiteralContainer);
                res = ts.addRange(res, reexportContainers);
                return res;
            }
            var candidates = ts.mapDefined(symbol.declarations, function (d) {
                if (!ts.isAmbientModule(d) && d.parent) {
                    if (hasNonGlobalAugmentationExternalModuleSymbol(d.parent)) {
                        return getSymbolOfNode(d.parent);
                    }
                    if (ts.isModuleBlock(d.parent) && d.parent.parent && resolveExternalModuleSymbol(getSymbolOfNode(d.parent.parent)) === symbol) {
                        return getSymbolOfNode(d.parent.parent);
                    }
                }
                if (ts.isClassExpression(d) && ts.isBinaryExpression(d.parent) && d.parent.operatorToken.kind === 63 && ts.isAccessExpression(d.parent.left) && ts.isEntityNameExpression(d.parent.left.expression)) {
                    if (ts.isModuleExportsAccessExpression(d.parent.left) || ts.isExportsIdentifier(d.parent.left.expression)) {
                        return getSymbolOfNode(ts.getSourceFileOfNode(d));
                    }
                    checkExpressionCached(d.parent.left.expression);
                    return getNodeLinks(d.parent.left.expression).resolvedSymbol;
                }
            });
            if (!ts.length(candidates)) {
                return undefined;
            }
            return ts.mapDefined(candidates, function (candidate) { return getAliasForSymbolInContainer(candidate, symbol) ? candidate : undefined; });
            function fileSymbolIfFileSymbolExportEqualsContainer(d) {
                return container && getFileSymbolIfFileSymbolExportEqualsContainer(d, container);
            }
        }
        function getVariableDeclarationOfObjectLiteral(symbol, meaning) {
            var firstDecl = !!ts.length(symbol.declarations) && ts.first(symbol.declarations);
            if (meaning & 111551 && firstDecl && firstDecl.parent && ts.isVariableDeclaration(firstDecl.parent)) {
                if (ts.isObjectLiteralExpression(firstDecl) && firstDecl === firstDecl.parent.initializer || ts.isTypeLiteralNode(firstDecl) && firstDecl === firstDecl.parent.type) {
                    return getSymbolOfNode(firstDecl.parent);
                }
            }
        }
        function getFileSymbolIfFileSymbolExportEqualsContainer(d, container) {
            var fileSymbol = getExternalModuleContainer(d);
            var exported = fileSymbol && fileSymbol.exports && fileSymbol.exports.get("export=");
            return exported && getSymbolIfSameReference(exported, container) ? fileSymbol : undefined;
        }
        function getAliasForSymbolInContainer(container, symbol) {
            if (container === getParentOfSymbol(symbol)) {
                return symbol;
            }
            var exportEquals = container.exports && container.exports.get("export=");
            if (exportEquals && getSymbolIfSameReference(exportEquals, symbol)) {
                return container;
            }
            var exports = getExportsOfSymbol(container);
            var quick = exports.get(symbol.escapedName);
            if (quick && getSymbolIfSameReference(quick, symbol)) {
                return quick;
            }
            return ts.forEachEntry(exports, function (exported) {
                if (getSymbolIfSameReference(exported, symbol)) {
                    return exported;
                }
            });
        }
        function getSymbolIfSameReference(s1, s2) {
            if (getMergedSymbol(resolveSymbol(getMergedSymbol(s1))) === getMergedSymbol(resolveSymbol(getMergedSymbol(s2)))) {
                return s1;
            }
        }
        function getExportSymbolOfValueSymbolIfExported(symbol) {
            return getMergedSymbol(symbol && (symbol.flags & 1048576) !== 0 && symbol.exportSymbol || symbol);
        }
        function symbolIsValue(symbol) {
            return !!(symbol.flags & 111551 || symbol.flags & 2097152 && resolveAlias(symbol).flags & 111551 && !getTypeOnlyAliasDeclaration(symbol));
        }
        function findConstructorDeclaration(node) {
            var members = node.members;
            for (var _i = 0, members_3 = members; _i < members_3.length; _i++) {
                var member = members_3[_i];
                if (member.kind === 171 && ts.nodeIsPresent(member.body)) {
                    return member;
                }
            }
        }
        function createType(flags) {
            var result = new Type(checker, flags);
            typeCount++;
            result.id = typeCount;
            ts.tracing === null || ts.tracing === void 0 ? void 0 : ts.tracing.recordType(result);
            return result;
        }
        function createOriginType(flags) {
            return new Type(checker, flags);
        }
        function createIntrinsicType(kind, intrinsicName, objectFlags) {
            if (objectFlags === void 0) { objectFlags = 0; }
            var type = createType(kind);
            type.intrinsicName = intrinsicName;
            type.objectFlags = objectFlags;
            return type;
        }
        function createObjectType(objectFlags, symbol) {
            var type = createType(524288);
            type.objectFlags = objectFlags;
            type.symbol = symbol;
            type.members = undefined;
            type.properties = undefined;
            type.callSignatures = undefined;
            type.constructSignatures = undefined;
            type.indexInfos = undefined;
            return type;
        }
        function createTypeofType() {
            return getUnionType(ts.arrayFrom(typeofEQFacts.keys(), getStringLiteralType));
        }
        function createTypeParameter(symbol) {
            var type = createType(262144);
            if (symbol)
                type.symbol = symbol;
            return type;
        }
        function isReservedMemberName(name) {
            return name.charCodeAt(0) === 95 &&
                name.charCodeAt(1) === 95 &&
                name.charCodeAt(2) !== 95 &&
                name.charCodeAt(2) !== 64 &&
                name.charCodeAt(2) !== 35;
        }
        function getNamedMembers(members) {
            var result;
            members.forEach(function (symbol, id) {
                if (isNamedMember(symbol, id)) {
                    (result || (result = [])).push(symbol);
                }
            });
            return result || ts.emptyArray;
        }
        function isNamedMember(member, escapedName) {
            return !isReservedMemberName(escapedName) && symbolIsValue(member);
        }
        function getNamedOrIndexSignatureMembers(members) {
            var result = getNamedMembers(members);
            var index = getIndexSymbolFromSymbolTable(members);
            return index ? ts.concatenate(result, [index]) : result;
        }
        function setStructuredTypeMembers(type, members, callSignatures, constructSignatures, indexInfos) {
            var resolved = type;
            resolved.members = members;
            resolved.properties = ts.emptyArray;
            resolved.callSignatures = callSignatures;
            resolved.constructSignatures = constructSignatures;
            resolved.indexInfos = indexInfos;
            if (members !== emptySymbols)
                resolved.properties = getNamedMembers(members);
            return resolved;
        }
        function createAnonymousType(symbol, members, callSignatures, constructSignatures, indexInfos) {
            return setStructuredTypeMembers(createObjectType(16, symbol), members, callSignatures, constructSignatures, indexInfos);
        }
        function getResolvedTypeWithoutAbstractConstructSignatures(type) {
            if (type.constructSignatures.length === 0)
                return type;
            if (type.objectTypeWithoutAbstractConstructSignatures)
                return type.objectTypeWithoutAbstractConstructSignatures;
            var constructSignatures = ts.filter(type.constructSignatures, function (signature) { return !(signature.flags & 4); });
            if (type.constructSignatures === constructSignatures)
                return type;
            var typeCopy = createAnonymousType(type.symbol, type.members, type.callSignatures, ts.some(constructSignatures) ? constructSignatures : ts.emptyArray, type.indexInfos);
            type.objectTypeWithoutAbstractConstructSignatures = typeCopy;
            typeCopy.objectTypeWithoutAbstractConstructSignatures = typeCopy;
            return typeCopy;
        }
        function forEachSymbolTableInScope(enclosingDeclaration, callback) {
            var result;
            var _loop_8 = function (location) {
                if (location.locals && !isGlobalSourceFile(location)) {
                    if (result = callback(location.locals, undefined, true, location)) {
                        return { value: result };
                    }
                }
                switch (location.kind) {
                    case 305:
                        if (!ts.isExternalOrCommonJsModule(location)) {
                            break;
                        }
                    case 261:
                        var sym = getSymbolOfNode(location);
                        if (result = callback((sym === null || sym === void 0 ? void 0 : sym.exports) || emptySymbols, undefined, true, location)) {
                            return { value: result };
                        }
                        break;
                    case 257:
                    case 226:
                    case 258:
                        var table_1;
                        (getSymbolOfNode(location).members || emptySymbols).forEach(function (memberSymbol, key) {
                            if (memberSymbol.flags & (788968 & ~67108864)) {
                                (table_1 || (table_1 = ts.createSymbolTable())).set(key, memberSymbol);
                            }
                        });
                        if (table_1 && (result = callback(table_1, undefined, false, location))) {
                            return { value: result };
                        }
                        break;
                }
            };
            for (var location = enclosingDeclaration; location; location = location.parent) {
                var state_2 = _loop_8(location);
                if (typeof state_2 === "object")
                    return state_2.value;
            }
            return callback(globals, undefined, true);
        }
        function getQualifiedLeftMeaning(rightMeaning) {
            return rightMeaning === 111551 ? 111551 : 1920;
        }
        function getAccessibleSymbolChain(symbol, enclosingDeclaration, meaning, useOnlyExternalAliasing, visitedSymbolTablesMap) {
            if (visitedSymbolTablesMap === void 0) { visitedSymbolTablesMap = new ts.Map(); }
            if (!(symbol && !isPropertyOrMethodDeclarationSymbol(symbol))) {
                return undefined;
            }
            var links = getSymbolLinks(symbol);
            var cache = (links.accessibleChainCache || (links.accessibleChainCache = new ts.Map()));
            var firstRelevantLocation = forEachSymbolTableInScope(enclosingDeclaration, function (_, __, ___, node) { return node; });
            var key = "".concat(useOnlyExternalAliasing ? 0 : 1, "|").concat(firstRelevantLocation && getNodeId(firstRelevantLocation), "|").concat(meaning);
            if (cache.has(key)) {
                return cache.get(key);
            }
            var id = getSymbolId(symbol);
            var visitedSymbolTables = visitedSymbolTablesMap.get(id);
            if (!visitedSymbolTables) {
                visitedSymbolTablesMap.set(id, visitedSymbolTables = []);
            }
            var result = forEachSymbolTableInScope(enclosingDeclaration, getAccessibleSymbolChainFromSymbolTable);
            cache.set(key, result);
            return result;
            function getAccessibleSymbolChainFromSymbolTable(symbols, ignoreQualification, isLocalNameLookup) {
                if (!ts.pushIfUnique(visitedSymbolTables, symbols)) {
                    return undefined;
                }
                var result = trySymbolTable(symbols, ignoreQualification, isLocalNameLookup);
                visitedSymbolTables.pop();
                return result;
            }
            function canQualifySymbol(symbolFromSymbolTable, meaning) {
                return !needsQualification(symbolFromSymbolTable, enclosingDeclaration, meaning) ||
                    !!getAccessibleSymbolChain(symbolFromSymbolTable.parent, enclosingDeclaration, getQualifiedLeftMeaning(meaning), useOnlyExternalAliasing, visitedSymbolTablesMap);
            }
            function isAccessible(symbolFromSymbolTable, resolvedAliasSymbol, ignoreQualification) {
                return (symbol === (resolvedAliasSymbol || symbolFromSymbolTable) || getMergedSymbol(symbol) === getMergedSymbol(resolvedAliasSymbol || symbolFromSymbolTable)) &&
                    !ts.some(symbolFromSymbolTable.declarations, hasNonGlobalAugmentationExternalModuleSymbol) &&
                    (ignoreQualification || canQualifySymbol(getMergedSymbol(symbolFromSymbolTable), meaning));
            }
            function trySymbolTable(symbols, ignoreQualification, isLocalNameLookup) {
                if (isAccessible(symbols.get(symbol.escapedName), undefined, ignoreQualification)) {
                    return [symbol];
                }
                var result = ts.forEachEntry(symbols, function (symbolFromSymbolTable) {
                    if (symbolFromSymbolTable.flags & 2097152
                        && symbolFromSymbolTable.escapedName !== "export="
                        && symbolFromSymbolTable.escapedName !== "default"
                        && !(ts.isUMDExportSymbol(symbolFromSymbolTable) && enclosingDeclaration && ts.isExternalModule(ts.getSourceFileOfNode(enclosingDeclaration)))
                        && (!useOnlyExternalAliasing || ts.some(symbolFromSymbolTable.declarations, ts.isExternalModuleImportEqualsDeclaration))
                        && (isLocalNameLookup ? !ts.some(symbolFromSymbolTable.declarations, ts.isNamespaceReexportDeclaration) : true)
                        && (ignoreQualification || !ts.getDeclarationOfKind(symbolFromSymbolTable, 275))) {
                        var resolvedImportedSymbol = resolveAlias(symbolFromSymbolTable);
                        var candidate = getCandidateListForSymbol(symbolFromSymbolTable, resolvedImportedSymbol, ignoreQualification);
                        if (candidate) {
                            return candidate;
                        }
                    }
                    if (symbolFromSymbolTable.escapedName === symbol.escapedName && symbolFromSymbolTable.exportSymbol) {
                        if (isAccessible(getMergedSymbol(symbolFromSymbolTable.exportSymbol), undefined, ignoreQualification)) {
                            return [symbol];
                        }
                    }
                });
                return result || (symbols === globals ? getCandidateListForSymbol(globalThisSymbol, globalThisSymbol, ignoreQualification) : undefined);
            }
            function getCandidateListForSymbol(symbolFromSymbolTable, resolvedImportedSymbol, ignoreQualification) {
                if (isAccessible(symbolFromSymbolTable, resolvedImportedSymbol, ignoreQualification)) {
                    return [symbolFromSymbolTable];
                }
                var candidateTable = getExportsOfSymbol(resolvedImportedSymbol);
                var accessibleSymbolsFromExports = candidateTable && getAccessibleSymbolChainFromSymbolTable(candidateTable, true);
                if (accessibleSymbolsFromExports && canQualifySymbol(symbolFromSymbolTable, getQualifiedLeftMeaning(meaning))) {
                    return [symbolFromSymbolTable].concat(accessibleSymbolsFromExports);
                }
            }
        }
        function needsQualification(symbol, enclosingDeclaration, meaning) {
            var qualify = false;
            forEachSymbolTableInScope(enclosingDeclaration, function (symbolTable) {
                var symbolFromSymbolTable = getMergedSymbol(symbolTable.get(symbol.escapedName));
                if (!symbolFromSymbolTable) {
                    return false;
                }
                if (symbolFromSymbolTable === symbol) {
                    return true;
                }
                symbolFromSymbolTable = (symbolFromSymbolTable.flags & 2097152 && !ts.getDeclarationOfKind(symbolFromSymbolTable, 275)) ? resolveAlias(symbolFromSymbolTable) : symbolFromSymbolTable;
                if (symbolFromSymbolTable.flags & meaning) {
                    qualify = true;
                    return true;
                }
                return false;
            });
            return qualify;
        }
        function isPropertyOrMethodDeclarationSymbol(symbol) {
            if (symbol.declarations && symbol.declarations.length) {
                for (var _i = 0, _a = symbol.declarations; _i < _a.length; _i++) {
                    var declaration = _a[_i];
                    switch (declaration.kind) {
                        case 167:
                        case 169:
                        case 172:
                        case 173:
                            continue;
                        default:
                            return false;
                    }
                }
                return true;
            }
            return false;
        }
        function isTypeSymbolAccessible(typeSymbol, enclosingDeclaration) {
            var access = isSymbolAccessibleWorker(typeSymbol, enclosingDeclaration, 788968, false, true);
            return access.accessibility === 0;
        }
        function isValueSymbolAccessible(typeSymbol, enclosingDeclaration) {
            var access = isSymbolAccessibleWorker(typeSymbol, enclosingDeclaration, 111551, false, true);
            return access.accessibility === 0;
        }
        function isSymbolAccessibleByFlags(typeSymbol, enclosingDeclaration, flags) {
            var access = isSymbolAccessibleWorker(typeSymbol, enclosingDeclaration, flags, false, false);
            return access.accessibility === 0;
        }
        function isAnySymbolAccessible(symbols, enclosingDeclaration, initialSymbol, meaning, shouldComputeAliasesToMakeVisible, allowModules) {
            if (!ts.length(symbols))
                return;
            var hadAccessibleChain;
            var earlyModuleBail = false;
            for (var _i = 0, _a = symbols; _i < _a.length; _i++) {
                var symbol = _a[_i];
                var accessibleSymbolChain = getAccessibleSymbolChain(symbol, enclosingDeclaration, meaning, false);
                if (accessibleSymbolChain) {
                    hadAccessibleChain = symbol;
                    var hasAccessibleDeclarations = hasVisibleDeclarations(accessibleSymbolChain[0], shouldComputeAliasesToMakeVisible);
                    if (hasAccessibleDeclarations) {
                        return hasAccessibleDeclarations;
                    }
                }
                if (allowModules) {
                    if (ts.some(symbol.declarations, hasNonGlobalAugmentationExternalModuleSymbol)) {
                        if (shouldComputeAliasesToMakeVisible) {
                            earlyModuleBail = true;
                            continue;
                        }
                        return {
                            accessibility: 0
                        };
                    }
                }
                var containers = getContainersOfSymbol(symbol, enclosingDeclaration, meaning);
                var parentResult = isAnySymbolAccessible(containers, enclosingDeclaration, initialSymbol, initialSymbol === symbol ? getQualifiedLeftMeaning(meaning) : meaning, shouldComputeAliasesToMakeVisible, allowModules);
                if (parentResult) {
                    return parentResult;
                }
            }
            if (earlyModuleBail) {
                return {
                    accessibility: 0
                };
            }
            if (hadAccessibleChain) {
                return {
                    accessibility: 1,
                    errorSymbolName: symbolToString(initialSymbol, enclosingDeclaration, meaning),
                    errorModuleName: hadAccessibleChain !== initialSymbol ? symbolToString(hadAccessibleChain, enclosingDeclaration, 1920) : undefined,
                };
            }
        }
        function isSymbolAccessible(symbol, enclosingDeclaration, meaning, shouldComputeAliasesToMakeVisible) {
            return isSymbolAccessibleWorker(symbol, enclosingDeclaration, meaning, shouldComputeAliasesToMakeVisible, true);
        }
        function isSymbolAccessibleWorker(symbol, enclosingDeclaration, meaning, shouldComputeAliasesToMakeVisible, allowModules) {
            if (symbol && enclosingDeclaration) {
                var result = isAnySymbolAccessible([symbol], enclosingDeclaration, symbol, meaning, shouldComputeAliasesToMakeVisible, allowModules);
                if (result) {
                    return result;
                }
                var symbolExternalModule = ts.forEach(symbol.declarations, getExternalModuleContainer);
                if (symbolExternalModule) {
                    var enclosingExternalModule = getExternalModuleContainer(enclosingDeclaration);
                    if (symbolExternalModule !== enclosingExternalModule) {
                        return {
                            accessibility: 2,
                            errorSymbolName: symbolToString(symbol, enclosingDeclaration, meaning),
                            errorModuleName: symbolToString(symbolExternalModule),
                            errorNode: ts.isInJSFile(enclosingDeclaration) ? enclosingDeclaration : undefined,
                        };
                    }
                }
                return {
                    accessibility: 1,
                    errorSymbolName: symbolToString(symbol, enclosingDeclaration, meaning),
                };
            }
            return { accessibility: 0 };
        }
        function getExternalModuleContainer(declaration) {
            var node = ts.findAncestor(declaration, hasExternalModuleSymbol);
            return node && getSymbolOfNode(node);
        }
        function hasExternalModuleSymbol(declaration) {
            return ts.isAmbientModule(declaration) || (declaration.kind === 305 && ts.isExternalOrCommonJsModule(declaration));
        }
        function hasNonGlobalAugmentationExternalModuleSymbol(declaration) {
            return ts.isModuleWithStringLiteralName(declaration) || (declaration.kind === 305 && ts.isExternalOrCommonJsModule(declaration));
        }
        function hasVisibleDeclarations(symbol, shouldComputeAliasToMakeVisible) {
            var aliasesToMakeVisible;
            if (!ts.every(ts.filter(symbol.declarations, function (d) { return d.kind !== 79; }), getIsDeclarationVisible)) {
                return undefined;
            }
            return { accessibility: 0, aliasesToMakeVisible: aliasesToMakeVisible };
            function getIsDeclarationVisible(declaration) {
                var _a, _b;
                if (!isDeclarationVisible(declaration)) {
                    var anyImportSyntax = getAnyImportSyntax(declaration);
                    if (anyImportSyntax &&
                        !ts.hasSyntacticModifier(anyImportSyntax, 1) &&
                        isDeclarationVisible(anyImportSyntax.parent)) {
                        return addVisibleAlias(declaration, anyImportSyntax);
                    }
                    else if (ts.isVariableDeclaration(declaration) && ts.isVariableStatement(declaration.parent.parent) &&
                        !ts.hasSyntacticModifier(declaration.parent.parent, 1) &&
                        isDeclarationVisible(declaration.parent.parent.parent)) {
                        return addVisibleAlias(declaration, declaration.parent.parent);
                    }
                    else if (ts.isLateVisibilityPaintedStatement(declaration)
                        && !ts.hasSyntacticModifier(declaration, 1)
                        && isDeclarationVisible(declaration.parent)) {
                        return addVisibleAlias(declaration, declaration);
                    }
                    else if (symbol.flags & 2097152 && ts.isBindingElement(declaration) && ts.isInJSFile(declaration) && ((_a = declaration.parent) === null || _a === void 0 ? void 0 : _a.parent)
                        && ts.isVariableDeclaration(declaration.parent.parent)
                        && ((_b = declaration.parent.parent.parent) === null || _b === void 0 ? void 0 : _b.parent) && ts.isVariableStatement(declaration.parent.parent.parent.parent)
                        && !ts.hasSyntacticModifier(declaration.parent.parent.parent.parent, 1)
                        && declaration.parent.parent.parent.parent.parent
                        && isDeclarationVisible(declaration.parent.parent.parent.parent.parent)) {
                        return addVisibleAlias(declaration, declaration.parent.parent.parent.parent);
                    }
                    return false;
                }
                return true;
            }
            function addVisibleAlias(declaration, aliasingStatement) {
                if (shouldComputeAliasToMakeVisible) {
                    getNodeLinks(declaration).isVisible = true;
                    aliasesToMakeVisible = ts.appendIfUnique(aliasesToMakeVisible, aliasingStatement);
                }
                return true;
            }
        }
        function isEntityNameVisible(entityName, enclosingDeclaration) {
            var meaning;
            if (entityName.parent.kind === 181 ||
                entityName.parent.kind === 228 && !ts.isPartOfTypeNode(entityName.parent) ||
                entityName.parent.kind === 162) {
                meaning = 111551 | 1048576;
            }
            else if (entityName.kind === 161 || entityName.kind === 206 ||
                entityName.parent.kind === 265) {
                meaning = 1920;
            }
            else {
                meaning = 788968;
            }
            var firstIdentifier = ts.getFirstIdentifier(entityName);
            var symbol = resolveName(enclosingDeclaration, firstIdentifier.escapedText, meaning, undefined, undefined, false);
            if (symbol && symbol.flags & 262144 && meaning & 788968) {
                return { accessibility: 0 };
            }
            return (symbol && hasVisibleDeclarations(symbol, true)) || {
                accessibility: 1,
                errorSymbolName: ts.getTextOfNode(firstIdentifier),
                errorNode: firstIdentifier
            };
        }
        function symbolToString(symbol, enclosingDeclaration, meaning, flags, writer) {
            if (flags === void 0) { flags = 4; }
            var nodeFlags = 70221824;
            if (flags & 2) {
                nodeFlags |= 128;
            }
            if (flags & 1) {
                nodeFlags |= 512;
            }
            if (flags & 8) {
                nodeFlags |= 16384;
            }
            if (flags & 16) {
                nodeFlags |= 134217728;
            }
            var builder = flags & 4 ? nodeBuilder.symbolToExpression : nodeBuilder.symbolToEntityName;
            return writer ? symbolToStringWorker(writer).getText() : ts.usingSingleLineStringWriter(symbolToStringWorker);
            function symbolToStringWorker(writer) {
                var entity = builder(symbol, meaning, enclosingDeclaration, nodeFlags);
                var printer = (enclosingDeclaration === null || enclosingDeclaration === void 0 ? void 0 : enclosingDeclaration.kind) === 305 ? ts.createPrinter({ removeComments: true, neverAsciiEscape: true }) : ts.createPrinter({ removeComments: true });
                var sourceFile = enclosingDeclaration && ts.getSourceFileOfNode(enclosingDeclaration);
                printer.writeNode(4, entity, sourceFile, writer);
                return writer;
            }
        }
        function signatureToString(signature, enclosingDeclaration, flags, kind, writer) {
            if (flags === void 0) { flags = 0; }
            return writer ? signatureToStringWorker(writer).getText() : ts.usingSingleLineStringWriter(signatureToStringWorker);
            function signatureToStringWorker(writer) {
                var sigOutput;
                if (flags & 262144) {
                    sigOutput = kind === 1 ? 180 : 179;
                }
                else {
                    sigOutput = kind === 1 ? 175 : 174;
                }
                var sig = nodeBuilder.signatureToSignatureDeclaration(signature, sigOutput, enclosingDeclaration, toNodeBuilderFlags(flags) | 70221824 | 512);
                var printer = ts.createPrinter({ removeComments: true, omitTrailingSemicolon: true });
                var sourceFile = enclosingDeclaration && ts.getSourceFileOfNode(enclosingDeclaration);
                printer.writeNode(4, sig, sourceFile, ts.getTrailingSemicolonDeferringWriter(writer));
                return writer;
            }
        }
        function typeToString(type, enclosingDeclaration, flags, writer) {
            if (flags === void 0) { flags = 1048576 | 16384; }
            if (writer === void 0) { writer = ts.createTextWriter(""); }
            var noTruncation = compilerOptions.noErrorTruncation || flags & 1;
            var typeNode = nodeBuilder.typeToTypeNode(type, enclosingDeclaration, toNodeBuilderFlags(flags) | 70221824 | (noTruncation ? 1 : 0), writer);
            if (typeNode === undefined)
                return ts.Debug.fail("should always get typenode");
            var options = { removeComments: type !== unresolvedType };
            var printer = ts.createPrinter(options);
            var sourceFile = enclosingDeclaration && ts.getSourceFileOfNode(enclosingDeclaration);
            printer.writeNode(4, typeNode, sourceFile, writer);
            var result = writer.getText();
            var maxLength = noTruncation ? ts.noTruncationMaximumTruncationLength * 2 : ts.defaultMaximumTruncationLength * 2;
            if (maxLength && result && result.length >= maxLength) {
                return result.substr(0, maxLength - "...".length) + "...";
            }
            return result;
        }
        function getTypeNamesForErrorDisplay(left, right) {
            var leftStr = symbolValueDeclarationIsContextSensitive(left.symbol) ? typeToString(left, left.symbol.valueDeclaration) : typeToString(left);
            var rightStr = symbolValueDeclarationIsContextSensitive(right.symbol) ? typeToString(right, right.symbol.valueDeclaration) : typeToString(right);
            if (leftStr === rightStr) {
                leftStr = getTypeNameForErrorDisplay(left);
                rightStr = getTypeNameForErrorDisplay(right);
            }
            return [leftStr, rightStr];
        }
        function getTypeNameForErrorDisplay(type) {
            return typeToString(type, undefined, 64);
        }
        function symbolValueDeclarationIsContextSensitive(symbol) {
            return symbol && !!symbol.valueDeclaration && ts.isExpression(symbol.valueDeclaration) && !isContextSensitive(symbol.valueDeclaration);
        }
        function toNodeBuilderFlags(flags) {
            if (flags === void 0) { flags = 0; }
            return flags & 814775659;
        }
        function isClassInstanceSide(type) {
            return !!type.symbol && !!(type.symbol.flags & 32) && (type === getDeclaredTypeOfClassOrInterface(type.symbol) || (!!(type.flags & 524288) && !!(ts.getObjectFlags(type) & 16777216)));
        }
        function createNodeBuilder() {
            return {
                typeToTypeNode: function (type, enclosingDeclaration, flags, tracker) {
                    return withContext(enclosingDeclaration, flags, tracker, function (context) { return typeToTypeNodeHelper(type, context); });
                },
                indexInfoToIndexSignatureDeclaration: function (indexInfo, enclosingDeclaration, flags, tracker) {
                    return withContext(enclosingDeclaration, flags, tracker, function (context) { return indexInfoToIndexSignatureDeclarationHelper(indexInfo, context, undefined); });
                },
                signatureToSignatureDeclaration: function (signature, kind, enclosingDeclaration, flags, tracker) {
                    return withContext(enclosingDeclaration, flags, tracker, function (context) { return signatureToSignatureDeclarationHelper(signature, kind, context); });
                },
                symbolToEntityName: function (symbol, meaning, enclosingDeclaration, flags, tracker) {
                    return withContext(enclosingDeclaration, flags, tracker, function (context) { return symbolToName(symbol, context, meaning, false); });
                },
                symbolToExpression: function (symbol, meaning, enclosingDeclaration, flags, tracker) {
                    return withContext(enclosingDeclaration, flags, tracker, function (context) { return symbolToExpression(symbol, context, meaning); });
                },
                symbolToTypeParameterDeclarations: function (symbol, enclosingDeclaration, flags, tracker) {
                    return withContext(enclosingDeclaration, flags, tracker, function (context) { return typeParametersToTypeParameterDeclarations(symbol, context); });
                },
                symbolToParameterDeclaration: function (symbol, enclosingDeclaration, flags, tracker) {
                    return withContext(enclosingDeclaration, flags, tracker, function (context) { return symbolToParameterDeclaration(symbol, context); });
                },
                typeParameterToDeclaration: function (parameter, enclosingDeclaration, flags, tracker) {
                    return withContext(enclosingDeclaration, flags, tracker, function (context) { return typeParameterToDeclaration(parameter, context); });
                },
                symbolTableToDeclarationStatements: function (symbolTable, enclosingDeclaration, flags, tracker, bundled) {
                    return withContext(enclosingDeclaration, flags, tracker, function (context) { return symbolTableToDeclarationStatements(symbolTable, context, bundled); });
                },
            };
            function withContext(enclosingDeclaration, flags, tracker, cb) {
                var _a, _b;
                ts.Debug.assert(enclosingDeclaration === undefined || (enclosingDeclaration.flags & 8) === 0);
                var context = {
                    enclosingDeclaration: enclosingDeclaration,
                    flags: flags || 0,
                    tracker: tracker && tracker.trackSymbol ? tracker : { trackSymbol: function () { return false; }, moduleResolverHost: flags & 134217728 ? {
                            getCommonSourceDirectory: !!host.getCommonSourceDirectory ? function () { return host.getCommonSourceDirectory(); } : function () { return ""; },
                            getCurrentDirectory: function () { return host.getCurrentDirectory(); },
                            getSymlinkCache: ts.maybeBind(host, host.getSymlinkCache),
                            getPackageJsonInfoCache: function () { var _a; return (_a = host.getPackageJsonInfoCache) === null || _a === void 0 ? void 0 : _a.call(host); },
                            useCaseSensitiveFileNames: ts.maybeBind(host, host.useCaseSensitiveFileNames),
                            redirectTargetsMap: host.redirectTargetsMap,
                            getProjectReferenceRedirect: function (fileName) { return host.getProjectReferenceRedirect(fileName); },
                            isSourceOfProjectReferenceRedirect: function (fileName) { return host.isSourceOfProjectReferenceRedirect(fileName); },
                            fileExists: function (fileName) { return host.fileExists(fileName); },
                            getFileIncludeReasons: function () { return host.getFileIncludeReasons(); },
                            readFile: host.readFile ? (function (fileName) { return host.readFile(fileName); }) : undefined,
                        } : undefined },
                    encounteredError: false,
                    reportedDiagnostic: false,
                    visitedTypes: undefined,
                    symbolDepth: undefined,
                    inferTypeParameters: undefined,
                    approximateLength: 0
                };
                context.tracker = wrapSymbolTrackerToReportForContext(context, context.tracker);
                var resultingNode = cb(context);
                if (context.truncating && context.flags & 1) {
                    (_b = (_a = context.tracker) === null || _a === void 0 ? void 0 : _a.reportTruncationError) === null || _b === void 0 ? void 0 : _b.call(_a);
                }
                return context.encounteredError ? undefined : resultingNode;
            }
            function wrapSymbolTrackerToReportForContext(context, tracker) {
                var oldTrackSymbol = tracker.trackSymbol;
                return __assign(__assign({}, tracker), { reportCyclicStructureError: wrapReportedDiagnostic(tracker.reportCyclicStructureError), reportInaccessibleThisError: wrapReportedDiagnostic(tracker.reportInaccessibleThisError), reportInaccessibleUniqueSymbolError: wrapReportedDiagnostic(tracker.reportInaccessibleUniqueSymbolError), reportLikelyUnsafeImportRequiredError: wrapReportedDiagnostic(tracker.reportLikelyUnsafeImportRequiredError), reportNonlocalAugmentation: wrapReportedDiagnostic(tracker.reportNonlocalAugmentation), reportPrivateInBaseOfClassExpression: wrapReportedDiagnostic(tracker.reportPrivateInBaseOfClassExpression), reportNonSerializableProperty: wrapReportedDiagnostic(tracker.reportNonSerializableProperty), trackSymbol: oldTrackSymbol && (function () {
                        var args = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            args[_i] = arguments[_i];
                        }
                        var result = oldTrackSymbol.apply(void 0, args);
                        if (result) {
                            context.reportedDiagnostic = true;
                        }
                        return result;
                    }) });
                function wrapReportedDiagnostic(method) {
                    if (!method) {
                        return method;
                    }
                    return (function () {
                        var args = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            args[_i] = arguments[_i];
                        }
                        context.reportedDiagnostic = true;
                        return method.apply(void 0, args);
                    });
                }
            }
            function checkTruncationLength(context) {
                if (context.truncating)
                    return context.truncating;
                return context.truncating = context.approximateLength > ((context.flags & 1) ? ts.noTruncationMaximumTruncationLength : ts.defaultMaximumTruncationLength);
            }
            function typeToTypeNodeHelper(type, context) {
                if (cancellationToken && cancellationToken.throwIfCancellationRequested) {
                    cancellationToken.throwIfCancellationRequested();
                }
                var inTypeAlias = context.flags & 8388608;
                context.flags &= ~8388608;
                if (!type) {
                    if (!(context.flags & 262144)) {
                        context.encounteredError = true;
                        return undefined;
                    }
                    context.approximateLength += 3;
                    return ts.factory.createKeywordTypeNode(130);
                }
                if (!(context.flags & 536870912)) {
                    type = getReducedType(type);
                }
                if (type.flags & 1) {
                    if (type.aliasSymbol) {
                        return ts.factory.createTypeReferenceNode(symbolToEntityNameNode(type.aliasSymbol), mapToTypeNodes(type.aliasTypeArguments, context));
                    }
                    if (type === unresolvedType) {
                        return ts.addSyntheticLeadingComment(ts.factory.createKeywordTypeNode(130), 3, "unresolved");
                    }
                    context.approximateLength += 3;
                    return ts.factory.createKeywordTypeNode(type === intrinsicMarkerType ? 138 : 130);
                }
                if (type.flags & 2) {
                    return ts.factory.createKeywordTypeNode(155);
                }
                if (type.flags & 4) {
                    context.approximateLength += 6;
                    return ts.factory.createKeywordTypeNode(150);
                }
                if (type.flags & 8) {
                    context.approximateLength += 6;
                    return ts.factory.createKeywordTypeNode(147);
                }
                if (type.flags & 64) {
                    context.approximateLength += 6;
                    return ts.factory.createKeywordTypeNode(158);
                }
                if (type.flags & 16 && !type.aliasSymbol) {
                    context.approximateLength += 7;
                    return ts.factory.createKeywordTypeNode(133);
                }
                if (type.flags & 1024 && !(type.flags & 1048576)) {
                    var parentSymbol = getParentOfSymbol(type.symbol);
                    var parentName = symbolToTypeNode(parentSymbol, context, 788968);
                    if (getDeclaredTypeOfSymbol(parentSymbol) === type) {
                        return parentName;
                    }
                    var memberName = ts.symbolName(type.symbol);
                    if (ts.isIdentifierText(memberName, 0)) {
                        return appendReferenceToType(parentName, ts.factory.createTypeReferenceNode(memberName, undefined));
                    }
                    if (ts.isImportTypeNode(parentName)) {
                        parentName.isTypeOf = true;
                        return ts.factory.createIndexedAccessTypeNode(parentName, ts.factory.createLiteralTypeNode(ts.factory.createStringLiteral(memberName)));
                    }
                    else if (ts.isTypeReferenceNode(parentName)) {
                        return ts.factory.createIndexedAccessTypeNode(ts.factory.createTypeQueryNode(parentName.typeName), ts.factory.createLiteralTypeNode(ts.factory.createStringLiteral(memberName)));
                    }
                    else {
                        return ts.Debug.fail("Unhandled type node kind returned from `symbolToTypeNode`.");
                    }
                }
                if (type.flags & 1056) {
                    return symbolToTypeNode(type.symbol, context, 788968);
                }
                if (type.flags & 128) {
                    context.approximateLength += (type.value.length + 2);
                    return ts.factory.createLiteralTypeNode(ts.setEmitFlags(ts.factory.createStringLiteral(type.value, !!(context.flags & 268435456)), 16777216));
                }
                if (type.flags & 256) {
                    var value = type.value;
                    context.approximateLength += ("" + value).length;
                    return ts.factory.createLiteralTypeNode(value < 0 ? ts.factory.createPrefixUnaryExpression(40, ts.factory.createNumericLiteral(-value)) : ts.factory.createNumericLiteral(value));
                }
                if (type.flags & 2048) {
                    context.approximateLength += (ts.pseudoBigIntToString(type.value).length) + 1;
                    return ts.factory.createLiteralTypeNode((ts.factory.createBigIntLiteral(type.value)));
                }
                if (type.flags & 512) {
                    context.approximateLength += type.intrinsicName.length;
                    return ts.factory.createLiteralTypeNode(type.intrinsicName === "true" ? ts.factory.createTrue() : ts.factory.createFalse());
                }
                if (type.flags & 8192) {
                    if (!(context.flags & 1048576)) {
                        if (isValueSymbolAccessible(type.symbol, context.enclosingDeclaration)) {
                            context.approximateLength += 6;
                            return symbolToTypeNode(type.symbol, context, 111551);
                        }
                        if (context.tracker.reportInaccessibleUniqueSymbolError) {
                            context.tracker.reportInaccessibleUniqueSymbolError();
                        }
                    }
                    context.approximateLength += 13;
                    return ts.factory.createTypeOperatorNode(154, ts.factory.createKeywordTypeNode(151));
                }
                if (type.flags & 16384) {
                    context.approximateLength += 4;
                    return ts.factory.createKeywordTypeNode(114);
                }
                if (type.flags & 32768) {
                    context.approximateLength += 9;
                    return ts.factory.createKeywordTypeNode(153);
                }
                if (type.flags & 65536) {
                    context.approximateLength += 4;
                    return ts.factory.createLiteralTypeNode(ts.factory.createNull());
                }
                if (type.flags & 131072) {
                    context.approximateLength += 5;
                    return ts.factory.createKeywordTypeNode(143);
                }
                if (type.flags & 4096) {
                    context.approximateLength += 6;
                    return ts.factory.createKeywordTypeNode(151);
                }
                if (type.flags & 67108864) {
                    context.approximateLength += 6;
                    return ts.factory.createKeywordTypeNode(148);
                }
                if (ts.isThisTypeParameter(type)) {
                    if (context.flags & 4194304) {
                        if (!context.encounteredError && !(context.flags & 32768)) {
                            context.encounteredError = true;
                        }
                        if (context.tracker.reportInaccessibleThisError) {
                            context.tracker.reportInaccessibleThisError();
                        }
                    }
                    context.approximateLength += 4;
                    return ts.factory.createThisTypeNode();
                }
                if (!inTypeAlias && type.aliasSymbol && (context.flags & 16384 || isTypeSymbolAccessible(type.aliasSymbol, context.enclosingDeclaration))) {
                    var typeArgumentNodes = mapToTypeNodes(type.aliasTypeArguments, context);
                    if (isReservedMemberName(type.aliasSymbol.escapedName) && !(type.aliasSymbol.flags & 32))
                        return ts.factory.createTypeReferenceNode(ts.factory.createIdentifier(""), typeArgumentNodes);
                    return symbolToTypeNode(type.aliasSymbol, context, 788968, typeArgumentNodes);
                }
                var objectFlags = ts.getObjectFlags(type);
                if (objectFlags & 4) {
                    ts.Debug.assert(!!(type.flags & 524288));
                    return type.node ? visitAndTransformType(type, typeReferenceToTypeNode) : typeReferenceToTypeNode(type);
                }
                if (type.flags & 262144 || objectFlags & 3) {
                    if (type.flags & 262144 && ts.contains(context.inferTypeParameters, type)) {
                        context.approximateLength += (ts.symbolName(type.symbol).length + 6);
                        var constraintNode = void 0;
                        var constraint = getConstraintOfTypeParameter(type);
                        if (constraint) {
                            var inferredConstraint = getInferredTypeParameterConstraint(type, true);
                            if (!(inferredConstraint && isTypeIdenticalTo(constraint, inferredConstraint))) {
                                context.approximateLength += 9;
                                constraintNode = constraint && typeToTypeNodeHelper(constraint, context);
                            }
                        }
                        return ts.factory.createInferTypeNode(typeParameterToDeclarationWithConstraint(type, context, constraintNode));
                    }
                    if (context.flags & 4 &&
                        type.flags & 262144 &&
                        !isTypeSymbolAccessible(type.symbol, context.enclosingDeclaration)) {
                        var name_2 = typeParameterToName(type, context);
                        context.approximateLength += ts.idText(name_2).length;
                        return ts.factory.createTypeReferenceNode(ts.factory.createIdentifier(ts.idText(name_2)), undefined);
                    }
                    if (type.symbol) {
                        return symbolToTypeNode(type.symbol, context, 788968);
                    }
                    var name = (type === markerSuperType || type === markerSubType) && varianceTypeParameter && varianceTypeParameter.symbol ?
                        (type === markerSubType ? "sub-" : "super-") + ts.symbolName(varianceTypeParameter.symbol) : "?";
                    return ts.factory.createTypeReferenceNode(ts.factory.createIdentifier(name), undefined);
                }
                if (type.flags & 1048576 && type.origin) {
                    type = type.origin;
                }
                if (type.flags & (1048576 | 2097152)) {
                    var types = type.flags & 1048576 ? formatUnionTypes(type.types) : type.types;
                    if (ts.length(types) === 1) {
                        return typeToTypeNodeHelper(types[0], context);
                    }
                    var typeNodes = mapToTypeNodes(types, context, true);
                    if (typeNodes && typeNodes.length > 0) {
                        return type.flags & 1048576 ? ts.factory.createUnionTypeNode(typeNodes) : ts.factory.createIntersectionTypeNode(typeNodes);
                    }
                    else {
                        if (!context.encounteredError && !(context.flags & 262144)) {
                            context.encounteredError = true;
                        }
                        return undefined;
                    }
                }
                if (objectFlags & (16 | 32)) {
                    ts.Debug.assert(!!(type.flags & 524288));
                    return createAnonymousTypeNode(type);
                }
                if (type.flags & 4194304) {
                    var indexedType = type.type;
                    context.approximateLength += 6;
                    var indexTypeNode = typeToTypeNodeHelper(indexedType, context);
                    return ts.factory.createTypeOperatorNode(140, indexTypeNode);
                }
                if (type.flags & 134217728) {
                    var texts_1 = type.texts;
                    var types_1 = type.types;
                    var templateHead = ts.factory.createTemplateHead(texts_1[0]);
                    var templateSpans = ts.factory.createNodeArray(ts.map(types_1, function (t, i) { return ts.factory.createTemplateLiteralTypeSpan(typeToTypeNodeHelper(t, context), (i < types_1.length - 1 ? ts.factory.createTemplateMiddle : ts.factory.createTemplateTail)(texts_1[i + 1])); }));
                    context.approximateLength += 2;
                    return ts.factory.createTemplateLiteralType(templateHead, templateSpans);
                }
                if (type.flags & 268435456) {
                    var typeNode = typeToTypeNodeHelper(type.type, context);
                    return symbolToTypeNode(type.symbol, context, 788968, [typeNode]);
                }
                if (type.flags & 8388608) {
                    var objectTypeNode = typeToTypeNodeHelper(type.objectType, context);
                    var indexTypeNode = typeToTypeNodeHelper(type.indexType, context);
                    context.approximateLength += 2;
                    return ts.factory.createIndexedAccessTypeNode(objectTypeNode, indexTypeNode);
                }
                if (type.flags & 16777216) {
                    return visitAndTransformType(type, function (type) { return conditionalTypeToTypeNode(type); });
                }
                if (type.flags & 33554432) {
                    return typeToTypeNodeHelper(type.baseType, context);
                }
                return ts.Debug.fail("Should be unreachable.");
                function conditionalTypeToTypeNode(type) {
                    var checkTypeNode = typeToTypeNodeHelper(type.checkType, context);
                    context.approximateLength += 15;
                    if (context.flags & 4 && type.root.isDistributive && !(type.checkType.flags & 262144)) {
                        var newParam = createTypeParameter(createSymbol(262144, "T"));
                        var name = typeParameterToName(newParam, context);
                        var newTypeVariable = ts.factory.createTypeReferenceNode(name);
                        context.approximateLength += 37;
                        var newMapper = prependTypeMapping(type.root.checkType, newParam, type.combinedMapper || type.mapper);
                        var saveInferTypeParameters_1 = context.inferTypeParameters;
                        context.inferTypeParameters = type.root.inferTypeParameters;
                        var extendsTypeNode_1 = typeToTypeNodeHelper(instantiateType(type.root.extendsType, newMapper), context);
                        context.inferTypeParameters = saveInferTypeParameters_1;
                        var trueTypeNode_1 = typeToTypeNodeOrCircularityElision(instantiateType(getTypeFromTypeNode(type.root.node.trueType), newMapper));
                        var falseTypeNode_1 = typeToTypeNodeOrCircularityElision(instantiateType(getTypeFromTypeNode(type.root.node.falseType), newMapper));
                        return ts.factory.createConditionalTypeNode(checkTypeNode, ts.factory.createInferTypeNode(ts.factory.createTypeParameterDeclaration(undefined, ts.factory.cloneNode(newTypeVariable.typeName))), ts.factory.createConditionalTypeNode(ts.factory.createTypeReferenceNode(ts.factory.cloneNode(name)), typeToTypeNodeHelper(type.checkType, context), ts.factory.createConditionalTypeNode(newTypeVariable, extendsTypeNode_1, trueTypeNode_1, falseTypeNode_1), ts.factory.createKeywordTypeNode(143)), ts.factory.createKeywordTypeNode(143));
                    }
                    var saveInferTypeParameters = context.inferTypeParameters;
                    context.inferTypeParameters = type.root.inferTypeParameters;
                    var extendsTypeNode = typeToTypeNodeHelper(type.extendsType, context);
                    context.inferTypeParameters = saveInferTypeParameters;
                    var trueTypeNode = typeToTypeNodeOrCircularityElision(getTrueTypeFromConditionalType(type));
                    var falseTypeNode = typeToTypeNodeOrCircularityElision(getFalseTypeFromConditionalType(type));
                    return ts.factory.createConditionalTypeNode(checkTypeNode, extendsTypeNode, trueTypeNode, falseTypeNode);
                }
                function typeToTypeNodeOrCircularityElision(type) {
                    var _a, _b, _c;
                    if (type.flags & 1048576) {
                        if ((_a = context.visitedTypes) === null || _a === void 0 ? void 0 : _a.has(getTypeId(type))) {
                            if (!(context.flags & 131072)) {
                                context.encounteredError = true;
                                (_c = (_b = context.tracker) === null || _b === void 0 ? void 0 : _b.reportCyclicStructureError) === null || _c === void 0 ? void 0 : _c.call(_b);
                            }
                            return createElidedInformationPlaceholder(context);
                        }
                        return visitAndTransformType(type, function (type) { return typeToTypeNodeHelper(type, context); });
                    }
                    return typeToTypeNodeHelper(type, context);
                }
                function createMappedTypeNodeFromType(type) {
                    ts.Debug.assert(!!(type.flags & 524288));
                    var readonlyToken = type.declaration.readonlyToken ? ts.factory.createToken(type.declaration.readonlyToken.kind) : undefined;
                    var questionToken = type.declaration.questionToken ? ts.factory.createToken(type.declaration.questionToken.kind) : undefined;
                    var appropriateConstraintTypeNode;
                    var newTypeVariable;
                    if (isMappedTypeWithKeyofConstraintDeclaration(type)) {
                        if (!(getModifiersTypeFromMappedType(type).flags & 262144) && context.flags & 4) {
                            var newParam = createTypeParameter(createSymbol(262144, "T"));
                            var name = typeParameterToName(newParam, context);
                            newTypeVariable = ts.factory.createTypeReferenceNode(name);
                        }
                        appropriateConstraintTypeNode = ts.factory.createTypeOperatorNode(140, newTypeVariable || typeToTypeNodeHelper(getModifiersTypeFromMappedType(type), context));
                    }
                    else {
                        appropriateConstraintTypeNode = typeToTypeNodeHelper(getConstraintTypeFromMappedType(type), context);
                    }
                    var typeParameterNode = typeParameterToDeclarationWithConstraint(getTypeParameterFromMappedType(type), context, appropriateConstraintTypeNode);
                    var nameTypeNode = type.declaration.nameType ? typeToTypeNodeHelper(getNameTypeFromMappedType(type), context) : undefined;
                    var templateTypeNode = typeToTypeNodeHelper(removeMissingType(getTemplateTypeFromMappedType(type), !!(getMappedTypeModifiers(type) & 4)), context);
                    var mappedTypeNode = ts.factory.createMappedTypeNode(readonlyToken, typeParameterNode, nameTypeNode, questionToken, templateTypeNode, undefined);
                    context.approximateLength += 10;
                    var result = ts.setEmitFlags(mappedTypeNode, 1);
                    if (isMappedTypeWithKeyofConstraintDeclaration(type) && !(getModifiersTypeFromMappedType(type).flags & 262144) && context.flags & 4) {
                        return ts.factory.createConditionalTypeNode(typeToTypeNodeHelper(getModifiersTypeFromMappedType(type), context), ts.factory.createInferTypeNode(ts.factory.createTypeParameterDeclaration(undefined, ts.factory.cloneNode(newTypeVariable.typeName))), result, ts.factory.createKeywordTypeNode(143));
                    }
                    return result;
                }
                function createAnonymousTypeNode(type) {
                    var _a;
                    var typeId = type.id;
                    var symbol = type.symbol;
                    if (symbol) {
                        var isInstanceType = isClassInstanceSide(type) ? 788968 : 111551;
                        if (isJSConstructor(symbol.valueDeclaration)) {
                            return symbolToTypeNode(symbol, context, isInstanceType);
                        }
                        else if (symbol.flags & 32
                            && !getBaseTypeVariableOfClass(symbol)
                            && !(symbol.valueDeclaration && symbol.valueDeclaration.kind === 226 && context.flags & 2048) ||
                            symbol.flags & (384 | 512) ||
                            shouldWriteTypeOfFunctionSymbol()) {
                            return symbolToTypeNode(symbol, context, isInstanceType);
                        }
                        else if ((_a = context.visitedTypes) === null || _a === void 0 ? void 0 : _a.has(typeId)) {
                            var typeAlias = getTypeAliasForTypeLiteral(type);
                            if (typeAlias) {
                                return symbolToTypeNode(typeAlias, context, 788968);
                            }
                            else {
                                return createElidedInformationPlaceholder(context);
                            }
                        }
                        else {
                            return visitAndTransformType(type, createTypeNodeFromObjectType);
                        }
                    }
                    else {
                        return createTypeNodeFromObjectType(type);
                    }
                    function shouldWriteTypeOfFunctionSymbol() {
                        var _a;
                        var isStaticMethodSymbol = !!(symbol.flags & 8192) &&
                            ts.some(symbol.declarations, function (declaration) { return ts.isStatic(declaration); });
                        var isNonLocalFunctionSymbol = !!(symbol.flags & 16) &&
                            (symbol.parent ||
                                ts.forEach(symbol.declarations, function (declaration) {
                                    return declaration.parent.kind === 305 || declaration.parent.kind === 262;
                                }));
                        if (isStaticMethodSymbol || isNonLocalFunctionSymbol) {
                            return (!!(context.flags & 4096) || ((_a = context.visitedTypes) === null || _a === void 0 ? void 0 : _a.has(typeId))) &&
                                (!(context.flags & 8) || isValueSymbolAccessible(symbol, context.enclosingDeclaration));
                        }
                    }
                }
                function visitAndTransformType(type, transform) {
                    var _a, _b;
                    var typeId = type.id;
                    var isConstructorObject = ts.getObjectFlags(type) & 16 && type.symbol && type.symbol.flags & 32;
                    var id = ts.getObjectFlags(type) & 4 && type.node ? "N" + getNodeId(type.node) :
                        type.flags & 16777216 ? "N" + getNodeId(type.root.node) :
                            type.symbol ? (isConstructorObject ? "+" : "") + getSymbolId(type.symbol) :
                                undefined;
                    if (!context.visitedTypes) {
                        context.visitedTypes = new ts.Set();
                    }
                    if (id && !context.symbolDepth) {
                        context.symbolDepth = new ts.Map();
                    }
                    var links = context.enclosingDeclaration && getNodeLinks(context.enclosingDeclaration);
                    var key = "".concat(getTypeId(type), "|").concat(context.flags);
                    if (links) {
                        links.serializedTypes || (links.serializedTypes = new ts.Map());
                    }
                    var cachedResult = (_a = links === null || links === void 0 ? void 0 : links.serializedTypes) === null || _a === void 0 ? void 0 : _a.get(key);
                    if (cachedResult) {
                        if (cachedResult.truncating) {
                            context.truncating = true;
                        }
                        context.approximateLength += cachedResult.addedLength;
                        return deepCloneOrReuseNode(cachedResult);
                    }
                    var depth;
                    if (id) {
                        depth = context.symbolDepth.get(id) || 0;
                        if (depth > 10) {
                            return createElidedInformationPlaceholder(context);
                        }
                        context.symbolDepth.set(id, depth + 1);
                    }
                    context.visitedTypes.add(typeId);
                    var startLength = context.approximateLength;
                    var result = transform(type);
                    var addedLength = context.approximateLength - startLength;
                    if (!context.reportedDiagnostic && !context.encounteredError) {
                        if (context.truncating) {
                            result.truncating = true;
                        }
                        result.addedLength = addedLength;
                        (_b = links === null || links === void 0 ? void 0 : links.serializedTypes) === null || _b === void 0 ? void 0 : _b.set(key, result);
                    }
                    context.visitedTypes.delete(typeId);
                    if (id) {
                        context.symbolDepth.set(id, depth);
                    }
                    return result;
                    function deepCloneOrReuseNode(node) {
                        if (!ts.nodeIsSynthesized(node) && ts.getParseTreeNode(node) === node) {
                            return node;
                        }
                        return ts.setTextRange(ts.factory.cloneNode(ts.visitEachChild(node, deepCloneOrReuseNode, ts.nullTransformationContext, deepCloneOrReuseNodes)), node);
                    }
                    function deepCloneOrReuseNodes(nodes, visitor, test, start, count) {
                        if (nodes && nodes.length === 0) {
                            return ts.setTextRange(ts.factory.createNodeArray(undefined, nodes.hasTrailingComma), nodes);
                        }
                        return ts.visitNodes(nodes, visitor, test, start, count);
                    }
                }
                function createTypeNodeFromObjectType(type) {
                    if (isGenericMappedType(type) || type.containsError) {
                        return createMappedTypeNodeFromType(type);
                    }
                    var resolved = resolveStructuredTypeMembers(type);
                    if (!resolved.properties.length && !resolved.indexInfos.length) {
                        if (!resolved.callSignatures.length && !resolved.constructSignatures.length) {
                            context.approximateLength += 2;
                            return ts.setEmitFlags(ts.factory.createTypeLiteralNode(undefined), 1);
                        }
                        if (resolved.callSignatures.length === 1 && !resolved.constructSignatures.length) {
                            var signature = resolved.callSignatures[0];
                            var signatureNode = signatureToSignatureDeclarationHelper(signature, 179, context);
                            return signatureNode;
                        }
                        if (resolved.constructSignatures.length === 1 && !resolved.callSignatures.length) {
                            var signature = resolved.constructSignatures[0];
                            var signatureNode = signatureToSignatureDeclarationHelper(signature, 180, context);
                            return signatureNode;
                        }
                    }
                    var abstractSignatures = ts.filter(resolved.constructSignatures, function (signature) { return !!(signature.flags & 4); });
                    if (ts.some(abstractSignatures)) {
                        var types = ts.map(abstractSignatures, getOrCreateTypeFromSignature);
                        var typeElementCount = resolved.callSignatures.length +
                            (resolved.constructSignatures.length - abstractSignatures.length) +
                            resolved.indexInfos.length +
                            (context.flags & 2048 ?
                                ts.countWhere(resolved.properties, function (p) { return !(p.flags & 4194304); }) :
                                ts.length(resolved.properties));
                        if (typeElementCount) {
                            types.push(getResolvedTypeWithoutAbstractConstructSignatures(resolved));
                        }
                        return typeToTypeNodeHelper(getIntersectionType(types), context);
                    }
                    var savedFlags = context.flags;
                    context.flags |= 4194304;
                    var members = createTypeNodesFromResolvedType(resolved);
                    context.flags = savedFlags;
                    var typeLiteralNode = ts.factory.createTypeLiteralNode(members);
                    context.approximateLength += 2;
                    ts.setEmitFlags(typeLiteralNode, (context.flags & 1024) ? 0 : 1);
                    return typeLiteralNode;
                }
                function typeReferenceToTypeNode(type) {
                    var typeArguments = getTypeArguments(type);
                    if (type.target === globalArrayType || type.target === globalReadonlyArrayType) {
                        if (context.flags & 2) {
                            var typeArgumentNode = typeToTypeNodeHelper(typeArguments[0], context);
                            return ts.factory.createTypeReferenceNode(type.target === globalArrayType ? "Array" : "ReadonlyArray", [typeArgumentNode]);
                        }
                        var elementType = typeToTypeNodeHelper(typeArguments[0], context);
                        var arrayType = ts.factory.createArrayTypeNode(elementType);
                        return type.target === globalArrayType ? arrayType : ts.factory.createTypeOperatorNode(145, arrayType);
                    }
                    else if (type.target.objectFlags & 8) {
                        typeArguments = ts.sameMap(typeArguments, function (t, i) { return removeMissingType(t, !!(type.target.elementFlags[i] & 2)); });
                        if (typeArguments.length > 0) {
                            var arity = getTypeReferenceArity(type);
                            var tupleConstituentNodes = mapToTypeNodes(typeArguments.slice(0, arity), context);
                            if (tupleConstituentNodes) {
                                if (type.target.labeledElementDeclarations) {
                                    for (var i = 0; i < tupleConstituentNodes.length; i++) {
                                        var flags = type.target.elementFlags[i];
                                        tupleConstituentNodes[i] = ts.factory.createNamedTupleMember(flags & 12 ? ts.factory.createToken(25) : undefined, ts.factory.createIdentifier(ts.unescapeLeadingUnderscores(getTupleElementLabel(type.target.labeledElementDeclarations[i]))), flags & 2 ? ts.factory.createToken(57) : undefined, flags & 4 ? ts.factory.createArrayTypeNode(tupleConstituentNodes[i]) :
                                            tupleConstituentNodes[i]);
                                    }
                                }
                                else {
                                    for (var i = 0; i < Math.min(arity, tupleConstituentNodes.length); i++) {
                                        var flags = type.target.elementFlags[i];
                                        tupleConstituentNodes[i] =
                                            flags & 12 ? ts.factory.createRestTypeNode(flags & 4 ? ts.factory.createArrayTypeNode(tupleConstituentNodes[i]) : tupleConstituentNodes[i]) :
                                                flags & 2 ? ts.factory.createOptionalTypeNode(tupleConstituentNodes[i]) :
                                                    tupleConstituentNodes[i];
                                    }
                                }
                                var tupleTypeNode = ts.setEmitFlags(ts.factory.createTupleTypeNode(tupleConstituentNodes), 1);
                                return type.target.readonly ? ts.factory.createTypeOperatorNode(145, tupleTypeNode) : tupleTypeNode;
                            }
                        }
                        if (context.encounteredError || (context.flags & 524288)) {
                            var tupleTypeNode = ts.setEmitFlags(ts.factory.createTupleTypeNode([]), 1);
                            return type.target.readonly ? ts.factory.createTypeOperatorNode(145, tupleTypeNode) : tupleTypeNode;
                        }
                        context.encounteredError = true;
                        return undefined;
                    }
                    else if (context.flags & 2048 &&
                        type.symbol.valueDeclaration &&
                        ts.isClassLike(type.symbol.valueDeclaration) &&
                        !isValueSymbolAccessible(type.symbol, context.enclosingDeclaration)) {
                        return createAnonymousTypeNode(type);
                    }
                    else {
                        var outerTypeParameters = type.target.outerTypeParameters;
                        var i = 0;
                        var resultType = void 0;
                        if (outerTypeParameters) {
                            var length_2 = outerTypeParameters.length;
                            while (i < length_2) {
                                var start = i;
                                var parent = getParentSymbolOfTypeParameter(outerTypeParameters[i]);
                                do {
                                    i++;
                                } while (i < length_2 && getParentSymbolOfTypeParameter(outerTypeParameters[i]) === parent);
                                if (!ts.rangeEquals(outerTypeParameters, typeArguments, start, i)) {
                                    var typeArgumentSlice = mapToTypeNodes(typeArguments.slice(start, i), context);
                                    var flags_3 = context.flags;
                                    context.flags |= 16;
                                    var ref = symbolToTypeNode(parent, context, 788968, typeArgumentSlice);
                                    context.flags = flags_3;
                                    resultType = !resultType ? ref : appendReferenceToType(resultType, ref);
                                }
                            }
                        }
                        var typeArgumentNodes = void 0;
                        if (typeArguments.length > 0) {
                            var typeParameterCount = (type.target.typeParameters || ts.emptyArray).length;
                            typeArgumentNodes = mapToTypeNodes(typeArguments.slice(i, typeParameterCount), context);
                        }
                        var flags = context.flags;
                        context.flags |= 16;
                        var finalRef = symbolToTypeNode(type.symbol, context, 788968, typeArgumentNodes);
                        context.flags = flags;
                        return !resultType ? finalRef : appendReferenceToType(resultType, finalRef);
                    }
                }
                function appendReferenceToType(root, ref) {
                    if (ts.isImportTypeNode(root)) {
                        var typeArguments = root.typeArguments;
                        var qualifier = root.qualifier;
                        if (qualifier) {
                            if (ts.isIdentifier(qualifier)) {
                                qualifier = ts.factory.updateIdentifier(qualifier, typeArguments);
                            }
                            else {
                                qualifier = ts.factory.updateQualifiedName(qualifier, qualifier.left, ts.factory.updateIdentifier(qualifier.right, typeArguments));
                            }
                        }
                        typeArguments = ref.typeArguments;
                        var ids = getAccessStack(ref);
                        for (var _i = 0, ids_1 = ids; _i < ids_1.length; _i++) {
                            var id = ids_1[_i];
                            qualifier = qualifier ? ts.factory.createQualifiedName(qualifier, id) : id;
                        }
                        return ts.factory.updateImportTypeNode(root, root.argument, qualifier, typeArguments, root.isTypeOf);
                    }
                    else {
                        var typeArguments = root.typeArguments;
                        var typeName = root.typeName;
                        if (ts.isIdentifier(typeName)) {
                            typeName = ts.factory.updateIdentifier(typeName, typeArguments);
                        }
                        else {
                            typeName = ts.factory.updateQualifiedName(typeName, typeName.left, ts.factory.updateIdentifier(typeName.right, typeArguments));
                        }
                        typeArguments = ref.typeArguments;
                        var ids = getAccessStack(ref);
                        for (var _a = 0, ids_2 = ids; _a < ids_2.length; _a++) {
                            var id = ids_2[_a];
                            typeName = ts.factory.createQualifiedName(typeName, id);
                        }
                        return ts.factory.updateTypeReferenceNode(root, typeName, typeArguments);
                    }
                }
                function getAccessStack(ref) {
                    var state = ref.typeName;
                    var ids = [];
                    while (!ts.isIdentifier(state)) {
                        ids.unshift(state.right);
                        state = state.left;
                    }
                    ids.unshift(state);
                    return ids;
                }
                function createTypeNodesFromResolvedType(resolvedType) {
                    if (checkTruncationLength(context)) {
                        return [ts.factory.createPropertySignature(undefined, "...", undefined, undefined)];
                    }
                    var typeElements = [];
                    for (var _i = 0, _a = resolvedType.callSignatures; _i < _a.length; _i++) {
                        var signature = _a[_i];
                        typeElements.push(signatureToSignatureDeclarationHelper(signature, 174, context));
                    }
                    for (var _b = 0, _c = resolvedType.constructSignatures; _b < _c.length; _b++) {
                        var signature = _c[_b];
                        if (signature.flags & 4)
                            continue;
                        typeElements.push(signatureToSignatureDeclarationHelper(signature, 175, context));
                    }
                    for (var _d = 0, _e = resolvedType.indexInfos; _d < _e.length; _d++) {
                        var info = _e[_d];
                        typeElements.push(indexInfoToIndexSignatureDeclarationHelper(info, context, resolvedType.objectFlags & 1024 ? createElidedInformationPlaceholder(context) : undefined));
                    }
                    var properties = resolvedType.properties;
                    if (!properties) {
                        return typeElements;
                    }
                    var i = 0;
                    for (var _f = 0, properties_1 = properties; _f < properties_1.length; _f++) {
                        var propertySymbol = properties_1[_f];
                        i++;
                        if (context.flags & 2048) {
                            if (propertySymbol.flags & 4194304) {
                                continue;
                            }
                            if (ts.getDeclarationModifierFlagsFromSymbol(propertySymbol) & (8 | 16) && context.tracker.reportPrivateInBaseOfClassExpression) {
                                context.tracker.reportPrivateInBaseOfClassExpression(ts.unescapeLeadingUnderscores(propertySymbol.escapedName));
                            }
                        }
                        if (checkTruncationLength(context) && (i + 2 < properties.length - 1)) {
                            typeElements.push(ts.factory.createPropertySignature(undefined, "... ".concat(properties.length - i, " more ..."), undefined, undefined));
                            addPropertyToElementList(properties[properties.length - 1], context, typeElements);
                            break;
                        }
                        addPropertyToElementList(propertySymbol, context, typeElements);
                    }
                    return typeElements.length ? typeElements : undefined;
                }
            }
            function createElidedInformationPlaceholder(context) {
                context.approximateLength += 3;
                if (!(context.flags & 1)) {
                    return ts.factory.createTypeReferenceNode(ts.factory.createIdentifier("..."), undefined);
                }
                return ts.factory.createKeywordTypeNode(130);
            }
            function shouldUsePlaceholderForProperty(propertySymbol, context) {
                var _a;
                return !!(ts.getCheckFlags(propertySymbol) & 8192)
                    && (ts.contains(context.reverseMappedStack, propertySymbol)
                        || (((_a = context.reverseMappedStack) === null || _a === void 0 ? void 0 : _a[0])
                            && !(ts.getObjectFlags(ts.last(context.reverseMappedStack).propertyType) & 16)));
            }
            function addPropertyToElementList(propertySymbol, context, typeElements) {
                var _a, _b;
                var propertyIsReverseMapped = !!(ts.getCheckFlags(propertySymbol) & 8192);
                var propertyType = shouldUsePlaceholderForProperty(propertySymbol, context) ?
                    anyType : getNonMissingTypeOfSymbol(propertySymbol);
                var saveEnclosingDeclaration = context.enclosingDeclaration;
                context.enclosingDeclaration = undefined;
                if (context.tracker.trackSymbol && ts.getCheckFlags(propertySymbol) & 4096 && isLateBoundName(propertySymbol.escapedName)) {
                    if (propertySymbol.declarations) {
                        var decl = ts.first(propertySymbol.declarations);
                        if (hasLateBindableName(decl)) {
                            if (ts.isBinaryExpression(decl)) {
                                var name = ts.getNameOfDeclaration(decl);
                                if (name && ts.isElementAccessExpression(name) && ts.isPropertyAccessEntityNameExpression(name.argumentExpression)) {
                                    trackComputedName(name.argumentExpression, saveEnclosingDeclaration, context);
                                }
                            }
                            else {
                                trackComputedName(decl.name.expression, saveEnclosingDeclaration, context);
                            }
                        }
                    }
                    else if ((_a = context.tracker) === null || _a === void 0 ? void 0 : _a.reportNonSerializableProperty) {
                        context.tracker.reportNonSerializableProperty(symbolToString(propertySymbol));
                    }
                }
                context.enclosingDeclaration = propertySymbol.valueDeclaration || ((_b = propertySymbol.declarations) === null || _b === void 0 ? void 0 : _b[0]) || saveEnclosingDeclaration;
                var propertyName = getPropertyNameNodeForSymbol(propertySymbol, context);
                context.enclosingDeclaration = saveEnclosingDeclaration;
                context.approximateLength += (ts.symbolName(propertySymbol).length + 1);
                var optionalToken = propertySymbol.flags & 16777216 ? ts.factory.createToken(57) : undefined;
                if (propertySymbol.flags & (16 | 8192) && !getPropertiesOfObjectType(propertyType).length && !isReadonlySymbol(propertySymbol)) {
                    var signatures = getSignaturesOfType(filterType(propertyType, function (t) { return !(t.flags & 32768); }), 0);
                    for (var _i = 0, signatures_1 = signatures; _i < signatures_1.length; _i++) {
                        var signature = signatures_1[_i];
                        var methodDeclaration = signatureToSignatureDeclarationHelper(signature, 168, context, { name: propertyName, questionToken: optionalToken });
                        typeElements.push(preserveCommentsOn(methodDeclaration));
                    }
                }
                else {
                    var propertyTypeNode = void 0;
                    if (shouldUsePlaceholderForProperty(propertySymbol, context)) {
                        propertyTypeNode = createElidedInformationPlaceholder(context);
                    }
                    else {
                        if (propertyIsReverseMapped) {
                            context.reverseMappedStack || (context.reverseMappedStack = []);
                            context.reverseMappedStack.push(propertySymbol);
                        }
                        propertyTypeNode = propertyType ? serializeTypeForDeclaration(context, propertyType, propertySymbol, saveEnclosingDeclaration) : ts.factory.createKeywordTypeNode(130);
                        if (propertyIsReverseMapped) {
                            context.reverseMappedStack.pop();
                        }
                    }
                    var modifiers = isReadonlySymbol(propertySymbol) ? [ts.factory.createToken(145)] : undefined;
                    if (modifiers) {
                        context.approximateLength += 9;
                    }
                    var propertySignature = ts.factory.createPropertySignature(modifiers, propertyName, optionalToken, propertyTypeNode);
                    typeElements.push(preserveCommentsOn(propertySignature));
                }
                function preserveCommentsOn(node) {
                    var _a;
                    if (ts.some(propertySymbol.declarations, function (d) { return d.kind === 347; })) {
                        var d = (_a = propertySymbol.declarations) === null || _a === void 0 ? void 0 : _a.find(function (d) { return d.kind === 347; });
                        var commentText = ts.getTextOfJSDocComment(d.comment);
                        if (commentText) {
                            ts.setSyntheticLeadingComments(node, [{ kind: 3, text: "*\n * " + commentText.replace(/\n/g, "\n * ") + "\n ", pos: -1, end: -1, hasTrailingNewLine: true }]);
                        }
                    }
                    else if (propertySymbol.valueDeclaration) {
                        ts.setCommentRange(node, propertySymbol.valueDeclaration);
                    }
                    return node;
                }
            }
            function mapToTypeNodes(types, context, isBareList) {
                if (ts.some(types)) {
                    if (checkTruncationLength(context)) {
                        if (!isBareList) {
                            return [ts.factory.createTypeReferenceNode("...", undefined)];
                        }
                        else if (types.length > 2) {
                            return [
                                typeToTypeNodeHelper(types[0], context),
                                ts.factory.createTypeReferenceNode("... ".concat(types.length - 2, " more ..."), undefined),
                                typeToTypeNodeHelper(types[types.length - 1], context)
                            ];
                        }
                    }
                    var mayHaveNameCollisions = !(context.flags & 64);
                    var seenNames = mayHaveNameCollisions ? ts.createUnderscoreEscapedMultiMap() : undefined;
                    var result_5 = [];
                    var i = 0;
                    for (var _i = 0, types_2 = types; _i < types_2.length; _i++) {
                        var type = types_2[_i];
                        i++;
                        if (checkTruncationLength(context) && (i + 2 < types.length - 1)) {
                            result_5.push(ts.factory.createTypeReferenceNode("... ".concat(types.length - i, " more ..."), undefined));
                            var typeNode_1 = typeToTypeNodeHelper(types[types.length - 1], context);
                            if (typeNode_1) {
                                result_5.push(typeNode_1);
                            }
                            break;
                        }
                        context.approximateLength += 2;
                        var typeNode = typeToTypeNodeHelper(type, context);
                        if (typeNode) {
                            result_5.push(typeNode);
                            if (seenNames && ts.isIdentifierTypeReference(typeNode)) {
                                seenNames.add(typeNode.typeName.escapedText, [type, result_5.length - 1]);
                            }
                        }
                    }
                    if (seenNames) {
                        var saveContextFlags = context.flags;
                        context.flags |= 64;
                        seenNames.forEach(function (types) {
                            if (!ts.arrayIsHomogeneous(types, function (_a, _b) {
                                var a = _a[0];
                                var b = _b[0];
                                return typesAreSameReference(a, b);
                            })) {
                                for (var _i = 0, types_3 = types; _i < types_3.length; _i++) {
                                    var _a = types_3[_i], type = _a[0], resultIndex = _a[1];
                                    result_5[resultIndex] = typeToTypeNodeHelper(type, context);
                                }
                            }
                        });
                        context.flags = saveContextFlags;
                    }
                    return result_5;
                }
            }
            function typesAreSameReference(a, b) {
                return a === b
                    || !!a.symbol && a.symbol === b.symbol
                    || !!a.aliasSymbol && a.aliasSymbol === b.aliasSymbol;
            }
            function indexInfoToIndexSignatureDeclarationHelper(indexInfo, context, typeNode) {
                var name = ts.getNameFromIndexInfo(indexInfo) || "x";
                var indexerTypeNode = typeToTypeNodeHelper(indexInfo.keyType, context);
                var indexingParameter = ts.factory.createParameterDeclaration(undefined, undefined, undefined, name, undefined, indexerTypeNode, undefined);
                if (!typeNode) {
                    typeNode = typeToTypeNodeHelper(indexInfo.type || anyType, context);
                }
                if (!indexInfo.type && !(context.flags & 2097152)) {
                    context.encounteredError = true;
                }
                context.approximateLength += (name.length + 4);
                return ts.factory.createIndexSignature(undefined, indexInfo.isReadonly ? [ts.factory.createToken(145)] : undefined, [indexingParameter], typeNode);
            }
            function signatureToSignatureDeclarationHelper(signature, kind, context, options) {
                var _a, _b, _c, _d;
                var suppressAny = context.flags & 256;
                if (suppressAny)
                    context.flags &= ~256;
                context.approximateLength += 3;
                var typeParameters;
                var typeArguments;
                if (context.flags & 32 && signature.target && signature.mapper && signature.target.typeParameters) {
                    typeArguments = signature.target.typeParameters.map(function (parameter) { return typeToTypeNodeHelper(instantiateType(parameter, signature.mapper), context); });
                }
                else {
                    typeParameters = signature.typeParameters && signature.typeParameters.map(function (parameter) { return typeParameterToDeclaration(parameter, context); });
                }
                var expandedParams = getExpandedParameters(signature, true)[0];
                var parameters = (ts.some(expandedParams, function (p) { return p !== expandedParams[expandedParams.length - 1] && !!(ts.getCheckFlags(p) & 32768); }) ? signature.parameters : expandedParams).map(function (parameter) { return symbolToParameterDeclaration(parameter, context, kind === 171, options === null || options === void 0 ? void 0 : options.privateSymbolVisitor, options === null || options === void 0 ? void 0 : options.bundledImports); });
                var thisParameter = tryGetThisParameterDeclaration(signature, context);
                if (thisParameter) {
                    parameters.unshift(thisParameter);
                }
                var returnTypeNode;
                var typePredicate = getTypePredicateOfSignature(signature);
                if (typePredicate) {
                    var assertsModifier = typePredicate.kind === 2 || typePredicate.kind === 3 ?
                        ts.factory.createToken(128) :
                        undefined;
                    var parameterName = typePredicate.kind === 1 || typePredicate.kind === 3 ?
                        ts.setEmitFlags(ts.factory.createIdentifier(typePredicate.parameterName), 16777216) :
                        ts.factory.createThisTypeNode();
                    var typeNode = typePredicate.type && typeToTypeNodeHelper(typePredicate.type, context);
                    returnTypeNode = ts.factory.createTypePredicateNode(assertsModifier, parameterName, typeNode);
                }
                else {
                    var returnType = getReturnTypeOfSignature(signature);
                    if (returnType && !(suppressAny && isTypeAny(returnType))) {
                        returnTypeNode = serializeReturnTypeForSignature(context, returnType, signature, options === null || options === void 0 ? void 0 : options.privateSymbolVisitor, options === null || options === void 0 ? void 0 : options.bundledImports);
                    }
                    else if (!suppressAny) {
                        returnTypeNode = ts.factory.createKeywordTypeNode(130);
                    }
                }
                var modifiers = options === null || options === void 0 ? void 0 : options.modifiers;
                if ((kind === 180) && signature.flags & 4) {
                    var flags = ts.modifiersToFlags(modifiers);
                    modifiers = ts.factory.createModifiersFromModifierFlags(flags | 128);
                }
                var node = kind === 174 ? ts.factory.createCallSignature(typeParameters, parameters, returnTypeNode) :
                    kind === 175 ? ts.factory.createConstructSignature(typeParameters, parameters, returnTypeNode) :
                        kind === 168 ? ts.factory.createMethodSignature(modifiers, (_a = options === null || options === void 0 ? void 0 : options.name) !== null && _a !== void 0 ? _a : ts.factory.createIdentifier(""), options === null || options === void 0 ? void 0 : options.questionToken, typeParameters, parameters, returnTypeNode) :
                            kind === 169 ? ts.factory.createMethodDeclaration(undefined, modifiers, undefined, (_b = options === null || options === void 0 ? void 0 : options.name) !== null && _b !== void 0 ? _b : ts.factory.createIdentifier(""), undefined, typeParameters, parameters, returnTypeNode, undefined) :
                                kind === 171 ? ts.factory.createConstructorDeclaration(undefined, modifiers, parameters, undefined) :
                                    kind === 172 ? ts.factory.createGetAccessorDeclaration(undefined, modifiers, (_c = options === null || options === void 0 ? void 0 : options.name) !== null && _c !== void 0 ? _c : ts.factory.createIdentifier(""), parameters, returnTypeNode, undefined) :
                                        kind === 173 ? ts.factory.createSetAccessorDeclaration(undefined, modifiers, (_d = options === null || options === void 0 ? void 0 : options.name) !== null && _d !== void 0 ? _d : ts.factory.createIdentifier(""), parameters, undefined) :
                                            kind === 176 ? ts.factory.createIndexSignature(undefined, modifiers, parameters, returnTypeNode) :
                                                kind === 317 ? ts.factory.createJSDocFunctionType(parameters, returnTypeNode) :
                                                    kind === 179 ? ts.factory.createFunctionTypeNode(typeParameters, parameters, returnTypeNode !== null && returnTypeNode !== void 0 ? returnTypeNode : ts.factory.createTypeReferenceNode(ts.factory.createIdentifier(""))) :
                                                        kind === 180 ? ts.factory.createConstructorTypeNode(modifiers, typeParameters, parameters, returnTypeNode !== null && returnTypeNode !== void 0 ? returnTypeNode : ts.factory.createTypeReferenceNode(ts.factory.createIdentifier(""))) :
                                                            kind === 256 ? ts.factory.createFunctionDeclaration(undefined, modifiers, undefined, (options === null || options === void 0 ? void 0 : options.name) ? ts.cast(options.name, ts.isIdentifier) : ts.factory.createIdentifier(""), typeParameters, parameters, returnTypeNode, undefined) :
                                                                kind === 213 ? ts.factory.createFunctionExpression(modifiers, undefined, (options === null || options === void 0 ? void 0 : options.name) ? ts.cast(options.name, ts.isIdentifier) : ts.factory.createIdentifier(""), typeParameters, parameters, returnTypeNode, ts.factory.createBlock([])) :
                                                                    kind === 214 ? ts.factory.createArrowFunction(modifiers, typeParameters, parameters, returnTypeNode, undefined, ts.factory.createBlock([])) :
                                                                        ts.Debug.assertNever(kind);
                if (typeArguments) {
                    node.typeArguments = ts.factory.createNodeArray(typeArguments);
                }
                return node;
            }
            function tryGetThisParameterDeclaration(signature, context) {
                if (signature.thisParameter) {
                    return symbolToParameterDeclaration(signature.thisParameter, context);
                }
                if (signature.declaration) {
                    var thisTag = ts.getJSDocThisTag(signature.declaration);
                    if (thisTag && thisTag.typeExpression) {
                        return ts.factory.createParameterDeclaration(undefined, undefined, undefined, "this", undefined, typeToTypeNodeHelper(getTypeFromTypeNode(thisTag.typeExpression), context));
                    }
                }
            }
            function typeParameterToDeclarationWithConstraint(type, context, constraintNode) {
                var savedContextFlags = context.flags;
                context.flags &= ~512;
                var modifiers = ts.factory.createModifiersFromModifierFlags(getVarianceModifiers(type));
                var name = typeParameterToName(type, context);
                var defaultParameter = getDefaultFromTypeParameter(type);
                var defaultParameterNode = defaultParameter && typeToTypeNodeHelper(defaultParameter, context);
                context.flags = savedContextFlags;
                return ts.factory.createTypeParameterDeclaration(modifiers, name, constraintNode, defaultParameterNode);
            }
            function typeParameterToDeclaration(type, context, constraint) {
                if (constraint === void 0) { constraint = getConstraintOfTypeParameter(type); }
                var constraintNode = constraint && typeToTypeNodeHelper(constraint, context);
                return typeParameterToDeclarationWithConstraint(type, context, constraintNode);
            }
            function symbolToParameterDeclaration(parameterSymbol, context, preserveModifierFlags, privateSymbolVisitor, bundledImports) {
                var parameterDeclaration = ts.getDeclarationOfKind(parameterSymbol, 164);
                if (!parameterDeclaration && !ts.isTransientSymbol(parameterSymbol)) {
                    parameterDeclaration = ts.getDeclarationOfKind(parameterSymbol, 340);
                }
                var parameterType = getTypeOfSymbol(parameterSymbol);
                if (parameterDeclaration && isRequiredInitializedParameter(parameterDeclaration)) {
                    parameterType = getOptionalType(parameterType);
                }
                var parameterTypeNode = serializeTypeForDeclaration(context, parameterType, parameterSymbol, context.enclosingDeclaration, privateSymbolVisitor, bundledImports);
                var modifiers = !(context.flags & 8192) && preserveModifierFlags && parameterDeclaration && parameterDeclaration.modifiers ? parameterDeclaration.modifiers.map(ts.factory.cloneNode) : undefined;
                var isRest = parameterDeclaration && ts.isRestParameter(parameterDeclaration) || ts.getCheckFlags(parameterSymbol) & 32768;
                var dotDotDotToken = isRest ? ts.factory.createToken(25) : undefined;
                var name = parameterDeclaration ? parameterDeclaration.name ?
                    parameterDeclaration.name.kind === 79 ? ts.setEmitFlags(ts.factory.cloneNode(parameterDeclaration.name), 16777216) :
                        parameterDeclaration.name.kind === 161 ? ts.setEmitFlags(ts.factory.cloneNode(parameterDeclaration.name.right), 16777216) :
                            cloneBindingName(parameterDeclaration.name) :
                    ts.symbolName(parameterSymbol) :
                    ts.symbolName(parameterSymbol);
                var isOptional = parameterDeclaration && isOptionalParameter(parameterDeclaration) || ts.getCheckFlags(parameterSymbol) & 16384;
                var questionToken = isOptional ? ts.factory.createToken(57) : undefined;
                var parameterNode = ts.factory.createParameterDeclaration(undefined, modifiers, dotDotDotToken, name, questionToken, parameterTypeNode, undefined);
                context.approximateLength += ts.symbolName(parameterSymbol).length + 3;
                return parameterNode;
                function cloneBindingName(node) {
                    return elideInitializerAndSetEmitFlags(node);
                    function elideInitializerAndSetEmitFlags(node) {
                        if (context.tracker.trackSymbol && ts.isComputedPropertyName(node) && isLateBindableName(node)) {
                            trackComputedName(node.expression, context.enclosingDeclaration, context);
                        }
                        var visited = ts.visitEachChild(node, elideInitializerAndSetEmitFlags, ts.nullTransformationContext, undefined, elideInitializerAndSetEmitFlags);
                        if (ts.isBindingElement(visited)) {
                            visited = ts.factory.updateBindingElement(visited, visited.dotDotDotToken, visited.propertyName, visited.name, undefined);
                        }
                        if (!ts.nodeIsSynthesized(visited)) {
                            visited = ts.factory.cloneNode(visited);
                        }
                        return ts.setEmitFlags(visited, 1 | 16777216);
                    }
                }
            }
            function trackComputedName(accessExpression, enclosingDeclaration, context) {
                if (!context.tracker.trackSymbol)
                    return;
                var firstIdentifier = ts.getFirstIdentifier(accessExpression);
                var name = resolveName(firstIdentifier, firstIdentifier.escapedText, 111551 | 1048576, undefined, undefined, true);
                if (name) {
                    context.tracker.trackSymbol(name, enclosingDeclaration, 111551);
                }
            }
            function lookupSymbolChain(symbol, context, meaning, yieldModuleSymbol) {
                context.tracker.trackSymbol(symbol, context.enclosingDeclaration, meaning);
                return lookupSymbolChainWorker(symbol, context, meaning, yieldModuleSymbol);
            }
            function lookupSymbolChainWorker(symbol, context, meaning, yieldModuleSymbol) {
                var chain;
                var isTypeParameter = symbol.flags & 262144;
                if (!isTypeParameter && (context.enclosingDeclaration || context.flags & 64) && !(context.flags & 134217728)) {
                    chain = ts.Debug.checkDefined(getSymbolChain(symbol, meaning, true));
                    ts.Debug.assert(chain && chain.length > 0);
                }
                else {
                    chain = [symbol];
                }
                return chain;
                function getSymbolChain(symbol, meaning, endOfChain) {
                    var accessibleSymbolChain = getAccessibleSymbolChain(symbol, context.enclosingDeclaration, meaning, !!(context.flags & 128));
                    var parentSpecifiers;
                    if (!accessibleSymbolChain ||
                        needsQualification(accessibleSymbolChain[0], context.enclosingDeclaration, accessibleSymbolChain.length === 1 ? meaning : getQualifiedLeftMeaning(meaning))) {
                        var parents_1 = getContainersOfSymbol(accessibleSymbolChain ? accessibleSymbolChain[0] : symbol, context.enclosingDeclaration, meaning);
                        if (ts.length(parents_1)) {
                            parentSpecifiers = parents_1.map(function (symbol) {
                                return ts.some(symbol.declarations, hasNonGlobalAugmentationExternalModuleSymbol)
                                    ? getSpecifierForModuleSymbol(symbol, context)
                                    : undefined;
                            });
                            var indices = parents_1.map(function (_, i) { return i; });
                            indices.sort(sortByBestName);
                            var sortedParents = indices.map(function (i) { return parents_1[i]; });
                            for (var _i = 0, sortedParents_1 = sortedParents; _i < sortedParents_1.length; _i++) {
                                var parent = sortedParents_1[_i];
                                var parentChain = getSymbolChain(parent, getQualifiedLeftMeaning(meaning), false);
                                if (parentChain) {
                                    if (parent.exports && parent.exports.get("export=") &&
                                        getSymbolIfSameReference(parent.exports.get("export="), symbol)) {
                                        accessibleSymbolChain = parentChain;
                                        break;
                                    }
                                    accessibleSymbolChain = parentChain.concat(accessibleSymbolChain || [getAliasForSymbolInContainer(parent, symbol) || symbol]);
                                    break;
                                }
                            }
                        }
                    }
                    if (accessibleSymbolChain) {
                        return accessibleSymbolChain;
                    }
                    if (endOfChain ||
                        !(symbol.flags & (2048 | 4096))) {
                        if (!endOfChain && !yieldModuleSymbol && !!ts.forEach(symbol.declarations, hasNonGlobalAugmentationExternalModuleSymbol)) {
                            return;
                        }
                        return [symbol];
                    }
                    function sortByBestName(a, b) {
                        var specifierA = parentSpecifiers[a];
                        var specifierB = parentSpecifiers[b];
                        if (specifierA && specifierB) {
                            var isBRelative = ts.pathIsRelative(specifierB);
                            if (ts.pathIsRelative(specifierA) === isBRelative) {
                                return ts.moduleSpecifiers.countPathComponents(specifierA) - ts.moduleSpecifiers.countPathComponents(specifierB);
                            }
                            if (isBRelative) {
                                return -1;
                            }
                            return 1;
                        }
                        return 0;
                    }
                }
            }
            function typeParametersToTypeParameterDeclarations(symbol, context) {
                var typeParameterNodes;
                var targetSymbol = getTargetSymbol(symbol);
                if (targetSymbol.flags & (32 | 64 | 524288)) {
                    typeParameterNodes = ts.factory.createNodeArray(ts.map(getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol), function (tp) { return typeParameterToDeclaration(tp, context); }));
                }
                return typeParameterNodes;
            }
            function lookupTypeParameterNodes(chain, index, context) {
                var _a;
                ts.Debug.assert(chain && 0 <= index && index < chain.length);
                var symbol = chain[index];
                var symbolId = getSymbolId(symbol);
                if ((_a = context.typeParameterSymbolList) === null || _a === void 0 ? void 0 : _a.has(symbolId)) {
                    return undefined;
                }
                (context.typeParameterSymbolList || (context.typeParameterSymbolList = new ts.Set())).add(symbolId);
                var typeParameterNodes;
                if (context.flags & 512 && index < (chain.length - 1)) {
                    var parentSymbol = symbol;
                    var nextSymbol_1 = chain[index + 1];
                    if (ts.getCheckFlags(nextSymbol_1) & 1) {
                        var params = getTypeParametersOfClassOrInterface(parentSymbol.flags & 2097152 ? resolveAlias(parentSymbol) : parentSymbol);
                        typeParameterNodes = mapToTypeNodes(ts.map(params, function (t) { return getMappedType(t, nextSymbol_1.mapper); }), context);
                    }
                    else {
                        typeParameterNodes = typeParametersToTypeParameterDeclarations(symbol, context);
                    }
                }
                return typeParameterNodes;
            }
            function getTopmostIndexedAccessType(top) {
                if (ts.isIndexedAccessTypeNode(top.objectType)) {
                    return getTopmostIndexedAccessType(top.objectType);
                }
                return top;
            }
            function getSpecifierForModuleSymbol(symbol, context, overrideImportMode) {
                var _a;
                var file = ts.getDeclarationOfKind(symbol, 305);
                if (!file) {
                    var equivalentFileSymbol = ts.firstDefined(symbol.declarations, function (d) { return getFileSymbolIfFileSymbolExportEqualsContainer(d, symbol); });
                    if (equivalentFileSymbol) {
                        file = ts.getDeclarationOfKind(equivalentFileSymbol, 305);
                    }
                }
                if (file && file.moduleName !== undefined) {
                    return file.moduleName;
                }
                if (!file) {
                    if (context.tracker.trackReferencedAmbientModule) {
                        var ambientDecls = ts.filter(symbol.declarations, ts.isAmbientModule);
                        if (ts.length(ambientDecls)) {
                            for (var _i = 0, _b = ambientDecls; _i < _b.length; _i++) {
                                var decl = _b[_i];
                                context.tracker.trackReferencedAmbientModule(decl, symbol);
                            }
                        }
                    }
                    if (ambientModuleSymbolRegex.test(symbol.escapedName)) {
                        return symbol.escapedName.substring(1, symbol.escapedName.length - 1);
                    }
                }
                if (!context.enclosingDeclaration || !context.tracker.moduleResolverHost) {
                    if (ambientModuleSymbolRegex.test(symbol.escapedName)) {
                        return symbol.escapedName.substring(1, symbol.escapedName.length - 1);
                    }
                    return ts.getSourceFileOfNode(ts.getNonAugmentationDeclaration(symbol)).fileName;
                }
                var contextFile = ts.getSourceFileOfNode(ts.getOriginalNode(context.enclosingDeclaration));
                var resolutionMode = overrideImportMode || (contextFile === null || contextFile === void 0 ? void 0 : contextFile.impliedNodeFormat);
                var cacheKey = getSpecifierCacheKey(contextFile.path, resolutionMode);
                var links = getSymbolLinks(symbol);
                var specifier = links.specifierCache && links.specifierCache.get(cacheKey);
                if (!specifier) {
                    var isBundle_1 = !!ts.outFile(compilerOptions);
                    var moduleResolverHost = context.tracker.moduleResolverHost;
                    var specifierCompilerOptions = isBundle_1 ? __assign(__assign({}, compilerOptions), { baseUrl: moduleResolverHost.getCommonSourceDirectory() }) : compilerOptions;
                    specifier = ts.first(ts.moduleSpecifiers.getModuleSpecifiers(symbol, checker, specifierCompilerOptions, contextFile, moduleResolverHost, {
                        importModuleSpecifierPreference: isBundle_1 ? "non-relative" : "project-relative",
                        importModuleSpecifierEnding: isBundle_1 ? "minimal"
                            : resolutionMode === ts.ModuleKind.ESNext ? "js"
                                : undefined,
                    }, { overrideImportMode: overrideImportMode }));
                    (_a = links.specifierCache) !== null && _a !== void 0 ? _a : (links.specifierCache = new ts.Map());
                    links.specifierCache.set(cacheKey, specifier);
                }
                return specifier;
                function getSpecifierCacheKey(path, mode) {
                    return mode === undefined ? path : "".concat(mode, "|").concat(path);
                }
            }
            function symbolToEntityNameNode(symbol) {
                var identifier = ts.factory.createIdentifier(ts.unescapeLeadingUnderscores(symbol.escapedName));
                return symbol.parent ? ts.factory.createQualifiedName(symbolToEntityNameNode(symbol.parent), identifier) : identifier;
            }
            function symbolToTypeNode(symbol, context, meaning, overrideTypeArguments) {
                var _a, _b, _c, _d;
                var chain = lookupSymbolChain(symbol, context, meaning, !(context.flags & 16384));
                var isTypeOf = meaning === 111551;
                if (ts.some(chain[0].declarations, hasNonGlobalAugmentationExternalModuleSymbol)) {
                    var nonRootParts = chain.length > 1 ? createAccessFromSymbolChain(chain, chain.length - 1, 1) : undefined;
                    var typeParameterNodes = overrideTypeArguments || lookupTypeParameterNodes(chain, 0, context);
                    var contextFile = ts.getSourceFileOfNode(ts.getOriginalNode(context.enclosingDeclaration));
                    var targetFile = ts.getSourceFileOfModule(chain[0]);
                    var specifier = void 0;
                    var assertion = void 0;
                    if (ts.getEmitModuleResolutionKind(compilerOptions) === ts.ModuleResolutionKind.Node16 || ts.getEmitModuleResolutionKind(compilerOptions) === ts.ModuleResolutionKind.NodeNext) {
                        if ((targetFile === null || targetFile === void 0 ? void 0 : targetFile.impliedNodeFormat) === ts.ModuleKind.ESNext && targetFile.impliedNodeFormat !== (contextFile === null || contextFile === void 0 ? void 0 : contextFile.impliedNodeFormat)) {
                            specifier = getSpecifierForModuleSymbol(chain[0], context, ts.ModuleKind.ESNext);
                            assertion = ts.factory.createImportTypeAssertionContainer(ts.factory.createAssertClause(ts.factory.createNodeArray([
                                ts.factory.createAssertEntry(ts.factory.createStringLiteral("resolution-mode"), ts.factory.createStringLiteral("import"))
                            ])));
                            (_b = (_a = context.tracker).reportImportTypeNodeResolutionModeOverride) === null || _b === void 0 ? void 0 : _b.call(_a);
                        }
                    }
                    if (!specifier) {
                        specifier = getSpecifierForModuleSymbol(chain[0], context);
                    }
                    if (!(context.flags & 67108864) && ts.getEmitModuleResolutionKind(compilerOptions) !== ts.ModuleResolutionKind.Classic && specifier.indexOf("/node_modules/") >= 0) {
                        var oldSpecifier = specifier;
                        if (ts.getEmitModuleResolutionKind(compilerOptions) === ts.ModuleResolutionKind.Node16 || ts.getEmitModuleResolutionKind(compilerOptions) === ts.ModuleResolutionKind.NodeNext) {
                            var swappedMode = (contextFile === null || contextFile === void 0 ? void 0 : contextFile.impliedNodeFormat) === ts.ModuleKind.ESNext ? ts.ModuleKind.CommonJS : ts.ModuleKind.ESNext;
                            specifier = getSpecifierForModuleSymbol(chain[0], context, swappedMode);
                            if (specifier.indexOf("/node_modules/") >= 0) {
                                specifier = oldSpecifier;
                            }
                            else {
                                assertion = ts.factory.createImportTypeAssertionContainer(ts.factory.createAssertClause(ts.factory.createNodeArray([
                                    ts.factory.createAssertEntry(ts.factory.createStringLiteral("resolution-mode"), ts.factory.createStringLiteral(swappedMode === ts.ModuleKind.ESNext ? "import" : "require"))
                                ])));
                                (_d = (_c = context.tracker).reportImportTypeNodeResolutionModeOverride) === null || _d === void 0 ? void 0 : _d.call(_c);
                            }
                        }
                        if (!assertion) {
                            context.encounteredError = true;
                            if (context.tracker.reportLikelyUnsafeImportRequiredError) {
                                context.tracker.reportLikelyUnsafeImportRequiredError(oldSpecifier);
                            }
                        }
                    }
                    var lit = ts.factory.createLiteralTypeNode(ts.factory.createStringLiteral(specifier));
                    if (context.tracker.trackExternalModuleSymbolOfImportTypeNode)
                        context.tracker.trackExternalModuleSymbolOfImportTypeNode(chain[0]);
                    context.approximateLength += specifier.length + 10;
                    if (!nonRootParts || ts.isEntityName(nonRootParts)) {
                        if (nonRootParts) {
                            var lastId = ts.isIdentifier(nonRootParts) ? nonRootParts : nonRootParts.right;
                            lastId.typeArguments = undefined;
                        }
                        return ts.factory.createImportTypeNode(lit, assertion, nonRootParts, typeParameterNodes, isTypeOf);
                    }
                    else {
                        var splitNode = getTopmostIndexedAccessType(nonRootParts);
                        var qualifier = splitNode.objectType.typeName;
                        return ts.factory.createIndexedAccessTypeNode(ts.factory.createImportTypeNode(lit, assertion, qualifier, typeParameterNodes, isTypeOf), splitNode.indexType);
                    }
                }
                var entityName = createAccessFromSymbolChain(chain, chain.length - 1, 0);
                if (ts.isIndexedAccessTypeNode(entityName)) {
                    return entityName;
                }
                if (isTypeOf) {
                    return ts.factory.createTypeQueryNode(entityName);
                }
                else {
                    var lastId = ts.isIdentifier(entityName) ? entityName : entityName.right;
                    var lastTypeArgs = lastId.typeArguments;
                    lastId.typeArguments = undefined;
                    return ts.factory.createTypeReferenceNode(entityName, lastTypeArgs);
                }
                function createAccessFromSymbolChain(chain, index, stopper) {
                    var typeParameterNodes = index === (chain.length - 1) ? overrideTypeArguments : lookupTypeParameterNodes(chain, index, context);
                    var symbol = chain[index];
                    var parent = chain[index - 1];
                    var symbolName;
                    if (index === 0) {
                        context.flags |= 16777216;
                        symbolName = getNameOfSymbolAsWritten(symbol, context);
                        context.approximateLength += (symbolName ? symbolName.length : 0) + 1;
                        context.flags ^= 16777216;
                    }
                    else {
                        if (parent && getExportsOfSymbol(parent)) {
                            var exports_2 = getExportsOfSymbol(parent);
                            ts.forEachEntry(exports_2, function (ex, name) {
                                if (getSymbolIfSameReference(ex, symbol) && !isLateBoundName(name) && name !== "export=") {
                                    symbolName = ts.unescapeLeadingUnderscores(name);
                                    return true;
                                }
                            });
                        }
                    }
                    if (symbolName === undefined) {
                        var name = ts.firstDefined(symbol.declarations, ts.getNameOfDeclaration);
                        if (name && ts.isComputedPropertyName(name) && ts.isEntityName(name.expression)) {
                            var LHS = createAccessFromSymbolChain(chain, index - 1, stopper);
                            if (ts.isEntityName(LHS)) {
                                return ts.factory.createIndexedAccessTypeNode(ts.factory.createParenthesizedType(ts.factory.createTypeQueryNode(LHS)), ts.factory.createTypeQueryNode(name.expression));
                            }
                            return LHS;
                        }
                        symbolName = getNameOfSymbolAsWritten(symbol, context);
                    }
                    context.approximateLength += symbolName.length + 1;
                    if (!(context.flags & 16) && parent &&
                        getMembersOfSymbol(parent) && getMembersOfSymbol(parent).get(symbol.escapedName) &&
                        getSymbolIfSameReference(getMembersOfSymbol(parent).get(symbol.escapedName), symbol)) {
                        var LHS = createAccessFromSymbolChain(chain, index - 1, stopper);
                        if (ts.isIndexedAccessTypeNode(LHS)) {
                            return ts.factory.createIndexedAccessTypeNode(LHS, ts.factory.createLiteralTypeNode(ts.factory.createStringLiteral(symbolName)));
                        }
                        else {
                            return ts.factory.createIndexedAccessTypeNode(ts.factory.createTypeReferenceNode(LHS, typeParameterNodes), ts.factory.createLiteralTypeNode(ts.factory.createStringLiteral(symbolName)));
                        }
                    }
                    var identifier = ts.setEmitFlags(ts.factory.createIdentifier(symbolName, typeParameterNodes), 16777216);
                    identifier.symbol = symbol;
                    if (index > stopper) {
                        var LHS = createAccessFromSymbolChain(chain, index - 1, stopper);
                        if (!ts.isEntityName(LHS)) {
                            return ts.Debug.fail("Impossible construct - an export of an indexed access cannot be reachable");
                        }
                        return ts.factory.createQualifiedName(LHS, identifier);
                    }
                    return identifier;
                }
            }
            function typeParameterShadowsNameInScope(escapedName, context, type) {
                var result = resolveName(context.enclosingDeclaration, escapedName, 788968, undefined, escapedName, false);
                if (result) {
                    if (result.flags & 262144 && result === type.symbol) {
                        return false;
                    }
                    return true;
                }
                return false;
            }
            function typeParameterToName(type, context) {
                var _a, _b;
                if (context.flags & 4 && context.typeParameterNames) {
                    var cached = context.typeParameterNames.get(getTypeId(type));
                    if (cached) {
                        return cached;
                    }
                }
                var result = symbolToName(type.symbol, context, 788968, true);
                if (!(result.kind & 79)) {
                    return ts.factory.createIdentifier("(Missing type parameter)");
                }
                if (context.flags & 4) {
                    var rawtext = result.escapedText;
                    var i = ((_a = context.typeParameterNamesByTextNextNameCount) === null || _a === void 0 ? void 0 : _a.get(rawtext)) || 0;
                    var text = rawtext;
                    while (((_b = context.typeParameterNamesByText) === null || _b === void 0 ? void 0 : _b.has(text)) || typeParameterShadowsNameInScope(text, context, type)) {
                        i++;
                        text = "".concat(rawtext, "_").concat(i);
                    }
                    if (text !== rawtext) {
                        result = ts.factory.createIdentifier(text, result.typeArguments);
                    }
                    (context.typeParameterNamesByTextNextNameCount || (context.typeParameterNamesByTextNextNameCount = new ts.Map())).set(rawtext, i);
                    (context.typeParameterNames || (context.typeParameterNames = new ts.Map())).set(getTypeId(type), result);
                    (context.typeParameterNamesByText || (context.typeParameterNamesByText = new ts.Set())).add(rawtext);
                }
                return result;
            }
            function symbolToName(symbol, context, meaning, expectsIdentifier) {
                var chain = lookupSymbolChain(symbol, context, meaning);
                if (expectsIdentifier && chain.length !== 1
                    && !context.encounteredError
                    && !(context.flags & 65536)) {
                    context.encounteredError = true;
                }
                return createEntityNameFromSymbolChain(chain, chain.length - 1);
                function createEntityNameFromSymbolChain(chain, index) {
                    var typeParameterNodes = lookupTypeParameterNodes(chain, index, context);
                    var symbol = chain[index];
                    if (index === 0) {
                        context.flags |= 16777216;
                    }
                    var symbolName = getNameOfSymbolAsWritten(symbol, context);
                    if (index === 0) {
                        context.flags ^= 16777216;
                    }
                    var identifier = ts.setEmitFlags(ts.factory.createIdentifier(symbolName, typeParameterNodes), 16777216);
                    identifier.symbol = symbol;
                    return index > 0 ? ts.factory.createQualifiedName(createEntityNameFromSymbolChain(chain, index - 1), identifier) : identifier;
                }
            }
            function symbolToExpression(symbol, context, meaning) {
                var chain = lookupSymbolChain(symbol, context, meaning);
                return createExpressionFromSymbolChain(chain, chain.length - 1);
                function createExpressionFromSymbolChain(chain, index) {
                    var typeParameterNodes = lookupTypeParameterNodes(chain, index, context);
                    var symbol = chain[index];
                    if (index === 0) {
                        context.flags |= 16777216;
                    }
                    var symbolName = getNameOfSymbolAsWritten(symbol, context);
                    if (index === 0) {
                        context.flags ^= 16777216;
                    }
                    var firstChar = symbolName.charCodeAt(0);
                    if (ts.isSingleOrDoubleQuote(firstChar) && ts.some(symbol.declarations, hasNonGlobalAugmentationExternalModuleSymbol)) {
                        return ts.factory.createStringLiteral(getSpecifierForModuleSymbol(symbol, context));
                    }
                    var canUsePropertyAccess = firstChar === 35 ?
                        symbolName.length > 1 && ts.isIdentifierStart(symbolName.charCodeAt(1), languageVersion) :
                        ts.isIdentifierStart(firstChar, languageVersion);
                    if (index === 0 || canUsePropertyAccess) {
                        var identifier = ts.setEmitFlags(ts.factory.createIdentifier(symbolName, typeParameterNodes), 16777216);
                        identifier.symbol = symbol;
                        return index > 0 ? ts.factory.createPropertyAccessExpression(createExpressionFromSymbolChain(chain, index - 1), identifier) : identifier;
                    }
                    else {
                        if (firstChar === 91) {
                            symbolName = symbolName.substring(1, symbolName.length - 1);
                            firstChar = symbolName.charCodeAt(0);
                        }
                        var expression = void 0;
                        if (ts.isSingleOrDoubleQuote(firstChar) && !(symbol.flags & 8)) {
                            expression = ts.factory.createStringLiteral(ts.stripQuotes(symbolName).replace(/\\./g, function (s) { return s.substring(1); }), firstChar === 39);
                        }
                        else if (("" + +symbolName) === symbolName) {
                            expression = ts.factory.createNumericLiteral(+symbolName);
                        }
                        if (!expression) {
                            expression = ts.setEmitFlags(ts.factory.createIdentifier(symbolName, typeParameterNodes), 16777216);
                            expression.symbol = symbol;
                        }
                        return ts.factory.createElementAccessExpression(createExpressionFromSymbolChain(chain, index - 1), expression);
                    }
                }
            }
            function isStringNamed(d) {
                var name = ts.getNameOfDeclaration(d);
                return !!name && ts.isStringLiteral(name);
            }
            function isSingleQuotedStringNamed(d) {
                var name = ts.getNameOfDeclaration(d);
                return !!(name && ts.isStringLiteral(name) && (name.singleQuote || !ts.nodeIsSynthesized(name) && ts.startsWith(ts.getTextOfNode(name, false), "'")));
            }
            function getPropertyNameNodeForSymbol(symbol, context) {
                var singleQuote = !!ts.length(symbol.declarations) && ts.every(symbol.declarations, isSingleQuotedStringNamed);
                var fromNameType = getPropertyNameNodeForSymbolFromNameType(symbol, context, singleQuote);
                if (fromNameType) {
                    return fromNameType;
                }
                var rawName = ts.unescapeLeadingUnderscores(symbol.escapedName);
                var stringNamed = !!ts.length(symbol.declarations) && ts.every(symbol.declarations, isStringNamed);
                return ts.createPropertyNameNodeForIdentifierOrLiteral(rawName, ts.getEmitScriptTarget(compilerOptions), singleQuote, stringNamed);
            }
            function getPropertyNameNodeForSymbolFromNameType(symbol, context, singleQuote) {
                var nameType = getSymbolLinks(symbol).nameType;
                if (nameType) {
                    if (nameType.flags & 384) {
                        var name = "" + nameType.value;
                        if (!ts.isIdentifierText(name, ts.getEmitScriptTarget(compilerOptions)) && !ts.isNumericLiteralName(name)) {
                            return ts.factory.createStringLiteral(name, !!singleQuote);
                        }
                        if (ts.isNumericLiteralName(name) && ts.startsWith(name, "-")) {
                            return ts.factory.createComputedPropertyName(ts.factory.createNumericLiteral(+name));
                        }
                        return ts.createPropertyNameNodeForIdentifierOrLiteral(name, ts.getEmitScriptTarget(compilerOptions));
                    }
                    if (nameType.flags & 8192) {
                        return ts.factory.createComputedPropertyName(symbolToExpression(nameType.symbol, context, 111551));
                    }
                }
            }
            function cloneNodeBuilderContext(context) {
                var initial = __assign({}, context);
                if (initial.typeParameterNames) {
                    initial.typeParameterNames = new ts.Map(initial.typeParameterNames);
                }
                if (initial.typeParameterNamesByText) {
                    initial.typeParameterNamesByText = new ts.Set(initial.typeParameterNamesByText);
                }
                if (initial.typeParameterSymbolList) {
                    initial.typeParameterSymbolList = new ts.Set(initial.typeParameterSymbolList);
                }
                initial.tracker = wrapSymbolTrackerToReportForContext(initial, initial.tracker);
                return initial;
            }
            function getDeclarationWithTypeAnnotation(symbol, enclosingDeclaration) {
                return symbol.declarations && ts.find(symbol.declarations, function (s) { return !!ts.getEffectiveTypeAnnotationNode(s) && (!enclosingDeclaration || !!ts.findAncestor(s, function (n) { return n === enclosingDeclaration; })); });
            }
            function existingTypeNodeIsNotReferenceOrIsReferenceWithCompatibleTypeArgumentCount(existing, type) {
                return !(ts.getObjectFlags(type) & 4) || !ts.isTypeReferenceNode(existing) || ts.length(existing.typeArguments) >= getMinTypeArgumentCount(type.target.typeParameters);
            }
            function serializeTypeForDeclaration(context, type, symbol, enclosingDeclaration, includePrivateSymbol, bundled) {
                if (!isErrorType(type) && enclosingDeclaration) {
                    var declWithExistingAnnotation = getDeclarationWithTypeAnnotation(symbol, enclosingDeclaration);
                    if (declWithExistingAnnotation && !ts.isFunctionLikeDeclaration(declWithExistingAnnotation) && !ts.isGetAccessorDeclaration(declWithExistingAnnotation)) {
                        var existing = ts.getEffectiveTypeAnnotationNode(declWithExistingAnnotation);
                        if (typeNodeIsEquivalentToType(existing, declWithExistingAnnotation, type) && existingTypeNodeIsNotReferenceOrIsReferenceWithCompatibleTypeArgumentCount(existing, type)) {
                            var result_6 = serializeExistingTypeNode(context, existing, includePrivateSymbol, bundled);
                            if (result_6) {
                                return result_6;
                            }
                        }
                    }
                }
                var oldFlags = context.flags;
                if (type.flags & 8192 &&
                    type.symbol === symbol && (!context.enclosingDeclaration || ts.some(symbol.declarations, function (d) { return ts.getSourceFileOfNode(d) === ts.getSourceFileOfNode(context.enclosingDeclaration); }))) {
                    context.flags |= 1048576;
                }
                var result = typeToTypeNodeHelper(type, context);
                context.flags = oldFlags;
                return result;
            }
            function typeNodeIsEquivalentToType(typeNode, annotatedDeclaration, type) {
                var typeFromTypeNode = getTypeFromTypeNode(typeNode);
                if (typeFromTypeNode === type) {
                    return true;
                }
                if (ts.isParameter(annotatedDeclaration) && annotatedDeclaration.questionToken) {
                    return getTypeWithFacts(type, 524288) === typeFromTypeNode;
                }
                return false;
            }
            function serializeReturnTypeForSignature(context, type, signature, includePrivateSymbol, bundled) {
                if (!isErrorType(type) && context.enclosingDeclaration) {
                    var annotation = signature.declaration && ts.getEffectiveReturnTypeNode(signature.declaration);
                    if (!!ts.findAncestor(annotation, function (n) { return n === context.enclosingDeclaration; }) && annotation) {
                        var annotated = getTypeFromTypeNode(annotation);
                        var thisInstantiated = annotated.flags & 262144 && annotated.isThisType ? instantiateType(annotated, signature.mapper) : annotated;
                        if (thisInstantiated === type && existingTypeNodeIsNotReferenceOrIsReferenceWithCompatibleTypeArgumentCount(annotation, type)) {
                            var result = serializeExistingTypeNode(context, annotation, includePrivateSymbol, bundled);
                            if (result) {
                                return result;
                            }
                        }
                    }
                }
                return typeToTypeNodeHelper(type, context);
            }
            function trackExistingEntityName(node, context, includePrivateSymbol) {
                var _a, _b;
                var introducesError = false;
                var leftmost = ts.getFirstIdentifier(node);
                if (ts.isInJSFile(node) && (ts.isExportsIdentifier(leftmost) || ts.isModuleExportsAccessExpression(leftmost.parent) || (ts.isQualifiedName(leftmost.parent) && ts.isModuleIdentifier(leftmost.parent.left) && ts.isExportsIdentifier(leftmost.parent.right)))) {
                    introducesError = true;
                    return { introducesError: introducesError, node: node };
                }
                var sym = resolveEntityName(leftmost, 67108863, true, true);
                if (sym) {
                    if (isSymbolAccessible(sym, context.enclosingDeclaration, 67108863, false).accessibility !== 0) {
                        introducesError = true;
                    }
                    else {
                        (_b = (_a = context.tracker) === null || _a === void 0 ? void 0 : _a.trackSymbol) === null || _b === void 0 ? void 0 : _b.call(_a, sym, context.enclosingDeclaration, 67108863);
                        includePrivateSymbol === null || includePrivateSymbol === void 0 ? void 0 : includePrivateSymbol(sym);
                    }
                    if (ts.isIdentifier(node)) {
                        var type = getDeclaredTypeOfSymbol(sym);
                        var name = sym.flags & 262144 && !isTypeSymbolAccessible(type.symbol, context.enclosingDeclaration) ? typeParameterToName(type, context) : ts.factory.cloneNode(node);
                        name.symbol = sym;
                        return { introducesError: introducesError, node: ts.setEmitFlags(ts.setOriginalNode(name, node), 16777216) };
                    }
                }
                return { introducesError: introducesError, node: node };
            }
            function serializeExistingTypeNode(context, existing, includePrivateSymbol, bundled) {
                if (cancellationToken && cancellationToken.throwIfCancellationRequested) {
                    cancellationToken.throwIfCancellationRequested();
                }
                var hadError = false;
                var file = ts.getSourceFileOfNode(existing);
                var transformed = ts.visitNode(existing, visitExistingNodeTreeSymbols);
                if (hadError) {
                    return undefined;
                }
                return transformed === existing ? ts.setTextRange(ts.factory.cloneNode(existing), existing) : transformed;
                function visitExistingNodeTreeSymbols(node) {
                    if (ts.isJSDocAllType(node) || node.kind === 319) {
                        return ts.factory.createKeywordTypeNode(130);
                    }
                    if (ts.isJSDocUnknownType(node)) {
                        return ts.factory.createKeywordTypeNode(155);
                    }
                    if (ts.isJSDocNullableType(node)) {
                        return ts.factory.createUnionTypeNode([ts.visitNode(node.type, visitExistingNodeTreeSymbols), ts.factory.createLiteralTypeNode(ts.factory.createNull())]);
                    }
                    if (ts.isJSDocOptionalType(node)) {
                        return ts.factory.createUnionTypeNode([ts.visitNode(node.type, visitExistingNodeTreeSymbols), ts.factory.createKeywordTypeNode(153)]);
                    }
                    if (ts.isJSDocNonNullableType(node)) {
                        return ts.visitNode(node.type, visitExistingNodeTreeSymbols);
                    }
                    if (ts.isJSDocVariadicType(node)) {
                        return ts.factory.createArrayTypeNode(ts.visitNode(node.type, visitExistingNodeTreeSymbols));
                    }
                    if (ts.isJSDocTypeLiteral(node)) {
                        return ts.factory.createTypeLiteralNode(ts.map(node.jsDocPropertyTags, function (t) {
                            var name = ts.isIdentifier(t.name) ? t.name : t.name.right;
                            var typeViaParent = getTypeOfPropertyOfType(getTypeFromTypeNode(node), name.escapedText);
                            var overrideTypeNode = typeViaParent && t.typeExpression && getTypeFromTypeNode(t.typeExpression.type) !== typeViaParent ? typeToTypeNodeHelper(typeViaParent, context) : undefined;
                            return ts.factory.createPropertySignature(undefined, name, t.isBracketed || t.typeExpression && ts.isJSDocOptionalType(t.typeExpression.type) ? ts.factory.createToken(57) : undefined, overrideTypeNode || (t.typeExpression && ts.visitNode(t.typeExpression.type, visitExistingNodeTreeSymbols)) || ts.factory.createKeywordTypeNode(130));
                        }));
                    }
                    if (ts.isTypeReferenceNode(node) && ts.isIdentifier(node.typeName) && node.typeName.escapedText === "") {
                        return ts.setOriginalNode(ts.factory.createKeywordTypeNode(130), node);
                    }
                    if ((ts.isExpressionWithTypeArguments(node) || ts.isTypeReferenceNode(node)) && ts.isJSDocIndexSignature(node)) {
                        return ts.factory.createTypeLiteralNode([ts.factory.createIndexSignature(undefined, undefined, [ts.factory.createParameterDeclaration(undefined, undefined, undefined, "x", undefined, ts.visitNode(node.typeArguments[0], visitExistingNodeTreeSymbols))], ts.visitNode(node.typeArguments[1], visitExistingNodeTreeSymbols))]);
                    }
                    if (ts.isJSDocFunctionType(node)) {
                        if (ts.isJSDocConstructSignature(node)) {
                            var newTypeNode_1;
                            return ts.factory.createConstructorTypeNode(node.modifiers, ts.visitNodes(node.typeParameters, visitExistingNodeTreeSymbols), ts.mapDefined(node.parameters, function (p, i) { return p.name && ts.isIdentifier(p.name) && p.name.escapedText === "new" ? (newTypeNode_1 = p.type, undefined) : ts.factory.createParameterDeclaration(undefined, undefined, getEffectiveDotDotDotForParameter(p), getNameForJSDocFunctionParameter(p, i), p.questionToken, ts.visitNode(p.type, visitExistingNodeTreeSymbols), undefined); }), ts.visitNode(newTypeNode_1 || node.type, visitExistingNodeTreeSymbols) || ts.factory.createKeywordTypeNode(130));
                        }
                        else {
                            return ts.factory.createFunctionTypeNode(ts.visitNodes(node.typeParameters, visitExistingNodeTreeSymbols), ts.map(node.parameters, function (p, i) { return ts.factory.createParameterDeclaration(undefined, undefined, getEffectiveDotDotDotForParameter(p), getNameForJSDocFunctionParameter(p, i), p.questionToken, ts.visitNode(p.type, visitExistingNodeTreeSymbols), undefined); }), ts.visitNode(node.type, visitExistingNodeTreeSymbols) || ts.factory.createKeywordTypeNode(130));
                        }
                    }
                    if (ts.isTypeReferenceNode(node) && ts.isInJSDoc(node) && (!existingTypeNodeIsNotReferenceOrIsReferenceWithCompatibleTypeArgumentCount(node, getTypeFromTypeNode(node)) || getIntendedTypeFromJSDocTypeReference(node) || unknownSymbol === resolveTypeReferenceName(node, 788968, true))) {
                        return ts.setOriginalNode(typeToTypeNodeHelper(getTypeFromTypeNode(node), context), node);
                    }
                    if (ts.isLiteralImportTypeNode(node)) {
                        var nodeSymbol = getNodeLinks(node).resolvedSymbol;
                        if (ts.isInJSDoc(node) &&
                            nodeSymbol &&
                            ((!node.isTypeOf && !(nodeSymbol.flags & 788968)) ||
                                !(ts.length(node.typeArguments) >= getMinTypeArgumentCount(getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(nodeSymbol))))) {
                            return ts.setOriginalNode(typeToTypeNodeHelper(getTypeFromTypeNode(node), context), node);
                        }
                        return ts.factory.updateImportTypeNode(node, ts.factory.updateLiteralTypeNode(node.argument, rewriteModuleSpecifier(node, node.argument.literal)), node.qualifier, ts.visitNodes(node.typeArguments, visitExistingNodeTreeSymbols, ts.isTypeNode), node.isTypeOf);
                    }
                    if (ts.isEntityName(node) || ts.isEntityNameExpression(node)) {
                        var _a = trackExistingEntityName(node, context, includePrivateSymbol), introducesError = _a.introducesError, result = _a.node;
                        hadError = hadError || introducesError;
                        if (result !== node) {
                            return result;
                        }
                    }
                    if (file && ts.isTupleTypeNode(node) && (ts.getLineAndCharacterOfPosition(file, node.pos).line === ts.getLineAndCharacterOfPosition(file, node.end).line)) {
                        ts.setEmitFlags(node, 1);
                    }
                    return ts.visitEachChild(node, visitExistingNodeTreeSymbols, ts.nullTransformationContext);
                    function getEffectiveDotDotDotForParameter(p) {
                        return p.dotDotDotToken || (p.type && ts.isJSDocVariadicType(p.type) ? ts.factory.createToken(25) : undefined);
                    }
                    function getNameForJSDocFunctionParameter(p, index) {
                        return p.name && ts.isIdentifier(p.name) && p.name.escapedText === "this" ? "this"
                            : getEffectiveDotDotDotForParameter(p) ? "args"
                                : "arg".concat(index);
                    }
                    function rewriteModuleSpecifier(parent, lit) {
                        if (bundled) {
                            if (context.tracker && context.tracker.moduleResolverHost) {
                                var targetFile = getExternalModuleFileFromDeclaration(parent);
                                if (targetFile) {
                                    var getCanonicalFileName = ts.createGetCanonicalFileName(!!host.useCaseSensitiveFileNames);
                                    var resolverHost = {
                                        getCanonicalFileName: getCanonicalFileName,
                                        getCurrentDirectory: function () { return context.tracker.moduleResolverHost.getCurrentDirectory(); },
                                        getCommonSourceDirectory: function () { return context.tracker.moduleResolverHost.getCommonSourceDirectory(); }
                                    };
                                    var newName = ts.getResolvedExternalModuleName(resolverHost, targetFile);
                                    return ts.factory.createStringLiteral(newName);
                                }
                            }
                        }
                        else {
                            if (context.tracker && context.tracker.trackExternalModuleSymbolOfImportTypeNode) {
                                var moduleSym = resolveExternalModuleNameWorker(lit, lit, undefined);
                                if (moduleSym) {
                                    context.tracker.trackExternalModuleSymbolOfImportTypeNode(moduleSym);
                                }
                            }
                        }
                        return lit;
                    }
                }
            }
            function symbolTableToDeclarationStatements(symbolTable, context, bundled) {
                var serializePropertySymbolForClass = makeSerializePropertySymbol(ts.factory.createPropertyDeclaration, 169, true);
                var serializePropertySymbolForInterfaceWorker = makeSerializePropertySymbol(function (_decorators, mods, name, question, type) { return ts.factory.createPropertySignature(mods, name, question, type); }, 168, false);
                var enclosingDeclaration = context.enclosingDeclaration;
                var results = [];
                var visitedSymbols = new ts.Set();
                var deferredPrivatesStack = [];
                var oldcontext = context;
                context = __assign(__assign({}, oldcontext), { usedSymbolNames: new ts.Set(oldcontext.usedSymbolNames), remappedSymbolNames: new ts.Map(), tracker: __assign(__assign({}, oldcontext.tracker), { trackSymbol: function (sym, decl, meaning) {
                            var accessibleResult = isSymbolAccessible(sym, decl, meaning, false);
                            if (accessibleResult.accessibility === 0) {
                                var chain = lookupSymbolChainWorker(sym, context, meaning);
                                if (!(sym.flags & 4)) {
                                    includePrivateSymbol(chain[0]);
                                }
                            }
                            else if (oldcontext.tracker && oldcontext.tracker.trackSymbol) {
                                return oldcontext.tracker.trackSymbol(sym, decl, meaning);
                            }
                            return false;
                        } }) });
                context.tracker = wrapSymbolTrackerToReportForContext(context, context.tracker);
                ts.forEachEntry(symbolTable, function (symbol, name) {
                    var baseName = ts.unescapeLeadingUnderscores(name);
                    void getInternalSymbolName(symbol, baseName);
                });
                var addingDeclare = !bundled;
                var exportEquals = symbolTable.get("export=");
                if (exportEquals && symbolTable.size > 1 && exportEquals.flags & 2097152) {
                    symbolTable = ts.createSymbolTable();
                    symbolTable.set("export=", exportEquals);
                }
                visitSymbolTable(symbolTable);
                return mergeRedundantStatements(results);
                function isIdentifierAndNotUndefined(node) {
                    return !!node && node.kind === 79;
                }
                function getNamesOfDeclaration(statement) {
                    if (ts.isVariableStatement(statement)) {
                        return ts.filter(ts.map(statement.declarationList.declarations, ts.getNameOfDeclaration), isIdentifierAndNotUndefined);
                    }
                    return ts.filter([ts.getNameOfDeclaration(statement)], isIdentifierAndNotUndefined);
                }
                function flattenExportAssignedNamespace(statements) {
                    var exportAssignment = ts.find(statements, ts.isExportAssignment);
                    var nsIndex = ts.findIndex(statements, ts.isModuleDeclaration);
                    var ns = nsIndex !== -1 ? statements[nsIndex] : undefined;
                    if (ns && exportAssignment && exportAssignment.isExportEquals &&
                        ts.isIdentifier(exportAssignment.expression) && ts.isIdentifier(ns.name) && ts.idText(ns.name) === ts.idText(exportAssignment.expression) &&
                        ns.body && ts.isModuleBlock(ns.body)) {
                        var excessExports = ts.filter(statements, function (s) { return !!(ts.getEffectiveModifierFlags(s) & 1); });
                        var name_3 = ns.name;
                        var body = ns.body;
                        if (ts.length(excessExports)) {
                            ns = ts.factory.updateModuleDeclaration(ns, ns.decorators, ns.modifiers, ns.name, body = ts.factory.updateModuleBlock(body, ts.factory.createNodeArray(__spreadArray(__spreadArray([], ns.body.statements, true), [ts.factory.createExportDeclaration(undefined, undefined, false, ts.factory.createNamedExports(ts.map(ts.flatMap(excessExports, function (e) { return getNamesOfDeclaration(e); }), function (id) { return ts.factory.createExportSpecifier(false, undefined, id); })), undefined)], false))));
                            statements = __spreadArray(__spreadArray(__spreadArray([], statements.slice(0, nsIndex), true), [ns], false), statements.slice(nsIndex + 1), true);
                        }
                        if (!ts.find(statements, function (s) { return s !== ns && ts.nodeHasName(s, name_3); })) {
                            results = [];
                            var mixinExportFlag_1 = !ts.some(body.statements, function (s) { return ts.hasSyntacticModifier(s, 1) || ts.isExportAssignment(s) || ts.isExportDeclaration(s); });
                            ts.forEach(body.statements, function (s) {
                                addResult(s, mixinExportFlag_1 ? 1 : 0);
                            });
                            statements = __spreadArray(__spreadArray([], ts.filter(statements, function (s) { return s !== ns && s !== exportAssignment; }), true), results, true);
                        }
                    }
                    return statements;
                }
                function mergeExportDeclarations(statements) {
                    var exports = ts.filter(statements, function (d) { return ts.isExportDeclaration(d) && !d.moduleSpecifier && !!d.exportClause && ts.isNamedExports(d.exportClause); });
                    if (ts.length(exports) > 1) {
                        var nonExports = ts.filter(statements, function (d) { return !ts.isExportDeclaration(d) || !!d.moduleSpecifier || !d.exportClause; });
                        statements = __spreadArray(__spreadArray([], nonExports, true), [ts.factory.createExportDeclaration(undefined, undefined, false, ts.factory.createNamedExports(ts.flatMap(exports, function (e) { return ts.cast(e.exportClause, ts.isNamedExports).elements; })), undefined)], false);
                    }
                    var reexports = ts.filter(statements, function (d) { return ts.isExportDeclaration(d) && !!d.moduleSpecifier && !!d.exportClause && ts.isNamedExports(d.exportClause); });
                    if (ts.length(reexports) > 1) {
                        var groups = ts.group(reexports, function (decl) { return ts.isStringLiteral(decl.moduleSpecifier) ? ">" + decl.moduleSpecifier.text : ">"; });
                        if (groups.length !== reexports.length) {
                            var _loop_9 = function (group_1) {
                                if (group_1.length > 1) {
                                    statements = __spreadArray(__spreadArray([], ts.filter(statements, function (s) { return group_1.indexOf(s) === -1; }), true), [
                                        ts.factory.createExportDeclaration(undefined, undefined, false, ts.factory.createNamedExports(ts.flatMap(group_1, function (e) { return ts.cast(e.exportClause, ts.isNamedExports).elements; })), group_1[0].moduleSpecifier)
                                    ], false);
                                }
                            };
                            for (var _i = 0, groups_1 = groups; _i < groups_1.length; _i++) {
                                var group_1 = groups_1[_i];
                                _loop_9(group_1);
                            }
                        }
                    }
                    return statements;
                }
                function inlineExportModifiers(statements) {
                    var index = ts.findIndex(statements, function (d) { return ts.isExportDeclaration(d) && !d.moduleSpecifier && !d.assertClause && !!d.exportClause && ts.isNamedExports(d.exportClause); });
                    if (index >= 0) {
                        var exportDecl = statements[index];
                        var replacements = ts.mapDefined(exportDecl.exportClause.elements, function (e) {
                            if (!e.propertyName) {
                                var indices = ts.indicesOf(statements);
                                var associatedIndices = ts.filter(indices, function (i) { return ts.nodeHasName(statements[i], e.name); });
                                if (ts.length(associatedIndices) && ts.every(associatedIndices, function (i) { return canHaveExportModifier(statements[i]); })) {
                                    for (var _i = 0, associatedIndices_1 = associatedIndices; _i < associatedIndices_1.length; _i++) {
                                        var index_1 = associatedIndices_1[_i];
                                        statements[index_1] = addExportModifier(statements[index_1]);
                                    }
                                    return undefined;
                                }
                            }
                            return e;
                        });
                        if (!ts.length(replacements)) {
                            ts.orderedRemoveItemAt(statements, index);
                        }
                        else {
                            statements[index] = ts.factory.updateExportDeclaration(exportDecl, exportDecl.decorators, exportDecl.modifiers, exportDecl.isTypeOnly, ts.factory.updateNamedExports(exportDecl.exportClause, replacements), exportDecl.moduleSpecifier, exportDecl.assertClause);
                        }
                    }
                    return statements;
                }
                function mergeRedundantStatements(statements) {
                    statements = flattenExportAssignedNamespace(statements);
                    statements = mergeExportDeclarations(statements);
                    statements = inlineExportModifiers(statements);
                    if (enclosingDeclaration &&
                        ((ts.isSourceFile(enclosingDeclaration) && ts.isExternalOrCommonJsModule(enclosingDeclaration)) || ts.isModuleDeclaration(enclosingDeclaration)) &&
                        (!ts.some(statements, ts.isExternalModuleIndicator) || (!ts.hasScopeMarker(statements) && ts.some(statements, ts.needsScopeMarker)))) {
                        statements.push(ts.createEmptyExports(ts.factory));
                    }
                    return statements;
                }
                function canHaveExportModifier(node) {
                    return ts.isEnumDeclaration(node) ||
                        ts.isVariableStatement(node) ||
                        ts.isFunctionDeclaration(node) ||
                        ts.isClassDeclaration(node) ||
                        (ts.isModuleDeclaration(node) && !ts.isExternalModuleAugmentation(node) && !ts.isGlobalScopeAugmentation(node)) ||
                        ts.isInterfaceDeclaration(node) ||
                        isTypeDeclaration(node);
                }
                function addExportModifier(node) {
                    var flags = (ts.getEffectiveModifierFlags(node) | 1) & ~2;
                    return ts.factory.updateModifiers(node, flags);
                }
                function removeExportModifier(node) {
                    var flags = ts.getEffectiveModifierFlags(node) & ~1;
                    return ts.factory.updateModifiers(node, flags);
                }
                function visitSymbolTable(symbolTable, suppressNewPrivateContext, propertyAsAlias) {
                    if (!suppressNewPrivateContext) {
                        deferredPrivatesStack.push(new ts.Map());
                    }
                    symbolTable.forEach(function (symbol) {
                        serializeSymbol(symbol, false, !!propertyAsAlias);
                    });
                    if (!suppressNewPrivateContext) {
                        deferredPrivatesStack[deferredPrivatesStack.length - 1].forEach(function (symbol) {
                            serializeSymbol(symbol, true, !!propertyAsAlias);
                        });
                        deferredPrivatesStack.pop();
                    }
                }
                function serializeSymbol(symbol, isPrivate, propertyAsAlias) {
                    var visitedSym = getMergedSymbol(symbol);
                    if (visitedSymbols.has(getSymbolId(visitedSym))) {
                        return;
                    }
                    visitedSymbols.add(getSymbolId(visitedSym));
                    var skipMembershipCheck = !isPrivate;
                    if (skipMembershipCheck || (!!ts.length(symbol.declarations) && ts.some(symbol.declarations, function (d) { return !!ts.findAncestor(d, function (n) { return n === enclosingDeclaration; }); }))) {
                        var oldContext = context;
                        context = cloneNodeBuilderContext(context);
                        var result = serializeSymbolWorker(symbol, isPrivate, propertyAsAlias);
                        if (context.reportedDiagnostic) {
                            oldcontext.reportedDiagnostic = context.reportedDiagnostic;
                        }
                        context = oldContext;
                        return result;
                    }
                }
                function serializeSymbolWorker(symbol, isPrivate, propertyAsAlias) {
                    var _a, _b, _c, _d;
                    var symbolName = ts.unescapeLeadingUnderscores(symbol.escapedName);
                    var isDefault = symbol.escapedName === "default";
                    if (isPrivate && !(context.flags & 131072) && ts.isStringANonContextualKeyword(symbolName) && !isDefault) {
                        context.encounteredError = true;
                        return;
                    }
                    var needsPostExportDefault = isDefault && !!(symbol.flags & -113
                        || (symbol.flags & 16 && ts.length(getPropertiesOfType(getTypeOfSymbol(symbol))))) && !(symbol.flags & 2097152);
                    var needsExportDeclaration = !needsPostExportDefault && !isPrivate && ts.isStringANonContextualKeyword(symbolName) && !isDefault;
                    if (needsPostExportDefault || needsExportDeclaration) {
                        isPrivate = true;
                    }
                    var modifierFlags = (!isPrivate ? 1 : 0) | (isDefault && !needsPostExportDefault ? 512 : 0);
                    var isConstMergedWithNS = symbol.flags & 1536 &&
                        symbol.flags & (2 | 1 | 4) &&
                        symbol.escapedName !== "export=";
                    var isConstMergedWithNSPrintableAsSignatureMerge = isConstMergedWithNS && isTypeRepresentableAsFunctionNamespaceMerge(getTypeOfSymbol(symbol), symbol);
                    if (symbol.flags & (16 | 8192) || isConstMergedWithNSPrintableAsSignatureMerge) {
                        serializeAsFunctionNamespaceMerge(getTypeOfSymbol(symbol), symbol, getInternalSymbolName(symbol, symbolName), modifierFlags);
                    }
                    if (symbol.flags & 524288) {
                        serializeTypeAlias(symbol, symbolName, modifierFlags);
                    }
                    if (symbol.flags & (2 | 1 | 4)
                        && symbol.escapedName !== "export="
                        && !(symbol.flags & 4194304)
                        && !(symbol.flags & 32)
                        && !isConstMergedWithNSPrintableAsSignatureMerge) {
                        if (propertyAsAlias) {
                            var createdExport = serializeMaybeAliasAssignment(symbol);
                            if (createdExport) {
                                needsExportDeclaration = false;
                                needsPostExportDefault = false;
                            }
                        }
                        else {
                            var type = getTypeOfSymbol(symbol);
                            var localName = getInternalSymbolName(symbol, symbolName);
                            if (!(symbol.flags & 16) && isTypeRepresentableAsFunctionNamespaceMerge(type, symbol)) {
                                serializeAsFunctionNamespaceMerge(type, symbol, localName, modifierFlags);
                            }
                            else {
                                var flags = !(symbol.flags & 2)
                                    ? ((_a = symbol.parent) === null || _a === void 0 ? void 0 : _a.valueDeclaration) && ts.isSourceFile((_b = symbol.parent) === null || _b === void 0 ? void 0 : _b.valueDeclaration)
                                        ? 2
                                        : undefined
                                    : isConstVariable(symbol)
                                        ? 2
                                        : 1;
                                var name = (needsPostExportDefault || !(symbol.flags & 4)) ? localName : getUnusedName(localName, symbol);
                                var textRange = symbol.declarations && ts.find(symbol.declarations, function (d) { return ts.isVariableDeclaration(d); });
                                if (textRange && ts.isVariableDeclarationList(textRange.parent) && textRange.parent.declarations.length === 1) {
                                    textRange = textRange.parent.parent;
                                }
                                var propertyAccessRequire = (_c = symbol.declarations) === null || _c === void 0 ? void 0 : _c.find(ts.isPropertyAccessExpression);
                                if (propertyAccessRequire && ts.isBinaryExpression(propertyAccessRequire.parent) && ts.isIdentifier(propertyAccessRequire.parent.right)
                                    && ((_d = type.symbol) === null || _d === void 0 ? void 0 : _d.valueDeclaration) && ts.isSourceFile(type.symbol.valueDeclaration)) {
                                    var alias = localName === propertyAccessRequire.parent.right.escapedText ? undefined : propertyAccessRequire.parent.right;
                                    addResult(ts.factory.createExportDeclaration(undefined, undefined, false, ts.factory.createNamedExports([ts.factory.createExportSpecifier(false, alias, localName)])), 0);
                                    context.tracker.trackSymbol(type.symbol, context.enclosingDeclaration, 111551);
                                }
                                else {
                                    var statement = ts.setTextRange(ts.factory.createVariableStatement(undefined, ts.factory.createVariableDeclarationList([
                                        ts.factory.createVariableDeclaration(name, undefined, serializeTypeForDeclaration(context, type, symbol, enclosingDeclaration, includePrivateSymbol, bundled))
                                    ], flags)), textRange);
                                    addResult(statement, name !== localName ? modifierFlags & ~1 : modifierFlags);
                                    if (name !== localName && !isPrivate) {
                                        addResult(ts.factory.createExportDeclaration(undefined, undefined, false, ts.factory.createNamedExports([ts.factory.createExportSpecifier(false, name, localName)])), 0);
                                        needsExportDeclaration = false;
                                        needsPostExportDefault = false;
                                    }
                                }
                            }
                        }
                    }
                    if (symbol.flags & 384) {
                        serializeEnum(symbol, symbolName, modifierFlags);
                    }
                    if (symbol.flags & 32) {
                        if (symbol.flags & 4
                            && symbol.valueDeclaration
                            && ts.isBinaryExpression(symbol.valueDeclaration.parent)
                            && ts.isClassExpression(symbol.valueDeclaration.parent.right)) {
                            serializeAsAlias(symbol, getInternalSymbolName(symbol, symbolName), modifierFlags);
                        }
                        else {
                            serializeAsClass(symbol, getInternalSymbolName(symbol, symbolName), modifierFlags);
                        }
                    }
                    if ((symbol.flags & (512 | 1024) && (!isConstMergedWithNS || isTypeOnlyNamespace(symbol))) || isConstMergedWithNSPrintableAsSignatureMerge) {
                        serializeModule(symbol, symbolName, modifierFlags);
                    }
                    if (symbol.flags & 64 && !(symbol.flags & 32)) {
                        serializeInterface(symbol, symbolName, modifierFlags);
                    }
                    if (symbol.flags & 2097152) {
                        serializeAsAlias(symbol, getInternalSymbolName(symbol, symbolName), modifierFlags);
                    }
                    if (symbol.flags & 4 && symbol.escapedName === "export=") {
                        serializeMaybeAliasAssignment(symbol);
                    }
                    if (symbol.flags & 8388608) {
                        if (symbol.declarations) {
                            for (var _i = 0, _e = symbol.declarations; _i < _e.length; _i++) {
                                var node = _e[_i];
                                var resolvedModule = resolveExternalModuleName(node, node.moduleSpecifier);
                                if (!resolvedModule)
                                    continue;
                                addResult(ts.factory.createExportDeclaration(undefined, undefined, false, undefined, ts.factory.createStringLiteral(getSpecifierForModuleSymbol(resolvedModule, context))), 0);
                            }
                        }
                    }
                    if (needsPostExportDefault) {
                        addResult(ts.factory.createExportAssignment(undefined, undefined, false, ts.factory.createIdentifier(getInternalSymbolName(symbol, symbolName))), 0);
                    }
                    else if (needsExportDeclaration) {
                        addResult(ts.factory.createExportDeclaration(undefined, undefined, false, ts.factory.createNamedExports([ts.factory.createExportSpecifier(false, getInternalSymbolName(symbol, symbolName), symbolName)])), 0);
                    }
                }
                function includePrivateSymbol(symbol) {
                    if (ts.some(symbol.declarations, ts.isParameterDeclaration))
                        return;
                    ts.Debug.assertIsDefined(deferredPrivatesStack[deferredPrivatesStack.length - 1]);
                    getUnusedName(ts.unescapeLeadingUnderscores(symbol.escapedName), symbol);
                    var isExternalImportAlias = !!(symbol.flags & 2097152) && !ts.some(symbol.declarations, function (d) {
                        return !!ts.findAncestor(d, ts.isExportDeclaration) ||
                            ts.isNamespaceExport(d) ||
                            (ts.isImportEqualsDeclaration(d) && !ts.isExternalModuleReference(d.moduleReference));
                    });
                    deferredPrivatesStack[isExternalImportAlias ? 0 : (deferredPrivatesStack.length - 1)].set(getSymbolId(symbol), symbol);
                }
                function isExportingScope(enclosingDeclaration) {
                    return ((ts.isSourceFile(enclosingDeclaration) && (ts.isExternalOrCommonJsModule(enclosingDeclaration) || ts.isJsonSourceFile(enclosingDeclaration))) ||
                        (ts.isAmbientModule(enclosingDeclaration) && !ts.isGlobalScopeAugmentation(enclosingDeclaration)));
                }
                function addResult(node, additionalModifierFlags) {
                    if (ts.canHaveModifiers(node)) {
                        var newModifierFlags = 0;
                        var enclosingDeclaration_1 = context.enclosingDeclaration &&
                            (ts.isJSDocTypeAlias(context.enclosingDeclaration) ? ts.getSourceFileOfNode(context.enclosingDeclaration) : context.enclosingDeclaration);
                        if (additionalModifierFlags & 1 &&
                            enclosingDeclaration_1 && (isExportingScope(enclosingDeclaration_1) || ts.isModuleDeclaration(enclosingDeclaration_1)) &&
                            canHaveExportModifier(node)) {
                            newModifierFlags |= 1;
                        }
                        if (addingDeclare && !(newModifierFlags & 1) &&
                            (!enclosingDeclaration_1 || !(enclosingDeclaration_1.flags & 16777216)) &&
                            (ts.isEnumDeclaration(node) || ts.isVariableStatement(node) || ts.isFunctionDeclaration(node) || ts.isClassDeclaration(node) || ts.isModuleDeclaration(node))) {
                            newModifierFlags |= 2;
                        }
                        if ((additionalModifierFlags & 512) && (ts.isClassDeclaration(node) || ts.isInterfaceDeclaration(node) || ts.isFunctionDeclaration(node))) {
                            newModifierFlags |= 512;
                        }
                        if (newModifierFlags) {
                            node = ts.factory.updateModifiers(node, newModifierFlags | ts.getEffectiveModifierFlags(node));
                        }
                    }
                    results.push(node);
                }
                function serializeTypeAlias(symbol, symbolName, modifierFlags) {
                    var _a;
                    var aliasType = getDeclaredTypeOfTypeAlias(symbol);
                    var typeParams = getSymbolLinks(symbol).typeParameters;
                    var typeParamDecls = ts.map(typeParams, function (p) { return typeParameterToDeclaration(p, context); });
                    var jsdocAliasDecl = (_a = symbol.declarations) === null || _a === void 0 ? void 0 : _a.find(ts.isJSDocTypeAlias);
                    var commentText = ts.getTextOfJSDocComment(jsdocAliasDecl ? jsdocAliasDecl.comment || jsdocAliasDecl.parent.comment : undefined);
                    var oldFlags = context.flags;
                    context.flags |= 8388608;
                    var oldEnclosingDecl = context.enclosingDeclaration;
                    context.enclosingDeclaration = jsdocAliasDecl;
                    var typeNode = jsdocAliasDecl && jsdocAliasDecl.typeExpression
                        && ts.isJSDocTypeExpression(jsdocAliasDecl.typeExpression)
                        && serializeExistingTypeNode(context, jsdocAliasDecl.typeExpression.type, includePrivateSymbol, bundled)
                        || typeToTypeNodeHelper(aliasType, context);
                    addResult(ts.setSyntheticLeadingComments(ts.factory.createTypeAliasDeclaration(undefined, undefined, getInternalSymbolName(symbol, symbolName), typeParamDecls, typeNode), !commentText ? [] : [{ kind: 3, text: "*\n * " + commentText.replace(/\n/g, "\n * ") + "\n ", pos: -1, end: -1, hasTrailingNewLine: true }]), modifierFlags);
                    context.flags = oldFlags;
                    context.enclosingDeclaration = oldEnclosingDecl;
                }
                function serializeInterface(symbol, symbolName, modifierFlags) {
                    var interfaceType = getDeclaredTypeOfClassOrInterface(symbol);
                    var localParams = getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol);
                    var typeParamDecls = ts.map(localParams, function (p) { return typeParameterToDeclaration(p, context); });
                    var baseTypes = getBaseTypes(interfaceType);
                    var baseType = ts.length(baseTypes) ? getIntersectionType(baseTypes) : undefined;
                    var members = ts.flatMap(getPropertiesOfType(interfaceType), function (p) { return serializePropertySymbolForInterface(p, baseType); });
                    var callSignatures = serializeSignatures(0, interfaceType, baseType, 174);
                    var constructSignatures = serializeSignatures(1, interfaceType, baseType, 175);
                    var indexSignatures = serializeIndexSignatures(interfaceType, baseType);
                    var heritageClauses = !ts.length(baseTypes) ? undefined : [ts.factory.createHeritageClause(94, ts.mapDefined(baseTypes, function (b) { return trySerializeAsTypeReference(b, 111551); }))];
                    addResult(ts.factory.createInterfaceDeclaration(undefined, undefined, getInternalSymbolName(symbol, symbolName), typeParamDecls, heritageClauses, __spreadArray(__spreadArray(__spreadArray(__spreadArray([], indexSignatures, true), constructSignatures, true), callSignatures, true), members, true)), modifierFlags);
                }
                function getNamespaceMembersForSerialization(symbol) {
                    return !symbol.exports ? [] : ts.filter(ts.arrayFrom(symbol.exports.values()), isNamespaceMember);
                }
                function isTypeOnlyNamespace(symbol) {
                    return ts.every(getNamespaceMembersForSerialization(symbol), function (m) { return !(resolveSymbol(m).flags & 111551); });
                }
                function serializeModule(symbol, symbolName, modifierFlags) {
                    var members = getNamespaceMembersForSerialization(symbol);
                    var locationMap = ts.arrayToMultiMap(members, function (m) { return m.parent && m.parent === symbol ? "real" : "merged"; });
                    var realMembers = locationMap.get("real") || ts.emptyArray;
                    var mergedMembers = locationMap.get("merged") || ts.emptyArray;
                    if (ts.length(realMembers)) {
                        var localName = getInternalSymbolName(symbol, symbolName);
                        serializeAsNamespaceDeclaration(realMembers, localName, modifierFlags, !!(symbol.flags & (16 | 67108864)));
                    }
                    if (ts.length(mergedMembers)) {
                        var containingFile_1 = ts.getSourceFileOfNode(context.enclosingDeclaration);
                        var localName = getInternalSymbolName(symbol, symbolName);
                        var nsBody = ts.factory.createModuleBlock([ts.factory.createExportDeclaration(undefined, undefined, false, ts.factory.createNamedExports(ts.mapDefined(ts.filter(mergedMembers, function (n) { return n.escapedName !== "export="; }), function (s) {
                                var _a, _b;
                                var name = ts.unescapeLeadingUnderscores(s.escapedName);
                                var localName = getInternalSymbolName(s, name);
                                var aliasDecl = s.declarations && getDeclarationOfAliasSymbol(s);
                                if (containingFile_1 && (aliasDecl ? containingFile_1 !== ts.getSourceFileOfNode(aliasDecl) : !ts.some(s.declarations, function (d) { return ts.getSourceFileOfNode(d) === containingFile_1; }))) {
                                    (_b = (_a = context.tracker) === null || _a === void 0 ? void 0 : _a.reportNonlocalAugmentation) === null || _b === void 0 ? void 0 : _b.call(_a, containingFile_1, symbol, s);
                                    return undefined;
                                }
                                var target = aliasDecl && getTargetOfAliasDeclaration(aliasDecl, true);
                                includePrivateSymbol(target || s);
                                var targetName = target ? getInternalSymbolName(target, ts.unescapeLeadingUnderscores(target.escapedName)) : localName;
                                return ts.factory.createExportSpecifier(false, name === targetName ? undefined : targetName, name);
                            })))]);
                        addResult(ts.factory.createModuleDeclaration(undefined, undefined, ts.factory.createIdentifier(localName), nsBody, 16), 0);
                    }
                }
                function serializeEnum(symbol, symbolName, modifierFlags) {
                    addResult(ts.factory.createEnumDeclaration(undefined, ts.factory.createModifiersFromModifierFlags(isConstEnumSymbol(symbol) ? 2048 : 0), getInternalSymbolName(symbol, symbolName), ts.map(ts.filter(getPropertiesOfType(getTypeOfSymbol(symbol)), function (p) { return !!(p.flags & 8); }), function (p) {
                        var initializedValue = p.declarations && p.declarations[0] && ts.isEnumMember(p.declarations[0]) ? getConstantValue(p.declarations[0]) : undefined;
                        return ts.factory.createEnumMember(ts.unescapeLeadingUnderscores(p.escapedName), initializedValue === undefined ? undefined :
                            typeof initializedValue === "string" ? ts.factory.createStringLiteral(initializedValue) :
                                ts.factory.createNumericLiteral(initializedValue));
                    })), modifierFlags);
                }
                function serializeAsFunctionNamespaceMerge(type, symbol, localName, modifierFlags) {
                    var signatures = getSignaturesOfType(type, 0);
                    for (var _i = 0, signatures_2 = signatures; _i < signatures_2.length; _i++) {
                        var sig = signatures_2[_i];
                        var decl = signatureToSignatureDeclarationHelper(sig, 256, context, { name: ts.factory.createIdentifier(localName), privateSymbolVisitor: includePrivateSymbol, bundledImports: bundled });
                        addResult(ts.setTextRange(decl, getSignatureTextRangeLocation(sig)), modifierFlags);
                    }
                    if (!(symbol.flags & (512 | 1024) && !!symbol.exports && !!symbol.exports.size)) {
                        var props = ts.filter(getPropertiesOfType(type), isNamespaceMember);
                        serializeAsNamespaceDeclaration(props, localName, modifierFlags, true);
                    }
                }
                function getSignatureTextRangeLocation(signature) {
                    if (signature.declaration && signature.declaration.parent) {
                        if (ts.isBinaryExpression(signature.declaration.parent) && ts.getAssignmentDeclarationKind(signature.declaration.parent) === 5) {
                            return signature.declaration.parent;
                        }
                        if (ts.isVariableDeclaration(signature.declaration.parent) && signature.declaration.parent.parent) {
                            return signature.declaration.parent.parent;
                        }
                    }
                    return signature.declaration;
                }
                function serializeAsNamespaceDeclaration(props, localName, modifierFlags, suppressNewPrivateContext) {
                    if (ts.length(props)) {
                        var localVsRemoteMap = ts.arrayToMultiMap(props, function (p) {
                            return !ts.length(p.declarations) || ts.some(p.declarations, function (d) {
                                return ts.getSourceFileOfNode(d) === ts.getSourceFileOfNode(context.enclosingDeclaration);
                            }) ? "local" : "remote";
                        });
                        var localProps = localVsRemoteMap.get("local") || ts.emptyArray;
                        var fakespace = ts.parseNodeFactory.createModuleDeclaration(undefined, undefined, ts.factory.createIdentifier(localName), ts.factory.createModuleBlock([]), 16);
                        ts.setParent(fakespace, enclosingDeclaration);
                        fakespace.locals = ts.createSymbolTable(props);
                        fakespace.symbol = props[0].parent;
                        var oldResults = results;
                        results = [];
                        var oldAddingDeclare = addingDeclare;
                        addingDeclare = false;
                        var subcontext = __assign(__assign({}, context), { enclosingDeclaration: fakespace });
                        var oldContext = context;
                        context = subcontext;
                        visitSymbolTable(ts.createSymbolTable(localProps), suppressNewPrivateContext, true);
                        context = oldContext;
                        addingDeclare = oldAddingDeclare;
                        var declarations = results;
                        results = oldResults;
                        var defaultReplaced = ts.map(declarations, function (d) { return ts.isExportAssignment(d) && !d.isExportEquals && ts.isIdentifier(d.expression) ? ts.factory.createExportDeclaration(undefined, undefined, false, ts.factory.createNamedExports([ts.factory.createExportSpecifier(false, d.expression, ts.factory.createIdentifier("default"))])) : d; });
                        var exportModifierStripped = ts.every(defaultReplaced, function (d) { return ts.hasSyntacticModifier(d, 1); }) ? ts.map(defaultReplaced, removeExportModifier) : defaultReplaced;
                        fakespace = ts.factory.updateModuleDeclaration(fakespace, fakespace.decorators, fakespace.modifiers, fakespace.name, ts.factory.createModuleBlock(exportModifierStripped));
                        addResult(fakespace, modifierFlags);
                    }
                }
                function isNamespaceMember(p) {
                    return !!(p.flags & (788968 | 1920 | 2097152)) ||
                        !(p.flags & 4194304 || p.escapedName === "prototype" || p.valueDeclaration && ts.isStatic(p.valueDeclaration) && ts.isClassLike(p.valueDeclaration.parent));
                }
                function sanitizeJSDocImplements(clauses) {
                    var result = ts.mapDefined(clauses, function (e) {
                        var _a;
                        var oldEnclosing = context.enclosingDeclaration;
                        context.enclosingDeclaration = e;
                        var expr = e.expression;
                        if (ts.isEntityNameExpression(expr)) {
                            if (ts.isIdentifier(expr) && ts.idText(expr) === "") {
                                return cleanup(undefined);
                            }
                            var introducesError = void 0;
                            (_a = trackExistingEntityName(expr, context, includePrivateSymbol), introducesError = _a.introducesError, expr = _a.node);
                            if (introducesError) {
                                return cleanup(undefined);
                            }
                        }
                        return cleanup(ts.factory.createExpressionWithTypeArguments(expr, ts.map(e.typeArguments, function (a) {
                            return serializeExistingTypeNode(context, a, includePrivateSymbol, bundled)
                                || typeToTypeNodeHelper(getTypeFromTypeNode(a), context);
                        })));
                        function cleanup(result) {
                            context.enclosingDeclaration = oldEnclosing;
                            return result;
                        }
                    });
                    if (result.length === clauses.length) {
                        return result;
                    }
                    return undefined;
                }
                function serializeAsClass(symbol, localName, modifierFlags) {
                    var _a, _b;
                    var originalDecl = (_a = symbol.declarations) === null || _a === void 0 ? void 0 : _a.find(ts.isClassLike);
                    var oldEnclosing = context.enclosingDeclaration;
                    context.enclosingDeclaration = originalDecl || oldEnclosing;
                    var localParams = getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol);
                    var typeParamDecls = ts.map(localParams, function (p) { return typeParameterToDeclaration(p, context); });
                    var classType = getDeclaredTypeOfClassOrInterface(symbol);
                    var baseTypes = getBaseTypes(classType);
                    var originalImplements = originalDecl && ts.getEffectiveImplementsTypeNodes(originalDecl);
                    var implementsExpressions = originalImplements && sanitizeJSDocImplements(originalImplements)
                        || ts.mapDefined(getImplementsTypes(classType), serializeImplementedType);
                    var staticType = getTypeOfSymbol(symbol);
                    var isClass = !!((_b = staticType.symbol) === null || _b === void 0 ? void 0 : _b.valueDeclaration) && ts.isClassLike(staticType.symbol.valueDeclaration);
                    var staticBaseType = isClass
                        ? getBaseConstructorTypeOfClass(staticType)
                        : anyType;
                    var heritageClauses = __spreadArray(__spreadArray([], !ts.length(baseTypes) ? [] : [ts.factory.createHeritageClause(94, ts.map(baseTypes, function (b) { return serializeBaseType(b, staticBaseType, localName); }))], true), !ts.length(implementsExpressions) ? [] : [ts.factory.createHeritageClause(117, implementsExpressions)], true);
                    var symbolProps = getNonInterhitedProperties(classType, baseTypes, getPropertiesOfType(classType));
                    var publicSymbolProps = ts.filter(symbolProps, function (s) {
                        var valueDecl = s.valueDeclaration;
                        return !!valueDecl && !(ts.isNamedDeclaration(valueDecl) && ts.isPrivateIdentifier(valueDecl.name));
                    });
                    var hasPrivateIdentifier = ts.some(symbolProps, function (s) {
                        var valueDecl = s.valueDeclaration;
                        return !!valueDecl && ts.isNamedDeclaration(valueDecl) && ts.isPrivateIdentifier(valueDecl.name);
                    });
                    var privateProperties = hasPrivateIdentifier ?
                        [ts.factory.createPropertyDeclaration(undefined, undefined, ts.factory.createPrivateIdentifier("#private"), undefined, undefined, undefined)] :
                        ts.emptyArray;
                    var publicProperties = ts.flatMap(publicSymbolProps, function (p) { return serializePropertySymbolForClass(p, false, baseTypes[0]); });
                    var staticMembers = ts.flatMap(ts.filter(getPropertiesOfType(staticType), function (p) { return !(p.flags & 4194304) && p.escapedName !== "prototype" && !isNamespaceMember(p); }), function (p) { return serializePropertySymbolForClass(p, true, staticBaseType); });
                    var isNonConstructableClassLikeInJsFile = !isClass &&
                        !!symbol.valueDeclaration &&
                        ts.isInJSFile(symbol.valueDeclaration) &&
                        !ts.some(getSignaturesOfType(staticType, 1));
                    var constructors = isNonConstructableClassLikeInJsFile ?
                        [ts.factory.createConstructorDeclaration(undefined, ts.factory.createModifiersFromModifierFlags(8), [], undefined)] :
                        serializeSignatures(1, staticType, staticBaseType, 171);
                    var indexSignatures = serializeIndexSignatures(classType, baseTypes[0]);
                    context.enclosingDeclaration = oldEnclosing;
                    addResult(ts.setTextRange(ts.factory.createClassDeclaration(undefined, undefined, localName, typeParamDecls, heritageClauses, __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], indexSignatures, true), staticMembers, true), constructors, true), publicProperties, true), privateProperties, true)), symbol.declarations && ts.filter(symbol.declarations, function (d) { return ts.isClassDeclaration(d) || ts.isClassExpression(d); })[0]), modifierFlags);
                }
                function getSomeTargetNameFromDeclarations(declarations) {
                    return ts.firstDefined(declarations, function (d) {
                        if (ts.isImportSpecifier(d) || ts.isExportSpecifier(d)) {
                            return ts.idText(d.propertyName || d.name);
                        }
                        if (ts.isBinaryExpression(d) || ts.isExportAssignment(d)) {
                            var expression = ts.isExportAssignment(d) ? d.expression : d.right;
                            if (ts.isPropertyAccessExpression(expression)) {
                                return ts.idText(expression.name);
                            }
                        }
                        if (isAliasSymbolDeclaration(d)) {
                            var name = ts.getNameOfDeclaration(d);
                            if (name && ts.isIdentifier(name)) {
                                return ts.idText(name);
                            }
                        }
                        return undefined;
                    });
                }
                function serializeAsAlias(symbol, localName, modifierFlags) {
                    var _a, _b, _c, _d, _e;
                    var node = getDeclarationOfAliasSymbol(symbol);
                    if (!node)
                        return ts.Debug.fail();
                    var target = getMergedSymbol(getTargetOfAliasDeclaration(node, true));
                    if (!target) {
                        return;
                    }
                    var verbatimTargetName = ts.isShorthandAmbientModuleSymbol(target) && getSomeTargetNameFromDeclarations(symbol.declarations) || ts.unescapeLeadingUnderscores(target.escapedName);
                    if (verbatimTargetName === "export=" && (ts.getESModuleInterop(compilerOptions) || compilerOptions.allowSyntheticDefaultImports)) {
                        verbatimTargetName = "default";
                    }
                    var targetName = getInternalSymbolName(target, verbatimTargetName);
                    includePrivateSymbol(target);
                    switch (node.kind) {
                        case 203:
                            if (((_b = (_a = node.parent) === null || _a === void 0 ? void 0 : _a.parent) === null || _b === void 0 ? void 0 : _b.kind) === 254) {
                                var specifier_1 = getSpecifierForModuleSymbol(target.parent || target, context);
                                var propertyName = node.propertyName;
                                addResult(ts.factory.createImportDeclaration(undefined, undefined, ts.factory.createImportClause(false, undefined, ts.factory.createNamedImports([ts.factory.createImportSpecifier(false, propertyName && ts.isIdentifier(propertyName) ? ts.factory.createIdentifier(ts.idText(propertyName)) : undefined, ts.factory.createIdentifier(localName))])), ts.factory.createStringLiteral(specifier_1), undefined), 0);
                                break;
                            }
                            ts.Debug.failBadSyntaxKind(((_c = node.parent) === null || _c === void 0 ? void 0 : _c.parent) || node, "Unhandled binding element grandparent kind in declaration serialization");
                            break;
                        case 297:
                            if (((_e = (_d = node.parent) === null || _d === void 0 ? void 0 : _d.parent) === null || _e === void 0 ? void 0 : _e.kind) === 221) {
                                serializeExportSpecifier(ts.unescapeLeadingUnderscores(symbol.escapedName), targetName);
                            }
                            break;
                        case 254:
                            if (ts.isPropertyAccessExpression(node.initializer)) {
                                var initializer = node.initializer;
                                var uniqueName = ts.factory.createUniqueName(localName);
                                var specifier_2 = getSpecifierForModuleSymbol(target.parent || target, context);
                                addResult(ts.factory.createImportEqualsDeclaration(undefined, undefined, false, uniqueName, ts.factory.createExternalModuleReference(ts.factory.createStringLiteral(specifier_2))), 0);
                                addResult(ts.factory.createImportEqualsDeclaration(undefined, undefined, false, ts.factory.createIdentifier(localName), ts.factory.createQualifiedName(uniqueName, initializer.name)), modifierFlags);
                                break;
                            }
                        case 265:
                            if (target.escapedName === "export=" && ts.some(target.declarations, ts.isJsonSourceFile)) {
                                serializeMaybeAliasAssignment(symbol);
                                break;
                            }
                            var isLocalImport = !(target.flags & 512) && !ts.isVariableDeclaration(node);
                            addResult(ts.factory.createImportEqualsDeclaration(undefined, undefined, false, ts.factory.createIdentifier(localName), isLocalImport
                                ? symbolToName(target, context, 67108863, false)
                                : ts.factory.createExternalModuleReference(ts.factory.createStringLiteral(getSpecifierForModuleSymbol(target, context)))), isLocalImport ? modifierFlags : 0);
                            break;
                        case 264:
                            addResult(ts.factory.createNamespaceExportDeclaration(ts.idText(node.name)), 0);
                            break;
                        case 267:
                            addResult(ts.factory.createImportDeclaration(undefined, undefined, ts.factory.createImportClause(false, ts.factory.createIdentifier(localName), undefined), ts.factory.createStringLiteral(getSpecifierForModuleSymbol(target.parent || target, context)), undefined), 0);
                            break;
                        case 268:
                            addResult(ts.factory.createImportDeclaration(undefined, undefined, ts.factory.createImportClause(false, undefined, ts.factory.createNamespaceImport(ts.factory.createIdentifier(localName))), ts.factory.createStringLiteral(getSpecifierForModuleSymbol(target, context)), undefined), 0);
                            break;
                        case 274:
                            addResult(ts.factory.createExportDeclaration(undefined, undefined, false, ts.factory.createNamespaceExport(ts.factory.createIdentifier(localName)), ts.factory.createStringLiteral(getSpecifierForModuleSymbol(target, context))), 0);
                            break;
                        case 270:
                            addResult(ts.factory.createImportDeclaration(undefined, undefined, ts.factory.createImportClause(false, undefined, ts.factory.createNamedImports([
                                ts.factory.createImportSpecifier(false, localName !== verbatimTargetName ? ts.factory.createIdentifier(verbatimTargetName) : undefined, ts.factory.createIdentifier(localName))
                            ])), ts.factory.createStringLiteral(getSpecifierForModuleSymbol(target.parent || target, context)), undefined), 0);
                            break;
                        case 275:
                            var specifier = node.parent.parent.moduleSpecifier;
                            serializeExportSpecifier(ts.unescapeLeadingUnderscores(symbol.escapedName), specifier ? verbatimTargetName : targetName, specifier && ts.isStringLiteralLike(specifier) ? ts.factory.createStringLiteral(specifier.text) : undefined);
                            break;
                        case 271:
                            serializeMaybeAliasAssignment(symbol);
                            break;
                        case 221:
                        case 206:
                        case 207:
                            if (symbol.escapedName === "default" || symbol.escapedName === "export=") {
                                serializeMaybeAliasAssignment(symbol);
                            }
                            else {
                                serializeExportSpecifier(localName, targetName);
                            }
                            break;
                        default:
                            return ts.Debug.failBadSyntaxKind(node, "Unhandled alias declaration kind in symbol serializer!");
                    }
                }
                function serializeExportSpecifier(localName, targetName, specifier) {
                    addResult(ts.factory.createExportDeclaration(undefined, undefined, false, ts.factory.createNamedExports([ts.factory.createExportSpecifier(false, localName !== targetName ? targetName : undefined, localName)]), specifier), 0);
                }
                function serializeMaybeAliasAssignment(symbol) {
                    if (symbol.flags & 4194304) {
                        return false;
                    }
                    var name = ts.unescapeLeadingUnderscores(symbol.escapedName);
                    var isExportEquals = name === "export=";
                    var isDefault = name === "default";
                    var isExportAssignmentCompatibleSymbolName = isExportEquals || isDefault;
                    var aliasDecl = symbol.declarations && getDeclarationOfAliasSymbol(symbol);
                    var target = aliasDecl && getTargetOfAliasDeclaration(aliasDecl, true);
                    if (target && ts.length(target.declarations) && ts.some(target.declarations, function (d) { return ts.getSourceFileOfNode(d) === ts.getSourceFileOfNode(enclosingDeclaration); })) {
                        var expr = aliasDecl && ((ts.isExportAssignment(aliasDecl) || ts.isBinaryExpression(aliasDecl)) ? ts.getExportAssignmentExpression(aliasDecl) : ts.getPropertyAssignmentAliasLikeExpression(aliasDecl));
                        var first_1 = expr && ts.isEntityNameExpression(expr) ? getFirstNonModuleExportsIdentifier(expr) : undefined;
                        var referenced = first_1 && resolveEntityName(first_1, 67108863, true, true, enclosingDeclaration);
                        if (referenced || target) {
                            includePrivateSymbol(referenced || target);
                        }
                        var oldTrack = context.tracker.trackSymbol;
                        context.tracker.trackSymbol = function () { return false; };
                        if (isExportAssignmentCompatibleSymbolName) {
                            results.push(ts.factory.createExportAssignment(undefined, undefined, isExportEquals, symbolToExpression(target, context, 67108863)));
                        }
                        else {
                            if (first_1 === expr && first_1) {
                                serializeExportSpecifier(name, ts.idText(first_1));
                            }
                            else if (expr && ts.isClassExpression(expr)) {
                                serializeExportSpecifier(name, getInternalSymbolName(target, ts.symbolName(target)));
                            }
                            else {
                                var varName = getUnusedName(name, symbol);
                                addResult(ts.factory.createImportEqualsDeclaration(undefined, undefined, false, ts.factory.createIdentifier(varName), symbolToName(target, context, 67108863, false)), 0);
                                serializeExportSpecifier(name, varName);
                            }
                        }
                        context.tracker.trackSymbol = oldTrack;
                        return true;
                    }
                    else {
                        var varName = getUnusedName(name, symbol);
                        var typeToSerialize = getWidenedType(getTypeOfSymbol(getMergedSymbol(symbol)));
                        if (isTypeRepresentableAsFunctionNamespaceMerge(typeToSerialize, symbol)) {
                            serializeAsFunctionNamespaceMerge(typeToSerialize, symbol, varName, isExportAssignmentCompatibleSymbolName ? 0 : 1);
                        }
                        else {
                            var statement = ts.factory.createVariableStatement(undefined, ts.factory.createVariableDeclarationList([
                                ts.factory.createVariableDeclaration(varName, undefined, serializeTypeForDeclaration(context, typeToSerialize, symbol, enclosingDeclaration, includePrivateSymbol, bundled))
                            ], 2));
                            addResult(statement, target && target.flags & 4 && target.escapedName === "export=" ? 2
                                : name === varName ? 1
                                    : 0);
                        }
                        if (isExportAssignmentCompatibleSymbolName) {
                            results.push(ts.factory.createExportAssignment(undefined, undefined, isExportEquals, ts.factory.createIdentifier(varName)));
                            return true;
                        }
                        else if (name !== varName) {
                            serializeExportSpecifier(name, varName);
                            return true;
                        }
                        return false;
                    }
                }
                function isTypeRepresentableAsFunctionNamespaceMerge(typeToSerialize, hostSymbol) {
                    var ctxSrc = ts.getSourceFileOfNode(context.enclosingDeclaration);
                    return ts.getObjectFlags(typeToSerialize) & (16 | 32) &&
                        !ts.length(getIndexInfosOfType(typeToSerialize)) &&
                        !isClassInstanceSide(typeToSerialize) &&
                        !!(ts.length(ts.filter(getPropertiesOfType(typeToSerialize), isNamespaceMember)) || ts.length(getSignaturesOfType(typeToSerialize, 0))) &&
                        !ts.length(getSignaturesOfType(typeToSerialize, 1)) &&
                        !getDeclarationWithTypeAnnotation(hostSymbol, enclosingDeclaration) &&
                        !(typeToSerialize.symbol && ts.some(typeToSerialize.symbol.declarations, function (d) { return ts.getSourceFileOfNode(d) !== ctxSrc; })) &&
                        !ts.some(getPropertiesOfType(typeToSerialize), function (p) { return isLateBoundName(p.escapedName); }) &&
                        !ts.some(getPropertiesOfType(typeToSerialize), function (p) { return ts.some(p.declarations, function (d) { return ts.getSourceFileOfNode(d) !== ctxSrc; }); }) &&
                        ts.every(getPropertiesOfType(typeToSerialize), function (p) { return ts.isIdentifierText(ts.symbolName(p), languageVersion); });
                }
                function makeSerializePropertySymbol(createProperty, methodKind, useAccessors) {
                    return function serializePropertySymbol(p, isStatic, baseType) {
                        var _a, _b, _c, _d, _e;
                        var modifierFlags = ts.getDeclarationModifierFlagsFromSymbol(p);
                        var isPrivate = !!(modifierFlags & 8);
                        if (isStatic && (p.flags & (788968 | 1920 | 2097152))) {
                            return [];
                        }
                        if (p.flags & 4194304 ||
                            (baseType && getPropertyOfType(baseType, p.escapedName)
                                && isReadonlySymbol(getPropertyOfType(baseType, p.escapedName)) === isReadonlySymbol(p)
                                && (p.flags & 16777216) === (getPropertyOfType(baseType, p.escapedName).flags & 16777216)
                                && isTypeIdenticalTo(getTypeOfSymbol(p), getTypeOfPropertyOfType(baseType, p.escapedName)))) {
                            return [];
                        }
                        var flag = (modifierFlags & ~256) | (isStatic ? 32 : 0);
                        var name = getPropertyNameNodeForSymbol(p, context);
                        var firstPropertyLikeDecl = (_a = p.declarations) === null || _a === void 0 ? void 0 : _a.find(ts.or(ts.isPropertyDeclaration, ts.isAccessor, ts.isVariableDeclaration, ts.isPropertySignature, ts.isBinaryExpression, ts.isPropertyAccessExpression));
                        if (p.flags & 98304 && useAccessors) {
                            var result = [];
                            if (p.flags & 65536) {
                                result.push(ts.setTextRange(ts.factory.createSetAccessorDeclaration(undefined, ts.factory.createModifiersFromModifierFlags(flag), name, [ts.factory.createParameterDeclaration(undefined, undefined, undefined, "arg", undefined, isPrivate ? undefined : serializeTypeForDeclaration(context, getTypeOfSymbol(p), p, enclosingDeclaration, includePrivateSymbol, bundled))], undefined), ((_b = p.declarations) === null || _b === void 0 ? void 0 : _b.find(ts.isSetAccessor)) || firstPropertyLikeDecl));
                            }
                            if (p.flags & 32768) {
                                var isPrivate_1 = modifierFlags & 8;
                                result.push(ts.setTextRange(ts.factory.createGetAccessorDeclaration(undefined, ts.factory.createModifiersFromModifierFlags(flag), name, [], isPrivate_1 ? undefined : serializeTypeForDeclaration(context, getTypeOfSymbol(p), p, enclosingDeclaration, includePrivateSymbol, bundled), undefined), ((_c = p.declarations) === null || _c === void 0 ? void 0 : _c.find(ts.isGetAccessor)) || firstPropertyLikeDecl));
                            }
                            return result;
                        }
                        else if (p.flags & (4 | 3 | 98304)) {
                            return ts.setTextRange(createProperty(undefined, ts.factory.createModifiersFromModifierFlags((isReadonlySymbol(p) ? 64 : 0) | flag), name, p.flags & 16777216 ? ts.factory.createToken(57) : undefined, isPrivate ? undefined : serializeTypeForDeclaration(context, getTypeOfSymbol(p), p, enclosingDeclaration, includePrivateSymbol, bundled), undefined), ((_d = p.declarations) === null || _d === void 0 ? void 0 : _d.find(ts.or(ts.isPropertyDeclaration, ts.isVariableDeclaration))) || firstPropertyLikeDecl);
                        }
                        if (p.flags & (8192 | 16)) {
                            var type = getTypeOfSymbol(p);
                            var signatures = getSignaturesOfType(type, 0);
                            if (flag & 8) {
                                return ts.setTextRange(createProperty(undefined, ts.factory.createModifiersFromModifierFlags((isReadonlySymbol(p) ? 64 : 0) | flag), name, p.flags & 16777216 ? ts.factory.createToken(57) : undefined, undefined, undefined), ((_e = p.declarations) === null || _e === void 0 ? void 0 : _e.find(ts.isFunctionLikeDeclaration)) || signatures[0] && signatures[0].declaration || p.declarations && p.declarations[0]);
                            }
                            var results_1 = [];
                            for (var _i = 0, signatures_3 = signatures; _i < signatures_3.length; _i++) {
                                var sig = signatures_3[_i];
                                var decl = signatureToSignatureDeclarationHelper(sig, methodKind, context, {
                                    name: name,
                                    questionToken: p.flags & 16777216 ? ts.factory.createToken(57) : undefined,
                                    modifiers: flag ? ts.factory.createModifiersFromModifierFlags(flag) : undefined
                                });
                                var location = sig.declaration && ts.isPrototypePropertyAssignment(sig.declaration.parent) ? sig.declaration.parent : sig.declaration;
                                results_1.push(ts.setTextRange(decl, location));
                            }
                            return results_1;
                        }
                        return ts.Debug.fail("Unhandled class member kind! ".concat(p.__debugFlags || p.flags));
                    };
                }
                function serializePropertySymbolForInterface(p, baseType) {
                    return serializePropertySymbolForInterfaceWorker(p, false, baseType);
                }
                function serializeSignatures(kind, input, baseType, outputKind) {
                    var signatures = getSignaturesOfType(input, kind);
                    if (kind === 1) {
                        if (!baseType && ts.every(signatures, function (s) { return ts.length(s.parameters) === 0; })) {
                            return [];
                        }
                        if (baseType) {
                            var baseSigs = getSignaturesOfType(baseType, 1);
                            if (!ts.length(baseSigs) && ts.every(signatures, function (s) { return ts.length(s.parameters) === 0; })) {
                                return [];
                            }
                            if (baseSigs.length === signatures.length) {
                                var failed = false;
                                for (var i = 0; i < baseSigs.length; i++) {
                                    if (!compareSignaturesIdentical(signatures[i], baseSigs[i], false, false, true, compareTypesIdentical)) {
                                        failed = true;
                                        break;
                                    }
                                }
                                if (!failed) {
                                    return [];
                                }
                            }
                        }
                        var privateProtected = 0;
                        for (var _i = 0, signatures_4 = signatures; _i < signatures_4.length; _i++) {
                            var s = signatures_4[_i];
                            if (s.declaration) {
                                privateProtected |= ts.getSelectedEffectiveModifierFlags(s.declaration, 8 | 16);
                            }
                        }
                        if (privateProtected) {
                            return [ts.setTextRange(ts.factory.createConstructorDeclaration(undefined, ts.factory.createModifiersFromModifierFlags(privateProtected), [], undefined), signatures[0].declaration)];
                        }
                    }
                    var results = [];
                    for (var _a = 0, signatures_5 = signatures; _a < signatures_5.length; _a++) {
                        var sig = signatures_5[_a];
                        var decl = signatureToSignatureDeclarationHelper(sig, outputKind, context);
                        results.push(ts.setTextRange(decl, sig.declaration));
                    }
                    return results;
                }
                function serializeIndexSignatures(input, baseType) {
                    var results = [];
                    for (var _i = 0, _a = getIndexInfosOfType(input); _i < _a.length; _i++) {
                        var info = _a[_i];
                        if (baseType) {
                            var baseInfo = getIndexInfoOfType(baseType, info.keyType);
                            if (baseInfo) {
                                if (isTypeIdenticalTo(info.type, baseInfo.type)) {
                                    continue;
                                }
                            }
                        }
                        results.push(indexInfoToIndexSignatureDeclarationHelper(info, context, undefined));
                    }
                    return results;
                }
                function serializeBaseType(t, staticType, rootName) {
                    var ref = trySerializeAsTypeReference(t, 111551);
                    if (ref) {
                        return ref;
                    }
                    var tempName = getUnusedName("".concat(rootName, "_base"));
                    var statement = ts.factory.createVariableStatement(undefined, ts.factory.createVariableDeclarationList([
                        ts.factory.createVariableDeclaration(tempName, undefined, typeToTypeNodeHelper(staticType, context))
                    ], 2));
                    addResult(statement, 0);
                    return ts.factory.createExpressionWithTypeArguments(ts.factory.createIdentifier(tempName), undefined);
                }
                function trySerializeAsTypeReference(t, flags) {
                    var typeArgs;
                    var reference;
                    if (t.target && isSymbolAccessibleByFlags(t.target.symbol, enclosingDeclaration, flags)) {
                        typeArgs = ts.map(getTypeArguments(t), function (t) { return typeToTypeNodeHelper(t, context); });
                        reference = symbolToExpression(t.target.symbol, context, 788968);
                    }
                    else if (t.symbol && isSymbolAccessibleByFlags(t.symbol, enclosingDeclaration, flags)) {
                        reference = symbolToExpression(t.symbol, context, 788968);
                    }
                    if (reference) {
                        return ts.factory.createExpressionWithTypeArguments(reference, typeArgs);
                    }
                }
                function serializeImplementedType(t) {
                    var ref = trySerializeAsTypeReference(t, 788968);
                    if (ref) {
                        return ref;
                    }
                    if (t.symbol) {
                        return ts.factory.createExpressionWithTypeArguments(symbolToExpression(t.symbol, context, 788968), undefined);
                    }
                }
                function getUnusedName(input, symbol) {
                    var _a, _b;
                    var id = symbol ? getSymbolId(symbol) : undefined;
                    if (id) {
                        if (context.remappedSymbolNames.has(id)) {
                            return context.remappedSymbolNames.get(id);
                        }
                    }
                    if (symbol) {
                        input = getNameCandidateWorker(symbol, input);
                    }
                    var i = 0;
                    var original = input;
                    while ((_a = context.usedSymbolNames) === null || _a === void 0 ? void 0 : _a.has(input)) {
                        i++;
                        input = "".concat(original, "_").concat(i);
                    }
                    (_b = context.usedSymbolNames) === null || _b === void 0 ? void 0 : _b.add(input);
                    if (id) {
                        context.remappedSymbolNames.set(id, input);
                    }
                    return input;
                }
                function getNameCandidateWorker(symbol, localName) {
                    if (localName === "default" || localName === "__class" || localName === "__function") {
                        var flags = context.flags;
                        context.flags |= 16777216;
                        var nameCandidate = getNameOfSymbolAsWritten(symbol, context);
                        context.flags = flags;
                        localName = nameCandidate.length > 0 && ts.isSingleOrDoubleQuote(nameCandidate.charCodeAt(0)) ? ts.stripQuotes(nameCandidate) : nameCandidate;
                    }
                    if (localName === "default") {
                        localName = "_default";
                    }
                    else if (localName === "export=") {
                        localName = "_exports";
                    }
                    localName = ts.isIdentifierText(localName, languageVersion) && !ts.isStringANonContextualKeyword(localName) ? localName : "_" + localName.replace(/[^a-zA-Z0-9]/g, "_");
                    return localName;
                }
                function getInternalSymbolName(symbol, localName) {
                    var id = getSymbolId(symbol);
                    if (context.remappedSymbolNames.has(id)) {
                        return context.remappedSymbolNames.get(id);
                    }
                    localName = getNameCandidateWorker(symbol, localName);
                    context.remappedSymbolNames.set(id, localName);
                    return localName;
                }
            }
        }
        function typePredicateToString(typePredicate, enclosingDeclaration, flags, writer) {
            if (flags === void 0) { flags = 16384; }
            return writer ? typePredicateToStringWorker(writer).getText() : ts.usingSingleLineStringWriter(typePredicateToStringWorker);
            function typePredicateToStringWorker(writer) {
                var predicate = ts.factory.createTypePredicateNode(typePredicate.kind === 2 || typePredicate.kind === 3 ? ts.factory.createToken(128) : undefined, typePredicate.kind === 1 || typePredicate.kind === 3 ? ts.factory.createIdentifier(typePredicate.parameterName) : ts.factory.createThisTypeNode(), typePredicate.type && nodeBuilder.typeToTypeNode(typePredicate.type, enclosingDeclaration, toNodeBuilderFlags(flags) | 70221824 | 512));
                var printer = ts.createPrinter({ removeComments: true });
                var sourceFile = enclosingDeclaration && ts.getSourceFileOfNode(enclosingDeclaration);
                printer.writeNode(4, predicate, sourceFile, writer);
                return writer;
            }
        }
        function formatUnionTypes(types) {
            var result = [];
            var flags = 0;
            for (var i = 0; i < types.length; i++) {
                var t = types[i];
                flags |= t.flags;
                if (!(t.flags & 98304)) {
                    if (t.flags & (512 | 1024)) {
                        var baseType = t.flags & 512 ? booleanType : getBaseTypeOfEnumLiteralType(t);
                        if (baseType.flags & 1048576) {
                            var count = baseType.types.length;
                            if (i + count <= types.length && getRegularTypeOfLiteralType(types[i + count - 1]) === getRegularTypeOfLiteralType(baseType.types[count - 1])) {
                                result.push(baseType);
                                i += count - 1;
                                continue;
                            }
                        }
                    }
                    result.push(t);
                }
            }
            if (flags & 65536)
                result.push(nullType);
            if (flags & 32768)
                result.push(undefinedType);
            return result || types;
        }
        function visibilityToString(flags) {
            if (flags === 8) {
                return "private";
            }
            if (flags === 16) {
                return "protected";
            }
            return "public";
        }
        function getTypeAliasForTypeLiteral(type) {
            if (type.symbol && type.symbol.flags & 2048 && type.symbol.declarations) {
                var node = ts.walkUpParenthesizedTypes(type.symbol.declarations[0].parent);
                if (node.kind === 259) {
                    return getSymbolOfNode(node);
                }
            }
            return undefined;
        }
        function isTopLevelInExternalModuleAugmentation(node) {
            return node && node.parent &&
                node.parent.kind === 262 &&
                ts.isExternalModuleAugmentation(node.parent.parent);
        }
        function isDefaultBindingContext(location) {
            return location.kind === 305 || ts.isAmbientModule(location);
        }
        function getNameOfSymbolFromNameType(symbol, context) {
            var nameType = getSymbolLinks(symbol).nameType;
            if (nameType) {
                if (nameType.flags & 384) {
                    var name = "" + nameType.value;
                    if (!ts.isIdentifierText(name, ts.getEmitScriptTarget(compilerOptions)) && !ts.isNumericLiteralName(name)) {
                        return "\"".concat(ts.escapeString(name, 34), "\"");
                    }
                    if (ts.isNumericLiteralName(name) && ts.startsWith(name, "-")) {
                        return "[".concat(name, "]");
                    }
                    return name;
                }
                if (nameType.flags & 8192) {
                    return "[".concat(getNameOfSymbolAsWritten(nameType.symbol, context), "]");
                }
            }
        }
        function getNameOfSymbolAsWritten(symbol, context) {
            if (context && symbol.escapedName === "default" && !(context.flags & 16384) &&
                (!(context.flags & 16777216) ||
                    !symbol.declarations ||
                    (context.enclosingDeclaration && ts.findAncestor(symbol.declarations[0], isDefaultBindingContext) !== ts.findAncestor(context.enclosingDeclaration, isDefaultBindingContext)))) {
                return "default";
            }
            if (symbol.declarations && symbol.declarations.length) {
                var declaration = ts.firstDefined(symbol.declarations, function (d) { return ts.getNameOfDeclaration(d) ? d : undefined; });
                var name_4 = declaration && ts.getNameOfDeclaration(declaration);
                if (declaration && name_4) {
                    if (ts.isCallExpression(declaration) && ts.isBindableObjectDefinePropertyCall(declaration)) {
                        return ts.symbolName(symbol);
                    }
                    if (ts.isComputedPropertyName(name_4) && !(ts.getCheckFlags(symbol) & 4096)) {
                        var nameType = getSymbolLinks(symbol).nameType;
                        if (nameType && nameType.flags & 384) {
                            var result = getNameOfSymbolFromNameType(symbol, context);
                            if (result !== undefined) {
                                return result;
                            }
                        }
                    }
                    return ts.declarationNameToString(name_4);
                }
                if (!declaration) {
                    declaration = symbol.declarations[0];
                }
                if (declaration.parent && declaration.parent.kind === 254) {
                    return ts.declarationNameToString(declaration.parent.name);
                }
                switch (declaration.kind) {
                    case 226:
                    case 213:
                    case 214:
                        if (context && !context.encounteredError && !(context.flags & 131072)) {
                            context.encounteredError = true;
                        }
                        return declaration.kind === 226 ? "(Anonymous class)" : "(Anonymous function)";
                }
            }
            var name = getNameOfSymbolFromNameType(symbol, context);
            return name !== undefined ? name : ts.symbolName(symbol);
        }
        function isDeclarationVisible(node) {
            if (node) {
                var links = getNodeLinks(node);
                if (links.isVisible === undefined) {
                    links.isVisible = !!determineIfDeclarationIsVisible();
                }
                return links.isVisible;
            }
            return false;
            function determineIfDeclarationIsVisible() {
                switch (node.kind) {
                    case 338:
                    case 345:
                    case 339:
                        return !!(node.parent && node.parent.parent && node.parent.parent.parent && ts.isSourceFile(node.parent.parent.parent));
                    case 203:
                        return isDeclarationVisible(node.parent.parent);
                    case 254:
                        if (ts.isBindingPattern(node.name) &&
                            !node.name.elements.length) {
                            return false;
                        }
                    case 261:
                    case 257:
                    case 258:
                    case 259:
                    case 256:
                    case 260:
                    case 265:
                        if (ts.isExternalModuleAugmentation(node)) {
                            return true;
                        }
                        var parent = getDeclarationContainer(node);
                        if (!(ts.getCombinedModifierFlags(node) & 1) &&
                            !(node.kind !== 265 && parent.kind !== 305 && parent.flags & 16777216)) {
                            return isGlobalSourceFile(parent);
                        }
                        return isDeclarationVisible(parent);
                    case 167:
                    case 166:
                    case 172:
                    case 173:
                    case 169:
                    case 168:
                        if (ts.hasEffectiveModifier(node, 8 | 16)) {
                            return false;
                        }
                    case 171:
                    case 175:
                    case 174:
                    case 176:
                    case 164:
                    case 262:
                    case 179:
                    case 180:
                    case 182:
                    case 178:
                    case 183:
                    case 184:
                    case 187:
                    case 188:
                    case 191:
                    case 197:
                        return isDeclarationVisible(node.parent);
                    case 267:
                    case 268:
                    case 270:
                        return false;
                    case 163:
                    case 305:
                    case 264:
                        return true;
                    case 271:
                        return false;
                    default:
                        return false;
                }
            }
        }
        function collectLinkedAliases(node, setVisibility) {
            var exportSymbol;
            if (node.parent && node.parent.kind === 271) {
                exportSymbol = resolveName(node, node.escapedText, 111551 | 788968 | 1920 | 2097152, undefined, node, false);
            }
            else if (node.parent.kind === 275) {
                exportSymbol = getTargetOfExportSpecifier(node.parent, 111551 | 788968 | 1920 | 2097152);
            }
            var result;
            var visited;
            if (exportSymbol) {
                visited = new ts.Set();
                visited.add(getSymbolId(exportSymbol));
                buildVisibleNodeList(exportSymbol.declarations);
            }
            return result;
            function buildVisibleNodeList(declarations) {
                ts.forEach(declarations, function (declaration) {
                    var resultNode = getAnyImportSyntax(declaration) || declaration;
                    if (setVisibility) {
                        getNodeLinks(declaration).isVisible = true;
                    }
                    else {
                        result = result || [];
                        ts.pushIfUnique(result, resultNode);
                    }
                    if (ts.isInternalModuleImportEqualsDeclaration(declaration)) {
                        var internalModuleReference = declaration.moduleReference;
                        var firstIdentifier = ts.getFirstIdentifier(internalModuleReference);
                        var importSymbol = resolveName(declaration, firstIdentifier.escapedText, 111551 | 788968 | 1920, undefined, undefined, false);
                        if (importSymbol && visited) {
                            if (ts.tryAddToSet(visited, getSymbolId(importSymbol))) {
                                buildVisibleNodeList(importSymbol.declarations);
                            }
                        }
                    }
                });
            }
        }
        function pushTypeResolution(target, propertyName) {
            var resolutionCycleStartIndex = findResolutionCycleStartIndex(target, propertyName);
            if (resolutionCycleStartIndex >= 0) {
                var length_3 = resolutionTargets.length;
                for (var i = resolutionCycleStartIndex; i < length_3; i++) {
                    resolutionResults[i] = false;
                }
                return false;
            }
            resolutionTargets.push(target);
            resolutionResults.push(true);
            resolutionPropertyNames.push(propertyName);
            return true;
        }
        function findResolutionCycleStartIndex(target, propertyName) {
            for (var i = resolutionTargets.length - 1; i >= 0; i--) {
                if (hasType(resolutionTargets[i], resolutionPropertyNames[i])) {
                    return -1;
                }
                if (resolutionTargets[i] === target && resolutionPropertyNames[i] === propertyName) {
                    return i;
                }
            }
            return -1;
        }
        function hasType(target, propertyName) {
            switch (propertyName) {
                case 0:
                    return !!getSymbolLinks(target).type;
                case 5:
                    return !!(getNodeLinks(target).resolvedEnumType);
                case 2:
                    return !!getSymbolLinks(target).declaredType;
                case 1:
                    return !!target.resolvedBaseConstructorType;
                case 3:
                    return !!target.resolvedReturnType;
                case 4:
                    return !!target.immediateBaseConstraint;
                case 6:
                    return !!target.resolvedTypeArguments;
                case 7:
                    return !!target.baseTypesResolved;
                case 8:
                    return !!getSymbolLinks(target).writeType;
            }
            return ts.Debug.assertNever(propertyName);
        }
        function popTypeResolution() {
            resolutionTargets.pop();
            resolutionPropertyNames.pop();
            return resolutionResults.pop();
        }
        function getDeclarationContainer(node) {
            return ts.findAncestor(ts.getRootDeclaration(node), function (node) {
                switch (node.kind) {
                    case 254:
                    case 255:
                    case 270:
                    case 269:
                    case 268:
                    case 267:
                        return false;
                    default:
                        return true;
                }
            }).parent;
        }
        function getTypeOfPrototypeProperty(prototype) {
            var classType = getDeclaredTypeOfSymbol(getParentOfSymbol(prototype));
            return classType.typeParameters ? createTypeReference(classType, ts.map(classType.typeParameters, function (_) { return anyType; })) : classType;
        }
        function getTypeOfPropertyOfType(type, name) {
            var prop = getPropertyOfType(type, name);
            return prop ? getTypeOfSymbol(prop) : undefined;
        }
        function getTypeOfPropertyOrIndexSignature(type, name) {
            var _a;
            return getTypeOfPropertyOfType(type, name) || ((_a = getApplicableIndexInfoForName(type, name)) === null || _a === void 0 ? void 0 : _a.type) || unknownType;
        }
        function isTypeAny(type) {
            return type && (type.flags & 1) !== 0;
        }
        function isErrorType(type) {
            return type === errorType || !!(type.flags & 1 && type.aliasSymbol);
        }
        function getTypeForBindingElementParent(node, checkMode) {
            if (checkMode !== 0) {
                return getTypeForVariableLikeDeclaration(node, false, checkMode);
            }
            var symbol = getSymbolOfNode(node);
            return symbol && getSymbolLinks(symbol).type || getTypeForVariableLikeDeclaration(node, false, checkMode);
        }
        function getRestType(source, properties, symbol) {
            source = filterType(source, function (t) { return !(t.flags & 98304); });
            if (source.flags & 131072) {
                return emptyObjectType;
            }
            if (source.flags & 1048576) {
                return mapType(source, function (t) { return getRestType(t, properties, symbol); });
            }
            var omitKeyType = getUnionType(ts.map(properties, getLiteralTypeFromPropertyName));
            var spreadableProperties = [];
            var unspreadableToRestKeys = [];
            for (var _i = 0, _a = getPropertiesOfType(source); _i < _a.length; _i++) {
                var prop = _a[_i];
                var literalTypeFromProperty = getLiteralTypeFromProperty(prop, 8576);
                if (!isTypeAssignableTo(literalTypeFromProperty, omitKeyType)
                    && !(ts.getDeclarationModifierFlagsFromSymbol(prop) & (8 | 16))
                    && isSpreadableProperty(prop)) {
                    spreadableProperties.push(prop);
                }
                else {
                    unspreadableToRestKeys.push(literalTypeFromProperty);
                }
            }
            if (isGenericObjectType(source) || isGenericIndexType(omitKeyType)) {
                if (unspreadableToRestKeys.length) {
                    omitKeyType = getUnionType(__spreadArray([omitKeyType], unspreadableToRestKeys, true));
                }
                if (omitKeyType.flags & 131072) {
                    return source;
                }
                var omitTypeAlias = getGlobalOmitSymbol();
                if (!omitTypeAlias) {
                    return errorType;
                }
                return getTypeAliasInstantiation(omitTypeAlias, [source, omitKeyType]);
            }
            var members = ts.createSymbolTable();
            for (var _b = 0, spreadableProperties_1 = spreadableProperties; _b < spreadableProperties_1.length; _b++) {
                var prop = spreadableProperties_1[_b];
                members.set(prop.escapedName, getSpreadSymbol(prop, false));
            }
            var result = createAnonymousType(symbol, members, ts.emptyArray, ts.emptyArray, getIndexInfosOfType(source));
            result.objectFlags |= 4194304;
            return result;
        }
        function isGenericTypeWithUndefinedConstraint(type) {
            return !!(type.flags & 465829888) && maybeTypeOfKind(getBaseConstraintOfType(type) || unknownType, 32768);
        }
        function getNonUndefinedType(type) {
            var typeOrConstraint = someType(type, isGenericTypeWithUndefinedConstraint) ? mapType(type, function (t) { return t.flags & 465829888 ? getBaseConstraintOrType(t) : t; }) : type;
            return getTypeWithFacts(typeOrConstraint, 524288);
        }
        function getFlowTypeOfDestructuring(node, declaredType) {
            var reference = getSyntheticElementAccess(node);
            return reference ? getFlowTypeOfReference(reference, declaredType) : declaredType;
        }
        function getSyntheticElementAccess(node) {
            var parentAccess = getParentElementAccess(node);
            if (parentAccess && parentAccess.flowNode) {
                var propName = getDestructuringPropertyName(node);
                if (propName) {
                    var literal = ts.setTextRange(ts.parseNodeFactory.createStringLiteral(propName), node);
                    var lhsExpr = ts.isLeftHandSideExpression(parentAccess) ? parentAccess : ts.parseNodeFactory.createParenthesizedExpression(parentAccess);
                    var result = ts.setTextRange(ts.parseNodeFactory.createElementAccessExpression(lhsExpr, literal), node);
                    ts.setParent(literal, result);
                    ts.setParent(result, node);
                    if (lhsExpr !== parentAccess) {
                        ts.setParent(lhsExpr, result);
                    }
                    result.flowNode = parentAccess.flowNode;
                    return result;
                }
            }
        }
        function getParentElementAccess(node) {
            var ancestor = node.parent.parent;
            switch (ancestor.kind) {
                case 203:
                case 296:
                    return getSyntheticElementAccess(ancestor);
                case 204:
                    return getSyntheticElementAccess(node.parent);
                case 254:
                    return ancestor.initializer;
                case 221:
                    return ancestor.right;
            }
        }
        function getDestructuringPropertyName(node) {
            var parent = node.parent;
            if (node.kind === 203 && parent.kind === 201) {
                return getLiteralPropertyNameText(node.propertyName || node.name);
            }
            if (node.kind === 296 || node.kind === 297) {
                return getLiteralPropertyNameText(node.name);
            }
            return "" + parent.elements.indexOf(node);
        }
        function getLiteralPropertyNameText(name) {
            var type = getLiteralTypeFromPropertyName(name);
            return type.flags & (128 | 256) ? "" + type.value : undefined;
        }
        function getTypeForBindingElement(declaration) {
            var checkMode = declaration.dotDotDotToken ? 64 : 0;
            var parentType = getTypeForBindingElementParent(declaration.parent.parent, checkMode);
            return parentType && getBindingElementTypeFromParentType(declaration, parentType);
        }
        function getBindingElementTypeFromParentType(declaration, parentType) {
            if (isTypeAny(parentType)) {
                return parentType;
            }
            var pattern = declaration.parent;
            if (strictNullChecks && declaration.flags & 16777216 && ts.isParameterDeclaration(declaration)) {
                parentType = getNonNullableType(parentType);
            }
            else if (strictNullChecks && pattern.parent.initializer && !(getTypeFacts(getTypeOfInitializer(pattern.parent.initializer)) & 65536)) {
                parentType = getTypeWithFacts(parentType, 524288);
            }
            var type;
            if (pattern.kind === 201) {
                if (declaration.dotDotDotToken) {
                    parentType = getReducedType(parentType);
                    if (parentType.flags & 2 || !isValidSpreadType(parentType)) {
                        error(declaration, ts.Diagnostics.Rest_types_may_only_be_created_from_object_types);
                        return errorType;
                    }
                    var literalMembers = [];
                    for (var _i = 0, _a = pattern.elements; _i < _a.length; _i++) {
                        var element = _a[_i];
                        if (!element.dotDotDotToken) {
                            literalMembers.push(element.propertyName || element.name);
                        }
                    }
                    type = getRestType(parentType, literalMembers, declaration.symbol);
                }
                else {
                    var name = declaration.propertyName || declaration.name;
                    var indexType = getLiteralTypeFromPropertyName(name);
                    var declaredType = getIndexedAccessType(parentType, indexType, 32, name);
                    type = getFlowTypeOfDestructuring(declaration, declaredType);
                }
            }
            else {
                var elementType = checkIteratedTypeOrElementType(65 | (declaration.dotDotDotToken ? 0 : 128), parentType, undefinedType, pattern);
                var index_2 = pattern.elements.indexOf(declaration);
                if (declaration.dotDotDotToken) {
                    type = everyType(parentType, isTupleType) ?
                        mapType(parentType, function (t) { return sliceTupleType(t, index_2); }) :
                        createArrayType(elementType);
                }
                else if (isArrayLikeType(parentType)) {
                    var indexType = getNumberLiteralType(index_2);
                    var accessFlags = 32 | (hasDefaultValue(declaration) ? 16 : 0);
                    var declaredType = getIndexedAccessTypeOrUndefined(parentType, indexType, accessFlags, declaration.name) || errorType;
                    type = getFlowTypeOfDestructuring(declaration, declaredType);
                }
                else {
                    type = elementType;
                }
            }
            if (!declaration.initializer) {
                return type;
            }
            if (ts.getEffectiveTypeAnnotationNode(ts.walkUpBindingElementsAndPatterns(declaration))) {
                return strictNullChecks && !(getFalsyFlags(checkDeclarationInitializer(declaration, 0)) & 32768) ? getNonUndefinedType(type) : type;
            }
            return widenTypeInferredFromInitializer(declaration, getUnionType([getNonUndefinedType(type), checkDeclarationInitializer(declaration, 0)], 2));
        }
        function getTypeForDeclarationFromJSDocComment(declaration) {
            var jsdocType = ts.getJSDocType(declaration);
            if (jsdocType) {
                return getTypeFromTypeNode(jsdocType);
            }
            return undefined;
        }
        function isNullOrUndefined(node) {
            var expr = ts.skipParentheses(node, true);
            return expr.kind === 104 || expr.kind === 79 && getResolvedSymbol(expr) === undefinedSymbol;
        }
        function isEmptyArrayLiteral(node) {
            var expr = ts.skipParentheses(node, true);
            return expr.kind === 204 && expr.elements.length === 0;
        }
        function addOptionality(type, isProperty, isOptional) {
            if (isProperty === void 0) { isProperty = false; }
            if (isOptional === void 0) { isOptional = true; }
            return strictNullChecks && isOptional ? getOptionalType(type, isProperty) : type;
        }
        function getTypeForVariableLikeDeclaration(declaration, includeOptionality, checkMode) {
            if (ts.isVariableDeclaration(declaration) && declaration.parent.parent.kind === 243) {
                var indexType = getIndexType(getNonNullableTypeIfNeeded(checkExpression(declaration.parent.parent.expression, checkMode)));
                return indexType.flags & (262144 | 4194304) ? getExtractStringType(indexType) : stringType;
            }
            if (ts.isVariableDeclaration(declaration) && declaration.parent.parent.kind === 244) {
                var forOfStatement = declaration.parent.parent;
                return checkRightHandSideOfForOf(forOfStatement) || anyType;
            }
            if (ts.isBindingPattern(declaration.parent)) {
                return getTypeForBindingElement(declaration);
            }
            var isProperty = ts.isPropertyDeclaration(declaration) || ts.isPropertySignature(declaration);
            var isOptional = includeOptionality && (isProperty && !!declaration.questionToken ||
                ts.isParameter(declaration) && (!!declaration.questionToken || isJSDocOptionalParameter(declaration)) ||
                isOptionalJSDocPropertyLikeTag(declaration));
            var declaredType = tryGetTypeFromEffectiveTypeNode(declaration);
            if (declaredType) {
                return addOptionality(declaredType, isProperty, isOptional);
            }
            if ((noImplicitAny || ts.isInJSFile(declaration)) &&
                ts.isVariableDeclaration(declaration) && !ts.isBindingPattern(declaration.name) &&
                !(ts.getCombinedModifierFlags(declaration) & 1) && !(declaration.flags & 16777216)) {
                if (!(ts.getCombinedNodeFlags(declaration) & 2) && (!declaration.initializer || isNullOrUndefined(declaration.initializer))) {
                    return autoType;
                }
                if (declaration.initializer && isEmptyArrayLiteral(declaration.initializer)) {
                    return autoArrayType;
                }
            }
            if (ts.isParameter(declaration)) {
                var func = declaration.parent;
                if (func.kind === 173 && hasBindableName(func)) {
                    var getter = ts.getDeclarationOfKind(getSymbolOfNode(declaration.parent), 172);
                    if (getter) {
                        var getterSignature = getSignatureFromDeclaration(getter);
                        var thisParameter = getAccessorThisParameter(func);
                        if (thisParameter && declaration === thisParameter) {
                            ts.Debug.assert(!thisParameter.type);
                            return getTypeOfSymbol(getterSignature.thisParameter);
                        }
                        return getReturnTypeOfSignature(getterSignature);
                    }
                }
                if (ts.isInJSFile(declaration)) {
                    var type_1 = getParameterTypeOfTypeTag(func, declaration);
                    if (type_1)
                        return type_1;
                }
                var type = declaration.symbol.escapedName === "this" ? getContextualThisParameterType(func) : getContextuallyTypedParameterType(declaration);
                if (type) {
                    return addOptionality(type, false, isOptional);
                }
            }
            if (ts.hasOnlyExpressionInitializer(declaration) && !!declaration.initializer) {
                if (ts.isInJSFile(declaration) && !ts.isParameter(declaration)) {
                    var containerObjectType = getJSContainerObjectType(declaration, getSymbolOfNode(declaration), ts.getDeclaredExpandoInitializer(declaration));
                    if (containerObjectType) {
                        return containerObjectType;
                    }
                }
                var type = widenTypeInferredFromInitializer(declaration, checkDeclarationInitializer(declaration, checkMode));
                return addOptionality(type, isProperty, isOptional);
            }
            if (ts.isPropertyDeclaration(declaration) && (noImplicitAny || ts.isInJSFile(declaration))) {
                if (!ts.hasStaticModifier(declaration)) {
                    var constructor = findConstructorDeclaration(declaration.parent);
                    var type = constructor ? getFlowTypeInConstructor(declaration.symbol, constructor) :
                        ts.getEffectiveModifierFlags(declaration) & 2 ? getTypeOfPropertyInBaseClass(declaration.symbol) :
                            undefined;
                    return type && addOptionality(type, true, isOptional);
                }
                else {
                    var staticBlocks = ts.filter(declaration.parent.members, ts.isClassStaticBlockDeclaration);
                    var type = staticBlocks.length ? getFlowTypeInStaticBlocks(declaration.symbol, staticBlocks) :
                        ts.getEffectiveModifierFlags(declaration) & 2 ? getTypeOfPropertyInBaseClass(declaration.symbol) :
                            undefined;
                    return type && addOptionality(type, true, isOptional);
                }
            }
            if (ts.isJsxAttribute(declaration)) {
                return trueType;
            }
            if (ts.isBindingPattern(declaration.name)) {
                return getTypeFromBindingPattern(declaration.name, false, true);
            }
            return undefined;
        }
        function isConstructorDeclaredProperty(symbol) {
            if (symbol.valueDeclaration && ts.isBinaryExpression(symbol.valueDeclaration)) {
                var links = getSymbolLinks(symbol);
                if (links.isConstructorDeclaredProperty === undefined) {
                    links.isConstructorDeclaredProperty = false;
                    links.isConstructorDeclaredProperty = !!getDeclaringConstructor(symbol) && ts.every(symbol.declarations, function (declaration) {
                        return ts.isBinaryExpression(declaration) &&
                            isPossiblyAliasedThisProperty(declaration) &&
                            (declaration.left.kind !== 207 || ts.isStringOrNumericLiteralLike(declaration.left.argumentExpression)) &&
                            !getAnnotatedTypeForAssignmentDeclaration(undefined, declaration, symbol, decl